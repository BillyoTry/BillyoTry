<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>C7</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://billyotry.github.io/"/>
  <updated>2021-01-21T17:22:07.334Z</updated>
  <id>https://billyotry.github.io/</id>
  
  <author>
    <name>C7</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>这是标题</title>
    <link href="https://billyotry.github.io/2021/01/22/test/"/>
    <id>https://billyotry.github.io/2021/01/22/test/</id>
    <published>2021-01-21T17:14:34.658Z</published>
    <updated>2021-01-21T17:22:07.334Z</updated>
    
    <content type="html"><![CDATA[<p>test</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;test&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>关于纯字符shellcode的编写</title>
    <link href="https://billyotry.github.io/2021/01/22/%E5%85%B3%E4%BA%8E%E7%BA%AF%E5%AD%97%E7%AC%A6shellcode%E7%9A%84%E7%BC%96%E5%86%99/"/>
    <id>https://billyotry.github.io/2021/01/22/%E5%85%B3%E4%BA%8E%E7%BA%AF%E5%AD%97%E7%AC%A6shellcode%E7%9A%84%E7%BC%96%E5%86%99/</id>
    <published>2021-01-21T16:59:43.881Z</published>
    <updated>2021-01-22T03:42:05.489Z</updated>
    
    <content type="html"><![CDATA[<p>在上次MRCTF的时候遇到了一题，虽然只需要输入shellcode，但是对用户的输入字符进行了限制，只能有字母和数字这些可见字符。<strong>在此感谢TaQini师傅对于alphanumeric shellcode编写的指导！</strong>具体参考TaQini师傅的文章</p><p><a href='http://taqini.space/2020/03/31/alpha-shellcode-gen/#alphanumeric-shellcode'>纯字符shellcode生成指南</a></p><p>关键部分:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt; len) </span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">if</span> (((((<span class="keyword">char</span>)buf[i] &lt; <span class="string">&#x27;a&#x27;</span>) || (<span class="string">&#x27;z&#x27;</span> &lt; (<span class="keyword">char</span>)buf[i])) &amp;&amp;</span><br><span class="line">          (((<span class="keyword">char</span>)buf[i] &lt; <span class="string">&#x27;A&#x27;</span> || (<span class="string">&#x27;Z&#x27;</span> &lt; (<span class="keyword">char</span>)buf[i])))) &amp;&amp;</span><br><span class="line">         (((<span class="keyword">char</span>)buf[i] &lt; <span class="string">&#x27;0&#x27;</span> || (<span class="string">&#x27;Z&#x27;</span> &lt; (<span class="keyword">char</span>)buf[i])))) </span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I Can\&#x27;t Read This!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      i = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">buf();     <span class="comment">//可以看到程序会将我们的输入当成函数执行</span></span><br></pre></td></tr></table></figure><p>我们可以使用alpha3来将pwntools生成shellcode来转为alphanumeric shellcode.</p><p><code>1.python ALPHA3.py x64 ascii mixedcase rax --input=&quot;sc&quot;</code></p><p>在使用这条命令前我们还需要有pwntools生成的shellcode</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#filename  sc.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>(shellcode)</span><br></pre></td></tr></table></figure><p>如何将文件的输出输出到sc文件中(不能输出到终端复制过去,有不可见字符)</p><p><code>2.python sc.py &gt; sc</code></p><p>然后我们就可以用1命令生成alphanumeric shellcode(这里的shellcode是会输出的终端,如果你想输出到文件中的话可以去翻官方文档)        ——-&gt;         <a href='https://github.com/SkyLined/alpha3 '>alpha3</a></p><p><img src="https://i.loli.net/2020/04/15/Wi9Jhe4L1NdfDwq.png" alt="QQ图片20200415000820.png"></p><p>   Note:这里要还有要注意一个寄存器的问题,因为这里buf函数是<code>call rax</code>所以我们的1命令中使用<code>rax</code>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在上次MRCTF的时候遇到了一题，虽然只需要输入shellcode，但是对用户的输入字符进行了限制，只能有字母和数字这些可见字符。&lt;strong&gt;在此感谢TaQini师傅对于alphanumeric shellcode编写的指导！&lt;/strong&gt;具体参考TaQini师傅的
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【Glibc 源码分析】Glibc 2.23 -- malloc.c</title>
    <link href="https://billyotry.github.io/2021/01/22/%E3%80%90Glibc%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91Glibc%202.23%20--%20malloc.c/"/>
    <id>https://billyotry.github.io/2021/01/22/%E3%80%90Glibc%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91Glibc%202.23%20--%20malloc.c/</id>
    <published>2021-01-21T16:59:43.880Z</published>
    <updated>2021-01-22T03:43:06.847Z</updated>
    
    <content type="html"><![CDATA[<p>源码来自:<a href="https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c">https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c</a></p><h2 id="MMAP-support"><a href="#MMAP-support" class="headerlink" title="MMAP support"></a>MMAP support</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ------------------ MMAP support ------------------  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(MAP_ANONYMOUS) &amp;&amp; defined(MAP_ANON)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAP_ANONYMOUS MAP_ANON</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MAP_NORESERVE</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAP_NORESERVE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMAP(addr, size, prot, flags) \</span></span><br><span class="line"> __mmap((addr), (size), (prot), (flags)|MAP_ANONYMOUS|MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="Chunk-representations"><a href="#Chunk-representations" class="headerlink" title="Chunk representations"></a>Chunk representations</h2><h3 id="malloc-chunk-结构体"><a href="#malloc-chunk-结构体" class="headerlink" title="malloc_chunk 结构体"></a>malloc_chunk 结构体</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  -----------------------  Chunk representations -----------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们在前面可以看见<code>#define INTERNAL_SIZE_T size_t</code>也就是说在64位的机器上，这个类型就是<code>unsigned long</code>类型</p><p>prev_size： 如果前一个块处于空闲状态，那么该值为前一个块的大小</p><p>size：记录当前块的大小</p><p>fd：当前块空闲时指向后一个空闲的chunk</p><p>bk：当前块空闲时指向前一个空闲的chunk</p><p>fd_nextsize：记录 large bin 的前驱节点</p><p>bk_nextsize：记录 large bin 的后继节点</p><h3 id="malloc-chunk-的细节"><a href="#malloc-chunk-的细节" class="headerlink" title="malloc_chunk 的细节"></a>malloc_chunk 的细节</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   malloc_chunk details:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (The following includes lightly edited explanations by Colin Plumb.)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks of memory are maintained using a `boundary tag&#x27; method as</span></span><br><span class="line"><span class="comment">    described in e.g., Knuth or Standish.  (See the paper by Paul</span></span><br><span class="line"><span class="comment">    Wilson ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a</span></span><br><span class="line"><span class="comment">    survey of such techniques.)  Sizes of free chunks are stored both</span></span><br><span class="line"><span class="comment">    in the front of each chunk and at the end.  This makes</span></span><br><span class="line"><span class="comment">    consolidating fragmented chunks into bigger chunks very fast.  The</span></span><br><span class="line"><span class="comment">    size fields also hold bits representing whether chunks are free or</span></span><br><span class="line"><span class="comment">    in use.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    An allocated chunk looks like this:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Size of previous chunk, if allocated            | |</span></span><br><span class="line"><span class="comment">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Size of chunk, in bytes                       |M|P|</span></span><br><span class="line"><span class="comment">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             User data starts here...                          .</span></span><br><span class="line"><span class="comment">       .                                                               .</span></span><br><span class="line"><span class="comment">       .             (malloc_usable_size() bytes)                      .</span></span><br><span class="line"><span class="comment">       .                                                               |</span></span><br><span class="line"><span class="comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Size of chunk                                     |</span></span><br><span class="line"><span class="comment">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Where &quot;chunk&quot; is the front of the chunk for the purpose of most of</span></span><br><span class="line"><span class="comment">    the malloc code, but &quot;mem&quot; is the pointer that is returned to the</span></span><br><span class="line"><span class="comment">    user.  &quot;Nextchunk&quot; is the beginning of the next contiguous chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks always begin on even word boundaries, so the mem portion</span></span><br><span class="line"><span class="comment">    (which is returned to the user) is also on an even word boundary, and</span></span><br><span class="line"><span class="comment">    thus at least double-word aligned.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Free chunks are stored in circular doubly-linked lists, and look like this:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Size of previous chunk                            |</span></span><br><span class="line"><span class="comment">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    `head:&#x27; |             Size of chunk, in bytes                         |P|</span></span><br><span class="line"><span class="comment">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Forward pointer to next chunk in list             |</span></span><br><span class="line"><span class="comment">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Back pointer to previous chunk in list            |</span></span><br><span class="line"><span class="comment">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Unused space (may be 0 bytes long)                .</span></span><br><span class="line"><span class="comment">       .                                                               .</span></span><br><span class="line"><span class="comment">       .                                                               |</span></span><br><span class="line"><span class="comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    `foot:&#x27; |             Size of chunk, in bytes                           |</span></span><br><span class="line"><span class="comment">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The P (PREV_INUSE) bit, stored in the unused low-order bit of the</span></span><br><span class="line"><span class="comment">    chunk size (which is always a multiple of two words), is an in-use</span></span><br><span class="line"><span class="comment">    bit for the *previous* chunk.  If that bit is *clear*, then the</span></span><br><span class="line"><span class="comment">    word before the current chunk size contains the previous chunk</span></span><br><span class="line"><span class="comment">    size, and can be used to find the front of the previous chunk.</span></span><br><span class="line"><span class="comment">    The very first chunk allocated always has this bit set,</span></span><br><span class="line"><span class="comment">    preventing access to non-existent (or non-owned) memory. If</span></span><br><span class="line"><span class="comment">    prev_inuse is set for any given chunk, then you CANNOT determine</span></span><br><span class="line"><span class="comment">    the size of the previous chunk, and might even get a memory</span></span><br><span class="line"><span class="comment">    addressing fault when trying to do so.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Note that the `foot&#x27; of the current chunk is actually represented</span></span><br><span class="line"><span class="comment">    as the prev_size of the NEXT chunk. This makes it easier to</span></span><br><span class="line"><span class="comment">    deal with alignments etc but can be very confusing when trying</span></span><br><span class="line"><span class="comment">    to extend or adapt this code.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The two exceptions to all this are</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     1. The special chunk `top&#x27; doesn&#x27;t bother using the</span></span><br><span class="line"><span class="comment">   trailing size field since there is no next contiguous chunk</span></span><br><span class="line"><span class="comment">   that would have to index off it. After initialization, `top&#x27;</span></span><br><span class="line"><span class="comment">   is forced to always exist.  If it would become less than</span></span><br><span class="line"><span class="comment">   MINSIZE bytes long, it is replenished.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     2. Chunks allocated via mmap, which have the second-lowest-order</span></span><br><span class="line"><span class="comment">   bit M (IS_MMAPPED) set in their size fields.  Because they are</span></span><br><span class="line"><span class="comment">   allocated one-by-one, each must contain its own trailing size field.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="Size-and-alignment-checks-and-conversions"><a href="#Size-and-alignment-checks-and-conversions" class="headerlink" title="Size and alignment checks and conversions"></a>Size and alignment checks and conversions</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* conversion from malloc headers to user pointers, and back */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span></span><br></pre></td></tr></table></figure><p>该宏的作用是找到堆块 p 内用来存储 fd 指针的地址</p><p>说白了 <code>p</code> 就是用来存储当前堆块 <code>prev_size</code> 的地址，但是我们要的不是存储当前堆块 <code>prev_size</code> 和 <code>size</code> 的地址</p><p>用户输入的内容都是存储到<strong>那个存储 fd 指针的地址</strong>，也就是存储 size 的地址的下一个地址</p><p>fd 和 bk 都是在堆块空闲的时候才会存储在这个地址上，当堆块正在别使用的时候就是正常的存储区域</p><h3 id="mem2chunk-mem-宏"><a href="#mem2chunk-mem-宏" class="headerlink" title="mem2chunk(mem) 宏"></a>mem2chunk(mem) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span></span><br></pre></td></tr></table></figure><p>该宏的作用和 <strong>chunk2mem 宏</strong>是反过来的</p><p>由堆块内用于给用户输入的存储区地址找到堆块的起始地址，也就是用于存储当前堆块 prev_size 的地址</p><h3 id="MIN-CHUNK-SIZE-宏"><a href="#MIN-CHUNK-SIZE-宏" class="headerlink" title="MIN_CHUNK_SIZE 宏"></a>MIN_CHUNK_SIZE 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The smallest possible chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))</span></span><br></pre></td></tr></table></figure><p>首先要了解 <strong>offsetof 宏</strong>的定义</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> offsetof(type,ident) ((size_t)&amp;(((type*)0)-&gt;ident))</span></span><br></pre></td></tr></table></figure><p>该宏通过一个结构体中的元素来获取该结构体的其实地址到该元素之间的距离</p><p>该宏的作用是规定一整个 chunk 的最小值是多少，包括 prev_size 域和 size 域</p><p>由此可以知道，在 32 位系统下，MIN_CHUNK_SIZE 的值大小是 0x10字节</p><p>在 64 位系统下，MIN_CHUNK_SIZE 的值大小是 0x20字节</p><h3 id="MINSIZE-宏"><a href="#MINSIZE-宏" class="headerlink" title="MINSIZE 宏"></a>MINSIZE 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The smallest size we can malloc is an aligned minimal chunk */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINSIZE  \</span></span><br><span class="line">  (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span><br></pre></td></tr></table></figure><p>该宏用来规定最小的堆块的可用空间，也就是说申请的堆块至少有 MINSIZE 的大小</p><p>在 32 位下，MINSIZE 的值为0x10字节</p><p>在 64 位下，MINSIZE 的值为0x20字节</p><h3 id="aligned-OK-m-宏"><a href="#aligned-OK-m-宏" class="headerlink" title="aligned_OK(m) 宏"></a>aligned_OK(m) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Check if m has acceptable alignment */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br></pre></td></tr></table></figure><p>该宏用来判断申请到的堆块中的地址是否为对齐的地址</p><h3 id="misaligned-chunk-p-宏"><a href="#misaligned-chunk-p-宏" class="headerlink" title="misaligned_chunk(p) 宏"></a>misaligned_chunk(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> misaligned_chunk(p) \</span></span><br><span class="line">  ((<span class="keyword">uintptr_t</span>)(MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ ? (p) : chunk2mem (p)) \</span><br><span class="line">   &amp; MALLOC_ALIGN_MASK)</span><br></pre></td></tr></table></figure><p>如果 <code>MALLOC_ALIGNMENT == 2 * SIZE_SZ</code></p><p>即如果 <code>long double</code> 对齐所需要的字节大于 <code>2 * sizeof(size_t)</code></p><p>则返回 p 的地址，也就是堆块的起始地址；否则返回该堆块 fd 指针所在的地址</p><p>一般的架构返回 <code>chunk2mem (p)</code> 的</p><h3 id="REQUEST-OUT-OF-RANGE-req-宏（缺）"><a href="#REQUEST-OUT-OF-RANGE-req-宏（缺）" class="headerlink" title="REQUEST_OUT_OF_RANGE(req) 宏（缺）"></a>REQUEST_OUT_OF_RANGE(req) 宏（缺）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Check if a request is so large that it would wrap around zero when</span></span><br><span class="line"><span class="comment">   padded and aligned. To simplify some other code, the bound is made</span></span><br><span class="line"><span class="comment">   low enough so that adding MINSIZE will also not wrap around zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                 \</span></span><br><span class="line">  ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (req) &gt;=                         \</span><br><span class="line">   (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (INTERNAL_SIZE_T) (<span class="number">-2</span> * MINSIZE))</span><br></pre></td></tr></table></figure><p>待补充</p><h3 id="request2size-req-宏（缺）"><a href="#request2size-req-宏（缺）" class="headerlink" title="request2size(req) 宏（缺）"></a>request2size(req) 宏（缺）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request2size(req)                                         \</span></span><br><span class="line">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span><br><span class="line">   MINSIZE :                                                      \</span><br><span class="line">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br></pre></td></tr></table></figure><p>待补充</p><h3 id="checked-request2size-req-sz-宏（缺）"><a href="#checked-request2size-req-sz-宏（缺）" class="headerlink" title="checked_request2size(req, sz) 宏（缺）"></a>checked_request2size(req, sz) 宏（缺）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  Same, except also perform argument check */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> checked_request2size(req, sz)                             \</span></span><br><span class="line">  <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE (req)) &#123;                      \</span><br><span class="line">      __set_errno (ENOMEM);                         \</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;                               \</span><br><span class="line">    &#125;                                \</span><br><span class="line">  (sz) = request2size (req);</span><br></pre></td></tr></table></figure><p>待补充</p><h2 id="Physical-chunk-operations"><a href="#Physical-chunk-operations" class="headerlink" title="Physical chunk operations"></a>Physical chunk operations</h2><h3 id="PREV-INUSE-宏"><a href="#PREV-INUSE-宏" class="headerlink" title="PREV_INUSE 宏"></a>PREV_INUSE 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* size field is or&#x27;ed with PREV_INUSE when previous adjacent chunk in use */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_INUSE 0x1</span></span><br></pre></td></tr></table></figure><p>该宏的意思是当前堆块的前一个堆块处于非空闲状态，规定值为 0x1</p><h3 id="prev-inuse-p-宏"><a href="#prev-inuse-p-宏" class="headerlink" title="prev_inuse(p) 宏"></a>prev_inuse(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* extract inuse bit of previous chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_inuse(p)       ((p)-&gt;size &amp; PREV_INUSE)</span></span><br></pre></td></tr></table></figure><p>检查前一个堆块是否处于空闲状态</p><p>如果前一个堆块处于非空闲状态，则返回 0x1，否则返回 0</p><h3 id="IS-MMAPPED-宏"><a href="#IS-MMAPPED-宏" class="headerlink" title="IS_MMAPPED 宏"></a>IS_MMAPPED 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* size field is or&#x27;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_MMAPPED 0x2</span></span><br></pre></td></tr></table></figure><p>该宏的意思的当前的堆块是通过 mmap() 得到的</p><h3 id="chunk-is-mmapped-p-宏"><a href="#chunk-is-mmapped-p-宏" class="headerlink" title="chunk_is_mmapped(p) 宏"></a>chunk_is_mmapped(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* check for mmap()&#x27;ed chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;size &amp; IS_MMAPPED)</span></span><br></pre></td></tr></table></figure><p>检查当前堆块是否是通过 mmap() 得到的</p><p>如果是 mmap() 得到的，那么返回 0x2，否则返回 0</p><h3 id="NON-MAIN-ARENA-宏"><a href="#NON-MAIN-ARENA-宏" class="headerlink" title="NON_MAIN_ARENA 宏"></a>NON_MAIN_ARENA 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* size field is or&#x27;ed with NON_MAIN_ARENA if the chunk was obtained</span></span><br><span class="line"><span class="comment">   from a non-main arena.  This is only set immediately before handing</span></span><br><span class="line"><span class="comment">   the chunk to the user, if necessary.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NON_MAIN_ARENA 0x4</span></span><br></pre></td></tr></table></figure><p>该宏的意思是当前 chunk 不属于主线程</p><h3 id="chunk-non-main-arena-p-宏"><a href="#chunk-non-main-arena-p-宏" class="headerlink" title="chunk_non_main_arena(p) 宏"></a>chunk_non_main_arena(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* check for chunk from non-main arena */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_non_main_arena(p) ((p)-&gt;size &amp; NON_MAIN_ARENA)</span></span><br></pre></td></tr></table></figure><p>检查当前 chunk 是否属于主线程</p><p>如果不属于主线程，那么返回 0x4，否则返回 0</p><h3 id="SIZE-BITS-宏"><a href="#SIZE-BITS-宏" class="headerlink" title="SIZE_BITS 宏"></a>SIZE_BITS 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Bits to mask off when extracting size</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Note: IS_MMAPPED is intentionally not masked off from size field in</span></span><br><span class="line"><span class="comment">   macros for which mmapped chunks should never be seen. This should</span></span><br><span class="line"><span class="comment">   cause helpful core dumps to occur if it is tried by accident by</span></span><br><span class="line"><span class="comment">   people extending or adapting this malloc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br></pre></td></tr></table></figure><p>表面看这个宏的返回值就是 7，也就是 <code>111B</code>，作用在下面的宏中有体现</p><h3 id="chunksize-p-宏"><a href="#chunksize-p-宏" class="headerlink" title="chunksize(p) 宏"></a>chunksize(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p)         ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br></pre></td></tr></table></figure><p>得到堆块 p 中的 size 位的值，因为堆块是对齐的，所以后三位没有用而且也不算大小</p><p>此处清空后三位</p><h3 id="next-chunk-p-宏"><a href="#next-chunk-p-宏" class="headerlink" title="next_chunk(p) 宏"></a>next_chunk(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_chunk(p) ((mchunkptr) (((char *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))</span></span><br></pre></td></tr></table></figure><p>mchunkptr 结构体指针变量的定义：<code>typedef struct malloc_chunk* mchunkptr;</code></p><p>该宏的作用就是得到当前堆块的下一个堆块的地址</p><p>代码的意思就是用<strong>当前堆</strong> p 的地址加上<strong>当前堆</strong>大小 size ，那么得到的值就是下一个堆块的地址了</p><h3 id="prev-chunk-p-宏"><a href="#prev-chunk-p-宏" class="headerlink" title="prev_chunk(p) 宏"></a>prev_chunk(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Ptr to previous physical malloc_chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_chunk(p) ((mchunkptr) (((char *) (p)) - ((p)-&gt;prev_size)))</span></span><br></pre></td></tr></table></figure><p>该宏的作用就是得到当前堆块的前一个堆块的地址</p><p>代码的意思就是用<strong>当前堆</strong> p 的地址减去<strong>前一个堆</strong>大小 size，那么得到的值就是前一个堆块的地址</p><p>不过 pre_size 只有在前一个堆块处于空闲状态的时候才会在当前堆块中有值</p><h3 id="chunk-at-offset-p-s-宏"><a href="#chunk-at-offset-p-s-宏" class="headerlink" title="chunk_at_offset(p, s) 宏"></a>chunk_at_offset(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Treat space at ptr + offset as a chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span></span><br></pre></td></tr></table></figure><p>也是获得一个堆块的地址，不过是通过指定偏移大小的方式</p><h3 id="inuse-p-宏"><a href="#inuse-p-宏" class="headerlink" title="inuse(p) 宏"></a>inuse(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* extract p&#x27;s inuse bit */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse(p)                           \</span></span><br><span class="line">  ((((mchunkptr) (((<span class="keyword">char</span> *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size) &amp; PREV_INUSE)</span><br></pre></td></tr></table></figure><p>获取下一个堆块的 PREV_INUSE 位，也就是说该宏是用来判断当前堆块是否处于空闲状态的</p><p>若是处于空闲状态就返回1，否则返回 0</p><h3 id="set-inuse-p-宏"><a href="#set-inuse-p-宏" class="headerlink" title="set_inuse(p) 宏"></a>set_inuse(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* set/clear chunk as being inuse without otherwise disturbing */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_inuse(p)                           \</span></span><br><span class="line">  ((mchunkptr) (((<span class="keyword">char</span> *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size |= PREV_INUSE</span><br></pre></td></tr></table></figure><p>这个宏的作用就是通过当前堆块的大小及地址得到下一个堆块的地址</p><p>然后将下一个堆块的 PREV_INUSE 位设置为 1</p><h3 id="clear-inuse-p-宏"><a href="#clear-inuse-p-宏" class="headerlink" title="clear_inuse(p) 宏"></a>clear_inuse(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clear_inuse(p)                          \</span></span><br><span class="line">  ((mchunkptr) (((<span class="keyword">char</span> *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size &amp;= ~(PREV_INUSE)</span><br></pre></td></tr></table></figure><p>该函数的作用是清除掉 PREV_INUSE 位，<code>~(PREV_INUSE)</code> 的值是 -2</p><h3 id="inuse-bit-at-offset-p-s-宏"><a href="#inuse-bit-at-offset-p-s-宏" class="headerlink" title="inuse_bit_at_offset(p, s) 宏"></a>inuse_bit_at_offset(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* check/set/clear inuse bits in known places */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse_bit_at_offset(p, s)                    \</span></span><br><span class="line">  (((mchunkptr) (((<span class="keyword">char</span> *) (p)) + (s)))-&gt;size &amp; PREV_INUSE)</span><br></pre></td></tr></table></figure><p>类似于 <code>inuse(p)</code> 宏，区别是它可以自己指定偏移</p><h3 id="set-inuse-bit-at-offset-p-s-宏"><a href="#set-inuse-bit-at-offset-p-s-宏" class="headerlink" title="set_inuse_bit_at_offset(p, s) 宏"></a>set_inuse_bit_at_offset(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_inuse_bit_at_offset(p, s)                     \</span></span><br><span class="line">  (((mchunkptr) (((<span class="keyword">char</span> *) (p)) + (s)))-&gt;size |= PREV_INUSE)</span><br></pre></td></tr></table></figure><p>类似于 <code>set_inuse(p)</code> 宏，区别是它可以自己指定偏移</p><h3 id="clear-inuse-bit-at-offset-p-s-宏"><a href="#clear-inuse-bit-at-offset-p-s-宏" class="headerlink" title="clear_inuse_bit_at_offset(p, s) 宏"></a>clear_inuse_bit_at_offset(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clear_inuse_bit_at_offset(p, s)                   \</span></span><br><span class="line">  (((mchunkptr) (((<span class="keyword">char</span> *) (p)) + (s)))-&gt;size &amp;= ~(PREV_INUSE))</span><br></pre></td></tr></table></figure><p>类似于 <code>clear_inuse(p)</code> 宏，区别是它可以自己指定偏移</p><h3 id="set-head-size-p-s-宏"><a href="#set-head-size-p-s-宏" class="headerlink" title="set_head_size(p, s) 宏"></a>set_head_size(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set size at head, without disturbing its use bit */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_head_size(p, s)  ((p)-&gt;size = (((p)-&gt;size &amp; SIZE_BITS) | (s)))</span></span><br></pre></td></tr></table></figure><p>在堆块 p 的 size 位设置该堆块的大小，并且<strong>不会</strong>影响到该堆块的使用位</p><h3 id="set-head-p-s-宏"><a href="#set-head-p-s-宏" class="headerlink" title="set_head(p, s) 宏"></a>set_head(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set size/use field */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_head(p, s)       ((p)-&gt;size = (s))</span></span><br></pre></td></tr></table></figure><p>在堆块 p 的 size 位设置该堆块的大小，该方法<strong>会</strong>影响到该堆块的使用位</p><h3 id="set-foot-p-s-宏"><a href="#set-foot-p-s-宏" class="headerlink" title="set_foot(p, s) 宏"></a>set_foot(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set size at footer (only when chunk is not in use) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))-&gt;prev_size = (s))</span></span><br></pre></td></tr></table></figure><p>设置下一个堆块的 prev_size 位，该宏只有在当前堆块为空闲堆块时才会使用</p><p>看样子这个宏是专门在下一个堆块的 prev_size 位设置当前堆块的大小的</p><p>而且就算是该堆块的地址被申请回来了，那么下一个堆块的 prev_size位也不会改变</p><h2 id="Internal-data-structures"><a href="#Internal-data-structures" class="headerlink" title="Internal data structures"></a>Internal data structures</h2><h3 id="mbinptr-结构体指针变量"><a href="#mbinptr-结构体指针变量" class="headerlink" title="mbinptr 结构体指针变量"></a>mbinptr 结构体指针变量</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   -------------------- Internal data structures --------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   All internal state is held in an instance of malloc_state defined</span></span><br><span class="line"><span class="comment">   below. There are no other static variables, except in two optional</span></span><br><span class="line"><span class="comment">   cases:</span></span><br><span class="line"><span class="comment"> * If USE_MALLOC_LOCK is defined, the mALLOC_MUTEx declared above.</span></span><br><span class="line"><span class="comment"> * If mmap doesn&#x27;t support MAP_ANONYMOUS, a dummy file descriptor</span></span><br><span class="line"><span class="comment">     for mmap.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Beware of lots of tricks that minimize the total bookkeeping space</span></span><br><span class="line"><span class="comment">   requirements. The result is a little over 1K bytes (for 4byte</span></span><br><span class="line"><span class="comment">   pointers and size_t.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Bins</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    An array of bin headers for free chunks. Each bin is doubly</span></span><br><span class="line"><span class="comment">    linked.  The bins are approximately proportionally (log) spaced.</span></span><br><span class="line"><span class="comment">    There are a lot of these bins (128). This may look excessive, but</span></span><br><span class="line"><span class="comment">    works very well in practice.  Most bins hold sizes that are</span></span><br><span class="line"><span class="comment">    unusual as malloc request sizes, but are more usual for fragments</span></span><br><span class="line"><span class="comment">    and consolidated sets of chunks, which is what these bins hold, so</span></span><br><span class="line"><span class="comment">    they can be found quickly.  All procedures maintain the invariant</span></span><br><span class="line"><span class="comment">    that no consolidated chunk physically borders another one, so each</span></span><br><span class="line"><span class="comment">    chunk in a list is known to be preceeded and followed by either</span></span><br><span class="line"><span class="comment">    inuse chunks or the ends of memory.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks in bins are kept in size order, with ties going to the</span></span><br><span class="line"><span class="comment">    approximately least recently used chunk. Ordering isn&#x27;t needed</span></span><br><span class="line"><span class="comment">    for the small bins, which all contain the same-sized chunks, but</span></span><br><span class="line"><span class="comment">    facilitates best-fit allocation for larger chunks. These lists</span></span><br><span class="line"><span class="comment">    are just sequential. Keeping them in order almost never requires</span></span><br><span class="line"><span class="comment">    enough traversal to warrant using fancier ordered data</span></span><br><span class="line"><span class="comment">    structures.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks of the same size are linked with the most</span></span><br><span class="line"><span class="comment">    recently freed at the front, and allocations are taken from the</span></span><br><span class="line"><span class="comment">    back.  This results in LRU (FIFO) allocation order, which tends</span></span><br><span class="line"><span class="comment">    to give each chunk an equal opportunity to be consolidated with</span></span><br><span class="line"><span class="comment">    adjacent freed chunks, resulting in larger free chunks and less</span></span><br><span class="line"><span class="comment">    fragmentation.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    To simplify use in double-linked lists, each bin header acts</span></span><br><span class="line"><span class="comment">    as a malloc_chunk. This avoids special-casing for headers.</span></span><br><span class="line"><span class="comment">    But to conserve space and improve locality, we allocate</span></span><br><span class="line"><span class="comment">    only the fd/bk pointers of bins, and then use repositioning tricks</span></span><br><span class="line"><span class="comment">    to treat these as the fields of a malloc_chunk*.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mbinptr</span>;</span></span><br></pre></td></tr></table></figure><p>跟 <code>mchunkptr</code> 差不多，不过是用在 bin（空闲堆块）里的</p><h3 id="bin-at-m-i-宏"><a href="#bin-at-m-i-宏" class="headerlink" title="bin_at(m, i) 宏"></a>bin_at(m, i) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bin_at(m, i) \</span></span><br><span class="line">  (mbinptr) (((<span class="keyword">char</span> *) &amp;((m)-&gt;bins[((i) - <span class="number">1</span>) * <span class="number">2</span>]))                \</span><br><span class="line">             - offsetof (struct malloc_chunk, fd))</span><br></pre></td></tr></table></figure><p>该宏用于获得某种类型的 bins 的某一个 bin 的地址，且该 bins 的基地址下标是 1 ，而不能是 0</p><h3 id="next-bin-b-宏（缺具体）"><a href="#next-bin-b-宏（缺具体）" class="headerlink" title="next_bin(b) 宏（缺具体）"></a>next_bin(b) 宏（缺具体）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* analog of ++bin */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_bin(b)  ((mbinptr) ((char *) (b) + (sizeof (mchunkptr) &lt;&lt; 1)))</span></span><br></pre></td></tr></table></figure><p>获取下一个 bin 的地址</p><h3 id="first-b-宏"><a href="#first-b-宏" class="headerlink" title="first(b) 宏"></a>first(b) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Reminders about list directionality within bins */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> first(b)     ((b)-&gt;fd)</span></span><br></pre></td></tr></table></figure><p>获取 bin 中的 fd 指针</p><h3 id="last-b-宏"><a href="#last-b-宏" class="headerlink" title="last(b) 宏"></a>last(b) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> last(b)      ((b)-&gt;bk)</span></span><br></pre></td></tr></table></figure><p>获取 bin 中的 bk 指针</p><h3 id="unlink-AV-P-BK-FD-宏（重点）（缺）"><a href="#unlink-AV-P-BK-FD-宏（重点）（缺）" class="headerlink" title="unlink(AV, P, BK, FD) 宏（重点）（缺）"></a>unlink(AV, P, BK, FD) 宏（重点）（缺）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line">    FD = P-&gt;fd;                               \</span><br><span class="line">    BK = P-&gt;bk;                               \</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))           \</span><br><span class="line">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br><span class="line">    <span class="keyword">else</span> &#123;                            \</span><br><span class="line">        FD-&gt;bk = BK;                           \</span><br><span class="line">        BK-&gt;fd = FD;                           \</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size)                  \</span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;          \</span><br><span class="line">       <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)       \</span><br><span class="line">      || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">         malloc_printerr (check_action,                  \</span><br><span class="line">                <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    \</span><br><span class="line">                P, AV);                   \</span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;                \</span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)                  \</span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;           \</span><br><span class="line">                <span class="keyword">else</span> &#123;                         \</span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;              \</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;              \</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;              \</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;              \</span><br><span class="line">                  &#125;                            \</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;                         \</span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;           \</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;           \</span><br><span class="line">              &#125;                               \</span><br><span class="line">          &#125;                               \</span><br><span class="line">      &#125;                                  \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 - 4 行：<code>FD = P-&gt;fd</code> 和 <code>BK = P-&gt;bk</code> 是分别获取传入参数 P 的前驱节点和后继节点5</p><p>5 行：if 语句用于判断 P 的前驱节点的后继节点是否为 P，P的后继节点的前驱节点是否为 P，且要通过条件最后返回值为 0</p><p>6 行：如果第五行的返回值为 1，那么就调用 <code>malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV)</code></p><p>7 - 9 行：如果返回值是 0，进入 else 语句，并且让 <strong>P 的前驱节点的后继节点变成 P 的后继节点</strong></p><p>​                再让 <strong>P 的后继节点的前驱节点变成 P 的前驱节点</strong>，完成删除双向链表上的 P 节点的操作</p><p>10 - 11 行：</p><h2 id="Indexing"><a href="#Indexing" class="headerlink" title="Indexing"></a>Indexing</h2><h3 id="NBINS-宏"><a href="#NBINS-宏" class="headerlink" title="NBINS 宏"></a>NBINS 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Indexing</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Bins for sizes &lt; 512 bytes contain chunks of all the same size, spaced</span></span><br><span class="line"><span class="comment">    8 bytes apart. Larger bins are approximately logarithmically spaced:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    64 bins of size       8</span></span><br><span class="line"><span class="comment">    32 bins of size      64</span></span><br><span class="line"><span class="comment">    16 bins of size     512</span></span><br><span class="line"><span class="comment">     8 bins of size    4096</span></span><br><span class="line"><span class="comment">     4 bins of size   32768</span></span><br><span class="line"><span class="comment">     2 bins of size  262144</span></span><br><span class="line"><span class="comment">     1 bin  of size what&#x27;s left</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    There is actually a little bit of slop in the numbers in bin_index</span></span><br><span class="line"><span class="comment">    for the sake of speed. This makes no difference elsewhere.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The bins top out around 1MB because we expect to service large</span></span><br><span class="line"><span class="comment">    requests via mmap.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Bin 0 does not exist.  Bin 1 is the unordered list; if that would be</span></span><br><span class="line"><span class="comment">    a valid chunk size the small bins are bumped up one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NBINS             128</span></span><br></pre></td></tr></table></figure><p>规定计算正常 bin 大小时的基准值</p><h3 id="NSMALLBINS-宏"><a href="#NSMALLBINS-宏" class="headerlink" title="NSMALLBINS 宏"></a>NSMALLBINS 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSMALLBINS         64</span></span><br></pre></td></tr></table></figure><p>规定计算正常 smallbin 大小时的基准值</p><h3 id="SMALLBIN-WIDTH-宏"><a href="#SMALLBIN-WIDTH-宏" class="headerlink" title="SMALLBIN_WIDTH 宏"></a>SMALLBIN_WIDTH 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span></span><br></pre></td></tr></table></figure><p>正常情况在 32 位下，这个值是 0x08；在 64 下这个值是 0x10</p><h3 id="SMALLBIN-CORRECTION-宏"><a href="#SMALLBIN-CORRECTION-宏" class="headerlink" title="SMALLBIN_CORRECTION 宏"></a>SMALLBIN_CORRECTION 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br></pre></td></tr></table></figure><p>这种就是在非正常情况下会有返回值 1，即在满足 <code>2 *SIZE_SZ &lt; __alignof__ (long double)</code> 时</p><h3 id="MIN-LARGE-SIZE-宏"><a href="#MIN-LARGE-SIZE-宏" class="headerlink" title="MIN_LARGE_SIZE 宏"></a>MIN_LARGE_SIZE 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br></pre></td></tr></table></figure><p>用于规定 smallbin 的最大值(不等于)和 largebin 的最大值</p><p>正常情况下 64 位的最小值为 <code>(64 - 0) * 0x10 == 0x400</code>；32 位的最小值为 <code>(64 - 0) * 0x08 == 0x200</code></p><h3 id="in-smallbin-range-sz-宏"><a href="#in-smallbin-range-sz-宏" class="headerlink" title="in_smallbin_range(sz) 宏"></a>in_smallbin_range(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> in_smallbin_range(sz)  \</span></span><br><span class="line">  ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) MIN_LARGE_SIZE)</span><br></pre></td></tr></table></figure><p>如果一个 chunk 的 size 小于 MIN_LARGE_SIZE，那么该 chunk 就属于 smallbin</p><h3 id="smallbin-index-sz-宏"><a href="#smallbin-index-sz-宏" class="headerlink" title="smallbin_index(sz) 宏"></a>smallbin_index(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line">  ((SMALLBIN_WIDTH == <span class="number">16</span> ? (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">4</span>) : (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">3</span>))\</span><br><span class="line">   + SMALLBIN_CORRECTION)</span><br></pre></td></tr></table></figure><p>SMALLBIN_CORRECTION 是用来兼容 <code>long double</code> 的</p><p>这个宏的主要意思就是在 64 位下，smallbin 中堆块的下标按照 <code>(unsigned) (sz)) &gt;&gt; 4</code> 来规划</p><p>在 32 位下，smallbin 中堆块的下标按照 <code>(unsigned) (sz)) &gt;&gt; 3</code> 来规划</p><p>且可以看出 <code>2 *SIZE_SZ &lt; __alignof__ (long double)</code> 的兼容操作只可能会在 32 位系统上出现</p><h3 id="largebin-index-32-sz-宏"><a href="#largebin-index-32-sz-宏" class="headerlink" title="largebin_index_32(sz) 宏"></a>largebin_index_32(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_32(sz)                                                \</span></span><br><span class="line">  (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">38</span>) ?  <span class="number">56</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>) ?  <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>) ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>) ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>) ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) :\</span><br><span class="line">   <span class="number">126</span>)</span><br></pre></td></tr></table></figure><p>参考 largebin_index_64(sz) 吧，这个是一般情况下 32 位的 largebin 分布</p><h3 id="largebin-index-32-big-sz-宏"><a href="#largebin-index-32-big-sz-宏" class="headerlink" title="largebin_index_32_big(sz) 宏"></a>largebin_index_32_big(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_32_big(sz)                                            \</span></span><br><span class="line">  (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">45</span>) ?  <span class="number">49</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>) ?  <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>) ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>) ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>) ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) :\</span><br><span class="line">   <span class="number">126</span>)</span><br></pre></td></tr></table></figure><p>参考 largebin_index_64(sz) 吧</p><p>这个是满足 <code>2 *SIZE_SZ &lt; __alignof__ (long double)</code> 下 32 位的 largebin 分布</p><h3 id="largebin-index-64-sz-宏"><a href="#largebin-index-64-sz-宏" class="headerlink" title="largebin_index_64(sz) 宏"></a>largebin_index_64(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// XXX It remains to be seen whether it is good to keep the widths of</span></span><br><span class="line"><span class="comment">// XXX the buckets the same or whether it should be scaled by a factor</span></span><br><span class="line"><span class="comment">// XXX of two as well.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_64(sz)                                                \</span></span><br><span class="line">  (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">48</span>) ?  <span class="number">48</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>) ?  <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>) ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>) ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>) ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) :\</span><br><span class="line">   <span class="number">126</span>)</span><br></pre></td></tr></table></figure><p>可以看到大小为 <code>0x400</code> 的 chunk 对应的 index 为 <code>(0x400 &gt;&gt; 6) + 48</code> 即 64</p><p>而 index 为 64 对应的范围是 <code>[0x400, 0x400 + 1 &gt;&gt; 6)</code> 即 <code>[0x400, 0x440)</code></p><p>在这个级别的 index 中，size 的范围为 0x40（1&lt;&lt;6），依次类推 size 与 index 对应的关系是：</p><table><thead><tr><th align="center"></th><th align="center">size</th><th align="center">index</th></tr></thead><tbody><tr><td align="center">等差 0x40</td><td align="center">[0x400 , 0x440)</td><td align="center">64</td></tr><tr><td align="center"></td><td align="center">[0x440 , 0x480)</td><td align="center">65</td></tr><tr><td align="center"></td><td align="center">……</td><td align="center">……</td></tr><tr><td align="center"></td><td align="center">[0xC00 , 0xC40)</td><td align="center">96</td></tr><tr><td align="center"></td><td align="center">[0xC40 , 0xE00)</td><td align="center">97</td></tr><tr><td align="center">等差 0x200</td><td align="center">[0xE00 , 0x1000)</td><td align="center">98</td></tr><tr><td align="center"></td><td align="center">[0x1000 , 0x1200)</td><td align="center">99</td></tr><tr><td align="center"></td><td align="center">……</td><td align="center">……</td></tr><tr><td align="center"></td><td align="center">[0x2800 , 0x2A00)</td><td align="center">111</td></tr><tr><td align="center"></td><td align="center">[0x2A00 , 0x3000)</td><td align="center">112</td></tr><tr><td align="center">等差 0x1000</td><td align="center">[0x3000 , 0x4000)</td><td align="center">113</td></tr><tr><td align="center"></td><td align="center">[0x4000 , 0x5000)</td><td align="center">114</td></tr><tr><td align="center"></td><td align="center">……</td><td align="center">……</td></tr><tr><td align="center"></td><td align="center">[0x9000 , 0xA000)</td><td align="center">119</td></tr><tr><td align="center"></td><td align="center">[0xA000 , 0x10000)</td><td align="center">120</td></tr><tr><td align="center">等差 0x8000</td><td align="center">[0x10000 , 0x18000)</td><td align="center">121</td></tr><tr><td align="center"></td><td align="center">[0x18000 , 0x20000)</td><td align="center">122</td></tr><tr><td align="center"></td><td align="center">[0x20000 , 0x28000)</td><td align="center">123</td></tr><tr><td align="center">等差 0x18000</td><td align="center">[0x28000 , 0x40000)</td><td align="center">124</td></tr><tr><td align="center">等差 0x40000</td><td align="center">[0x40000 , 0x80000)</td><td align="center">125</td></tr><tr><td align="center"></td><td align="center">[0x80000 , …. )</td><td align="center">126</td></tr></tbody></table><h3 id="largebin-index-sz-宏"><a href="#largebin-index-sz-宏" class="headerlink" title="largebin_index(sz) 宏"></a>largebin_index(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index(sz) \</span></span><br><span class="line">  (SIZE_SZ == <span class="number">8</span> ? largebin_index_64 (sz)                                     \</span><br><span class="line">   : MALLOC_ALIGNMENT == <span class="number">16</span> ? largebin_index_32_big (sz)                     \</span><br><span class="line">   : largebin_index_32 (sz))</span><br></pre></td></tr></table></figure><p>用来指定 largebin 应该以哪一种方式来指定当前堆块大小所对应的下标</p><h3 id="bin-index-sz-宏"><a href="#bin-index-sz-宏" class="headerlink" title="bin_index(sz) 宏"></a>bin_index(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bin_index(sz) \</span></span><br><span class="line">  ((in_smallbin_range (sz)) ? smallbin_index (sz) : largebin_index (sz))</span><br></pre></td></tr></table></figure><p>判断当前堆块的大小是满足 smallbin 还是满足 largebin，然后去对应的宏里得到该堆块大小所对应的下标</p><h2 id="Unsorted-chunks"><a href="#Unsorted-chunks" class="headerlink" title="Unsorted chunks"></a>Unsorted chunks</h2><h3 id="unsorted-chunks-M"><a href="#unsorted-chunks-M" class="headerlink" title="unsorted_chunks(M)"></a>unsorted_chunks(M)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Unsorted chunks</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    All remainders from chunk splits, as well as all returned chunks,</span></span><br><span class="line"><span class="comment">    are first placed in the &quot;unsorted&quot; bin. They are then placed</span></span><br><span class="line"><span class="comment">    in regular bins after malloc gives them ONE chance to be used before</span></span><br><span class="line"><span class="comment">    binning. So, basically, the unsorted_chunks list acts as a queue,</span></span><br><span class="line"><span class="comment">    with chunks being placed on it in free (and malloc_consolidate),</span></span><br><span class="line"><span class="comment">    and taken off (to be either used or placed in bins) in malloc.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The NON_MAIN_ARENA flag is never set for unsorted chunks, so it</span></span><br><span class="line"><span class="comment">    does not have to be taken into account in size comparisons.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unsorted_chunks(M)          (bin_at (M, 1))</span></span><br></pre></td></tr></table></figure><h2 id="Top"><a href="#Top" class="headerlink" title="Top"></a>Top</h2><h3 id="initial-top-M-宏"><a href="#initial-top-M-宏" class="headerlink" title="initial_top(M) 宏"></a>initial_top(M) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Top</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The top-most available chunk (i.e., the one bordering the end of</span></span><br><span class="line"><span class="comment">    available memory) is treated specially. It is never included in</span></span><br><span class="line"><span class="comment">    any bin, is used only if no other chunk is available, and is</span></span><br><span class="line"><span class="comment">    released back to the system if it is very large (see</span></span><br><span class="line"><span class="comment">    M_TRIM_THRESHOLD).  Because top initially</span></span><br><span class="line"><span class="comment">    points to its own bin with initial zero size, thus forcing</span></span><br><span class="line"><span class="comment">    extension on the first malloc request, we avoid having any special</span></span><br><span class="line"><span class="comment">    code in malloc to check whether it even exists yet. But we still</span></span><br><span class="line"><span class="comment">    need to do so when getting memory from system, so we make</span></span><br><span class="line"><span class="comment">    initial_top treat the bin as a legal but unusable chunk during the</span></span><br><span class="line"><span class="comment">    interval between initialization and the first call to</span></span><br><span class="line"><span class="comment">    sysmalloc. (This is somewhat delicate, since it relies on</span></span><br><span class="line"><span class="comment">    the 2 preceding words to be zero during this interval as well.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conveniently, the unsorted bin can be used as dummy top on first call */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> initial_top(M)              (unsorted_chunks (M))</span></span><br></pre></td></tr></table></figure><h2 id="Binmap"><a href="#Binmap" class="headerlink" title="Binmap"></a>Binmap</h2><h3 id="BINMAPSHIFT-宏"><a href="#BINMAPSHIFT-宏" class="headerlink" title="BINMAPSHIFT 宏"></a>BINMAPSHIFT 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Binmap</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    To help compensate for the large number of bins, a one-level index</span></span><br><span class="line"><span class="comment">    structure is used for bin-by-bin searching.  `binmap&#x27; is a</span></span><br><span class="line"><span class="comment">    bitvector recording whether bins are definitely empty so they can</span></span><br><span class="line"><span class="comment">    be skipped over during during traversals.  The bits are NOT always</span></span><br><span class="line"><span class="comment">    cleared as soon as bins are empty, but instead only</span></span><br><span class="line"><span class="comment">    when they are noticed to be empty during traversal in malloc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conservatively use 32 bits per map word, even if on 64bit system */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINMAPSHIFT      5</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;源码来自:&lt;a href=&quot;https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c&quot;&gt;https://elixir.bootlin.com/glibc/glibc-2.23/source/mall
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【ASAN】简单使用指南</title>
    <link href="https://billyotry.github.io/2021/01/22/%E3%80%90ASAN%E3%80%91%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://billyotry.github.io/2021/01/22/%E3%80%90ASAN%E3%80%91%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</id>
    <published>2021-01-21T16:59:43.879Z</published>
    <updated>2021-01-22T03:43:36.920Z</updated>
    
    <content type="html"><![CDATA[<p>以下内容仅为归纳，具体细节可自行测试。</p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ul><li>用<code>-fsanitize=address</code>选项编译和链接你的程序。</li><li>用<code>-fno-omit-frame-pointer</code>编译，以得到更容易理解stack trace。</li><li>可选择<code>-O1</code>或者更高的优化级别编译</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gcc -fsanitize=address -fno-omit-frame-pointer -O1 -g use-after-<span class="built_in">free</span>.c -o use-after-<span class="built_in">free</span></span><br></pre></td></tr></table></figure><p>如果发现错误，就会打印如下日志信息，如<code>UAF</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==<span class="number">4897</span>==ERROR: AddressSanitizer: heap-use-after-free <span class="keyword">on</span> address <span class="number">0x60200000eff0</span> at pc <span class="number">0x0000004009b6</span> bp <span class="number">0x7fff58399250</span> sp <span class="number">0x7fff58399240</span></span><br><span class="line">READ of size <span class="number">4</span> at <span class="number">0x60200000eff0</span> thread T0</span><br><span class="line">    <span class="meta">#0 0x4009b5 in main /home/c7/桌面/asan/use_after_free.c:14</span></span><br><span class="line">    <span class="meta">#1 0x7fd6cf95b83f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line">    <span class="meta">#2 0x400868 in _start (/home/c7/桌面/asan/use_after_free+0x400868)</span></span><br><span class="line"></span><br><span class="line"><span class="number">0x60200000eff0</span> <span class="keyword">is</span> located <span class="number">0</span> bytes inside of <span class="number">4</span>-<span class="built_in">byte</span> region [<span class="number">0x60200000eff0</span>,<span class="number">0x60200000eff4</span>)</span><br><span class="line">freed <span class="keyword">by</span> thread T0 here:</span><br><span class="line">    <span class="meta">#0 0x7fd6cfd9d2ca in __interceptor_free (/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so+0x982ca)</span></span><br><span class="line">    <span class="meta">#1 0x40097e in main /home/c7/桌面/asan/use_after_free.c:13</span></span><br><span class="line">    <span class="meta">#2 0x7fd6cf95b83f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">previously allocated <span class="keyword">by</span> thread T0 here:</span><br><span class="line">    <span class="meta">#0 0x7fd6cfd9d602 in malloc (/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so+0x98602)</span></span><br><span class="line">    <span class="meta">#1 0x40094e in main /home/c7/桌面/asan/use_after_free.c:6</span></span><br><span class="line">    <span class="meta">#2 0x7fd6cf95b83f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: heap-use-after-free /home/c7/桌面/asan/use_after_free.c:<span class="number">14</span> main</span><br></pre></td></tr></table></figure><ul><li>第一部分（ERROR）指出错误类型是heap-use-after-free；</li><li>第二部分（READ）, 指出线程名thread T0，操作为READ，发生的位置是use-after-free.c:14。</li><li>第三部分 (SUMMARY) 前面输出的概要说明。</li></ul><h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2><h3 id="fsanitize-address"><a href="#fsanitize-address" class="headerlink" title="-fsanitize=address"></a>-fsanitize=address</h3><p>用户态内存错误检测，可以被环境变量ASAN_OPTIONS控制具体行为。</p><p><strong>use after free</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> * value = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span> == value)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;malloc failed\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(value);</span><br><span class="line">  <span class="keyword">return</span> *value;  <span class="comment">// use after free. BOOM!!!!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译链接</p><p><code>gcc -g -o use_after_free -fsanitize=address -lasan -fuse-ld=gold use_after_free.c</code></p><p><code>LD_PRELOAD=$&#123;LD_PRELOAD&#125;:/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so  ./use_after_free</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==<span class="number">4897</span>==ERROR: AddressSanitizer: heap-use-after-free <span class="keyword">on</span> address <span class="number">0x60200000eff0</span> at pc <span class="number">0x0000004009b6</span> bp <span class="number">0x7fff58399250</span> sp <span class="number">0x7fff58399240</span></span><br><span class="line">READ of size <span class="number">4</span> at <span class="number">0x60200000eff0</span> thread T0      <span class="comment">//访问释放后的内存</span></span><br><span class="line">    <span class="meta">#0 0x4009b5 in main /home/c7/桌面/asan/use_after_free.c:14</span></span><br><span class="line">    <span class="meta">#1 0x7fd6cf95b83f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line">    <span class="meta">#2 0x400868 in _start (/home/c7/桌面/asan/use_after_free+0x400868)</span></span><br><span class="line"></span><br><span class="line"><span class="number">0x60200000eff0</span> <span class="keyword">is</span> located <span class="number">0</span> bytes inside of <span class="number">4</span>-<span class="built_in">byte</span> region [<span class="number">0x60200000eff0</span>,<span class="number">0x60200000eff4</span>)</span><br><span class="line">freed <span class="keyword">by</span> thread T0 here:        <span class="comment">//内存在哪里释放</span></span><br><span class="line">    <span class="meta">#0 0x7fd6cfd9d2ca in __interceptor_free (/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so+0x982ca)</span></span><br><span class="line">    <span class="meta">#1 0x40097e in main /home/c7/桌面/asan/use_after_free.c:13</span></span><br><span class="line">    <span class="meta">#2 0x7fd6cf95b83f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">previously allocated <span class="keyword">by</span> thread T0 here:         <span class="comment">//内存在哪里申请</span></span><br><span class="line">    <span class="meta">#0 0x7fd6cfd9d602 in malloc (/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so+0x98602)</span></span><br><span class="line">    <span class="meta">#1 0x40094e in main /home/c7/桌面/asan/use_after_free.c:6</span></span><br><span class="line">    <span class="meta">#2 0x7fd6cf95b83f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: heap-use-after-free /home/c7/桌面/asan/use_after_free.c:<span class="number">14</span> main</span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line">  <span class="number">0x0c047fff9da0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9db0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9dc0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9dd0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9de0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">=&gt;<span class="number">0x0c047fff9df0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa[fd]fa</span><br><span class="line">  <span class="number">0x0c047fff9e00</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9e10</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9e20</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9e30</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9e40</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line"><span class="function">Shadow <span class="built_in">byte</span> <span class="title">legend</span> (<span class="params">one shadow <span class="built_in">byte</span> represents <span class="number">8</span> application bytes</span>):</span></span><br><span class="line"><span class="function">  Addressable:           00</span></span><br><span class="line"><span class="function">  Partially addressable: 01 02 03 04 05 06 07 </span></span><br><span class="line"><span class="function">  Heap left redzone:       fa</span></span><br><span class="line"><span class="function">  Heap right redzone:      fb</span></span><br><span class="line"><span class="function">  Freed heap region:       fd</span></span><br><span class="line"><span class="function">  Stack left redzone:      f1</span></span><br><span class="line"><span class="function">  Stack mid redzone:       f2</span></span><br><span class="line"><span class="function">  Stack right redzone:     f3</span></span><br><span class="line"><span class="function">  Stack <span class="keyword">partial</span> redzone:   f4</span></span><br><span class="line"><span class="function">  Stack after <span class="keyword">return</span>:      f5</span></span><br><span class="line"><span class="function">  Stack use after scope:   f8</span></span><br><span class="line"><span class="function">  Global redzone:          f9</span></span><br><span class="line"><span class="function">  Global <span class="keyword">init</span> order:       f6</span></span><br><span class="line"><span class="function">  Poisoned <span class="keyword">by</span> user:        f7</span></span><br><span class="line"><span class="function">  Container overflow:      fc</span></span><br><span class="line"><span class="function">  Array cookie:            ac</span></span><br><span class="line"><span class="function">  Intra <span class="built_in">object</span> redzone:    bb</span></span><br><span class="line"><span class="function">  ASan <span class="keyword">internal</span>:           fe</span></span><br><span class="line"><span class="function"></span>==<span class="number">4897</span>==ABORTING</span><br></pre></td></tr></table></figure><p><strong>heap-buffer-overflow</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> * value = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span> == value)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;malloc failed\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> a= <span class="number">100</span>;</span><br><span class="line">  *((<span class="keyword">int</span>*)value) = a;  <span class="comment">// heap buffer overflow.  BOOM</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> *value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gcc -g -o heap_buffer_overflow -fsanitize=address -lasan -fuse-ld=gold heap_buffer_overflow.c</code></p><p><code>LD_PRELOAD=$&#123;LD_PRELOAD&#125;:/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so  ./heap_buffer_overflow</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==<span class="number">4969</span>==ERROR: AddressSanitizer: heap-buffer-overflow <span class="keyword">on</span> address <span class="number">0x60200000eff0</span> at pc <span class="number">0x000000400971</span> bp <span class="number">0x7ffc34e7a150</span> sp <span class="number">0x7ffc34e7a140</span></span><br><span class="line">WRITE of size <span class="number">4</span> at <span class="number">0x60200000eff0</span> thread T0      <span class="comment">//这里内存越界</span></span><br><span class="line">    <span class="meta">#0 0x400970 in main /home/c7/桌面/asan/heap_buffer_overflow.c:13</span></span><br><span class="line">    <span class="meta">#1 0x7f817497183f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line">    <span class="meta">#2 0x400828 in _start (/home/c7/桌面/asan/heap_buffer_overflow+0x400828)</span></span><br><span class="line"></span><br><span class="line"><span class="number">0x60200000eff1</span> <span class="keyword">is</span> located <span class="number">0</span> bytes to the right of <span class="number">1</span>-<span class="built_in">byte</span> region [<span class="number">0x60200000eff0</span>,<span class="number">0x60200000eff1</span>)</span><br><span class="line">allocated <span class="keyword">by</span> thread T0 here:</span><br><span class="line">    <span class="meta">#0 0x7f8174db3602 in malloc (/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so+0x98602)</span></span><br><span class="line">    <span class="meta">#1 0x40090e in main /home/c7/桌面/asan/heap_buffer_overflow.c:6</span></span><br><span class="line">    <span class="meta">#2 0x7f817497183f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: heap-buffer-overflow /home/c7/桌面/asan/heap_buffer_overflow.c:<span class="number">13</span> main</span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line">  <span class="number">0x0c047fff9da0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9db0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9dc0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9dd0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9de0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">=&gt;<span class="number">0x0c047fff9df0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa[<span class="number">01</span>]fa</span><br><span class="line">  <span class="number">0x0c047fff9e00</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9e10</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9e20</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9e30</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9e40</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line"><span class="function">Shadow <span class="built_in">byte</span> <span class="title">legend</span> (<span class="params">one shadow <span class="built_in">byte</span> represents <span class="number">8</span> application bytes</span>):</span></span><br><span class="line"><span class="function">  Addressable:           00</span></span><br><span class="line"><span class="function">  Partially addressable: 01 02 03 04 05 06 07 </span></span><br><span class="line"><span class="function">  Heap left redzone:       fa</span></span><br><span class="line"><span class="function">  Heap right redzone:      fb</span></span><br><span class="line"><span class="function">  Freed heap region:       fd</span></span><br><span class="line"><span class="function">  Stack left redzone:      f1</span></span><br><span class="line"><span class="function">  Stack mid redzone:       f2</span></span><br><span class="line"><span class="function">  Stack right redzone:     f3</span></span><br><span class="line"><span class="function">  Stack <span class="keyword">partial</span> redzone:   f4</span></span><br><span class="line"><span class="function">  Stack after <span class="keyword">return</span>:      f5</span></span><br><span class="line"><span class="function">  Stack use after scope:   f8</span></span><br><span class="line"><span class="function">  Global redzone:          f9</span></span><br><span class="line"><span class="function">  Global <span class="keyword">init</span> order:       f6</span></span><br><span class="line"><span class="function">  Poisoned <span class="keyword">by</span> user:        f7</span></span><br><span class="line"><span class="function">  Container overflow:      fc</span></span><br><span class="line"><span class="function">  Array cookie:            ac</span></span><br><span class="line"><span class="function">  Intra <span class="built_in">object</span> redzone:    bb</span></span><br><span class="line"><span class="function">  ASan <span class="keyword">internal</span>:           fe</span></span><br><span class="line"><span class="function"></span>==<span class="number">4969</span>==ABORTING</span><br></pre></td></tr></table></figure><p><strong>memory leak</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  p = <span class="built_in">malloc</span>(<span class="number">7</span>);</span><br><span class="line">  p = <span class="number">0</span>; <span class="comment">// The memory is leaked here.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gcc -g -o memory_leak -fsanitize=address -lasan -fuse-ld=gold memory_leak.c</code></p><p><code>LD_PRELOAD=$&#123;LD_PRELOAD&#125;:/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so   ./memory_leak</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==<span class="number">5014</span>==ERROR: LeakSanitizer: detected memory leaks</span><br><span class="line"></span><br><span class="line">Direct leak of <span class="number">7</span> <span class="built_in">byte</span>(s) <span class="keyword">in</span> <span class="number">1</span> <span class="built_in">object</span>(s) allocated <span class="keyword">from</span>:</span><br><span class="line">    <span class="meta">#0 0x7f3e3f381602 in malloc (/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so+0x98602)</span></span><br><span class="line">    <span class="meta">#1 0x400703 in main /home/c7/桌面/asan/memory_leak.c:6</span></span><br><span class="line">    <span class="meta">#2 0x7f3e3ef3f83f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: <span class="number">7</span> <span class="built_in">byte</span>(s) leaked <span class="keyword">in</span> <span class="number">1</span> allocation(s).</span><br></pre></td></tr></table></figure><h3 id="Stack-buffer-overflow"><a href="#Stack-buffer-overflow" class="headerlink" title="Stack-buffer-overflow"></a>Stack-buffer-overflow</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> stack_array[<span class="number">100</span>];</span><br><span class="line">  stack_array[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> stack_array[argc + <span class="number">100</span>];  <span class="comment">// BOOM</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gcc -g -o memory_leak -fsanitize=address -lasan -fuse-ld=gold memory_leak.c</code></p><p><code>LD_PRELOAD=$&#123;LD_PRELOAD&#125;:/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so   ./stack_overflow</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==<span class="number">5077</span>==ERROR: AddressSanitizer: stack-buffer-overflow <span class="keyword">on</span> address <span class="number">0x7ffe67846ad4</span> at pc <span class="number">0x000000400916</span> bp <span class="number">0x7ffe67846900</span> sp <span class="number">0x7ffe678468f0</span></span><br><span class="line">READ of size <span class="number">4</span> at <span class="number">0x7ffe67846ad4</span> thread T0</span><br><span class="line">    <span class="meta">#0 0x400915 in main /home/c7/桌面/asan/stack_overflow.c:4</span></span><br><span class="line">    <span class="meta">#1 0x7fd65942183f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line">    <span class="meta">#2 0x400758 in _start (/home/c7/桌面/asan/stack_overflow+0x400758)</span></span><br><span class="line"></span><br><span class="line">Address <span class="number">0x7ffe67846ad4</span> <span class="keyword">is</span> located <span class="keyword">in</span> stack of thread T0 at offset <span class="number">436</span> <span class="keyword">in</span> frame</span><br><span class="line">    <span class="meta">#0 0x400835 in main /home/c7/桌面/asan/stack_overflow.c:1</span></span><br><span class="line"></span><br><span class="line">  This frame has <span class="number">1</span> <span class="built_in">object</span>(s):</span><br><span class="line">    [<span class="meta">32, 432) &#x27;stack_array&#x27; &lt;== Memory access at offset 436 overflows this variable</span></span><br><span class="line"><span class="meta">HINT: this may be a false positive if your program uses some custom stack unwind mechanism or swapcontext</span></span><br><span class="line"><span class="meta">      (longjmp and C++ exceptions *are* supported)</span></span><br><span class="line"><span class="meta">SUMMARY: AddressSanitizer: stack-buffer-overflow /home/c7/桌面/asan/stack_overflow.c:4 main</span></span><br><span class="line"><span class="meta">Shadow bytes around the buggy address:</span></span><br><span class="line"><span class="meta">  0x10004cf00d00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="meta">  0x10004cf00d10: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="meta">  0x10004cf00d20: 00 00 00 00 f1 f1 f1 f1 00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="meta">  0x10004cf00d30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="meta">  0x10004cf00d40: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="meta">=&gt;0x10004cf00d50: 00 00 00 00 00 00 00 00 00 00[f4</span>]f4 f3 f3 f3 f3</span><br><span class="line">  <span class="number">0x10004cf00d60</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x10004cf00d70</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x10004cf00d80</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x10004cf00d90</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x10004cf00da0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="function">Shadow <span class="built_in">byte</span> <span class="title">legend</span> (<span class="params">one shadow <span class="built_in">byte</span> represents <span class="number">8</span> application bytes</span>):</span></span><br><span class="line"><span class="function">  Addressable:           00</span></span><br><span class="line"><span class="function">  Partially addressable: 01 02 03 04 05 06 07 </span></span><br><span class="line"><span class="function">  Heap left redzone:       fa</span></span><br><span class="line"><span class="function">  Heap right redzone:      fb</span></span><br><span class="line"><span class="function">  Freed heap region:       fd</span></span><br><span class="line"><span class="function">  Stack left redzone:      f1</span></span><br><span class="line"><span class="function">  Stack mid redzone:       f2</span></span><br><span class="line"><span class="function">  Stack right redzone:     f3</span></span><br><span class="line"><span class="function">  Stack <span class="keyword">partial</span> redzone:   f4</span></span><br><span class="line"><span class="function">  Stack after <span class="keyword">return</span>:      f5</span></span><br><span class="line"><span class="function">  Stack use after scope:   f8</span></span><br><span class="line"><span class="function">  Global redzone:          f9</span></span><br><span class="line"><span class="function">  Global <span class="keyword">init</span> order:       f6</span></span><br><span class="line"><span class="function">  Poisoned <span class="keyword">by</span> user:        f7</span></span><br><span class="line"><span class="function">  Container overflow:      fc</span></span><br><span class="line"><span class="function">  Array cookie:            ac</span></span><br><span class="line"><span class="function">  Intra <span class="built_in">object</span> redzone:    bb</span></span><br><span class="line"><span class="function">  ASan <span class="keyword">internal</span>:           fe</span></span><br><span class="line"><span class="function"></span>==<span class="number">5077</span>==ABORTING</span><br></pre></td></tr></table></figure><h3 id="Global-buffer-overflow"><a href="#Global-buffer-overflow" class="headerlink" title="Global-buffer-overflow"></a>Global-buffer-overflow</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> global_array[<span class="number">100</span>] = &#123;<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> global_array[argc + <span class="number">100</span>];  <span class="comment">// BOOM</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gcc -g -o global_buffer_overflow -fsanitize=address -lasan -fuse-ld=gold global_overflow.c</code></p><p><code>LD_PRELOAD=$&#123;LD_PRELOAD&#125;:/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so   ./global_buffer_overflow</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==<span class="number">5117</span>==ERROR: AddressSanitizer: <span class="keyword">global</span>-buffer-overflow <span class="keyword">on</span> address <span class="number">0x0000004021f4</span> at pc <span class="number">0x00000040080c</span> bp <span class="number">0x7fff85f8aaf0</span> sp <span class="number">0x7fff85f8aae0</span></span><br><span class="line">READ of size <span class="number">4</span> at <span class="number">0x0000004021f4</span> thread T0</span><br><span class="line">    <span class="meta">#0 0x40080b in main /home/c7/桌面/asan/global_buffer_overflow.c:3</span></span><br><span class="line">    <span class="meta">#1 0x7fd4153e383f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line">    <span class="meta">#2 0x4006e8 in _start (/home/c7/桌面/asan/global_buffer_overflow+0x4006e8)</span></span><br><span class="line"></span><br><span class="line"><span class="number">0x0000004021f4</span> <span class="keyword">is</span> located <span class="number">4</span> bytes to the right of <span class="keyword">global</span> variable <span class="string">&#x27;global_array&#x27;</span> defined <span class="keyword">in</span> <span class="string">&#x27;global_buffer_overflow.c:1:5&#x27;</span> (<span class="number">0x402060</span>) of size <span class="number">400</span></span><br><span class="line">SUMMARY: AddressSanitizer: <span class="keyword">global</span>-buffer-overflow /home/c7/桌面/asan/global_buffer_overflow.c:<span class="number">3</span> main</span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line">  <span class="number">0x0000800783e0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x0000800783f0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x000080078400</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x000080078410</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x000080078420</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">=&gt;<span class="number">0x000080078430</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>[f9]f9</span><br><span class="line">  <span class="number">0x000080078440</span>: f9 f9 f9 f9 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x000080078450</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x000080078460</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x000080078470</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x000080078480</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="function">Shadow <span class="built_in">byte</span> <span class="title">legend</span> (<span class="params">one shadow <span class="built_in">byte</span> represents <span class="number">8</span> application bytes</span>):</span></span><br><span class="line"><span class="function">  Addressable:           00</span></span><br><span class="line"><span class="function">  Partially addressable: 01 02 03 04 05 06 07 </span></span><br><span class="line"><span class="function">  Heap left redzone:       fa</span></span><br><span class="line"><span class="function">  Heap right redzone:      fb</span></span><br><span class="line"><span class="function">  Freed heap region:       fd</span></span><br><span class="line"><span class="function">  Stack left redzone:      f1</span></span><br><span class="line"><span class="function">  Stack mid redzone:       f2</span></span><br><span class="line"><span class="function">  Stack right redzone:     f3</span></span><br><span class="line"><span class="function">  Stack <span class="keyword">partial</span> redzone:   f4</span></span><br><span class="line"><span class="function">  Stack after <span class="keyword">return</span>:      f5</span></span><br><span class="line"><span class="function">  Stack use after scope:   f8</span></span><br><span class="line"><span class="function">  Global redzone:          f9</span></span><br><span class="line"><span class="function">  Global <span class="keyword">init</span> order:       f6</span></span><br><span class="line"><span class="function">  Poisoned <span class="keyword">by</span> user:        f7</span></span><br><span class="line"><span class="function">  Container overflow:      fc</span></span><br><span class="line"><span class="function">  Array cookie:            ac</span></span><br><span class="line"><span class="function">  Intra <span class="built_in">object</span> redzone:    bb</span></span><br><span class="line"><span class="function">  ASan <span class="keyword">internal</span>:           fe</span></span><br><span class="line"><span class="function"></span>==<span class="number">5117</span>==ABORTING</span><br></pre></td></tr></table></figure><p>关于相关漏洞检测还有use after return、use after scope、initializations order bugs、memory leaks，可自行举例测试。</p><p>除了<strong>-fsanitize=address</strong>外，还有一些其他的编译选项检测功能。</p><h3 id="fsanitize-kernel-address"><a href="#fsanitize-kernel-address" class="headerlink" title="-fsanitize=kernel-address"></a>-fsanitize=kernel-address</h3><p>内核态内存错误检测器</p><h3 id="fsanitize-thread"><a href="#fsanitize-thread" class="headerlink" title="-fsanitize=thread"></a>-fsanitize=thread</h3><p>使能ThreadSanitizer，快速数据竞争检测。</p><p>这里使用的应该是TSAN，不是ASAN。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Global;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">Thread1</span><span class="params">(<span class="keyword">void</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Global = <span class="number">42</span>;<span class="comment">//访问内存资源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">Thread2</span><span class="params">(<span class="keyword">void</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Global = <span class="number">43</span>;<span class="comment">//访问内存资源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> t[<span class="number">2</span>];</span><br><span class="line">    pthread_create(&amp;t[<span class="number">0</span>], <span class="literal">NULL</span>, Thread1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;t[<span class="number">1</span>], <span class="literal">NULL</span>, Thread2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t[<span class="number">0</span>], <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t[<span class="number">1</span>], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gcc -g -o data_race -fsanitize=thread -ltsan -fuse-ld=gold data_race.c</code><br><code>./data_race</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">==================</span><br><span class="line">WARNING: ThreadSanitizer: <span class="function">data <span class="title">race</span> (<span class="params">pid=<span class="number">5172</span></span>)</span></span><br><span class="line"><span class="function">  Write of size 4 at 0x000000402064 <span class="keyword">by</span> thread T2:    <span class="comment">//线程T2访问了冲突的资源</span></span></span><br><span class="line"><span class="function">    #0 Thread2 /home/c7/桌面/asan/data_race.c:13 (<span class="params">data_race+<span class="number">0x000000400959</span></span>) <span class="comment">//访问内存资源</span></span></span><br><span class="line"><span class="function">    #1 &lt;<span class="literal">null</span>&gt; &lt;<span class="literal">null</span>&gt; (<span class="params">libtsan.so<span class="number">.0</span>+<span class="number">0x0000000230d9</span></span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  Previous write of size 4 at 0x000000402064 <span class="keyword">by</span> thread T1:   <span class="comment">//线程T1访问了冲突的资源</span></span></span><br><span class="line"><span class="function">    #0 Thread1 /home/c7/桌面/asan/data_race.c:7 (<span class="params">data_race+<span class="number">0x000000400918</span></span>)  <span class="comment">//访问冲突资源</span></span></span><br><span class="line"><span class="function">    #1 &lt;<span class="literal">null</span>&gt; &lt;<span class="literal">null</span>&gt; (<span class="params">libtsan.so<span class="number">.0</span>+<span class="number">0x0000000230d9</span></span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  Location <span class="keyword">is</span> <span class="keyword">global</span> &#x27;Global&#x27; of size 4 at 0<span class="title">x000000402064</span> (<span class="params">data_race+<span class="number">0x000000402064</span></span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  Thread <span class="title">T2</span> (<span class="params">tid=<span class="number">5175</span>, running</span>) created <span class="keyword">by</span> main thread at:    <span class="comment">//创建T2的调用栈</span></span></span><br><span class="line"><span class="function">    #0 <span class="title">pthread_create</span> &lt;<span class="literal">null</span>&gt; (<span class="params">libtsan.so<span class="number">.0</span>+<span class="number">0x000000027577</span></span>)</span></span><br><span class="line"><span class="function">    #1 main /home/c7/桌面/asan/data_race.c:21 (<span class="params">data_race+<span class="number">0x0000004009d5</span></span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  Thread <span class="title">T1</span> (<span class="params">tid=<span class="number">5174</span>, finished</span>) created <span class="keyword">by</span> main thread at: <span class="comment">//创建T1的调用栈</span></span></span><br><span class="line"><span class="function">    #0 <span class="title">pthread_create</span> &lt;<span class="literal">null</span>&gt; (<span class="params">libtsan.so<span class="number">.0</span>+<span class="number">0x000000027577</span></span>)</span></span><br><span class="line"><span class="function">    #1 main /home/c7/桌面/asan/data_race.c:20 (<span class="params">data_race+<span class="number">0x0000004009b6</span></span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">SUMMARY: ThreadSanitizer: data race /home/c7/桌面/asan/data_race.c:13 Thread2</span></span><br><span class="line"><span class="function"></span>==================</span><br><span class="line"></span><br><span class="line">ThreadSanitizer: reported <span class="number">1</span> warnings</span><br></pre></td></tr></table></figure><h3 id="fsanitize-leak"><a href="#fsanitize-leak" class="headerlink" title="-fsanitize=leak"></a>-fsanitize=leak</h3><p>使能LeakSanitizer，内存泄露检测，作用于链接阶段。只有当-fsanitize=address和-fsanitize=thread均不使能时才有效。<strong>没有-fsanitize=address功能全面，只做内存泄露检测，但是速度比-fsanitize=address要快</strong>。</p><p>内存泄露检查-fsanitize=leak只有在GCC版本≥4.9时才有效。</p><h3 id="fsanitize-undefined"><a href="#fsanitize-undefined" class="headerlink" title="-fsanitize=undefined"></a>-fsanitize=undefined</h3><p>运行时快速未定义行为检测器。包括如下6~22共17个子选项。</p><h3 id="fsanitize-shift"><a href="#fsanitize-shift" class="headerlink" title="-fsanitize=shift"></a>-fsanitize=shift</h3><p>移位操作符的移位大小超过了位宽或者小于零，或者左边是负值。 对于有符号数移位, 检查C中的有符号溢出，在C++中检查无符号溢出。</p><h3 id="fsanitize-integer-divide-by-zero"><a href="#fsanitize-integer-divide-by-zero" class="headerlink" title="-fsanitize=integer-divide-by-zero"></a>-fsanitize=integer-divide-by-zero</h3><p>整数除零。</p><h3 id="fsanitize-unreachable"><a href="#fsanitize-unreachable" class="headerlink" title="-fsanitize=unreachable"></a>-fsanitize=unreachable</h3><p>如果控制流到达 __builtin_unreachable。</p><h3 id="fsanitize-vla-bound"><a href="#fsanitize-vla-bound" class="headerlink" title="-fsanitize=vla-bound"></a>-fsanitize=vla-bound</h3><p>可变长数组边界值非正。</p><h3 id="fsanitize-null"><a href="#fsanitize-null" class="headerlink" title="-fsanitize=null"></a>-fsanitize=null</h3><p>使用一个空指针或者创建一个空引用。</p><h3 id="fsanitize-return"><a href="#fsanitize-return" class="headerlink" title="-fsanitize=return"></a>-fsanitize=return</h3><p><strong>仅C++有效</strong>，对函数返回值进行检查，定义了返回值为非空的函数如果未返回有效值将会报错。</p><h3 id="fsanitize-signed-integer-overflow"><a href="#fsanitize-signed-integer-overflow" class="headerlink" title="-fsanitize=signed-integer-overflow"></a>-fsanitize=signed-integer-overflow</h3><p>有符号整数溢出, 包含所有通过 -ftrapv 添加的检查, 并且检查有符号除法溢出 (INT_MIN / -1)。</p><h3 id="fsanitize-bounds"><a href="#fsanitize-bounds" class="headerlink" title="-fsanitize=bounds"></a>-fsanitize=bounds</h3><p>数组索引越界, 以防数组边界可以静态检测。</p><h3 id="fsanitize-alignment"><a href="#fsanitize-alignment" class="headerlink" title="-fsanitize=alignment"></a>-fsanitize=alignment</h3><p>使用一个未对齐的指针或者引用。</p><h3 id="fsanitize-object-size"><a href="#fsanitize-object-size" class="headerlink" title="-fsanitize=object-size"></a>-fsanitize=object-size</h3><p>尝试使用优化器可以探测到不属于访问对象的字节。 对象的大小使用 __builtin_object_size 检测, 并且结果可能会探测到多个问题在高层次的优化。</p><h3 id="fsanitize-float-divide-by-zero"><a href="#fsanitize-float-divide-by-zero" class="headerlink" title="-fsanitize=float-divide-by-zero"></a>-fsanitize=float-divide-by-zero</h3><p>浮点除零。不能被-fsanitize=undefined使能。</p><h3 id="fsanitize-float-cast-overflow"><a href="#fsanitize-float-cast-overflow" class="headerlink" title="-fsanitize=float-cast-overflow"></a>-fsanitize=float-cast-overflow</h3><p>浮点到整形转换的检查，不能被-fsanitize=undefined使能。</p><h3 id="fsanitize-nonnull-attribute"><a href="#fsanitize-nonnull-attribute" class="headerlink" title="-fsanitize=nonnull-attribute"></a>-fsanitize=nonnull-attribute</h3><p>对使用<strong>attribute</strong> nonnull限定参数非空的函数进行检查。</p><h3 id="fsanitize-returns-nonnull-attribute"><a href="#fsanitize-returns-nonnull-attribute" class="headerlink" title="-fsanitize=returns-nonnull-attribute"></a>-fsanitize=returns-nonnull-attribute</h3><p>对使用<strong>attribute</strong>((returns_nonnull))限定返回为非空指针的函数进行检测。</p><h3 id="fsanitize-bool"><a href="#fsanitize-bool" class="headerlink" title="-fsanitize=bool"></a>-fsanitize=bool</h3><p>加载一个既不是真也不是假的bool值。</p><h3 id="fsanitize-enum"><a href="#fsanitize-enum" class="headerlink" title="-fsanitize=enum"></a>-fsanitize=enum</h3><p>加载一个枚举类型的值，但是值不在那个枚举类型范围内。</p><h3 id="fsanitize-vptr"><a href="#fsanitize-vptr" class="headerlink" title="-fsanitize=vptr"></a>-fsanitize=vptr</h3><p>使用一个vptr预示着具有错误动态类型的对象，或者它的生命长度还未开始或者已经结束。与 -fno-rtti 兼容。</p><h3 id="fno-sanitize-all"><a href="#fno-sanitize-all" class="headerlink" title="-fno-sanitize=all"></a>-fno-sanitize=all</h3><p>禁止之前所有的子选项，-fsanitize=all是不能使用的，因某些子选项是不兼容的。</p><h3 id="fasan-shadow-offset-number"><a href="#fasan-shadow-offset-number" class="headerlink" title="-fasan-shadow-offset=number"></a>-fasan-shadow-offset=number</h3><p>自定义AddressSanitizer检查中的shadow偏移。</p><h3 id="fsanitize-recover-opts"><a href="#fsanitize-recover-opts" class="headerlink" title="-fsanitize-recover[=opts]"></a>-fsanitize-recover[=opts]</h3><p>使用逗号分隔的列表控制错误恢复模式。如：-fsanitize-recover=undefined,float-cast-overflow,float-divide-by-zero</p><p>-fno-sanitize-recover等同于</p><p>-fno-sanitize-recover=undefined,float-cast-overflow,float-divide-by-zero。</p><h3 id="fsanitize-undefined-trap-on-error"><a href="#fsanitize-undefined-trap-on-error" class="headerlink" title="-fsanitize-undefined-trap-on-error"></a>-fsanitize-undefined-trap-on-error</h3><p>控制编译器用using __builtin_trap替代libubsan报告未定义行为。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://bbs.huaweicloud.com/blogs/100056">https://bbs.huaweicloud.com/blogs/100056</a></p><p><a href="https://blog.csdn.net/wads23456/article/details/104842189/?utm_medium=distribute.pc_relevant.none-task-blog-title-1&amp;spm=1001.2101.3001.4242">https://blog.csdn.net/wads23456/article/details/104842189/?utm_medium=distribute.pc_relevant.none-task-blog-title-1&amp;spm=1001.2101.3001.4242</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下内容仅为归纳，具体细节可自行测试。&lt;/p&gt;
&lt;h2 id=&quot;使用步骤&quot;&gt;&lt;a href=&quot;#使用步骤&quot; class=&quot;headerlink&quot; title=&quot;使用步骤&quot;&gt;&lt;/a&gt;使用步骤&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;用&lt;code&gt;-fsanitize=address&lt;/co
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Understanding C parsers generated by GNU Bison</title>
    <link href="https://billyotry.github.io/2021/01/22/Understanding%20C%20parsers%20generated%20by%20GNU%20Bison/"/>
    <id>https://billyotry.github.io/2021/01/22/Understanding%20C%20parsers%20generated%20by%20GNU%20Bison/</id>
    <published>2021-01-21T16:59:43.872Z</published>
    <updated>2021-01-22T03:42:37.227Z</updated>
    
    <content type="html"><![CDATA[<h3 id="table分析"><a href="#table分析" class="headerlink" title="table分析"></a>table分析</h3><p>bision与flex类似，有一系列的表，理清这些表之间的关系及索引方式后能更好的理解<code>yyparse</code>。</p><h4 id="yytranslate"><a href="#yytranslate" class="headerlink" title="yytranslate"></a>yytranslate</h4><p>此表映射了token和symbol token之间的关系。如果是预定义的<code>%token</code>，则会映射到其他的token序号中；如果是普通的终结符，则会把字符对应的ascii码映射到对应token中。</p><p>例如<code>S: &#39;\n&#39; ;</code>规则在生成后如下</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_uint8 yytranslate[] =</span><br><span class="line">&#123;</span><br><span class="line">       <span class="number">0</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,</span><br><span class="line">       <span class="number">3</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,</span><br><span class="line">...       </span><br><span class="line">       <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">1</span>,     <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>&#39;\n&#39;</code>的ascii为10,所以yytranslate[10]=3</p><p>多数映射的token为2，2是未定义，只有在语法中定义的符号才被赋予有效的符号编号。</p><p>这里的<code>&#39;\n&#39;</code>为什么是3，那是因为终结符的编号从3开始，可以通过查看输出解析器中生成的yytname数组来检查分配给各种符号的符号编号，而这里的例子符号编号如下所示。</p><table><thead><tr><th align="center"><em>Symbol</em></th><th align="center"><em>Number</em></th></tr></thead><tbody><tr><td align="center">$end</td><td align="center">0</td></tr><tr><td align="center">error</td><td align="center">1</td></tr><tr><td align="center">$undefined</td><td align="center">2</td></tr><tr><td align="center">\n</td><td align="center">3</td></tr></tbody></table><p>每当<code>yyparse()</code>需要token时，它都会调用<code>yylex</code>，然后获取对应token的symbol token内部码。</p><h4 id="yydefact"><a href="#yydefact" class="headerlink" title="yydefact"></a>yydefact</h4><p>此表存储了每个状态下对应的产生式规则的序号。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state</span></span><br><span class="line"><span class="comment">   STATE-NUM when YYTABLE doesn&#x27;t specify something else to do.  Zero</span></span><br><span class="line"><span class="comment">   means the default is an error.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_uint8 yydefact[] =</span><br><span class="line">&#123;</span><br><span class="line">       <span class="number">0</span>,     <span class="number">2</span>,     <span class="number">0</span>,     <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>在STATE-NAME状态下，通过yydefact[STATE-NAME]来获取其对应的产生式规则的序号。</p></blockquote><p>其中，<code>0</code>号表示error。由于默认<code>($accept → L $end)</code>rule(其rule number为1)的存在，我们定义的所有rule索引都会增加1。即我们定义的第一个rule <code>S: &#39;\n&#39; ;</code>, 其rule number在此处为2。</p><h4 id="yydefgoto"><a href="#yydefgoto" class="headerlink" title="yydefgoto"></a>yydefgoto</h4><p>yydefgoto是GOTO跳转表的压缩形式。它的元素数量为语法中非终结符的数量，元素的值表示每个非终结符要跳转的状态。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* yydefgoto[nth non-terminal] = most common GOTO state for the nth non-terminal. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_int8 yydefgoto[] =</span><br><span class="line">&#123;</span><br><span class="line">      <span class="number">-1</span>,     <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>索引方式为<code>yytranslate</code>表中的符号编号减去非终结符的数目。</p><p>parser在用rule归约栈上内容的时候会查询yydefgoto，但在某些状态下会使用yytable表。</p><p>第一个非终结符<code>$accept</code>的rule为-1(即yydefgoto[0]),<code>$accept</code>不会被归约。</p><h4 id="yyr1-and-yyr2"><a href="#yyr1-and-yyr2" class="headerlink" title="yyr1 and yyr2"></a>yyr1 and yyr2</h4><p>yyr1表示每个rule左部的symbol数量，通过yyr1，当进行归约时，我们需要知道用于还原以转换为适当状态的规则的LHS符号，这就是该表使用的地方。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_uint8 yyr1[] =</span><br><span class="line">&#123;</span><br><span class="line">       <span class="number">0</span>,     <span class="number">4</span>,     <span class="number">5</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>yyr2表示每个rule右部的symbol数量，</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_uint8 yyr2[] =</span><br><span class="line">&#123;</span><br><span class="line">       <span class="number">0</span>,     <span class="number">2</span>,     <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例如<strong>rule2</strong>的<code>S: &#39;\n&#39;</code>右侧有1个symbol，因此yyr2[2]=1。在归约的时候，通过这个表中查找在对应的rule下，我们要从栈中pop出多少state来作为归约。</p><h4 id="yytable"><a href="#yytable" class="headerlink" title="yytable"></a>yytable</h4><p>yytable和yycheck, yypact, yypgoto 配合来表示当前的状态是应该放入移入中还是符合rule来进行归约。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If</span></span><br><span class="line"><span class="comment">   positive, shift that token.  If negative, reduce the rule which</span></span><br><span class="line"><span class="comment">   number is the opposite.  If zero, do what YYDEFACT says.</span></span><br><span class="line"><span class="comment">   If YYTABLE_NINF, syntax error.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YYTABLE_NINF -1</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_uint8 yytable[] =</span><br><span class="line">&#123;</span><br><span class="line">       <span class="number">1</span>,     <span class="number">3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>正数表示移入，负数表示归约，其中归约所使用的规则的number为元素的绝对值，即如果是-3，则使用rule3来进行归约。</p><h4 id="yypgoto"><a href="#yypgoto" class="headerlink" title="yypgoto"></a>yypgoto</h4><p>因为同一个非终结符，根据之前状态的不同，其跳转的状态也是不同的，那么对于存在不同情况的GOTO情况，则由yypgoto记录。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YYPGOTO[NTERM-NUM].  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_int8 yypgoto[] =</span><br><span class="line">&#123;</span><br><span class="line">      <span class="number">-4</span>,     <span class="number">-4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此表的索引对应这所有的非终结符，这里分别对应<code>$accept</code>,<code>S</code>。</p><p>比如现在在rule2 (<code>S -&gt; &#39;\n&#39;</code>)归约后，栈顶的状态为4，parser会将yypgoto[S]的值(此处yypgoto[1]=-4)加上原先的状态值作为现在的状态索引，去yytable找到新的状态值，即此时状态索引为0 (4-4)， 那么yytable[0]为1，那么现在的状态就是1，被压入状态栈顶。</p><p>parser到底是用<code>yypgoto</code>还是<code>yydefgoto</code>来设置接下来的状态，将在<code>yycheck</code>中指出。</p><h4 id="yypact"><a href="#yypact" class="headerlink" title="yypact"></a>yypact</h4><p>yypact定义了在初始状态下的部分yytable。它由token标号来索引。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YYPACT_NINF -4</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_int8 yypact[] =</span><br><span class="line">&#123;</span><br><span class="line">      <span class="number">-3</span>,    <span class="number">-4</span>,    <span class="number">1</span>,     <span class="number">-4</span>  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是解析循环查询的第一个表，在parse循环开始的时候，如果yypact[cur-state] = YYPACT_NINF，意味着使用yydefact来进行归约，并且只有归约没有移入操作。</p><p>例如此处如果是状态1和3，则为YYPACT_NINF，只进行归约操作。</p><p>如果现在在状态0，展望符为<code>\n</code>(即3号symbol,由yytranslate可得)，那么现在的yypact[0]为-3，所以在yytable中的索引应该为<code>-3+3=0</code>, yytable[0]为1，表示移入并转移到状态1。</p><h4 id="yycheck"><a href="#yycheck" class="headerlink" title="yycheck"></a>yycheck</h4><p>yycheck主要有两个作用，一个是判断归约还是移入，一个是判断选用<code>yypgoto</code>还是<code>yydefgoto</code>跳转表。</p><h5 id="yytable-or-yydefact"><a href="#yytable-or-yydefact" class="headerlink" title="yytable or yydefact"></a>yytable or yydefact</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">YYCHECK = a <span class="built_in">vector</span> indexed in parallel with YYTABLE.  It indicates,</span><br><span class="line">   in a roundabout way, the bounds of the portion you are trying to</span><br><span class="line">   examine.</span><br><span class="line"></span><br><span class="line">   Suppose that the portion of YYTABLE starts at index P <span class="keyword">and</span> the index</span><br><span class="line">   to be examined within the portion is I.  Then <span class="keyword">if</span> YYCHECK[P+I] != I,</span><br><span class="line">   I is outside the bounds of what is actually allocated, <span class="keyword">and</span> the</span><br><span class="line">   <span class="keyword">default</span> (from YYDEFACT <span class="keyword">or</span> YYDEFGOTO) should be used.  Otherwise,</span><br><span class="line">   YYTABLE[P+I] should be used.  </span><br></pre></td></tr></table></figure><p>parse会判断yycheck[0]是否为所有有效token的symbol number, 如果不是，则进行yydefault的归约。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">yyn += yytoken;</span><br><span class="line">  <span class="keyword">if</span> (yyn &lt; <span class="number">0</span> || YYLAST &lt; yyn || yycheck[yyn] != yytoken)</span><br><span class="line">    <span class="keyword">goto</span> yydefault;</span><br></pre></td></tr></table></figure><p>此时yycheck[0]=3，而<code>\n</code>正好是3号symbol，所有我们选择<code>yytable</code>。</p><h5 id="yydefgoto-or-yypgoto"><a href="#yydefgoto-or-yypgoto" class="headerlink" title="yydefgoto or yypgoto"></a>yydefgoto or yypgoto</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">yyn = yyr1[yyn];</span><br><span class="line">yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> &lt;= yystate &amp;&amp; yystate &lt;= YYLAST &amp;&amp; yycheck[yystate] == *yyssp)</span><br><span class="line">    yystate = yytable[yystate];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    yystate = yydefgoto[yyn - YYNTOKENS];</span><br></pre></td></tr></table></figure><p>比如现在在rule2 (<code>S -&gt; &#39;\n&#39;</code>)归约后，栈顶的状态为4，parser会将yypgoto[S]的值(此处yypgoto[1]=-4)加上原先的状态值作为现在的状态索引4-4=0，查询yycheck，如果为4，则表示状态4为特殊状态，选择yytable; 否则就用yydefgoto表来决定跳转。</p><h3 id="parse分析"><a href="#parse分析" class="headerlink" title="parse分析"></a>parse分析</h3><p>详见注释</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*全局变量*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 此变量存储展望符.  */</span></span><br><span class="line"><span class="keyword">int</span> yychar;</span><br><span class="line"><span class="comment">/* 展望符的语义值.  */</span></span><br><span class="line">YYSTYPE yylval;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> </span><br><span class="line">yyparse()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> yystate; <span class="comment">/* current state */</span></span><br><span class="line"><span class="keyword">int</span> yyn;<span class="comment">/* 这是一个通用变量！一次可能代表一种状态，下次可能代表一条规则 */</span></span><br><span class="line"><span class="keyword">int</span> yyresult;<span class="comment">/* 解析结果返回给调用者 */</span></span><br><span class="line"><span class="keyword">int</span> yytoken=<span class="number">0</span>;<span class="comment">/* current token */</span></span><br><span class="line"><span class="comment">/* The state stack: This parser does not shift symbols on to the stack. Only a stack of states is maintained. */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> yyssa[YYINITDEPTH];<span class="comment">/*YYINITDEPTH is 200 */</span></span><br><span class="line"> <span class="keyword">int</span> *yyss = yyssa<span class="comment">/* Bottom of state stack */</span></span><br><span class="line"> <span class="keyword">int</span> *yyssp;<span class="comment">/* Top of state stack */</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* The semantic value stack: 该栈与状态栈平行增长。每次减少时，都会从堆栈中弹出语义值，并执行语义操作 */</span></span><br><span class="line">  YYSTYPE yyvsa[YYINITDEPTH];</span><br><span class="line">  YYSTYPE *yyvs = yyvsa;<span class="comment">/* Bottom of semantic stack */</span></span><br><span class="line">  YYSTYPE *yyvsp;<span class="comment">/* Top of semantic stack */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* POP the state and semantic stacks by N symbols - useful for reduce actions */</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> yylen = <span class="number">0</span>;<span class="comment">/* 该变量用于归约操作中保存规则右侧的终结符长度 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Ok done declaring variables. Set the ball rolling */</span></span><br><span class="line">  </span><br><span class="line">  yystate = <span class="number">0</span>;<span class="comment">/* Initial state */</span></span><br><span class="line">  yychar = YYEMPTY <span class="comment">/* YYEMPTY is -2 */</span></span><br><span class="line">  </span><br><span class="line">  yyssp = yyss; <span class="comment">/* Top = bottom for state stack */</span></span><br><span class="line">  yyvsp = yyvs;<span class="comment">/* Same for semantic stack */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">goto</span> yysetstate; <span class="comment">/* Well, gotos are used for extracting maximum performance. */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Each label can be thought of as a function */</span></span><br><span class="line">  </span><br><span class="line">  yynewstate:  <span class="comment">/* Push a new state on the stack */</span></span><br><span class="line">  </span><br><span class="line">  yyssp ++;<span class="comment">/*Just increment the stack top; actual &#x27;pushing&#x27; will happen in yysetstate */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  yysetstate:</span><br><span class="line">  </span><br><span class="line">  *yyssp = yystate;<span class="comment">/* Ok pushed state on state stack top */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">goto</span> yybackup;<span class="comment">/* This is where you will find some action */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  yybackup:<span class="comment">/* The main parsing code starts here */</span></span><br><span class="line">  </span><br><span class="line">  yyn = yypact[yystate];<span class="comment">/* Refer to what yypact is saying about the current state */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ( yyn == YYPACT_NINF) <span class="comment">/* If negative infinity its time for a default reduction */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">goto</span> yydefault;<span class="comment">/* This label implements default reductions; see below */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Check if we have a look-ahead token ready. This is LALR(1) parsing */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (yychar == YYEMPTY)</span><br><span class="line">  </span><br><span class="line">  yychar = YYLEX; <span class="comment">/* Macro YYLEX is defined as yylex() */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (yychar &lt;= YYEOF) <span class="comment">/* YYEOF is 0 - the token returned by lexer at end of input */</span></span><br><span class="line">  </span><br><span class="line">  yychar = yytoken = YYEOF; <span class="comment">/* set all to EOF */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  </span><br><span class="line">  yytoken = yytranslate[yychar];<span class="comment">/* Translate the lexer token into internal symbol number */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Now we have a look-ahead token. Let the party begin ! */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  yyn = yyn + yytoken;<span class="comment">/* This is yypact[yystate] + yytoken */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Observe this check carefully. We are checking that yyn is within the bounds of yytable</span></span><br><span class="line"><span class="comment">   * and also if yycheck contains the current token number.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> ( yyn &lt; <span class="number">0</span> || YYLAST &lt; yyn  || yycheck[yyn] != yytoken )<span class="comment">/* YYLAST is the highest index in yytable */</span></span><br><span class="line">     </span><br><span class="line">  <span class="keyword">goto</span> yydefault; <span class="comment">/* Its time for a default reduction */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Ok, yyn is within bounds of yytable */</span></span><br><span class="line">  </span><br><span class="line">  yyn = yytable[yyn];<span class="comment">/* This is yytable[ yypact[yystate] + yytoken ] */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (yyn &lt;= <span class="number">0</span>)<span class="comment">/* If yytable happens to contain a -ve value, its not a shift - its a reduce */</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">if</span> (yyn == <span class="number">0</span> || yyn == YYTABLE_NINF)<span class="comment">/* But check for out of bounds condition*/</span></span><br><span class="line">  <span class="keyword">goto</span> yyerrlab;<span class="comment">/* Label to handle errors */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Other wise reduce with rule # -yyn */</span></span><br><span class="line">  </span><br><span class="line">  yyn = -yyn;</span><br><span class="line">  <span class="keyword">goto</span> yyreduce; <span class="comment">/* Label to implement reductions */</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Last check: See if we reached final state! */</span></span><br><span class="line">  <span class="keyword">if</span> (yyn == YYFINAL)<span class="comment">/* YYFINAL is 8 in our case */</span></span><br><span class="line">  YYACCEPT;<span class="comment">/* macro deined as &#x27;goto acceptlab - a label to finish up */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* That completes all checks; If we reached here, there is no other option but to shift */</span></span><br><span class="line">  </span><br><span class="line">  yystate = yyn;<span class="comment">/* Now, yyn (= yytable[ yypact[yystate] + yytoken ]) is a state that has to be pushed */</span></span><br><span class="line">  </span><br><span class="line">  *++yyvsp = yylval; <span class="comment">/* Push the semantic value of the symbol on the semantic stack */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">goto</span> yynewstate;<span class="comment">/* This will increment state stack top and the following yysetstate that will do the pushing */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  yydefault:<span class="comment">/* A label to implement default reductions */</span></span><br><span class="line">  </span><br><span class="line">  yyn = yydefact[yystate];<span class="comment">/* Get the default reduction rule for this state */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ( yyn == <span class="number">0</span> )<span class="comment">/* This state has no default reduction. Something is wrong */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">goto</span> yyerrlab;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">goto</span> yyreduce;<span class="comment">/* Ok, got the default reduction rule # in yyn; go ahead and reduce the stack */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  yyreduce:<span class="comment">/* A lablel that implements reductions on stack. */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* By the time we are here, yyn contains the rule# to use for reducing the stack. */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Steps for reduction:</span></span><br><span class="line"><span class="comment">   * 1. Find the length of RHS of rule #yyn</span></span><br><span class="line"><span class="comment">   * 2. Execute any semantic actions by taking the values from the semantic stack</span></span><br><span class="line"><span class="comment">   * 3. POP &#x27;length&#x27; symbols from the state stack and &#x27;length&#x27; values from semantic stack</span></span><br><span class="line"><span class="comment">   * 4. Find the LHS of rule #yyn</span></span><br><span class="line"><span class="comment">   * 5. Find the GOTO of state currently on top of stack on LHS symbol</span></span><br><span class="line"><span class="comment">   * 6. Push that state on top of stack</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   </span><br><span class="line">   yylen = yyr2[yyn];<span class="comment">/* Get length of RHS */</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* Default semantic action - $$=$1 */</span></span><br><span class="line">   yyval = yyvsp[<span class="number">1</span>-yylen];</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* Execute semantic actions */</span></span><br><span class="line">   <span class="keyword">switch</span> ( yyn )<span class="comment">/* Each rule has its own semantic action */</span></span><br><span class="line">   &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">default</span>:<span class="keyword">break</span>;<span class="comment">/* We didn&#x27;t have any semantic actions in the grammar.*/</span></span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   YYPOPSTACK (yylen);<span class="comment">/* This will pop both state and semantic stacks. See definition of this macro above */</span></span><br><span class="line">   </span><br><span class="line">   yylen = <span class="number">0</span>;<span class="comment">/* re-initialize yylen */</span></span><br><span class="line">   </span><br><span class="line">   *++yyvsp  = yyval;<span class="comment">/* Push the result of semantic evaluation on top of semantic stack */</span></span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* Now shift the result of reduction (steps 4 - 6) */</span></span><br><span class="line">   </span><br><span class="line">   yyn = yyr1[yyn];<span class="comment">/* Reuse yyn at every opportunity.  For now, yyn is the LHS symbol (number) of the rule */</span></span><br><span class="line">   </span><br><span class="line"> <span class="comment">/* First check for anomalous GOTOs, otherwise use Default GOTO (YYDEFGOTO)</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * Observe that if we subtract no. of terminals (YYNTOKENS) from symbol number of a nonterminal, we get</span></span><br><span class="line"><span class="comment">  * an index into yypgoto or yydefgoto for that non-terminal.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  </span><br><span class="line">   yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* A couple of checks are needed before we know this is not a default GOTO</span></span><br><span class="line"><span class="comment">    * 1. yystate must be within bounds of yytable. ( 0 to YYLAST )</span></span><br><span class="line"><span class="comment">    * 2. yycheck must contain the state currently on top of the stack</span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">   <span class="keyword">if</span> ( <span class="number">0</span> &lt;= yystate &amp;&amp; yystate &lt;= YYLAST &amp;&amp; yycheck[yystate] = *yyssp)</span><br><span class="line">   </span><br><span class="line">   yystate = yytable[yystate];<span class="comment">/* Take the GOTO from yytable */</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   </span><br><span class="line">   yystate = yydefgoto[yyn - YYNTOKENS];<span class="comment">/* Otherwise use the default GOTO */</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">goto</span> yynewstate;<span class="comment">/* Simply push the newly found state on top of stack and continue */</span></span><br><span class="line">   </span><br><span class="line">&#125;<span class="comment">/* End of yyparse() */</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来说和flex类似，其实也是通过一系列的表来驱动。</p><h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p><a href="https://www.cs.uic.edu/~spopuri/cparser.html#lr-parser">https://www.cs.uic.edu/~spopuri/cparser.html#lr-parser</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;table分析&quot;&gt;&lt;a href=&quot;#table分析&quot; class=&quot;headerlink&quot; title=&quot;table分析&quot;&gt;&lt;/a&gt;table分析&lt;/h3&gt;&lt;p&gt;bision与flex类似，有一系列的表，理清这些表之间的关系及索引方式后能更好的理解&lt;code&gt;y
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>lexical scanner generated by flex</title>
    <link href="https://billyotry.github.io/2021/01/22/lexical%20scanner%20generated%20by%20flex/"/>
    <id>https://billyotry.github.io/2021/01/22/lexical%20scanner%20generated%20by%20flex/</id>
    <published>2021-01-21T16:59:43.871Z</published>
    <updated>2021-01-22T03:42:50.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="flex生成代码分析"><a href="#flex生成代码分析" class="headerlink" title="flex生成代码分析"></a>flex生成代码分析</h2><p>本文从flex源码入手分析flex框架。</p><p>flex会根据我们所定义的正则表达式来匹配相应的字符，然后执行相应的函数操作来输出相应的 token。</p><p>新建空规则 <code>null.flex</code> 来了解 flex 是如何工作的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%%</span><br></pre></td></tr></table></figure><p>运行命令 <code>flex null.flex</code> 生成代码如下：<a href="https://pastebin.com/LBEXsnZK">https://pastebin.com/LBEXsnZK</a></p><p>首先定义与 flex 版本相关的宏</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define FLEX_SCANNER</span><br><span class="line">#define YY_FLEX_MAJOR_VERSION 2</span><br><span class="line">#define YY_FLEX_MINOR_VERSION 6</span><br><span class="line">#define YY_FLEX_SUBMINOR_VERSION 0</span><br><span class="line">#if YY_FLEX_SUBMINOR_VERSION &gt; 0</span><br><span class="line">#define FLEX_BETA</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>为了防止类型被用户代码冲突，此处将一些类型 define 成的自己的格式，或许是出于可移植性以及用户可定制性的考虑，flex 将大量关键字 define/typedef 成了自己的特殊关键字，不过从名称上大体都能猜出是什么含义。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">typedef int8_t flex_int8_t;</span><br><span class="line">typedef uint8_t flex_uint8_t;</span><br><span class="line">typedef int16_t flex_int16_t;</span><br><span class="line">typedef uint16_t flex_uint16_t;</span><br><span class="line">typedef int32_t flex_int32_t;</span><br><span class="line">typedef uint32_t flex_uint32_t;</span><br><span class="line">#else</span><br><span class="line">typedef signed char flex_int8_t;</span><br><span class="line">typedef short int flex_int16_t;</span><br><span class="line">typedef int flex_int32_t;</span><br><span class="line">typedef unsigned char flex_uint8_t; </span><br><span class="line">typedef unsigned short int flex_uint16_t;</span><br><span class="line">typedef unsigned int flex_uint32_t;</span><br></pre></td></tr></table></figure><p>然后是定义 EOF 的宏</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define YY_NULL 0</span><br></pre></td></tr></table></figure><p>将字符转为对应的 ascii 码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)</span><br></pre></td></tr></table></figure><p>虽然 DFA 在状态转移的过程中一次前进一个字符，但是为了提高 IO 效率，实际从文件读取的时候一般是批量往缓冲区读入的。如果有需要微调这个读入策略的需求，可以通过定义 <code>YY_INPUT</code> 宏来实现。在默认生成的代码中，这个宏被定义为一段比较复杂的C代码。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> YY_INPUT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YY_INPUT(buf,result,max_size) </span></span><br><span class="line"><span class="keyword">if</span> ( YY_CURRENT_BUFFER_LVALUE-&gt;yy_is_interactive ) </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">int</span> c = <span class="string">&#x27;*&#x27;</span>; </span><br><span class="line"><span class="keyword">size_t</span> n; </span><br><span class="line"><span class="keyword">for</span> ( n = <span class="number">0</span>; n &lt; max_size &amp;&amp; </span><br><span class="line">     (c = getc( yyin )) != EOF &amp;&amp; c != <span class="string">&#x27;\n&#x27;</span>; ++n ) </span><br><span class="line">buf[n] = (<span class="keyword">char</span>) c; </span><br><span class="line"><span class="keyword">if</span> ( c == <span class="string">&#x27;\n&#x27;</span> ) </span><br><span class="line">buf[n++] = (<span class="keyword">char</span>) c; </span><br><span class="line"><span class="keyword">if</span> ( c == EOF &amp;&amp; ferror( yyin ) ) </span><br><span class="line">YY_FATAL_ERROR( <span class="string">&quot;input in flex scanner failed&quot;</span> ); </span><br><span class="line">result = n; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123; </span><br><span class="line">errno=<span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span> ( (result = fread(buf, <span class="number">1</span>, max_size, yyin))==<span class="number">0</span> &amp;&amp; ferror(yyin)) </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span>( errno != EINTR) </span><br><span class="line">&#123; </span><br><span class="line">YY_FATAL_ERROR( <span class="string">&quot;input in flex scanner failed&quot;</span> ); </span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line">&#125; </span><br><span class="line">errno=<span class="number">0</span>; </span><br><span class="line">clearerr(yyin); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>上述 C 代码十分复杂，我们也可以将此宏修改成如下形式</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> YY_INPUT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YY_INPUT(buf,result,max_size) </span></span><br><span class="line">    <span class="keyword">if</span> ( (result = fread( (<span class="keyword">char</span>*)buf, <span class="keyword">sizeof</span>(<span class="keyword">char</span>), max_size, fin)) &lt; <span class="number">0</span>) </span><br><span class="line">        YY_FATAL_ERROR( <span class="string">&quot;read() in flex scanner failed&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="DFA状态转移表分析"><a href="#DFA状态转移表分析" class="headerlink" title="DFA状态转移表分析"></a>DFA状态转移表分析</h2><h3 id="未压缩状态矩阵"><a href="#未压缩状态矩阵" class="headerlink" title="未压缩状态矩阵"></a>未压缩状态矩阵</h3><p>以下是<strong>经过压缩</strong>的状态转移矩阵.其实 flex 在默认的情况下,会输出压缩版本的状态转移矩阵,因为完整版本的矩阵是 Nx128 大小(其中N是自动机的状态数，128 则是字符集大小如果不经压缩的话,会带来不必要的空间开销。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static yyconst flex_int16_t yy_accept[6]</span><br><span class="line">static yyconst YY_CHAR yy_ec[256]</span><br><span class="line">static yyconst YY_CHAR yy_meta[2]</span><br><span class="line">static yyconst flex_uint16_t yy_base[7]</span><br><span class="line">static yyconst flex_int16_t yy_def[7]</span><br><span class="line">static yyconst flex_uint16_t yy_nxt[5]</span><br><span class="line">static yyconst flex_int16_t yy_chk[5]</span><br></pre></td></tr></table></figure><p>以下是未经过压缩的状态转移矩阵。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static yyconst flex_int16_t yy_nxt[][128] &#x3D; &#123;...&#125;</span><br><span class="line">static yyconst flex_int16_t yy_accept[..] &#x3D; &#123;...&#125;</span><br></pre></td></tr></table></figure><ul><li>yy_accept 是 accept 的状态</li><li>yy_nxt 是状态跳转表</li></ul><p>有了状态转移表，接下来的关键问题就是如何使用它。这里我们就要参考词法分析函数的实现函数—— <code>yylex()</code>的具体实现了。</p><p>在 flex 所生成的代码中，连这个函数的定义语句都被define成<code>YY_DECL</code>：<code>#define YY_DECL int yylex (void)</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** The main scanner function which does all the work.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">YY_DECL</span><br><span class="line">&#123;</span><br><span class="line">    yy_state_type yy_current_state;</span><br><span class="line">    <span class="keyword">char</span> *yy_cp, *yy_bp;</span><br><span class="line">    <span class="keyword">int</span> yy_act;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ( !(yy_init) )</span><br><span class="line">        &#123;</span><br><span class="line">        (yy_init) = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> ( ! (yy_start) )</span><br><span class="line">            (yy_start) = <span class="number">1</span>; <span class="comment">// 初始状态定义</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* 设置文件输入、输出指针 */</span></span><br><span class="line">        <span class="keyword">if</span> ( ! yyin )</span><br><span class="line">            yyin = <span class="built_in">stdin</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> ( ! yyout )</span><br><span class="line">            yyout = <span class="built_in">stdout</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* 对非owner的buffer使用stack方式管理*/</span></span><br><span class="line">        <span class="keyword">if</span> ( ! YY_CURRENT_BUFFER ) &#123;</span><br><span class="line">            yyensure_buffer_stack ();</span><br><span class="line">            YY_CURRENT_BUFFER_LVALUE =</span><br><span class="line">                yy_create_buffer(yyin,YY_BUF_SIZE );</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        yy_load_buffer_state( );</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )        </span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// 设置各种buffer处的指针，以便在匹配成功时，通过yytext获取对应字符串</span></span><br><span class="line">        <span class="comment">/*此指针指向上一字符*/</span></span><br><span class="line">        yy_cp = (yy_c_buf_p);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* Support of yytext. */</span></span><br><span class="line">        <span class="comment">/*此指针不断指向要读入的字符,将会在状态跳转中不断更新*/</span></span><br><span class="line">        *yy_cp = (yy_hold_char);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* yy_bp points to the position in yy_ch_buf of the start of</span></span><br><span class="line"><span class="comment">         * the current run.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        yy_bp = yy_cp;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 默认从start状态开始</span></span><br><span class="line">        yy_current_state = (yy_start);</span><br><span class="line">yy_match:</span><br><span class="line">        <span class="comment">// 开始进行状态转移, 通过yy_nxt表，结合yy_current_state和当前读入的字符来索引跳转状态, 直到无法转移</span></span><br><span class="line">        <span class="comment">// 根据当前状态，以及下一个字符，来进行转移</span></span><br><span class="line">        <span class="keyword">while</span> ( (yy_current_state = yy_nxt[yy_current_state][ YY_SC_TO_UI(*yy_cp) ]) &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span> ( yy_accept[yy_current_state] )</span><br><span class="line">                &#123;</span><br><span class="line">                (yy_last_accepting_state) = yy_current_state;</span><br><span class="line">                (yy_last_accepting_cpos) = yy_cp;</span><br><span class="line">                &#125;</span><br><span class="line">            ++yy_cp;</span><br><span class="line"> &#125;</span><br><span class="line">        yy_current_state = -yy_current_state;</span><br><span class="line"> </span><br><span class="line">yy_find_action:</span><br><span class="line">        <span class="comment">// 状态转移完了，查看转移后的状态是否出于可接受状态</span></span><br><span class="line">        yy_act = yy_accept[yy_current_state];</span><br><span class="line"> </span><br><span class="line">        YY_DO_BEFORE_ACTION;</span><br><span class="line"> </span><br><span class="line">do_action:    <span class="comment">/* 这里主要是处理读取到EOF的情况. */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">switch</span> ( yy_act )    &#123; <span class="comment">/* beginning of action switch */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// yy_accept中值为1为接受状态，其他状态不合法 </span></span><br><span class="line">        &#123;<span class="keyword">return</span> <span class="literal">true</span> ;&#125;</span><br><span class="line">        YY_BREAK</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">case</span> <span class="title">YY_STATE_EOF</span><span class="params">(INITIAL)</span>:</span></span><br><span class="line"><span class="function">        <span class="title">yyterminate</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> YY_END_OF_BUFFER:</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">/* Amount of text matched not including the EOB char. */</span></span><br><span class="line">        <span class="keyword">int</span> yy_amount_of_matched_text = (<span class="keyword">int</span>) (yy_cp - (yytext_ptr)) - <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 还原YY_DO_BEFORE_ACTION做出的变动</span></span><br><span class="line">        *yy_cp = (yy_hold_char);</span><br><span class="line">        YY_RESTORE_YY_MORE_OFFSET</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 调整buffer，其中有对EOB的不同情况的处理等等</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        YY_FATAL_ERROR(<span class="string">&quot;fatal flex scanner internal error--no action found&quot;</span> );</span><br><span class="line">        &#125; <span class="comment">/* end of action switch */</span></span><br><span class="line">    &#125; <span class="comment">/* end of scanning one token */</span></span><br><span class="line">    &#125; <span class="comment">/* end of user&#x27;s declarations */</span></span><br><span class="line">&#125; <span class="comment">/* end of yylex */</span></span><br></pre></td></tr></table></figure><p>我们从中可以看出，<strong>1</strong> 是我们起始状态的起点,在进行正则匹配的时候，我们从这个状态开始不断的读入字符，不断的进行状态转移，最终会停在某个节点。此时我们就会判断当前状态对应的数值,如果是 <strong>1</strong> 则表示 accept 状态，如果不是则为非法的，这里面的两个 <code>1</code> <strong>含义完全不同</strong>：前者是状态的标识，后者则是标志某个状态是否是接受状态。</p><p>上面的 DFA 伪代码可以抽象成</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">state= <span class="number">0</span>; </span><br><span class="line">get next input character</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">not</span> end of input) &#123;</span><br><span class="line">    depending on current state <span class="keyword">and</span> input character</span><br><span class="line">        match: <span class="comment">/* input expected */</span></span><br><span class="line">            calculate <span class="keyword">new</span> state; get next input character</span><br><span class="line">        accept: <span class="comment">/* current pattern completely matched */</span></span><br><span class="line">            state= <span class="number">0</span>; perform action corresponding to pattern</span><br><span class="line">        error: <span class="comment">/* input unexpected */</span></span><br><span class="line">            state= <span class="number">0</span>; echo <span class="number">1</span>st character input after last accept <span class="keyword">or</span> error;</span><br><span class="line">            reset input to <span class="number">2</span>nd character input after last accept <span class="keyword">or</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结就是从开始状态开始，读取字符并结合状态跳转表来进行状态跳转，当无法继续跳转的时候或字符已经读取完成,此时判断是否是 accept 的状态，并执行用户定义的规则代码。</p><h3 id="压缩状态矩阵"><a href="#压缩状态矩阵" class="headerlink" title="压缩状态矩阵"></a>压缩状态矩阵</h3><p>状态跳转表以及accept表如下</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">yyconst <span class="keyword">flex_int16_t</span> yy_accept[<span class="number">10</span>]</span><br><span class="line">yyconst YY_CHAR yy_ec[<span class="number">256</span>]</span><br><span class="line">yyconst YY_CHAR yy_meta[<span class="number">7</span>]</span><br><span class="line">yyconst <span class="keyword">flex_uint16_t</span> yy_base[<span class="number">12</span>]</span><br><span class="line">yyconst <span class="keyword">flex_int16_t</span> yy_def[<span class="number">12</span>]</span><br><span class="line">yyconst <span class="keyword">flex_uint16_t</span> yy_nxt[<span class="number">19</span>]</span><br><span class="line">yyconst <span class="keyword">flex_int16_t</span> yy_chk[<span class="number">19</span>]</span><br></pre></td></tr></table></figure><p>而此时 match 中的代码就会变为</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">yy_current_state = (yy_start);</span><br><span class="line">yy_match:</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">register</span> YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;</span><br><span class="line">    <span class="comment">// 这个if语句就不影响状态转移，只是为了记录状态</span></span><br><span class="line">    <span class="keyword">if</span> ( yy_accept[yy_current_state] )</span><br><span class="line">        &#123;</span><br><span class="line">        (yy_last_accepting_state) = yy_current_state;</span><br><span class="line">        (yy_last_accepting_cpos) = yy_cp;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span> ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )</span><br><span class="line">        &#123;</span><br><span class="line">        yy_current_state = (<span class="keyword">int</span>) yy_def[yy_current_state];</span><br><span class="line">        <span class="comment">// 注意这个22是Magic Number，随accept数量变化</span></span><br><span class="line">        <span class="keyword">if</span> ( yy_current_state &gt;= <span class="number">22</span> )</span><br><span class="line">            yy_c = yy_meta[(<span class="keyword">unsigned</span> <span class="keyword">int</span>) yy_c];</span><br><span class="line">        &#125;</span><br><span class="line">    yy_current_state = yy_nxt[yy_base[yy_current_state] + (<span class="keyword">unsigned</span> <span class="keyword">int</span>) yy_c];</span><br><span class="line">    ++yy_cp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 这个43也是Magic Number</span></span><br><span class="line"><span class="keyword">while</span> ( yy_base[yy_current_state] != <span class="number">43</span> );</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从生成代码中我们<strong>最需要知道</strong>的就是：DFA 的状态转移图(以矩阵的形式体现出来),以及理解如何使用状态转移图的,也就是理解 <code>yylex()</code> 函数的具体实现,它其中定义了各个状态的含义。那么从代码中我们也能知道<code>yy_nxt[yy_current_state][ YY_SC_TO_UI(*yy_cp) ]</code>中 yy_nxt 就是我们的状态跳转表，YY_SC_TO_UI 能够将我们的字符转成相应的 ascii，yy_cp 指针指向我们要读取的字符。这样我们的矩阵抽象出来就是我们的每一行代表的是我们的状态，每一列代表的是我们的字符转成ascii后的无符号整数。<strong>一句话概括就是现实生活中的查表</strong>。</p><p>例如一个规则表达式 <code>a(b|c)d*e+</code>，其状态可由下图表示</p><p><img src="https://i.loli.net/2020/06/25/4iISH2a3tJGZToc.png" alt="image-20200625220424190.png"></p><p>会产生如下状态表</p><p><img src="https://i.loli.net/2020/06/25/ysTpxdPSIjnKCoB.png" alt="image-20200625220612068.png"></p><ul><li><p>a 表示 accept 状态</p></li><li><p>m(N) 表示跳转到 N 状态</p></li><li><p>空白处则为 error</p></li></ul><p>基本上 flex 生成的代码还是通过匹配循环来实现<code>规则-&gt;行为</code>的模式，不断的调用 yylex 来匹配输出相应的 token。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://tina2114.github.io/2020/06/16/lexer代码骨架整理/#more">https://tina2114.github.io/2020/06/16/lexer%E4%BB%A3%E7%A0%81%E9%AA%A8%E6%9E%B6%E6%95%B4%E7%90%86/#more</a></p><p><a href="https://chenyuzhuwhiskey.github.io/2020/06/21/flex-lexer分析/">https://chenyuzhuwhiskey.github.io/2020/06/21/flex-lexer%E5%88%86%E6%9E%90/</a></p><p><a href="https://happyers.top/uncategorized/understanding-c-lexer-generated-by-flex/#toc-head-1">https://happyers.top/uncategorized/understanding-c-lexer-generated-by-flex/#toc-head-1</a></p><p><a href="https://blog.finaltheory.me/research/Flex-Tricks.html#b129e">https://blog.finaltheory.me/research/Flex-Tricks.html#b129e</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;flex生成代码分析&quot;&gt;&lt;a href=&quot;#flex生成代码分析&quot; class=&quot;headerlink&quot; title=&quot;flex生成代码分析&quot;&gt;&lt;/a&gt;flex生成代码分析&lt;/h2&gt;&lt;p&gt;本文从flex源码入手分析flex框架。&lt;/p&gt;
&lt;p&gt;flex会根据我们所
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
