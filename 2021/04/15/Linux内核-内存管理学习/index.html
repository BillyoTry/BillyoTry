<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Linux内核-内存管理学习 | C7</title><meta name="keywords" content="Kernel"><meta name="author" content="C7"><meta name="copyright" content="C7"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Linux内核对物理内存描述Linux将物理内存按固定大小的页面（一般为4K）划分内存，在内核初始化的时候，会建立一个全局struct page结构数组mem_map。数组中的每个元素与物理内存页面一一对应，整个数组就代表着系统中的全部物理页面。Linux将NUMA中内存访问速度一致的部分称为一个节点（Node），用struct pglist_data数据结构表示，通常使用时用它的typedef定">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux内核-内存管理学习">
<meta property="og:url" content="https://billyotry.github.io/2021/04/15/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="C7">
<meta property="og:description" content="Linux内核对物理内存描述Linux将物理内存按固定大小的页面（一般为4K）划分内存，在内核初始化的时候，会建立一个全局struct page结构数组mem_map。数组中的每个元素与物理内存页面一一对应，整个数组就代表着系统中的全部物理页面。Linux将NUMA中内存访问速度一致的部分称为一个节点（Node），用struct pglist_data数据结构表示，通常使用时用它的typedef定">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg">
<meta property="article:published_time" content="2021-04-15T03:46:22.581Z">
<meta property="article:modified_time" content="2021-04-22T11:19:23.090Z">
<meta property="article:author" content="C7">
<meta property="article:tag" content="Kernel">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://billyotry.github.io/2021/04/15/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AD%A6%E4%B9%A0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

const saveToLocal = {
  // ttl 單位是 天
  set: function setWithExpiry(key, value, ttl) {
    if (ttl === 0) return
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-04-22 19:19:23'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="/clock/css/clock.css"/><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/css/MonoFonts.addition.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/macWhite.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/font-awesome-animation.min.css"><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="C7" type="application/atom+xml">
<link rel="alternate" href="/rss2.xml" title="C7" type="application/rss+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/./"><i class="fa-fw fa fa-home faa-shake animated-hover"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive faa-shake animated-hover"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags faa-shake animated-hover"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open faa-shake animated-hover"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link faa-shake animated-hover"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart faa-shake animated-hover"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-gamepad faa-shake animated-hover"></i><span> 放松一下</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/games/2048/"><i class="fa-fw fa fa-gamepad faa-shake animated-hover"></i><span> 2048 经典2048</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="http://taqini.space/games/battle-city/#/"><i class="fa-fw fa fa-gamepad faa-shake animated-hover"></i><span> BattleCity 坦克大战</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">C7</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/./"><i class="fa-fw fa fa-home faa-shake animated-hover"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive faa-shake animated-hover"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags faa-shake animated-hover"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open faa-shake animated-hover"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link faa-shake animated-hover"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart faa-shake animated-hover"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-gamepad faa-shake animated-hover"></i><span> 放松一下</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/games/2048/"><i class="fa-fw fa fa-gamepad faa-shake animated-hover"></i><span> 2048 经典2048</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="http://taqini.space/games/battle-city/#/"><i class="fa-fw fa fa-gamepad faa-shake animated-hover"></i><span> BattleCity 坦克大战</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux内核-内存管理学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-04-15T03:46:22.581Z" title="发表于 2021-04-15 11:46:22">2021-04-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-22T11:19:23.090Z" title="更新于 2021-04-22 19:19:23">2021-04-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Learning/">Learning</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Linux内核对物理内存描述"><a href="#Linux内核对物理内存描述" class="headerlink" title="Linux内核对物理内存描述"></a>Linux内核对物理内存描述</h2><p>Linux将物理内存按固定大小的页面（一般为4K）划分内存，在内核初始化的时候，会建立一个<strong>全局struct page结构数组mem_map</strong>。数组中的每个元素与物理内存页面一一对应，整个数组就代表着系统中的全部物理页面。Linux将NUMA中内存访问速度一致的部分称为一个节点（Node），用<code>struct pglist_data</code>数据结构表示，通常使用时用它的typedef定义<code>pg_data_t</code>。系统中的每个节点都通过<code>pgdat_list</code>链表<code>pg_data_t -&gt; node_next</code>连接起来，该连接以NULL为结束标志。</p>
<p>每个节点又进一步分为许多块，称为区域（zones）。区域标识内存中的一块范围。区域用<code>struct zone_struct</code>数据结构表示，它的typedef定义为<code>zone_t</code>。</p>
<p>每个区域（zone）中有多个页面（Pages）组成。节点、区域、页面三者关系如下图：</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13415667082/0" alt="image-20210416002829877"></p>
<h3 id="节点（Node）"><a href="#节点（Node）" class="headerlink" title="节点（Node）"></a>节点（Node）</h3><p>节点（Node），在linux中用<code>struct pglist_data</code>数据结构表示，通常使用时它的typedef定义<code>pg_data_t</code>，数据结构定义在文件<code>include/linux/mmzone.h</code>中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On NUMA machines, each NUMA node would have a pg_data_t to describe</span></span><br><span class="line"><span class="comment"> * it&#x27;s memory layout. On UMA machines there is a single pglist_data which</span></span><br><span class="line"><span class="comment"> * describes the whole memory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Memory statistics and page replacement data structures are maintained on a</span></span><br><span class="line"><span class="comment"> * per-zone basis.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * node_zones contains just the zones for THIS node. Not all of the</span></span><br><span class="line"><span class="comment">	 * zones may be populated, but it is the full list. It is referenced by</span></span><br><span class="line"><span class="comment">	 * this node&#x27;s node_zonelists as well as other node&#x27;s node_zonelists.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个节点的区域</span></span><br><span class="line">    <span class="comment">// 在x86中有 ZONE_HIGHMEM,ZONE_NORMAL,ZONE_DMA</span></span><br><span class="line">    <span class="comment">// 在X86_64中有 DMA,DMA32,NORMAL</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> <span class="title">node_zones</span>[<span class="title">MAX_NR_ZONES</span>];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * node_zonelists contains references to all zones in all nodes.</span></span><br><span class="line"><span class="comment">	 * Generally the first zones will be references to this node&#x27;s</span></span><br><span class="line"><span class="comment">	 * node_zones.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分配区域时的顺序</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> <span class="title">node_zonelists</span>[<span class="title">MAX_ZONELISTS</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区域的数量，一般来说值的范围为1~3，但并不是所有的节点都有三个区域</span></span><br><span class="line">	<span class="keyword">int</span> nr_zones; <span class="comment">/* number of populated zones in this node */</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_FLAT_NODE_MEM_MAP	<span class="comment">/* means !SPARSEMEM */</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该节点的第一个页面在全局变量mem_map数组中的地址</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">node_mem_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_PAGE_EXTENSION</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page_ext</span> *<span class="title">node_page_ext</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_MEMORY_HOTPLUG) || defined(CONFIG_DEFERRED_STRUCT_PAGE_INIT)</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Must be held any time you expect node_start_pfn,</span></span><br><span class="line"><span class="comment">	 * node_present_pages, node_spanned_pages or nr_zones to stay constant.</span></span><br><span class="line"><span class="comment">	 * Also synchronizes pgdat-&gt;first_deferred_pfn during deferred page</span></span><br><span class="line"><span class="comment">	 * init.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * pgdat_resize_lock() and pgdat_resize_unlock() are provided to</span></span><br><span class="line"><span class="comment">	 * manipulate node_size_lock without checking for CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line"><span class="comment">	 * or CONFIG_DEFERRED_STRUCT_PAGE_INIT.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Nests above zone-&gt;lock and zone-&gt;span_seqlock</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> node_size_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 该节点的起始物理页面号</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> node_start_pfn;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该节点中的总共页面数</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> node_present_pages; <span class="comment">/* total number of physical pages */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该节点中的所有物理页面数，包括内存空洞(如部分地址为外设I/O使用)</span></span><br><span class="line">    <span class="comment">// 个人认为与上者的区别是这里包括了不能用的物理页</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> node_spanned_pages; <span class="comment">/* total size of physical page</span></span><br><span class="line"><span class="comment">					     range, including holes */</span></span><br><span class="line">	<span class="comment">// 节点ID，从0开始</span></span><br><span class="line">    <span class="keyword">int</span> node_id;</span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> kswapd_wait;</span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> pfmemalloc_wait;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kswapd</span>;</span>	<span class="comment">/* Protected by</span></span><br><span class="line"><span class="comment">					   mem_hotplug_begin/end() */</span></span><br><span class="line">	<span class="keyword">int</span> kswapd_order;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">kswapd_highest_zoneidx</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> kswapd_failures;		<span class="comment">/* Number of &#x27;reclaimed == 0&#x27; runs */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">	<span class="keyword">int</span> kcompactd_max_order;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">kcompactd_highest_zoneidx</span>;</span></span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> kcompactd_wait;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kcompactd</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * This is a per-node reserve of pages that are not available</span></span><br><span class="line"><span class="comment">	 * to userspace allocations.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		totalreserve_pages;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * node reclaim becomes active if more unmapped pages exist.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		min_unmapped_pages;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		min_slab_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_NUMA */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Write-intensive fields used by page reclaim */</span></span><br><span class="line">	ZONE_PADDING(_pad1_)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If memory initialisation on large machines is deferred then this</span></span><br><span class="line"><span class="comment">	 * is the first PFN that needs to be initialised.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> first_deferred_pfn;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_DEFERRED_STRUCT_PAGE_INIT */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_TRANSPARENT_HUGEPAGE</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">deferred_split</span> <span class="title">deferred_split_queue</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Fields commonly accessed by the page reclaim scanner */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">NOTE:</span> THIS IS UNUSED IF MEMCG IS ENABLED.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Use mem_cgroup_lruvec() to look up lruvecs.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lruvec</span>		__<span class="title">lruvec</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		flags;</span><br><span class="line"></span><br><span class="line">	ZONE_PADDING(_pad2_)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Per-node vmstats */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_nodestat</span> __<span class="title">percpu</span> *<span class="title">per_cpu_nodestats</span>;</span></span><br><span class="line">	<span class="keyword">atomic_long_t</span>		vm_stat[NR_VM_NODE_STAT_ITEMS];</span><br><span class="line">&#125; <span class="keyword">pg_data_t</span>;</span><br></pre></td></tr></table></figure>
<p>当分配一个页面时，Linux使用本地节点分配策略，从运行的CPU最近的一个节点分配，因为进程倾向于在同一个CPU上运行，使用内存时也就更可能使用本节点的空间。</p>
<h3 id="区域（Zone）"><a href="#区域（Zone）" class="headerlink" title="区域（Zone）"></a>区域（Zone）</h3><h4 id="区域类型"><a href="#区域类型" class="headerlink" title="区域类型"></a>区域类型</h4><p>节点（Node）下面可以有多个区域，共有以下几种类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * ZONE_DMA and ZONE_DMA32 are used when there are peripherals not able</span></span><br><span class="line"><span class="comment">	 * to DMA to all of the addressable memory (ZONE_NORMAL).</span></span><br><span class="line"><span class="comment">	 * On architectures where this area covers the whole 32 bit address</span></span><br><span class="line"><span class="comment">	 * space ZONE_DMA32 is used. ZONE_DMA is left for the ones with smaller</span></span><br><span class="line"><span class="comment">	 * DMA addressing constraints. This distinction is important as a 32bit</span></span><br><span class="line"><span class="comment">	 * DMA mask is assumed when ZONE_DMA32 is defined. Some 64-bit</span></span><br><span class="line"><span class="comment">	 * platforms may need both zones as they support peripherals with</span></span><br><span class="line"><span class="comment">	 * different DMA addressing limitations.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ZONE_DMA</span></span><br><span class="line">	ZONE_DMA,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ZONE_DMA32</span></span><br><span class="line">	ZONE_DMA32,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Normal addressable memory is in ZONE_NORMAL. DMA operations can be</span></span><br><span class="line"><span class="comment">	 * performed on pages in ZONE_NORMAL if the DMA devices support</span></span><br><span class="line"><span class="comment">	 * transfers to all addressable memory.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ZONE_NORMAL,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_HIGHMEM</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * A memory area that is only addressable by the kernel through</span></span><br><span class="line"><span class="comment">	 * mapping portions into its own address space. This is for example</span></span><br><span class="line"><span class="comment">	 * used by i386 to allow the kernel to address the memory beyond</span></span><br><span class="line"><span class="comment">	 * 900MB. The kernel will set up special mappings (page</span></span><br><span class="line"><span class="comment">	 * table entries on i386) for each page that the kernel needs to</span></span><br><span class="line"><span class="comment">	 * access.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ZONE_HIGHMEM,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * ZONE_MOVABLE is similar to ZONE_NORMAL, except that it contains</span></span><br><span class="line"><span class="comment">	 * movable pages with few exceptional cases described below. Main use</span></span><br><span class="line"><span class="comment">	 * cases for ZONE_MOVABLE are to make memory offlining/unplug more</span></span><br><span class="line"><span class="comment">	 * likely to succeed, and to locally limit unmovable allocations - e.g.,</span></span><br><span class="line"><span class="comment">	 * to increase the number of THP/huge pages. Notable special cases are:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * 1. Pinned pages: (long-term) pinning of movable pages might</span></span><br><span class="line"><span class="comment">	 *    essentially turn such pages unmovable. Memory offlining might</span></span><br><span class="line"><span class="comment">	 *    retry a long time.</span></span><br><span class="line"><span class="comment">	 * 2. memblock allocations: kernelcore/movablecore setups might create</span></span><br><span class="line"><span class="comment">	 *    situations where ZONE_MOVABLE contains unmovable allocations</span></span><br><span class="line"><span class="comment">	 *    after boot. Memory offlining and allocations fail early.</span></span><br><span class="line"><span class="comment">	 * 3. Memory holes: kernelcore/movablecore setups might create very rare</span></span><br><span class="line"><span class="comment">	 *    situations where ZONE_MOVABLE contains memory holes after boot,</span></span><br><span class="line"><span class="comment">	 *    for example, if we have sections that are only partially</span></span><br><span class="line"><span class="comment">	 *    populated. Memory offlining and allocations fail early.</span></span><br><span class="line"><span class="comment">	 * 4. PG_hwpoison pages: while poisoned pages can be skipped during</span></span><br><span class="line"><span class="comment">	 *    memory offlining, such pages cannot be allocated.</span></span><br><span class="line"><span class="comment">	 * 5. Unmovable PG_offline pages: in paravirtualized environments,</span></span><br><span class="line"><span class="comment">	 *    hotplugged memory blocks might only partially be managed by the</span></span><br><span class="line"><span class="comment">	 *    buddy (e.g., via XEN-balloon, Hyper-V balloon, virtio-mem). The</span></span><br><span class="line"><span class="comment">	 *    parts not manged by the buddy are unmovable PG_offline pages. In</span></span><br><span class="line"><span class="comment">	 *    some cases (virtio-mem), such pages can be skipped during</span></span><br><span class="line"><span class="comment">	 *    memory offlining, however, cannot be moved/allocated. These</span></span><br><span class="line"><span class="comment">	 *    techniques might use alloc_contig_range() to hide previously</span></span><br><span class="line"><span class="comment">	 *    exposed pages from the buddy again (e.g., to implement some sort</span></span><br><span class="line"><span class="comment">	 *    of memory unplug in virtio-mem).</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * In general, no unmovable allocations that degrade memory offlining</span></span><br><span class="line"><span class="comment">	 * should end up in ZONE_MOVABLE. Allocators (like alloc_contig_range())</span></span><br><span class="line"><span class="comment">	 * have to expect that migrating pages in ZONE_MOVABLE can fail (even</span></span><br><span class="line"><span class="comment">	 * if has_unmovable_pages() states that there are no unmovable pages,</span></span><br><span class="line"><span class="comment">	 * there can be false negatives).</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ZONE_MOVABLE,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ZONE_DEVICE</span></span><br><span class="line">	ZONE_DEVICE,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	__MAX_NR_ZONES</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>ZONE_DMA</strong></p>
<p>是低内存的一块区域，这块区域由标准工业架构设备使用，适合DMA内存。这部分内存大小和CPU架构有关，在x86架构中，该部分区域大小限制为16MB。</p>
<p><strong>ZONE_DMA32</strong></p>
<p>该部分区域为适合支持32位地址总线的DMA内存空间。很显然，该部分仅在64位系统有效，在32位系统中，这部分区域为空。在x86-64架构中，这部分的区域范围为0~4GB。</p>
<p><strong>ZONE_NORMAL</strong></p>
<p>属于<code>ZONE_NORMAL</code>的内存被内核直接映射到线性地址。这部分区域仅表示可能存在这部分区域，如在64位系统中，若系统只有4GB物理内存，则所有的物理内存都属于<code>ZONE_DMA32</code>，而<code>ZONE_NORMAL</code>区域为空。</p>
<p>许多内核操作都仅在<code>ZONE_NORMAL</code>内存区域进行，所以这部分是系统性能关键的地方。</p>
<p><strong>ZONE_HIGHMEM</strong></p>
<p>是系统中剩下的可用内存，但因为内核的地址空间有限，这部分内存不直接映射到内核。</p>
<p>在x86架构中内存有三种区域：<code>ZONE_DMA</code>,<code>ZONE_NORMAL</code>,<code>ZONE_HIGHMEM</code>。不同类型的区域适合不同需要。在32位系统结构中，1G(内核空间) / 3G(内核空间)地址空间划分时，三种类型的区域如下：</p>
<ul>
<li><strong>ZONE_DMA</strong>：内存开始的16MB</li>
<li><strong>ZONE_NORMAL</strong>：16MB~896MB</li>
<li><strong>ZONE_HIGHMEM</strong>：896~结束</li>
</ul>
<p>4G(内核空间) / 4G(用户空间)地址空间划分时，三种类型区域划分为：</p>
<ul>
<li><strong>ZONE_DMA</strong>：内存开始的16MB</li>
<li><strong>ZONE_NORMAL</strong>：16MB~3968MB</li>
<li><strong>ZONE_HIGHMEM</strong>：3968MB~结束</li>
</ul>
<p>对于64位系统中，不存在高端内存，这里个人的理解是64位系统中，线性地址能达到2^64B这么多，就算是物理地址一一对应来映射，也能够访问到所有的物理地址。之所以出现高端内存是因为我们的虚拟地址不足以映射所有的物理地址，此时如果一一映射，那么我们就没法访问到所有的物理内存。下图为32为和64位系统中内存区域划分区别</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13417851569/0" alt="image-20210416155935255"></p>
<h4 id="struct-zone结构体"><a href="#struct-zone结构体" class="headerlink" title="struct zone结构体"></a>struct zone结构体</h4><p>每块区域的描述结构为<code>struct zone</code>。<code>zone</code>跟踪一些信息，如页面的使用统计、空闲页面及锁等，数据结构定义在文件<code>include/linux/mmzone.h</code>中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Read-mostly fields */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* zone watermarks, access with *_wmark_pages(zone) macros */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> _watermark[NR_WMARK];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> watermark_boost;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> nr_reserved_highatomic;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We don&#x27;t know if the memory that we&#x27;re going to allocate will be</span></span><br><span class="line"><span class="comment">	 * freeable or/and it will be released eventually, so to avoid totally</span></span><br><span class="line"><span class="comment">	 * wasting several GB of ram we must reserve some of the lower zone</span></span><br><span class="line"><span class="comment">	 * memory (otherwise we risk to run OOM on the lower zones despite</span></span><br><span class="line"><span class="comment">	 * there being tons of freeable ram on the higher zones).  This array is</span></span><br><span class="line"><span class="comment">	 * recalculated at runtime if the sysctl_lowmem_reserve_ratio sysctl</span></span><br><span class="line"><span class="comment">	 * changes.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 针对每个区域保存的物理页面数量，保证在任何条件下，申请内存都不会失败</span></span><br><span class="line">	<span class="keyword">long</span> lowmem_reserve[MAX_NR_ZONES];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="keyword">int</span> node;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 指向父亲pg_data_t</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span>	*<span class="title">zone_pgdat</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span> __<span class="title">percpu</span> *<span class="title">pageset</span>;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * the high and batch values are copied to individual pagesets for</span></span><br><span class="line"><span class="comment">	 * faster access</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> pageset_high;</span><br><span class="line">	<span class="keyword">int</span> pageset_batch;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SPARSEMEM</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Flags for a pageblock_nr_pages block. See pageblock-flags.h.</span></span><br><span class="line"><span class="comment">	 * In SPARSEMEM, this map is stored in struct mem_section</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		*pageblock_flags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_SPARSEMEM */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT */</span></span><br><span class="line">    <span class="comment">// 该区域节点的物理页面号</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		zone_start_pfn;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * spanned_pages is the total pages spanned by the zone, including</span></span><br><span class="line"><span class="comment">	 * holes, which is calculated as:</span></span><br><span class="line"><span class="comment">	 * 	spanned_pages = zone_end_pfn - zone_start_pfn;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * present_pages is physical pages existing within the zone, which</span></span><br><span class="line"><span class="comment">	 * is calculated as:</span></span><br><span class="line"><span class="comment">	 *	present_pages = spanned_pages - absent_pages(pages in holes);</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * managed_pages is present pages managed by the buddy system, which</span></span><br><span class="line"><span class="comment">	 * is calculated as (reserved_pages includes pages allocated by the</span></span><br><span class="line"><span class="comment">	 * bootmem allocator):</span></span><br><span class="line"><span class="comment">	 *	managed_pages = present_pages - reserved_pages;</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * cma pages is present pages that are assigned for CMA use</span></span><br><span class="line"><span class="comment">	 * (MIGRATE_CMA).</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * So present_pages may be used by memory hotplug or memory power</span></span><br><span class="line"><span class="comment">	 * management logic to figure out unmanaged pages by checking</span></span><br><span class="line"><span class="comment">	 * (present_pages - managed_pages). And managed_pages should be used</span></span><br><span class="line"><span class="comment">	 * by page allocator and vm scanner to calculate all kinds of watermarks</span></span><br><span class="line"><span class="comment">	 * and thresholds.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Locking rules:</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * zone_start_pfn and spanned_pages are protected by span_seqlock.</span></span><br><span class="line"><span class="comment">	 * It is a seqlock because it has to be read outside of zone-&gt;lock,</span></span><br><span class="line"><span class="comment">	 * and it is done in the main allocator path.  But, it is written</span></span><br><span class="line"><span class="comment">	 * quite infrequently.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The span_seq lock is declared along with zone-&gt;lock because it is</span></span><br><span class="line"><span class="comment">	 * frequently read in proximity to zone-&gt;lock.  It&#x27;s good to</span></span><br><span class="line"><span class="comment">	 * give them a chance of being in the same cacheline.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Write access to present_pages at runtime should be protected by</span></span><br><span class="line"><span class="comment">	 * mem_hotplug_begin/end(). Any reader who can&#x27;t tolerant drift of</span></span><br><span class="line"><span class="comment">	 * present_pages should get_online_mems() to get a stable value.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">atomic_long_t</span>		managed_pages;</span><br><span class="line">    <span class="comment">// 所有物理页面数，包括内存空洞</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		spanned_pages;</span><br><span class="line">    <span class="comment">// 总共页面数，不包括内存空洞</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		present_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CMA</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		cma_pages;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">// 区域的名字 &quot;DMA&quot;,&quot;DMA32&quot;,&quot;NORMAL&quot;,&quot;HIGHMEM&quot;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>		*name;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Number of isolated pageblock. It is used to solve incorrect</span></span><br><span class="line"><span class="comment">	 * freepage counting problem due to racy retrieving migratetype</span></span><br><span class="line"><span class="comment">	 * of pageblock. Protected by zone-&gt;lock.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		nr_isolate_pageblock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line">	<span class="comment">/* see spanned/present_pages for more description */</span></span><br><span class="line">	<span class="keyword">seqlock_t</span>		span_seqlock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> initialized;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Write-intensive fields used from the page allocator */</span></span><br><span class="line">	ZONE_PADDING(_pad1_)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* free areas of different sizes */</span></span><br><span class="line">    <span class="comment">// buddy分配器使用的空闲区域位图</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>	<span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* zone flags, see below */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Primarily protects free_area */</span></span><br><span class="line">    <span class="comment">// spinlock防止对区域的并发访问</span></span><br><span class="line">	<span class="keyword">spinlock_t</span>		lock;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Write-intensive fields used by compaction and vmstats. */</span></span><br><span class="line">	ZONE_PADDING(_pad2_)</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When free pages are below this point, additional steps are taken</span></span><br><span class="line"><span class="comment">	 * when reading the number of free pages to avoid per-cpu counter</span></span><br><span class="line"><span class="comment">	 * drift allowing watermarks to be breached</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> percpu_drift_mark;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span></span><br><span class="line">	<span class="comment">/* pfn where compaction free scanner should start */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		compact_cached_free_pfn;</span><br><span class="line">	<span class="comment">/* pfn where compaction migration scanner should start */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		compact_cached_migrate_pfn[ASYNC_AND_SYNC];</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		compact_init_migrate_pfn;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		compact_init_free_pfn;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * On compaction failure, 1&lt;&lt;compact_defer_shift compactions</span></span><br><span class="line"><span class="comment">	 * are skipped before trying again. The number attempted since</span></span><br><span class="line"><span class="comment">	 * last failure is tracked with compact_considered.</span></span><br><span class="line"><span class="comment">	 * compact_order_failed is the minimum compaction failed order.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		compact_considered;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		compact_defer_shift;</span><br><span class="line">	<span class="keyword">int</span>			compact_order_failed;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span></span><br><span class="line">	<span class="comment">/* Set to true when the PG_migrate_skip bits should be cleared */</span></span><br><span class="line">	<span class="keyword">bool</span>			compact_blockskip_flush;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span>			contiguous;</span><br><span class="line"></span><br><span class="line">	ZONE_PADDING(_pad3_)</span><br><span class="line">	<span class="comment">/* Zone statistics */</span></span><br><span class="line">	<span class="keyword">atomic_long_t</span>		vm_stat[NR_VM_ZONE_STAT_ITEMS];</span><br><span class="line">	<span class="keyword">atomic_long_t</span>		vm_numa_stat[NR_VM_NUMA_STAT_ITEMS];</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">pgdat_flags</span> &#123;</span></span><br><span class="line">	PGDAT_DIRTY,			<span class="comment">/* reclaim scanning has recently found</span></span><br><span class="line"><span class="comment">					 * many dirty file pages at the tail</span></span><br><span class="line"><span class="comment">					 * of the LRU.</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">	PGDAT_WRITEBACK,		<span class="comment">/* reclaim scanning has recently found</span></span><br><span class="line"><span class="comment">					 * many pages under writeback</span></span><br><span class="line"><span class="comment">					 */</span></span><br><span class="line">	PGDAT_RECLAIM_LOCKED,		<span class="comment">/* prevents concurrent reclaim */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="页面（Page）"><a href="#页面（Page）" class="headerlink" title="页面（Page）"></a>页面（Page）</h3><p>系统内存由固定的块组成，称为页帧（页框），每个页帧由<code>struct page</code>结构描述。内核在初始化时，会根据内存的大小计算出有多少页帧，每个页帧都会有一个page结构与之对应，这些信息保存在全局数组变量mem_map中。mem_map通常存储在<code>ZONE_NORMAL</code>区域中，在内存较小的机器中，会保存在加载内核镜像后的一片保留空间里。有多少个物理页面，就会有多个<code>struct page</code>结构。</p>
<h4 id="struct-page结构体"><a href="#struct-page结构体" class="headerlink" title="struct page结构体"></a>struct page结构体</h4><p><code>struct page</code>数据结构定义在文件<code>include/linux/mm_types.h</code>中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    <span class="comment">// 描述页面状态的标志。所有的标志在include/linux/page-flags.h中定义，</span></span><br><span class="line">    <span class="comment">// 主要标志包括PG_locked、PG_error、PG_referenced、PG_uptodate、</span></span><br><span class="line">    <span class="comment">// PG_active、PG_dirty、PG_lru等。</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;		<span class="comment">/* Atomic flags, some possibly</span></span><br><span class="line"><span class="comment">					 * updated asynchronously */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Five words (20/40 bytes) are available in this union.</span></span><br><span class="line"><span class="comment">	 * WARNING: bit 0 of the first word is used for PageTail(). That</span></span><br><span class="line"><span class="comment">	 * means the other users of this union MUST NOT use the bit to</span></span><br><span class="line"><span class="comment">	 * avoid collision and false-positive PageTail().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* Page cache and anonymous pages */</span></span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * @lru: Pageout list, eg. active_list protected by</span></span><br><span class="line"><span class="comment">			 * lruvec-&gt;lru_lock.  Sometimes used as a generic list</span></span><br><span class="line"><span class="comment">			 * by the page owner.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">            </span><br><span class="line">             <span class="comment">// 为页面替换策略，可以被换出的页面可能存在与active_list或者inactive_list。这是LRU的链表头</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span></span><br><span class="line">            </span><br><span class="line">			<span class="comment">/* See page-flags.h for PAGE_MAPPING_FLAGS */</span></span><br><span class="line">             <span class="comment">// 系统或者设备映射到内存中时，它们的inode结构就会和address_space</span></span><br><span class="line">             <span class="comment">// 相关联。当页面属于一个文件时，mmaping就会指向这个地址空间。</span></span><br><span class="line">             <span class="comment">// 如果这个页面是匿名的且映射开启，则address_space就是swapper_space</span></span><br><span class="line">             <span class="comment">// swapper_space是管理交换地址空间的</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span></span><br><span class="line">            </span><br><span class="line">			<span class="keyword">pgoff_t</span> index;		<span class="comment">/* Our offset within mapping. */</span></span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * @private: Mapping-private opaque data.</span></span><br><span class="line"><span class="comment">			 * Usually used for buffer_heads if PagePrivate.</span></span><br><span class="line"><span class="comment">			 * Used for swp_entry_t if PageSwapCache.</span></span><br><span class="line"><span class="comment">			 * Indicates order in the buddy system if PageBuddy.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">private</span>;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* page_pool used by netstack */</span></span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * @dma_addr: might require a 64-bit value even on</span></span><br><span class="line"><span class="comment">			 * 32-bit architectures.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">dma_addr_t</span> dma_addr;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* slab, slob and slub */</span></span><br><span class="line">			<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* Partial pages */</span></span><br><span class="line">					<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">					<span class="keyword">int</span> pages;	<span class="comment">/* Nr of pages left */</span></span><br><span class="line">					<span class="keyword">int</span> pobjects;	<span class="comment">/* Approximate count */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">					<span class="keyword">short</span> <span class="keyword">int</span> pages;</span><br><span class="line">					<span class="keyword">short</span> <span class="keyword">int</span> pobjects;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span> <span class="comment">/* not slob */</span></span><br><span class="line">			<span class="comment">/* Double-word boundary */</span></span><br><span class="line">			<span class="keyword">void</span> *freelist;		<span class="comment">/* first free object */</span></span><br><span class="line">			<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">				<span class="keyword">void</span> *s_mem;	<span class="comment">/* slab: first object */</span></span><br><span class="line">				<span class="keyword">unsigned</span> <span class="keyword">long</span> counters;		<span class="comment">/* SLUB */</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> &#123;</span>			<span class="comment">/* SLUB */</span></span><br><span class="line">					<span class="keyword">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line">					<span class="keyword">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line">					<span class="keyword">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">				&#125;;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* Tail pages of compound page */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> compound_head;	<span class="comment">/* Bit zero is set */</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">/* First tail page only */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">char</span> compound_dtor;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">char</span> compound_order;</span><br><span class="line">			<span class="keyword">atomic_t</span> compound_mapcount;</span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">int</span> compound_nr; <span class="comment">/* 1 &lt;&lt; compound_order */</span></span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* Second tail page of compound page */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> _compound_pad_1;	<span class="comment">/* compound_head */</span></span><br><span class="line">			<span class="keyword">atomic_t</span> hpage_pinned_refcount;</span><br><span class="line">			<span class="comment">/* For both global and memcg */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">deferred_list</span>;</span></span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* Page table pages */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> _pt_pad_1;	<span class="comment">/* compound_head */</span></span><br><span class="line">			<span class="keyword">pgtable_t</span> pmd_huge_pte; <span class="comment">/* protected by page-&gt;ptl */</span></span><br><span class="line">			<span class="keyword">unsigned</span> <span class="keyword">long</span> _pt_pad_2;	<span class="comment">/* mapping */</span></span><br><span class="line">			<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">pt_mm</span>;</span> <span class="comment">/* x86 pgds only */</span></span><br><span class="line">				<span class="keyword">atomic_t</span> pt_frag_refcount; <span class="comment">/* powerpc */</span></span><br><span class="line">			&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> ALLOC_SPLIT_PTLOCKS</span></span><br><span class="line">			<span class="keyword">spinlock_t</span> *ptl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">			<span class="keyword">spinlock_t</span> ptl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span>	<span class="comment">/* ZONE_DEVICE pages */</span></span><br><span class="line">			<span class="comment">/** @pgmap: Points to the hosting device page map. */</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">dev_pagemap</span> *<span class="title">pgmap</span>;</span></span><br><span class="line">			<span class="keyword">void</span> *zone_device_data;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * ZONE_DEVICE private pages are counted as being</span></span><br><span class="line"><span class="comment">			 * mapped so the next 3 words hold the mapping, index,</span></span><br><span class="line"><span class="comment">			 * and private fields from the source anonymous or</span></span><br><span class="line"><span class="comment">			 * page cache page while the page is migrated to device</span></span><br><span class="line"><span class="comment">			 * private memory.</span></span><br><span class="line"><span class="comment">			 * ZONE_DEVICE MEMORY_DEVICE_FS_DAX pages also</span></span><br><span class="line"><span class="comment">			 * use the mapping, index, and private fields when</span></span><br><span class="line"><span class="comment">			 * pmem backed DAX files are mapped.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/** @rcu_head: You can use this to free a page by RCU. */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span>		<span class="comment">/* This union is 4 bytes in size. */</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If the page can be mapped to userspace, encodes the number</span></span><br><span class="line"><span class="comment">		 * of times this page is referenced by a page table.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 页面表总共有多少项指向该页面</span></span><br><span class="line">		<span class="keyword">atomic_t</span> _mapcount;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * If the page is neither PageSlab nor mappable to userspace,</span></span><br><span class="line"><span class="comment">		 * the value stored here may help determine what this page</span></span><br><span class="line"><span class="comment">		 * is used for.  See page-flags.h for a list of page types</span></span><br><span class="line"><span class="comment">		 * which are currently stored here.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> page_type;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">int</span> active;		<span class="comment">/* SLAB */</span></span><br><span class="line">		<span class="keyword">int</span> units;			<span class="comment">/* SLOB */</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Usage count. *DO NOT USE DIRECTLY*. See page_ref.h */</span></span><br><span class="line">	<span class="keyword">atomic_t</span> _refcount;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> memcg_data;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * On machines where all RAM is mapped into kernel address space,</span></span><br><span class="line"><span class="comment">	 * we can simply calculate the virtual address. On machines with</span></span><br><span class="line"><span class="comment">	 * highmem some memory is mapped into kernel virtual memory</span></span><br><span class="line"><span class="comment">	 * dynamically, so we need a place to store that address.</span></span><br><span class="line"><span class="comment">	 * Note that this field could be 16 bits on x86 ... ;)</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Architectures with slow multiplication can define</span></span><br><span class="line"><span class="comment">	 * WANT_PAGE_VIRTUAL in asm/page.h</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(WANT_PAGE_VIRTUAL)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 正常情况下只有处于ZONE_NORMAL的页面内核直接映射。对于ZONE_HIGHMEM区域的页面</span></span><br><span class="line">    <span class="comment">// 内核使用kmap()来映射页面。当页面被映射后，virtual是它的虚拟地址</span></span><br><span class="line">	<span class="keyword">void</span> *<span class="keyword">virtual</span>;			<span class="comment">/* Kernel virtual address (NULL if</span></span><br><span class="line"><span class="comment">					   not kmapped, ie. highmem) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* WANT_PAGE_VIRTUAL */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LAST_CPUPID_NOT_IN_PAGE_FLAGS</span></span><br><span class="line">	<span class="keyword">int</span> _last_cpupid;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; _struct_page_alignment;</span><br></pre></td></tr></table></figure>
<p>此处用一张图来帮我们理一下我们的思路，以3G（用户空间）/ 1G（内核空间）</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13419102870/0" alt="image-20210416194931072"></p>
<p>可以看到物理地址0~896M，这里就是NORMAL的区域，这里是直接被映射到内核空间开始的896M处，往上就是HIGNMEM区域。这里有一个很重要的点就是，ZONE_DMA、ZONE_NORMAL、ZONE_HIGNMEM这些区域是对于物理地址而言，而且表示的是区间，不是对应大小的物理内存块，所以我们可以推断出不是所有的节点都有这三种区域的。</p>
<h4 id="页面标志"><a href="#页面标志" class="headerlink" title="页面标志"></a>页面标志</h4><p>页面标志尤其重要，内存分配与回收、IO操作等重要内核活动过程中都会使用到页面标志。所有的标志都在<code>include/linux/page-flags.h</code>中定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">pageflags</span> &#123;</span></span><br><span class="line">	PG_locked,		<span class="comment">/* Page is locked. Don&#x27;t touch. */</span></span><br><span class="line">	PG_referenced,</span><br><span class="line">	PG_uptodate,</span><br><span class="line">	PG_dirty,</span><br><span class="line">	PG_lru,</span><br><span class="line">	PG_active,</span><br><span class="line">	PG_workingset,</span><br><span class="line">	PG_waiters,		<span class="comment">/* Page has waiters, check its waitqueue. Must be bit #7 and in the same byte as &quot;PG_locked&quot; */</span></span><br><span class="line">	PG_error,</span><br><span class="line">	PG_slab,</span><br><span class="line">	PG_owner_priv_1,	<span class="comment">/* Owner use. If pagecache, fs may use*/</span></span><br><span class="line">	PG_arch_1,</span><br><span class="line">	PG_reserved,</span><br><span class="line">	PG_private,		<span class="comment">/* If pagecache, has fs-private data */</span></span><br><span class="line">	PG_private_2,		<span class="comment">/* If pagecache, has fs aux data */</span></span><br><span class="line">	PG_writeback,		<span class="comment">/* Page is under writeback */</span></span><br><span class="line">	PG_head,		<span class="comment">/* A head page */</span></span><br><span class="line">	PG_mappedtodisk,	<span class="comment">/* Has blocks allocated on-disk */</span></span><br><span class="line">	PG_reclaim,		<span class="comment">/* To be reclaimed asap */</span></span><br><span class="line">	PG_swapbacked,		<span class="comment">/* Page is backed by RAM/swap */</span></span><br><span class="line">	PG_unevictable,		<span class="comment">/* Page is &quot;unevictable&quot;  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MMU</span></span><br><span class="line">	PG_mlocked,		<span class="comment">/* Page is vma mlocked */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ARCH_USES_PG_UNCACHED</span></span><br><span class="line">	PG_uncached,		<span class="comment">/* Page has been mapped as uncached */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MEMORY_FAILURE</span></span><br><span class="line">	PG_hwpoison,		<span class="comment">/* hardware poisoned page. Don&#x27;t touch */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_IDLE_PAGE_TRACKING) &amp;&amp; defined(CONFIG_64BIT)</span></span><br><span class="line">	PG_young,</span><br><span class="line">	PG_idle,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">	PG_arch_2,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	__NR_PAGEFLAGS,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Filesystems */</span></span><br><span class="line">	PG_checked = PG_owner_priv_1,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* SwapBacked */</span></span><br><span class="line">	PG_swapcache = PG_owner_priv_1,	<span class="comment">/* Swap page: swp_entry_t in private */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Two page bits are conscripted by FS-Cache to maintain local caching</span></span><br><span class="line"><span class="comment">	 * state.  These bits are set on pages belonging to the netfs&#x27;s inodes</span></span><br><span class="line"><span class="comment">	 * when those inodes are being locally cached.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	PG_fscache = PG_private_2,	<span class="comment">/* page backed by cache */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* XEN */</span></span><br><span class="line">	<span class="comment">/* Pinned in Xen as a read-only pagetable page. */</span></span><br><span class="line">	PG_pinned = PG_owner_priv_1,</span><br><span class="line">	<span class="comment">/* Pinned as part of domain save (see xen_mm_pin_all()). */</span></span><br><span class="line">	PG_savepinned = PG_dirty,</span><br><span class="line">	<span class="comment">/* Has a grant mapping of another (foreign) domain&#x27;s page. */</span></span><br><span class="line">	PG_foreign = PG_owner_priv_1,</span><br><span class="line">	<span class="comment">/* Remapped by swiotlb-xen. */</span></span><br><span class="line">	PG_xen_remapped = PG_owner_priv_1,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* SLOB */</span></span><br><span class="line">	PG_slob_free = PG_private,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Compound pages. Stored in first tail page&#x27;s flags */</span></span><br><span class="line">	PG_double_map = PG_workingset,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* non-lru isolated movable page */</span></span><br><span class="line">	PG_isolated = PG_reclaim,</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Only valid for buddy pages. Used to track pages that are reported */</span></span><br><span class="line">	PG_reported = PG_uptodate,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里解释几个重要的页面标志：</p>
<p><strong>PG_locked</strong>：页面是否被锁住，若该位设置了该位，则不允许内核其他部分访问该页面。这用来防止内存管理过程中遇到的竞争条件，如当从硬盘读取数据到一个页面时，就不允许其他内核部分访问该页面，因为读数据的过程中，其他内核部分能访问的话，则读取到的数据是不完整的。</p>
<p><strong>PG_error</strong>：I/O出错，且操作和页面有关，就设置该标志。</p>
<p><strong>PG_referenced和PG_active</strong>：控制系统使用页面的活跃程度。这个信息对swap系统选择待交换出的页面非常重要。</p>
<p><strong>PG_update</strong>：表示成功完成从块设备上读取一个页面的数据。该标志和块设备I/O操作有关。</p>
<p><strong>PG_dirty</strong>：当内存页面中的数据和块设备上的数据不一致时，就设置该标志。在写数据到块设备时，为了提高将来的读性能，数据并不是立即回写到块设备上，而只是设置页面脏标志，表示该页面数据需要回写。</p>
<p><strong>PG_lru</strong>：该标志用来实现页面回收和交换。</p>
<p><strong>PG_highmem</strong>：表示该页面为属于高端内存。</p>
<h2 id="空闲页面的管理"><a href="#空闲页面的管理" class="headerlink" title="空闲页面的管理"></a>空闲页面的管理</h2><p>首先这里是页面的管理，比如我们要分配连续的物理页面，所以这里讲的是伙伴系统，当我们涉及到页面内的，以kb为单位，不再以页为单位去分配内存的时候，此时涉及到的就是slab分配算法。</p>
<h3 id="物理内存空间描述"><a href="#物理内存空间描述" class="headerlink" title="物理内存空间描述"></a>物理内存空间描述</h3><p>前面我们讲过内核将物理分为3个层次：节点（Node）、区域（Zone）、页面（Page），主要是简单的涉及到它的数据结构。三个关系如下：</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13419284497/0" alt="image-20210416203439973"></p>
<p>在Linux中，空闲内存管理的基本单位是页面(x86/x86-64 CPU定义的页面)，即以页面为单位来管理物理内存(kmalloc等slab/slub机制，是比页面更小的细分)。</p>
<p>Linux内核管理的每个内存空闲块都是2的幂次方个页面，幂次方的大小为order。把1个空闲页面放在一起、2个空闲页面（物理地址连续）放在一起、4个空闲页面（物理地址连续）放在一起…空闲页面组织，如下图所示：</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13419322858/0" alt="image-20210416204434890"></p>
<p>在我们的内核版本中(Linux5.12-cr7)，MAX_ORDER通常定义为11，内核管理最大的连续空闲物理内存大小为2^(11-1)，即4MB。</p>
<p><strong>区域（zone）与空闲页面</strong></p>
<p>在区域（zone）的数据结构中，有个数组<strong>free_area[MAX_ORDER]</strong>来保存每个空闲内存块链表</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13419353990/0" alt="image-20210416205324167"></p>
<p>这样<code>free_area[MAX_ORDER]</code>数组中第1个元素，指向内存块大小为2^0即1个页面的空闲页面链表，以此类推</p>
<p>每个区域（zone）都有一个<code>free_area[MAX_ORDER]</code>数组，其数据类型<code>free_area</code>结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> &#123;</span></span><br><span class="line">    <span class="comment">// 空闲页面块的双链表</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">free_list</span>[<span class="title">MIGRATE_TYPES</span>];</span></span><br><span class="line">    <span class="comment">// 该区域中的空闲页面块数量</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		nr_free;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每个空闲页面链表上的各个元素（大小相同的连续物理页面），通过<code>struct page</code>中的双链表成员变量来连接，如下图所示</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13419460908/0" alt="image-20210416212219830"></p>
<p>空闲页面的管理只是在区域（zone）这一层，节点（node）下的每个区域都管理着自己的空闲物理页面。空闲页面管理与节点、区域之间的关系如下图</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13419509509/0" alt="image-20210416213524986"></p>
<h2 id="伙伴算法"><a href="#伙伴算法" class="headerlink" title="伙伴算法"></a>伙伴算法</h2><p>伙伴算法的用途主要是尽可能的减少外部碎片，同时允许快速分配与回收物理页面。为了减少外部碎片，连续的空闲页面，根据空闲块（由连续的空闲页面组成）大小，组织成不同的链表（或orders）。前面涉及到的空闲页面管理就是伙伴系统的一部分。这样所有的2个页面大小的空闲块在一个链表中，4个页面大小的空闲块在一个链表中，以此类推。下面为空闲页面的分配示意图</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13419525548/0" alt="image-20210416213943809"></p>
<h3 id="伙伴系统举例"><a href="#伙伴系统举例" class="headerlink" title="伙伴系统举例"></a>伙伴系统举例</h3><h4 id="页面分配过程"><a href="#页面分配过程" class="headerlink" title="页面分配过程"></a>页面分配过程</h4><p>现上层请求分配<strong>4个连续地址</strong>的空闲物理页面块</p>
<ol>
<li>4=2^(3-1)，因此从Order = 3的空闲块链表上开始找空闲的块</li>
<li>此时假设在order = 3的链表上没有空闲块；需要到上级order查找是否有空闲块</li>
<li>从order = 4的链表上开始查找，有一个空闲结点；但该链表上的每个块大小为8个页面，分配4个页面给上层，标记该页面表为已使用</li>
<li>还剩4个页面。此时将该剩下的4个页面，放入order = 3的链表上</li>
<li>更新相关统计信息</li>
</ol>
<h4 id="页面回收过程"><a href="#页面回收过程" class="headerlink" title="页面回收过程"></a>页面回收过程</h4><ol>
<li>标记该页面块为空闲</li>
<li>检查相邻物理页面是否为空闲；若相邻物理页面为空闲，则尝试合并成更大的连续物理页面块（这样可以避免内存碎片化）</li>
<li>若有合并，则要更新<code>freearea</code>数组中链表元素</li>
<li>更新相关统计信息</li>
</ol>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>源码分析基于以下：</p>
<ol>
<li><p>Linux5.12-cr7</p>
</li>
<li><p>64bit代码处理逻辑</p>
</li>
<li><p>NUMA架构</p>
<blockquote>
<p>NUMA架构走的<code>alloc_pages_current</code>分支，NUA则是<code>alloc_pages_node</code>。</p>
</blockquote>
</li>
</ol>
<h4 id="alloc-pages"><a href="#alloc-pages" class="headerlink" title="alloc_pages"></a>alloc_pages</h4><p><strong>原型：static inline struct page *alloc_pages(gfp_t gfp_mask, unsigned int order)</strong></p>
<p>linux内核伙伴系统中分配物理内存常用的接口是<code>alloc_pages</code>，用于分配<strong>2^order</strong>个<strong>连续</strong>的物理页，失败则返回NULL。与<code>__get_free_pages</code>函数不同的是，该函数返回<strong>指向第一个页框的页描述符</strong>，而<code>__get_free_pages</code>返回的是页映射后的虚拟地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class"><span class="title">alloc_pages</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">return</span> alloc_pages_current(gfp_mask, order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们直接看<code>alloc_pages_current</code>函数</p>
<h4 id="alloc-pages-current"><a href="#alloc-pages-current" class="headerlink" title="alloc_pages_current"></a>alloc_pages_current</h4><p><strong>原型：struct page *alloc_pages_current(gfp_t gfp_mask, unsigned order);</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct page *<span class="title">alloc_pages_current</span><span class="params">(<span class="keyword">gfp_t</span> gfp, <span class="keyword">unsigned</span> order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// pol变量用来保存内存分配策略，这里保存的是默认的分配策略</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mempolicy</span> *<span class="title">pol</span> =</span> &amp;default_policy;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不在中断状态且未指定在当前节点分配内存时，使用get_task_policy获取当前进程的内存分配策略</span></span><br><span class="line">	<span class="keyword">if</span> (!in_interrupt() &amp;&amp; !(gfp &amp; __GFP_THISNODE))</span><br><span class="line">		pol = get_task_policy(current);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pol-&gt;mode == MPOL_INTERLEAVE)</span><br><span class="line">		page = alloc_page_interleave(gfp, order, interleave_nodes(pol));</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		page = __alloc_pages_nodemask(gfp, order,</span><br><span class="line">				policy_node(gfp, pol, numa_node_id()),</span><br><span class="line">				policy_nodemask(gfp, pol));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于NUMA的四种内存分配策略：</p>
<ul>
<li>MPOL_DEFAULT：默认策略。也就是应该从当前节点分配内存，当前节点没有空闲内存时，从最近有空闲内存的节点分配</li>
<li>MPOL_PREFERRED：从指定节点上分配内存，若该节点上没有空闲内存，则其他任何一个节点都可以</li>
<li>MPOL_INTERLEAVE：内存分配要覆盖所有节点。该策略通常用于共享内存区域，分配的内存覆盖所有区域用来保证不会有节点过载，同时每个节点上用的内存大小相同。</li>
<li>MPOL_BIND：内存分配指定在特定的节点集（即某几个节点）中。当这些节点不能提供所需要的内存时，内存分配就失败。</li>
</ul>
<p>我们首先使用<code>pol</code>变量保存系统默认的分配策略，默认的分配策略为<code>MPOL_PREFERRED</code></p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13439136626/0" alt="image-20210421211854180"></p>
<p>如果内存分配标志位置有<code>__GFP_THISNODE</code>表示从当前节点分配内存，跟我们的默认分配策略一样，所以不需要改变，也就是不需要获取策略；如果未置有，此时会进入<code>if</code>语句中，通过<code>get_task_policy</code>函数获取内存分配策略。如果获取的策略是<code>MPOL_INTERLEAVE</code>则进入<code>alloc_page_interleave</code>函数中，这里我们如果是默认内存分配策略的情况下，我们进入<code>else</code>分支中，<code>__alloc_pages_nodemask</code>函数中的两个参数<code>policy_node(gfp, pol, numa_node_id())</code>和<code>policy_nodemask(gfp, pol)</code>是根据NUMA策略来确定在哪些节点、哪些区域上分配内存。接下来我们看<code>__alloc_pages_nodemask</code>函数。</p>
<h4 id="alloc-pages-nodemask"><a href="#alloc-pages-nodemask" class="headerlink" title="__alloc_pages_nodemask"></a>__alloc_pages_nodemask</h4><p><strong>原型：struct page *__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, int preferred_nid,</strong></p>
<p>​              <strong>nodemask_t *nodemask);</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_nodemask</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">preferred_nid</span>,</span></span><br><span class="line"><span class="class">							<span class="title">nodemask_t</span> *<span class="title">nodemask</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> alloc_flags = ALLOC_WMARK_LOW;</span><br><span class="line">	<span class="keyword">gfp_t</span> alloc_mask; <span class="comment">/* The gfp_t that was actually used for allocation */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">alloc_context</span> <span class="title">ac</span> =</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果order大于MAX_ORDER(11), 则内存分配失败</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(order &gt;= MAX_ORDER)) &#123;</span><br><span class="line">		WARN_ON_ONCE(!(gfp_mask &amp; __GFP_NOWARN));</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加gfp_allowed_mask标志位</span></span><br><span class="line">	gfp_mask &amp;= gfp_allowed_mask;</span><br><span class="line">	alloc_mask = gfp_mask;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化alloc_context对象ac，保存相关的一些参数</span></span><br><span class="line">	<span class="keyword">if</span> (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &amp;ac, &amp;alloc_mask, &amp;alloc_flags))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 给alloc_flags添加ALLOC_NOFRAGMENT标志位(不使用zone备用迁移类型), 如果遍历完本地zone后仍然无法分配内存则取消该标志位, 该方案是为了减少内存碎片</span></span><br><span class="line">	alloc_flags |= alloc_flags_nofragment(ac.preferred_zoneref-&gt;zone, gfp_mask);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 首先尝试从空闲页面链表中分配页面，如果分配失败了，就要通过__alloc_pages_slowpath</span></span><br><span class="line">    <span class="comment">// 是内存分配的快速路径</span></span><br><span class="line">	page = get_page_from_freelist(alloc_mask, order, alloc_flags, &amp;ac);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 分配成功则跳出，否则调用下面的慢速路径分配继续处理</span></span><br><span class="line">    <span class="keyword">if</span> (likely(page))</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">    </span><br><span class="line">	alloc_mask = current_gfp_context(gfp_mask);</span><br><span class="line">	ac.spread_dirty_pages = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(ac.nodemask != nodemask))</span><br><span class="line">		ac.nodemask = nodemask;</span><br><span class="line"></span><br><span class="line">    ac.nodemask = nodemask;</span><br><span class="line">	<span class="comment">// 从全局内存池中分配页面，其中的工作包括回收物理内存页面</span></span><br><span class="line">    <span class="comment">// 是内存分配的慢速路径</span></span><br><span class="line">	page = __alloc_pages_slowpath(alloc_mask, order, &amp;ac);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (memcg_kmem_enabled() &amp;&amp; (gfp_mask &amp; __GFP_ACCOUNT) &amp;&amp; page &amp;&amp;</span><br><span class="line">	    unlikely(__memcg_kmem_charge(page, gfp_mask, order) != <span class="number">0</span>)) &#123;</span><br><span class="line">		__free_pages(page, order);</span><br><span class="line">		page = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	trace_mm_page_alloc(page, order, alloc_mask, ac.migratetype);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数主要是执行以下步骤：</p>
<ul>
<li>prepare_alloc_pages()</li>
<li>alloc_flags_nofragment()</li>
<li>get_page-from_freelist()</li>
<li>__alloc_pages_slowpath()</li>
</ul>
<p>这些函数在接下来都会介绍</p>
<h5 id="prepare-alloc-pages"><a href="#prepare-alloc-pages" class="headerlink" title="prepare_alloc_pages"></a>prepare_alloc_pages</h5><p><strong>原型：static inline bool prepare_alloc_pages(gfp_t gfp_mask, unsigned int order,</strong></p>
<p>​    <strong>int preferred_nid, nodemask_t* nodemask,</strong></p>
<p>​    <strong>struct alloc_context *ac, gfp_t *alloc_mask,</strong></p>
<p>​    <strong>unsigned int *alloc_flags)</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">prepare_alloc_pages</span><span class="params">(<span class="keyword">gfp_t</span> gfp_mask, <span class="keyword">unsigned</span> <span class="keyword">int</span> order,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">int</span> preferred_nid, <span class="keyword">nodemask_t</span> *nodemask,</span></span></span><br><span class="line"><span class="function"><span class="params">		struct alloc_context *ac, <span class="keyword">gfp_t</span> *alloc_mask,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">unsigned</span> <span class="keyword">int</span> *alloc_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ac填充从gfp_mask获取的内存分配参数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获得指定的zone，表示可供分配的那些zone中最高的那个zone的idx</span></span><br><span class="line">	ac-&gt;high_zoneidx = gfp_zone(gfp_mask);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 获得node对应的zone_list</span></span><br><span class="line">	ac-&gt;zonelist = node_zonelist(preferred_nid, gfp_mask);</span><br><span class="line">	ac-&gt;nodemask = nodemask;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 选择迁移类型</span></span><br><span class="line">	ac-&gt;migratetype = gfpflags_to_migratetype(gfp_mask);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断是否存在cpuset机制</span></span><br><span class="line">	<span class="keyword">if</span> (cpusets_enabled()) &#123;</span><br><span class="line">		*alloc_mask |= __GFP_HARDWALL;</span><br><span class="line">		<span class="keyword">if</span> (!ac-&gt;nodemask)</span><br><span class="line">			ac-&gt;nodemask = &amp;cpuset_current_mems_allowed;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			*alloc_flags |= ALLOC_CPUSET;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 函数未实现</span></span><br><span class="line">	fs_reclaim_acquire(gfp_mask);</span><br><span class="line">	fs_reclaim_release(gfp_mask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果内存紧张可能会休眠</span></span><br><span class="line">	might_sleep_if(gfp_mask &amp; __GFP_DIRECT_RECLAIM);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对gfp_mask, ord做检查(默认没有开启CONFIG_FAIL_PAGE_ALLOC的情况下, 直接return false)</span></span><br><span class="line">	<span class="keyword">if</span> (should_fail_alloc_page(gfp_mask, order))</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	*alloc_flags = current_alloc_flags(gfp_mask, *alloc_flags);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//指定是否进行脏页的传播</span></span><br><span class="line">	ac-&gt;spread_dirty_pages = (gfp_mask &amp; __GFP_WRITE);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//指定要在快速路径中首先分配的区域，在慢路径中指定了zonelist中的第一个可用区域</span></span><br><span class="line">	ac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,</span><br><span class="line">					ac-&gt;highest_zoneidx, ac-&gt;nodemask);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化页面分配器中会用到的参数，这些参数会临时存放在alloc_context数据结构中，也就是ac中，关于alloc_context数据结构可以看下图：</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13441677614/0" alt="image-20210422145831111"></p>
<ul>
<li>zonelist：指向用于分配页面的区域列表</li>
<li>nodemask：指定内存分配的Node，如果没有指定，则在所有节点中进行分配</li>
<li>preferred_zoneref：指定要在快速路径中首先分配的区域，在慢路径中指定了一个zonelist中的第一个可用区域</li>
<li>migratetype：页面迁移类型</li>
<li>highest_zoneidx：允许内存分配的最高zone</li>
<li>spread_dirty_pages：指定是否进行脏页的传播</li>
</ul>
<h5 id="alloc-flags-nofragment"><a href="#alloc-flags-nofragment" class="headerlink" title="alloc_flags_nofragment"></a>alloc_flags_nofragment</h5><p><strong>原型：static inline unsigned int alloc_flags_nofragment(struct zone <em>*zone</em>, gfp_t gfp_mask)</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line">alloc_flags_nofragment(struct zone *zone, <span class="keyword">gfp_t</span> gfp_mask)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> alloc_flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * __GFP_KSWAPD_RECLAIM is assumed to be the same as ALLOC_KSWAPD</span></span><br><span class="line"><span class="comment">	 * to save a branch.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 如果gfp_mask限定了使用__GFP_KSWAPD_RECLAIM， 则在alloc标志中添加ALLOC_KSWAPD， 在内存不足时以唤醒kswapd</span></span><br><span class="line">	alloc_flags = (__force <span class="keyword">int</span>) (gfp_mask &amp; __GFP_KSWAPD_RECLAIM);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_ZONE_DMA32</span></span><br><span class="line">	<span class="keyword">if</span> (!zone)</span><br><span class="line">		<span class="keyword">return</span> alloc_flags;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (zone_idx(zone) != ZONE_NORMAL)</span><br><span class="line">		<span class="keyword">return</span> alloc_flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If ZONE_DMA32 exists, assume it is the one after ZONE_NORMAL and</span></span><br><span class="line"><span class="comment">	 * the pointer is within zone-&gt;zone_pgdat-&gt;node_zones[]. Also assume</span></span><br><span class="line"><span class="comment">	 * on UMA that if Normal is populated then so is DMA32.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	BUILD_BUG_ON(ZONE_NORMAL - ZONE_DMA32 != <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (nr_online_nodes &gt; <span class="number">1</span> &amp;&amp; !populated_zone(--zone))</span><br><span class="line">		<span class="keyword">return</span> alloc_flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该标志表示需要避免碎片化</span></span><br><span class="line">	alloc_flags |= ALLOC_NOFRAGMENT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* CONFIG_ZONE_DMA32 */</span></span></span><br><span class="line">	<span class="keyword">return</span> alloc_flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数主要根据区域和gfp掩码请求添加分配标志，<code>alloc_flags</code>主要是函数内部使用。</p>
<h5 id="get-page-from-freelist"><a href="#get-page-from-freelist" class="headerlink" title="get_page_from_freelist"></a>get_page_from_freelist</h5><p><strong>原型：static struct page * get_page_from_freelist(gfp_t gfp_mask, unsigned int order, int alloc_flags,const struct alloc_context *ac)</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class"><span class="title">get_page_from_freelist</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">alloc_flags</span>,</span></span><br><span class="line"><span class="class">						<span class="title">const</span> <span class="keyword">struct</span> <span class="title">alloc_context</span> *<span class="title">ac</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> *<span class="title">z</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> *<span class="title">last_pgdat_dirty_limit</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">bool</span> no_fallback;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Scan zonelist, looking for a zone with enough free.</span></span><br><span class="line"><span class="comment">	 * See also __cpuset_node_allowed() comment in kernel/cpuset.c.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	no_fallback = alloc_flags &amp; ALLOC_NOFRAGMENT;</span><br><span class="line">	z = ac-&gt;preferred_zoneref;</span><br><span class="line">    <span class="comment">// 遍历zonelist，从ac-&gt;preferred_zoneref这个zone开始，</span></span><br><span class="line">    <span class="comment">// 结束判断条件是小于等于ac-&gt;high_zoneidx</span></span><br><span class="line">    <span class="comment">// 例：high_zoneidx=1，就是类似NORMAL(idx=1)-&gt;DMA(idx=0)这种顺利遍历zone,而其它zone不满足因其index不小于等于high_zoneidx</span></span><br><span class="line">	for_next_zone_zonelist_nodemask(zone, z, ac-&gt;highest_zoneidx,</span><br><span class="line">					ac-&gt;nodemask) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> mark;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断cpuset是否开启且当前cpu是否允许在内存域zone所在节点中分配内存</span></span><br><span class="line">		<span class="keyword">if</span> (cpusets_enabled() &amp;&amp;</span><br><span class="line">			(alloc_flags &amp; ALLOC_CPUSET) &amp;&amp;</span><br><span class="line">			!__cpuset_zone_allowed(zone, gfp_mask))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// ac-&gt;spread_dirty_pages不为0表示gfp_mask存在__GFP_WRITE标志位，又可能增加脏页</span></span><br><span class="line">		<span class="keyword">if</span> (ac-&gt;spread_dirty_pages) &#123;</span><br><span class="line">			<span class="keyword">if</span> (last_pgdat_dirty_limit == zone-&gt;zone_pgdat)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">	   <span class="comment">// 如果zone对应的node脏页超标则使用last_pgdat_dirty_limit标识, 并跳过该zone</span></span><br><span class="line">			<span class="keyword">if</span> (!node_dirty_ok(zone-&gt;zone_pgdat)) &#123;</span><br><span class="line">				last_pgdat_dirty_limit = zone-&gt;zone_pgdat;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">// 如果设置no_fallback且当前zone并非preferred_zone, 则索引zone-&gt;node, 如果该node并非preferred_zone-&gt;node, 则取消ALLOC_NOFRAGMENT标志位即设置fallback(因为相比于内存碎片, 内存局部性更重要)</span></span><br><span class="line">		<span class="keyword">if</span> (no_fallback &amp;&amp; nr_online_nodes &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">		    zone != ac-&gt;preferred_zoneref-&gt;zone) &#123;</span><br><span class="line">			<span class="keyword">int</span> local_nid;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If moving to a remote node, retry but allow</span></span><br><span class="line"><span class="comment">			 * fragmenting fallbacks. Locality is more important</span></span><br><span class="line"><span class="comment">			 * than fragmentation avoidance.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			local_nid = zone_to_nid(ac-&gt;preferred_zoneref-&gt;zone);</span><br><span class="line">			<span class="keyword">if</span> (zone_to_nid(zone) != local_nid) &#123;</span><br><span class="line">				alloc_flags &amp;= ~ALLOC_NOFRAGMENT;</span><br><span class="line">				<span class="keyword">goto</span> retry;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//mark保存当前的zone的水位值(如之前分配标志是ALLOC_WMARK_LOW，则这里是WMARK_LOW)</span></span><br><span class="line">		mark = wmark_pages(zone, alloc_flags &amp; ALLOC_WMARK_MASK);</span><br><span class="line">        <span class="comment">//判断此zone的free_pages是否大于mark+lowmem_reserve(最低预留)，如果大于表示满足返回ture</span></span><br><span class="line">		<span class="keyword">if</span> (!zone_watermark_fast(zone, order, mark,</span><br><span class="line">				       ac-&gt;highest_zoneidx, alloc_flags,</span><br><span class="line">				       gfp_mask)) &#123;</span><br><span class="line">        <span class="comment">//显然走到这行说明返回了false，因此空闲page不够需要先对内存进行回收</span></span><br><span class="line">			<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Watermark failed for this zone, but see if we can</span></span><br><span class="line"><span class="comment">			 * grow this zone if it contains deferred pages.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (static_branch_unlikely(&amp;deferred_pages)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (_deferred_grow_zone(zone, order))</span><br><span class="line">					<span class="keyword">goto</span> try_this_zone;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">			<span class="comment">/* Checked here to keep the fast path fast */</span></span><br><span class="line">			BUILD_BUG_ON(ALLOC_NO_WATERMARKS &lt; NR_WMARK);</span><br><span class="line">			<span class="keyword">if</span> (alloc_flags &amp; ALLOC_NO_WATERMARKS)</span><br><span class="line">				<span class="keyword">goto</span> try_this_zone;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (node_reclaim_mode == <span class="number">0</span> ||</span><br><span class="line">			    !zone_allows_reclaim(ac-&gt;preferred_zoneref-&gt;zone, zone))</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">// 内存回收</span></span><br><span class="line">			ret = node_reclaim(zone-&gt;zone_pgdat, gfp_mask, order);</span><br><span class="line">			<span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">			<span class="keyword">case</span> NODE_RECLAIM_NOSCAN:</span><br><span class="line">				<span class="comment">/* did not scan */</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">case</span> NODE_RECLAIM_FULL:</span><br><span class="line">				<span class="comment">/* scanned but unreclaimable */</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="comment">/* did we reclaim enough */</span></span><br><span class="line">				<span class="keyword">if</span> (zone_watermark_ok(zone, order, mark,</span><br><span class="line">					ac-&gt;highest_zoneidx, alloc_flags))</span><br><span class="line">					<span class="keyword">goto</span> try_this_zone;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">try_this_zone:</span><br><span class="line">        <span class="comment">// 伙伴算法开始分配页内存</span></span><br><span class="line">		page = rmqueue(ac-&gt;preferred_zoneref-&gt;zone, zone, order,</span><br><span class="line">				gfp_mask, alloc_flags, ac-&gt;migratetype);</span><br><span class="line">		<span class="keyword">if</span> (page) &#123;</span><br><span class="line">			prep_new_page(page, order, gfp_mask, alloc_flags);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If this is a high-order atomic allocation then check</span></span><br><span class="line"><span class="comment">			 * if the pageblock should be reserved for the future</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(order &amp;&amp; (alloc_flags &amp; ALLOC_HARDER)))</span><br><span class="line">				reserve_highatomic_pageblock(page, zone, order);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> page;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line">			<span class="comment">/* Try again if zone has deferred pages */</span></span><br><span class="line">			<span class="keyword">if</span> (static_branch_unlikely(&amp;deferred_pages)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (_deferred_grow_zone(zone, order))</span><br><span class="line">					<span class="keyword">goto</span> try_this_zone;</span><br><span class="line">			&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (no_fallback) &#123;</span><br><span class="line">		alloc_flags &amp;= ~ALLOC_NOFRAGMENT;</span><br><span class="line">		<span class="keyword">goto</span> retry;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从preferred zone开始遍历zonelist，这里使用<code>for_next_zone_zonelist_nodemask</code>宏来遍历。需要注意的是扫描zone的方向是从高端zone到低端zone。然后判断zone是否满足分配需求，如果zone空间不足，则进行node_reclaim()，尝试页面回收。如果回收后的空间满足要求，则调用<code>rmqueue()</code>从伙伴系统中进行内存分配。分配成功则返回<code>page</code></p>
<h6 id="rmqueue"><a href="#rmqueue" class="headerlink" title="rmqueue"></a>rmqueue</h6><p><strong>原型：static inline struct page* rmqueue(struct zone *preferred_zone,struct zone *zone, unsigned int order,gfp_t *gfp_flags, unsigned int alloc_flags,int migratetype)</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span></span><br><span class="line"><span class="function">struct page *<span class="title">rmqueue</span><span class="params">(struct zone *preferred_zone,</span></span></span><br><span class="line"><span class="function"><span class="params">			struct zone *zone, <span class="keyword">unsigned</span> <span class="keyword">int</span> order,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">gfp_t</span> gfp_flags, <span class="keyword">unsigned</span> <span class="keyword">int</span> alloc_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">int</span> migratetype)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (likely(order == <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * MIGRATE_MOVABLE pcplist could have the pages on CMA area and</span></span><br><span class="line"><span class="comment">		 * we need to skip it when CMA area isn&#x27;t allowed.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!IS_ENABLED(CONFIG_CMA) || alloc_flags &amp; ALLOC_CMA ||</span><br><span class="line">				migratetype != MIGRATE_MOVABLE) &#123;</span><br><span class="line">			page = rmqueue_pcplist(preferred_zone, zone, gfp_flags,</span><br><span class="line">					migratetype, alloc_flags);</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能使用__GFP_NOFAIL, 分配order&gt;1的页</span></span><br><span class="line">	WARN_ON_ONCE((gfp_flags &amp; __GFP_NOFAIL) &amp;&amp; (order &gt; <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 使用自旋锁加锁zone资源</span></span><br><span class="line">	spin_lock_irqsave(&amp;zone-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		page = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * order-0 request can reach here when the pcplist is skipped</span></span><br><span class="line"><span class="comment">		 * due to non-CMA allocation context. HIGHATOMIC area is</span></span><br><span class="line"><span class="comment">		 * reserved for high-order atomic allocation, so order-0</span></span><br><span class="line"><span class="comment">		 * request should skip it.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (order &gt; <span class="number">0</span> &amp;&amp; alloc_flags &amp; ALLOC_HARDER) &#123;</span><br><span class="line">			page = __rmqueue_smallest(zone, order, MIGRATE_HIGHATOMIC);</span><br><span class="line">			<span class="keyword">if</span> (page)</span><br><span class="line">				trace_mm_page_alloc_zone_locked(page, order, migratetype);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!page)</span><br><span class="line">			page = __rmqueue(zone, order, migratetype, alloc_flags);</span><br><span class="line">	&#125; <span class="keyword">while</span> (page &amp;&amp; check_new_pages(page, order));</span><br><span class="line">	spin_unlock(&amp;zone-&gt;lock);</span><br><span class="line">	<span class="keyword">if</span> (!page)</span><br><span class="line">		<span class="keyword">goto</span> failed;</span><br><span class="line">	__mod_zone_freepage_state(zone, -(<span class="number">1</span> &lt;&lt; order),</span><br><span class="line">				  get_pcppage_migratetype(page));</span><br><span class="line"></span><br><span class="line">	__count_zid_vm_events(PGALLOC, page_zonenum(page), <span class="number">1</span> &lt;&lt; order);</span><br><span class="line">	zone_statistics(preferred_zone, zone);</span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="comment">/* Separate test+clear to avoid unnecessary atomics */</span></span><br><span class="line">	<span class="keyword">if</span> (test_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags)) &#123;</span><br><span class="line">		clear_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags);</span><br><span class="line">		wakeup_kswapd(zone, <span class="number">0</span>, <span class="number">0</span>, zone_idx(zone));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	VM_BUG_ON_PAGE(page &amp;&amp; bad_range(zone, page), page);</span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line"></span><br><span class="line">failed:</span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>rmqueue</code>会根据order=0和order&gt;0两种情况走不同的分配流程。</p>
<p>在针对order=0的分配中，即从cpu高速缓存中分配，因单个(1个page)cpu访问非常频繁，这种涉及缓解了多cpu访问zone时的锁竞争提高了性能。注意这个不是送伙伴系统中申请，但当<code>pcp</code>中为空，则会从伙伴系统中申请<code>batch</code>数量的<code>page</code>来初始化<code>pcp</code>。下面简要看下流程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Lock and remove page from the per-cpu list */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct page *<span class="title">rmqueue_pcplist</span><span class="params">(struct zone *preferred_zone,</span></span></span><br><span class="line"><span class="function"><span class="params">			struct zone *zone, <span class="keyword">gfp_t</span> gfp_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">int</span> migratetype, <span class="keyword">unsigned</span> <span class="keyword">int</span> alloc_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pages</span> *<span class="title">pcp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁用全部中断，并将当前中断状态保存至flags</span></span><br><span class="line">	local_irq_save(flags);</span><br><span class="line">    <span class="comment">// 获取当前cpu中对应zone的pcp对象(热页)</span></span><br><span class="line">	pcp = &amp;this_cpu_ptr(zone-&gt;pageset)-&gt;pcp;</span><br><span class="line">    <span class="comment">// 通过pcp获取对应迁移类型的链表</span></span><br><span class="line">	<span class="built_in">list</span> = &amp;pcp-&gt;lists[migratetype];</span><br><span class="line">    <span class="comment">// 从pcplist链表上获取对应的page，如果list为空，则会调用rmqueue_bulk从伙伴系统申请batch数量的page来初始化list。</span></span><br><span class="line">	page = __rmqueue_pcplist(zone,  migratetype, alloc_flags, pcp, <span class="built_in">list</span>);</span><br><span class="line">	<span class="keyword">if</span> (page) &#123;</span><br><span class="line">		__count_zid_vm_events(PGALLOC, page_zonenum(page), <span class="number">1</span>);</span><br><span class="line">		zone_statistics(preferred_zone, zone);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 恢复中断状态并开中断</span></span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对order&gt;0即非单页，则从伙伴系统中对应的迁移类型列表中申请page</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">rmqueue</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">migratetype</span>,</span></span><br><span class="line"><span class="class">						<span class="title">unsigned</span> <span class="title">int</span> <span class="title">alloc_flags</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_CMA)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Balance movable allocations between regular and CMA areas by</span></span><br><span class="line"><span class="comment">		 * allocating from CMA when over half of the zone&#x27;s free memory</span></span><br><span class="line"><span class="comment">		 * is in the CMA area.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (alloc_flags &amp; ALLOC_CMA &amp;&amp;</span><br><span class="line">		    zone_page_state(zone, NR_FREE_CMA_PAGES) &gt;</span><br><span class="line">		    zone_page_state(zone, NR_FREE_PAGES) / <span class="number">2</span>) &#123;</span><br><span class="line">			page = __rmqueue_cma_fallback(zone, order);</span><br><span class="line">			<span class="keyword">if</span> (page)</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">retry:</span><br><span class="line">    <span class="comment">// 使用__rmqueue_smallest获得page</span></span><br><span class="line">	page = __rmqueue_smallest(zone, order, migratetype);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(!page)) &#123;</span><br><span class="line">        <span class="comment">// 如果分配失败，则加上ALLOC_CMA标志后再次尝试</span></span><br><span class="line">		<span class="keyword">if</span> (alloc_flags &amp; ALLOC_CMA)</span><br><span class="line">			page = __rmqueue_cma_fallback(zone, order);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// page分配再次失败后使用判断是否可以使用备用迁移类型(如果可以则修改order, migratetype)然后跳转进入retry</span></span><br><span class="line">		<span class="keyword">if</span> (!page &amp;&amp; __rmqueue_fallback(zone, order, migratetype,</span><br><span class="line">								alloc_flags))</span><br><span class="line">			<span class="keyword">goto</span> retry;</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (page)</span><br><span class="line">		trace_mm_page_alloc_zone_locked(page, order, migratetype);</span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="alloc-pages-slowpath"><a href="#alloc-pages-slowpath" class="headerlink" title="__alloc_pages_slowpath"></a>__alloc_pages_slowpath</h5><p>原型：static inline struct page* __alloc_pages_slowpath(gfp_t gfp_mask, unsigned int order,struct alloc_context *ac)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_slowpath</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class">						<span class="keyword">struct</span> <span class="title">alloc_context</span> *<span class="title">ac</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">bool</span> can_direct_reclaim = gfp_mask &amp; __GFP_DIRECT_RECLAIM;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">bool</span> costly_order = order &gt; PAGE_ALLOC_COSTLY_ORDER;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> alloc_flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> did_some_progress;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">compact_priority</span> <span class="title">compact_priority</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">compact_result</span> <span class="title">compact_result</span>;</span></span><br><span class="line">	<span class="keyword">int</span> compaction_retries;</span><br><span class="line">	<span class="keyword">int</span> no_progress_loops;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> cpuset_mems_cookie;</span><br><span class="line">	<span class="keyword">int</span> reserve_flags;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果内存分配标志包含__GFP_ATOMIC(来自不能阻塞或延迟和失败没有回调的原子上下文的请求), __GFP_DIRECT_RECLAIM(可以直接回收, 表示有回收需要时会阻塞请求), 明显二者冲突, 此处做一个校验</span></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON_ONCE((gfp_mask &amp; (__GFP_ATOMIC|__GFP_DIRECT_RECLAIM)) ==</span><br><span class="line">				(__GFP_ATOMIC|__GFP_DIRECT_RECLAIM)))</span><br><span class="line">		gfp_mask &amp;= ~__GFP_ATOMIC;</span><br><span class="line"></span><br><span class="line">retry_cpuset:</span><br><span class="line">	compaction_retries = <span class="number">0</span>;</span><br><span class="line">	no_progress_loops = <span class="number">0</span>;</span><br><span class="line">	compact_priority = DEF_COMPACT_PRIORITY;</span><br><span class="line">	cpuset_mems_cookie = read_mems_allowed_begin();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 降低要求, 重新构建标志位</span></span><br><span class="line">	alloc_flags = gfp_to_alloc_flags(gfp_mask);</span><br><span class="line"></span><br><span class="line">	ac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,</span><br><span class="line">					ac-&gt;highest_zoneidx, ac-&gt;nodemask);</span><br><span class="line">	<span class="keyword">if</span> (!ac-&gt;preferred_zoneref-&gt;zone)</span><br><span class="line">		<span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果设置了ALLOC_KSWAPD, 则唤醒交换进程</span></span><br><span class="line">	<span class="keyword">if</span> (alloc_flags &amp; ALLOC_KSWAPD)</span><br><span class="line">		wake_all_kswapds(order, gfp_mask, ac);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 内存调整后再次分配</span></span><br><span class="line">	page = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);</span><br><span class="line">	<span class="keyword">if</span> (page)</span><br><span class="line">		<span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果满足以下条件则尝试进行内存压缩</span></span><br><span class="line">	<span class="comment">// 1. 如果标识__GFP_DIRECT_RECLAIM&amp;ALLOC_NO_WATERMARK且order&gt;3(costly_order=1)则进入__alloc_pages_direct_compact</span></span><br><span class="line">	<span class="comment">// 2. 如果标识__GFP_DIRECT_RECLAIM&amp;ALLOC_NO_WATERMARK且order&lt;3(costly_order=0)且迁移类型不为MIGRATE_MOVABLE则进入__alloc_pages_direct_compact</span></span><br><span class="line">	<span class="keyword">if</span> (can_direct_reclaim &amp;&amp;</span><br><span class="line">			(costly_order ||</span><br><span class="line">			   (order &gt; <span class="number">0</span> &amp;&amp; ac-&gt;migratetype != MIGRATE_MOVABLE))</span><br><span class="line">			&amp;&amp; !gfp_pfmemalloc_allowed(gfp_mask)) &#123;</span><br><span class="line">		page = __alloc_pages_direct_compact(gfp_mask, order,</span><br><span class="line">						alloc_flags, ac,</span><br><span class="line">						INIT_COMPACT_PRIORITY,</span><br><span class="line">						&amp;compact_result);</span><br><span class="line">		<span class="keyword">if</span> (page)</span><br><span class="line">			<span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (costly_order &amp;&amp; (gfp_mask &amp; __GFP_NORETRY)) &#123;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> (compact_result == COMPACT_SKIPPED ||</span><br><span class="line">			    compact_result == COMPACT_DEFERRED)</span><br><span class="line">				<span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line">			compact_priority = INIT_COMPACT_PRIORITY;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">	<span class="comment">/* Ensure kswapd doesn&#x27;t accidentally go to sleep as long as we loop */</span></span><br><span class="line">	<span class="keyword">if</span> (alloc_flags &amp; ALLOC_KSWAPD)</span><br><span class="line">		wake_all_kswapds(order, gfp_mask, ac);</span><br><span class="line"></span><br><span class="line">	reserve_flags = __gfp_pfmemalloc_flags(gfp_mask);</span><br><span class="line">	<span class="keyword">if</span> (reserve_flags)</span><br><span class="line">		alloc_flags = current_alloc_flags(gfp_mask, reserve_flags);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (!(alloc_flags &amp; ALLOC_CPUSET) || reserve_flags) &#123;</span><br><span class="line">		ac-&gt;nodemask = <span class="literal">NULL</span>;</span><br><span class="line">		ac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,</span><br><span class="line">					ac-&gt;highest_zoneidx, ac-&gt;nodemask);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Attempt with potentially adjusted zonelist and alloc_flags */</span></span><br><span class="line">	page = get_page_from_freelist(gfp_mask, order, alloc_flags, ac);</span><br><span class="line">	<span class="keyword">if</span> (page)</span><br><span class="line">		<span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Caller is not willing to reclaim, we can&#x27;t balance anything */</span></span><br><span class="line">	<span class="keyword">if</span> (!can_direct_reclaim)</span><br><span class="line">		<span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Avoid recursion of direct reclaim */</span></span><br><span class="line">	<span class="keyword">if</span> (current-&gt;flags &amp; PF_MEMALLOC)</span><br><span class="line">		<span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 内存回收后分配内存</span></span><br><span class="line">	page = __alloc_pages_direct_reclaim(gfp_mask, order, alloc_flags, ac,</span><br><span class="line">							&amp;did_some_progress);</span><br><span class="line">	<span class="keyword">if</span> (page)</span><br><span class="line">		<span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 内存压缩后分配内存</span></span><br><span class="line">	page = __alloc_pages_direct_compact(gfp_mask, order, alloc_flags, ac,</span><br><span class="line">					compact_priority, &amp;compact_result);</span><br><span class="line">	<span class="keyword">if</span> (page)</span><br><span class="line">		<span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Do not loop if specifically requested */</span></span><br><span class="line">	<span class="keyword">if</span> (gfp_mask &amp; __GFP_NORETRY)</span><br><span class="line">		<span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Do not retry costly high order allocations unless they are</span></span><br><span class="line"><span class="comment">	 * __GFP_RETRY_MAYFAIL</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (costly_order &amp;&amp; !(gfp_mask &amp; __GFP_RETRY_MAYFAIL))</span><br><span class="line">		<span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分析是否应该再次内存回收</span></span><br><span class="line">	<span class="keyword">if</span> (should_reclaim_retry(gfp_mask, order, ac, alloc_flags,</span><br><span class="line">				 did_some_progress &gt; <span class="number">0</span>, &amp;no_progress_loops))</span><br><span class="line">		<span class="keyword">goto</span> retry;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (did_some_progress &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">			should_compact_retry(ac, order, alloc_flags,</span><br><span class="line">				compact_result, &amp;compact_priority,</span><br><span class="line">				&amp;compaction_retries))</span><br><span class="line">		<span class="keyword">goto</span> retry;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Deal with possible cpuset update races before we start OOM killing */</span></span><br><span class="line">	<span class="keyword">if</span> (check_retry_cpuset(cpuset_mems_cookie, ac))</span><br><span class="line">		<span class="keyword">goto</span> retry_cpuset;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 杀死一些进程以获得内存</span></span><br><span class="line">	page = __alloc_pages_may_oom(gfp_mask, order, ac, &amp;did_some_progress);</span><br><span class="line">	<span class="keyword">if</span> (page)</span><br><span class="line">		<span class="keyword">goto</span> got_pg;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Avoid allocations with no watermarks from looping endlessly */</span></span><br><span class="line">	<span class="keyword">if</span> (tsk_is_oom_victim(current) &amp;&amp;</span><br><span class="line">	    (alloc_flags &amp; ALLOC_OOM ||</span><br><span class="line">	     (gfp_mask &amp; __GFP_NOMEMALLOC)))</span><br><span class="line">		<span class="keyword">goto</span> nopage;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Retry as long as the OOM killer is making progress */</span></span><br><span class="line">	<span class="keyword">if</span> (did_some_progress) &#123;</span><br><span class="line">		no_progress_loops = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">goto</span> retry;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">nopage:</span><br><span class="line">	<span class="comment">/* Deal with possible cpuset update races before we fail */</span></span><br><span class="line">	<span class="keyword">if</span> (check_retry_cpuset(cpuset_mems_cookie, ac))</span><br><span class="line">		<span class="keyword">goto</span> retry_cpuset;</span><br><span class="line">	<span class="keyword">if</span> (gfp_mask &amp; __GFP_NOFAIL) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (WARN_ON_ONCE(!can_direct_reclaim))</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">		WARN_ON_ONCE(current-&gt;flags &amp; PF_MEMALLOC);</span><br><span class="line">		WARN_ON_ONCE(order &gt; PAGE_ALLOC_COSTLY_ORDER);</span><br><span class="line">		page = __alloc_pages_cpuset_fallback(gfp_mask, order, ALLOC_HARDER, ac);</span><br><span class="line">		<span class="keyword">if</span> (page)</span><br><span class="line">			<span class="keyword">goto</span> got_pg;</span><br><span class="line">		cond_resched();</span><br><span class="line">		<span class="keyword">goto</span> retry;</span><br><span class="line">	&#125;</span><br><span class="line">fail:</span><br><span class="line">	warn_alloc(gfp_mask, ac-&gt;nodemask,</span><br><span class="line">			<span class="string">&quot;page allocation failure: order:%u&quot;</span>, order);</span><br><span class="line">got_pg:</span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="free-pages"><a href="#free-pages" class="headerlink" title="free_pages"></a>free_pages</h4><p><strong>原型：extern void free_pages(unsigned long <em>addr</em>, unsigned int order);</strong></p>
<p>关于<code>free_pages</code>其实没什么内容，我们只需要一直跟进到<code>free_the_page</code>，它的调用链如下：</p>
<p><code>free_pages</code> -&gt; <code>__free_pages</code> -&gt; <code>free_the_page</code></p>
<h5 id="free-the-page"><a href="#free-the-page" class="headerlink" title="free_the_page"></a>free_the_page</h5><p><strong>原型：static inline void free_the_page(struct page *page, unsigned int order)</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">free_the_page</span><span class="params">(struct page *page, <span class="keyword">unsigned</span> <span class="keyword">int</span> order)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (order == <span class="number">0</span>)		<span class="comment">/* Via pcp? */</span></span><br><span class="line">		free_unref_page(page);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		__free_pages_ok(page, order, FPI_NONE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到存在两条路径，一条是order=0，另一条是order&gt;0的路径。先看order=0的路径，<code>free_unref_page</code>主要调用了<code>free_unref_page_commit</code>，我们来看<code>free_unref_page_commit</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">free_unref_page_commit</span><span class="params">(struct page *page, <span class="keyword">unsigned</span> <span class="keyword">long</span> pfn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span> =</span> page_zone(page);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pages</span> *<span class="title">pcp</span>;</span></span><br><span class="line">	<span class="keyword">int</span> migratetype;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得迁移类型</span></span><br><span class="line">	migratetype = get_pcppage_migratetype(page);</span><br><span class="line">	__count_vm_event(PGFREE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// pcp_list 只放置unmovable, reclaimable, movable类型page</span></span><br><span class="line">	<span class="comment">// 大于等于MIGRATE_PCPTYPES的迁移类型中MIGRATE_ISOLATE不能被放入pcp</span></span><br><span class="line">	<span class="keyword">if</span> (migratetype &gt;= MIGRATE_PCPTYPES) &#123;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(is_migrate_isolate(migratetype))) &#123;</span><br><span class="line">            <span class="comment">// 放入伙伴系统</span></span><br><span class="line">			free_one_page(zone, page, pfn, <span class="number">0</span>, migratetype,</span><br><span class="line">				      FPI_NONE);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		migratetype = MIGRATE_MOVABLE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pcp = &amp;this_cpu_ptr(zone-&gt;pageset)-&gt;pcp;</span><br><span class="line">    <span class="comment">// 将page放入pcp-&gt;lists[migratetype]链表表头</span></span><br><span class="line">	list_add(&amp;page-&gt;lru, &amp;pcp-&gt;lists[migratetype]);</span><br><span class="line">	pcp-&gt;count++;</span><br><span class="line">    <span class="comment">// 如果pcp-&gt;count(pcp中页数目) &gt;= pcp-&gt;high(pcp中最大页数目), 则将多余的page放入伙伴系统</span></span><br><span class="line">	<span class="keyword">if</span> (pcp-&gt;count &gt;= READ_ONCE(pcp-&gt;high))</span><br><span class="line">		free_pcppages_bulk(zone, READ_ONCE(pcp-&gt;batch), pcp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里单个页的释放其实可以看到是和我们的申请是相对应的。</p>
<p>接下来我们看另一条路径<code>__free_pages_ok</code> ，<code>__free_pages_ok</code> 主要是对<code>free_one_page</code>的调用，我们看<code>free_one_page</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __free_one_page(struct page *page,</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> pfn,</span><br><span class="line">		struct zone *zone, <span class="keyword">unsigned</span> <span class="keyword">int</span> order,</span><br><span class="line">		<span class="keyword">int</span> migratetype, <span class="keyword">fpi_t</span> fpi_flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">capture_control</span> *<span class="title">capc</span> =</span> task_capc(zone);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> buddy_pfn;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> combined_pfn;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> max_order;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">buddy</span>;</span></span><br><span class="line">	<span class="keyword">bool</span> to_tail;</span><br><span class="line"></span><br><span class="line">	max_order = <span class="keyword">min_t</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>, MAX_ORDER - <span class="number">1</span>, pageblock_order);</span><br><span class="line"></span><br><span class="line">	VM_BUG_ON(!zone_is_initialized(zone));</span><br><span class="line">	VM_BUG_ON_PAGE(page-&gt;flags &amp; PAGE_FLAGS_CHECK_AT_PREP, page);</span><br><span class="line"></span><br><span class="line">	VM_BUG_ON(migratetype == <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span> (likely(!is_migrate_isolate(migratetype)))</span><br><span class="line">		__mod_zone_freepage_state(zone, <span class="number">1</span> &lt;&lt; order, migratetype);</span><br><span class="line"></span><br><span class="line">	VM_BUG_ON_PAGE(pfn &amp; ((<span class="number">1</span> &lt;&lt; order) - <span class="number">1</span>), page);</span><br><span class="line">	VM_BUG_ON_PAGE(bad_range(zone, page), page);</span><br><span class="line"></span><br><span class="line">continue_merging:</span><br><span class="line">    <span class="comment">// 循环遍历知道order = max_order - 1</span></span><br><span class="line">	<span class="keyword">while</span> (order &lt; max_order) &#123;</span><br><span class="line">		<span class="keyword">if</span> (compaction_capture(capc, page, order, migratetype)) &#123;</span><br><span class="line">			__mod_zone_freepage_state(zone, -(<span class="number">1</span> &lt;&lt; order),</span><br><span class="line">								migratetype);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">         <span class="comment">// buddy_pfn = page_pfn ^ (1 &lt;&lt; order);</span></span><br><span class="line">		<span class="comment">// 定位兄弟页</span></span><br><span class="line">		buddy_pfn = __find_buddy_pfn(pfn, order);</span><br><span class="line">         <span class="comment">// 获得兄弟页的struct page</span></span><br><span class="line">		buddy = page + (buddy_pfn - pfn);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 判断buddy_pfn是否有效</span></span><br><span class="line">		<span class="keyword">if</span> (!pfn_valid_within(buddy_pfn))</span><br><span class="line">			<span class="keyword">goto</span> done_merging;</span><br><span class="line">         <span class="comment">// 1. buddy_ord == order</span></span><br><span class="line">		<span class="comment">// 2. buddy_zone == zone</span></span><br><span class="line">		<span class="comment">// 3. buddy-&gt;_refcount == 0</span></span><br><span class="line">		<span class="comment">// 若满足以上条件则buddy可合并</span></span><br><span class="line">		<span class="keyword">if</span> (!page_is_buddy(page, buddy, order))</span><br><span class="line">			<span class="keyword">goto</span> done_merging;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (page_is_guard(buddy))</span><br><span class="line">			clear_page_guard(zone, buddy, order, migratetype);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 将buddy从对应free_area[order]中删除</span></span><br><span class="line">			del_page_from_free_list(buddy, zone, order);</span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 设置合并页的struct page以及pfn</span></span><br><span class="line">		combined_pfn = buddy_pfn &amp; pfn;</span><br><span class="line">		page = page + (combined_pfn - pfn);</span><br><span class="line">		pfn = combined_pfn;</span><br><span class="line">		order++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (order &lt; MAX_ORDER - <span class="number">1</span>) &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (unlikely(has_isolate_pageblock(zone))) &#123;</span><br><span class="line">			<span class="keyword">int</span> buddy_mt;</span><br><span class="line"></span><br><span class="line">			buddy_pfn = __find_buddy_pfn(pfn, order);</span><br><span class="line">			buddy = page + (buddy_pfn - pfn);</span><br><span class="line">			buddy_mt = get_pageblock_migratetype(buddy);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (migratetype != buddy_mt</span><br><span class="line">					&amp;&amp; (is_migrate_isolate(migratetype) ||</span><br><span class="line">						is_migrate_isolate(buddy_mt)))</span><br><span class="line">				<span class="keyword">goto</span> done_merging;</span><br><span class="line">		&#125;</span><br><span class="line">		max_order = order + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">goto</span> continue_merging;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">done_merging:</span><br><span class="line">    <span class="comment">// 设置page的阶数, 将page标记为伙伴系统页</span></span><br><span class="line">	set_buddy_order(page, order);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果page并不是最大的page, 检查伙伴页是否是free状态的, 如果是, 但是上述步骤合并失败则有可能伙伴页正在被释放, 这时候应该把page放在zone-&gt;free_area[order]尾部(延缓page被分配出去), 这样等伙伴页释放完成后就可以一起被合并成更大的page了</span></span><br><span class="line">	<span class="keyword">if</span> (fpi_flags &amp; FPI_TO_TAIL)</span><br><span class="line">		to_tail = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (is_shuffle_order(order))</span><br><span class="line">		to_tail = shuffle_pick_tail();</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		to_tail = buddy_merge_likely(pfn, buddy_pfn, page, order);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (to_tail)</span><br><span class="line">        <span class="comment">// 把page置入zone-&gt;free_area[order]链表尾部</span></span><br><span class="line">		add_to_free_list_tail(page, zone, order, migratetype);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 把page置入zone-&gt;free_area[order]链表头部</span></span><br><span class="line">		add_to_free_list(page, zone, order, migratetype);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Notify page reporting subsystem of freed page */</span></span><br><span class="line">	<span class="keyword">if</span> (!(fpi_flags &amp; FPI_SKIP_REPORT_NOTIFY))</span><br><span class="line">		page_reporting_notify_free(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">C7</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://billyotry.github.io/2021/04/15/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AD%A6%E4%B9%A0/">https://billyotry.github.io/2021/04/15/Linux%E5%86%85%E6%A0%B8-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%AD%A6%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://billyotry.github.io" target="_blank">C7</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Kernel/">Kernel</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/04/22/DirtyCow%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%B0%83%E8%AF%95%E8%AE%B0%E5%BD%95/"><img class="prev-cover" src="https://i.loli.net/2021/04/17/LmQWxH4wAb8ZpnO.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">DirtyCow学习与调试记录</div></div></a></div><div class="next-post pull-right"><a href="/2021/04/07/%E3%80%90Writeup%E3%80%91GitHub%20Security%20Lab%20CTF-1/"><img class="next-cover" src="https://i.loli.net/2021/04/07/TjW1lwOqU9M5dAK.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【Writeup】GitHub Security Lab CTF-1</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">C7</div><div class="author-info__description">雖不能至 心嚮往之</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><a class="button--animated" id="card-info-btn"><i class="fa fa-paper-plane-o"></i><span>加入书签</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/BillyoTry" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1347405944@qq.com" target="_blank" title="Email"><i class="fa fa-envelope"></i></a><a class="social-icon" href="tencent://message/?uin=1347405944&amp;Site=&amp;Menu=yes" target="_blank" title=""><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">大家疫情期间注意保护自己噢~~~~</div></div><div class="sticky_layout"><div class="card-widget card-clock" style="padding:0"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="clock" style="padding:20px"><img v-if="clockshow == &quot;false&quot;" src="/clock/images/weather/loading.gif" style="height:120px;width:100%"/><table class="clock" v-if="clockshow"><tbody><tr><td class="clockdate">{{date}}</td><td class="weatherimg" align="center" valign="middle"><img id="weatherimg" :src="weatherimg"/></td><td class="temperature" align="center" valign="middle">{{temperature}}</td><td class="humidityimg"><img id="humidityimg" :src="humidityimg"/></td><td class="humidity">{{humidity}}</td></tr><tr class="time"><td colspan="5">{{time}}</td></tr><tr><td class="usaqi" colspan="1"> <span>{{ip}}</span></td><td class="city" colspan="2">{{city}}</td><td class="daylight" colspan="2">{{daylight}}</td></tr></tbody></table></div></div></div></div></div><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E5%86%85%E6%A0%B8%E5%AF%B9%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">Linux内核对物理内存描述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%EF%BC%88Node%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">节点（Node）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9F%9F%EF%BC%88Zone%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">区域（Zone）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%9F%9F%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">区域类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-zone%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.2.2.</span> <span class="toc-text">struct zone结构体</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%EF%BC%88Page%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">页面（Page）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-page%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.3.1.</span> <span class="toc-text">struct page结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E6%A0%87%E5%BF%97"><span class="toc-number">1.3.2.</span> <span class="toc-text">页面标志</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">空闲页面的管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E6%8F%8F%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">物理内存空间描述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%99%E4%BC%B4%E7%AE%97%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">伙伴算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%99%E4%BC%B4%E7%B3%BB%E7%BB%9F%E4%B8%BE%E4%BE%8B"><span class="toc-number">3.1.</span> <span class="toc-text">伙伴系统举例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="toc-number">3.1.1.</span> <span class="toc-text">页面分配过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B"><span class="toc-number">3.1.2.</span> <span class="toc-text">页面回收过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">3.2.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#alloc-pages"><span class="toc-number">3.2.1.</span> <span class="toc-text">alloc_pages</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#alloc-pages-current"><span class="toc-number">3.2.2.</span> <span class="toc-text">alloc_pages_current</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#alloc-pages-nodemask"><span class="toc-number">3.2.3.</span> <span class="toc-text">__alloc_pages_nodemask</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#prepare-alloc-pages"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">prepare_alloc_pages</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#alloc-flags-nofragment"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">alloc_flags_nofragment</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#get-page-from-freelist"><span class="toc-number">3.2.3.3.</span> <span class="toc-text">get_page_from_freelist</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#rmqueue"><span class="toc-number">3.2.3.3.1.</span> <span class="toc-text">rmqueue</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#alloc-pages-slowpath"><span class="toc-number">3.2.3.4.</span> <span class="toc-text">__alloc_pages_slowpath</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#free-pages"><span class="toc-number">3.2.4.</span> <span class="toc-text">free_pages</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#free-the-page"><span class="toc-number">3.2.4.1.</span> <span class="toc-text">free_the_page</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2099/01/01/test/" title="这是标题"><img src="https://i.loli.net/2021/01/22/QJ1bzWyEp9IKx7R.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="这是标题"/></a><div class="content"><a class="title" href="/2099/01/01/test/" title="这是标题">这是标题</a><time datetime="2098-12-31T16:00:00.000Z" title="发表于 2099-01-01 00:00:00">2099-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/06/07/qemu%20pwn%E5%9F%BA%E7%A1%80/" title="qemu pwn基础"><img src="https://i.loli.net/2021/06/07/AFvIGNcrB7wZxD5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="qemu pwn基础"/></a><div class="content"><a class="title" href="/2021/06/07/qemu%20pwn%E5%9F%BA%E7%A1%80/" title="qemu pwn基础">qemu pwn基础</a><time datetime="2021-06-07T12:13:55.028Z" title="发表于 2021-06-07 20:13:55">2021-06-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/29/%E8%AE%BAORW%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%88%A9%E7%94%A8%E5%A7%BF%E5%8A%BF/" title="论ORW的多种利用姿势"><img src="https://i.loli.net/2021/06/03/qOFcBw4g6tAjUEL.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="论ORW的多种利用姿势"/></a><div class="content"><a class="title" href="/2021/05/29/%E8%AE%BAORW%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%88%A9%E7%94%A8%E5%A7%BF%E5%8A%BF/" title="论ORW的多种利用姿势">论ORW的多种利用姿势</a><time datetime="2021-05-29T13:47:40.255Z" title="发表于 2021-05-29 21:47:40">2021-05-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/10/%E3%80%90how2heap%E3%80%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="【how2heap】学习笔记"><img src="https://i.loli.net/2021/05/20/EbwjRFDSotqX95g.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【how2heap】学习笔记"/></a><div class="content"><a class="title" href="/2021/05/10/%E3%80%90how2heap%E3%80%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="【how2heap】学习笔记">【how2heap】学习笔记</a><time datetime="2021-05-10T03:08:56.640Z" title="发表于 2021-05-10 11:08:56">2021-05-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/08/%E3%80%90Kernel%20Pwn%E3%80%91StarCTF%20hackme/" title="【Kernel Pwn】StarCTF hackme"><img src="https://i.loli.net/2020/04/14/s8lQEMGd2KVD6Fx.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【Kernel Pwn】StarCTF hackme"/></a><div class="content"><a class="title" href="/2021/05/08/%E3%80%90Kernel%20Pwn%E3%80%91StarCTF%20hackme/" title="【Kernel Pwn】StarCTF hackme">【Kernel Pwn】StarCTF hackme</a><time datetime="2021-05-08T12:57:29.247Z" title="发表于 2021-05-08 20:57:29">2021-05-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By C7</div><div class="footer_custom_text"><p><a style="margin-inline:5px" target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a><a style="margin-inline:5px" target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a><a style="margin-inline:5px" target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a><a style="margin-inline:5px" target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a><a style="margin-inline:5px" target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a><a style="margin-inline:5px" target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a><a style="margin-inline:5px" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: '',
      appKey: '',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign(initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="/js/unbanner.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script src="/clock/js/clock.js"></script><script async src="//at.alicdn.com/t/font_2264842_3izu8i5eoc2.js"></script><script async src="/js/xktool.js"></script><script async src="/js/fish.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>