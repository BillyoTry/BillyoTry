<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>【MIT 6.828】JOS学习笔记 Lab5 | C7</title><meta name="keywords" content="OS"><meta name="author" content="C7"><meta name="copyright" content="C7"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="File system preliminaries我们要完成一个相对简单的文件系统，其可以实现创建、读、写以及删除在分层目录结构中组织的文件。目前，我们的OS只支持单用户，因此我们的文件系统也不支持UNIX文件拥有或权限的概念。同时不支持硬链接、符号链接、时间戳或者特别的设备文件。 On-Disk File System StructureJOS的文件系统不适用inodes，所有文件的元数据都被存">
<meta property="og:type" content="article">
<meta property="og:title" content="【MIT 6.828】JOS学习笔记 Lab5">
<meta property="og:url" content="https://billyotry.github.io/2021/08/24/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab5/index.html">
<meta property="og:site_name" content="C7">
<meta property="og:description" content="File system preliminaries我们要完成一个相对简单的文件系统，其可以实现创建、读、写以及删除在分层目录结构中组织的文件。目前，我们的OS只支持单用户，因此我们的文件系统也不支持UNIX文件拥有或权限的概念。同时不支持硬链接、符号链接、时间戳或者特别的设备文件。 On-Disk File System StructureJOS的文件系统不适用inodes，所有文件的元数据都被存">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg">
<meta property="article:published_time" content="2021-08-24T11:49:31.377Z">
<meta property="article:modified_time" content="2021-08-28T15:02:30.853Z">
<meta property="article:author" content="C7">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://billyotry.github.io/2021/08/24/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab5/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

const saveToLocal = {
  // ttl 單位是 天
  set: function setWithExpiry(key, value, ttl) {
    if (ttl === 0) return
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-08-28 23:02:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="/clock/css/clock.css"/><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/css/MonoFonts.addition.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/macWhite.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/font-awesome-animation.min.css"><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="C7" type="application/atom+xml">
<link rel="alternate" href="/rss2.xml" title="C7" type="application/rss+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/./"><i class="fa-fw fa fa-home faa-shake animated-hover"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive faa-shake animated-hover"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags faa-shake animated-hover"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open faa-shake animated-hover"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link faa-shake animated-hover"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart faa-shake animated-hover"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-gamepad faa-shake animated-hover"></i><span> 放松一下</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/games/2048/"><i class="fa-fw fa fa-gamepad faa-shake animated-hover"></i><span> 2048 经典2048</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="http://taqini.space/games/battle-city/#/"><i class="fa-fw fa fa-gamepad faa-shake animated-hover"></i><span> BattleCity 坦克大战</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">C7</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/./"><i class="fa-fw fa fa-home faa-shake animated-hover"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive faa-shake animated-hover"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags faa-shake animated-hover"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open faa-shake animated-hover"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link faa-shake animated-hover"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart faa-shake animated-hover"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-gamepad faa-shake animated-hover"></i><span> 放松一下</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/games/2048/"><i class="fa-fw fa fa-gamepad faa-shake animated-hover"></i><span> 2048 经典2048</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="http://taqini.space/games/battle-city/#/"><i class="fa-fw fa fa-gamepad faa-shake animated-hover"></i><span> BattleCity 坦克大战</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【MIT 6.828】JOS学习笔记 Lab5</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-24T11:49:31.377Z" title="发表于 2021-08-24 19:49:31">2021-08-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-08-28T15:02:30.853Z" title="更新于 2021-08-28 23:02:30">2021-08-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Learning/">Learning</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="File-system-preliminaries"><a href="#File-system-preliminaries" class="headerlink" title="File system preliminaries"></a>File system preliminaries</h1><p>我们要完成一个相对简单的文件系统，其可以实现创建、读、写以及删除在分层目录结构中组织的文件。目前，我们的OS只支持单用户，因此我们的文件系统也不支持UNIX文件拥有或权限的概念。同时不支持硬链接、符号链接、时间戳或者特别的设备文件。</p>
<h2 id="On-Disk-File-System-Structure"><a href="#On-Disk-File-System-Structure" class="headerlink" title="On-Disk File System Structure"></a>On-Disk File System Structure</h2><p>JOS的文件系统不适用inodes，所有文件的元数据都被存储在directory entry中。</p>
<p>文件和目录逻辑上都是由一系列数据block组成，这些blocks分散在磁盘中，文件系统屏蔽block分布的细节，提供一个可以顺序读写文件的接口。JOS文件系统允许用户读目录元数据，这就意味着用户可以扫描目录来像实现ls这种程序，UNIX没有采用这种方式的原因是，这种方式使得应用程序过度依赖目录元数据格式。</p>
<h3 id="Sectors-and-Blocks"><a href="#Sectors-and-Blocks" class="headerlink" title="Sectors and Blocks"></a>Sectors and Blocks</h3><p>大部分磁盘都是以为Sectors为粒度进行读写，JOS中Secotrs为512字节。文件系统以block为单位分配和使用磁盘。注意区别，secotr size是磁盘的属性，block size是操作系统使用磁盘的粒度。JOS文件系统的block size被定为4096字节。</p>
<h3 id="Superblocks"><a href="#Superblocks" class="headerlink" title="Superblocks"></a>Superblocks</h3><p>文件系统使用一些特殊的block保存文件系统属性元数据，比如block size，disk size，根目录位置等。这些特殊的block称为superblock。</p>
<p>我们的文件系统使用一个superblock，位于磁盘的block 1。block 0被用来保存boot loader和分区表。很多文件系统维护多个superblock，这样当一个损坏的时候，依然可以正常允许。</p>
<p>磁盘结构如下：</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13923446162/0" alt="image-20210826233321315"></p>
<p>Super的结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Super</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> s_magic;       <span class="comment">// Magic number: FS_MAGIC</span></span><br><span class="line">    <span class="keyword">uint32_t</span> s_nblocks;     <span class="comment">// Total number of blocks on disk</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> <span class="title">s_root</span>;</span>     <span class="comment">// Root directory node</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="File-Meta-data"><a href="#File-Meta-data" class="headerlink" title="File Meta-data"></a>File Meta-data</h3><p>我们的文件系统使用struct File结构描述文件，该结构包含文件名、大小、类型，保存文件内容的block号。struct File结构的f_direct数组保存前NDIRECT(10)个block号，这样对于10*4096 = 40KB的文件不需要额外的空间来记录内容block号。对于更大的文件我们需要分配一个额外的block来保存，可容纳多达4096/4 = 1024个额外的block。所以我们的文件系统允许文件拥有1034个block。</p>
<p>File结构如下：</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13923462031/0" alt="image-20210826234231996"></p>
<p>File结构定义在inc/fs.h中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">File</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> f_name[MAXNAMELEN];	<span class="comment">// filename</span></span><br><span class="line">	<span class="keyword">off_t</span> f_size;			<span class="comment">// file size in bytes</span></span><br><span class="line">	<span class="keyword">uint32_t</span> f_type;		<span class="comment">// file type</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Block pointers.</span></span><br><span class="line">	<span class="comment">// A block is allocated iff its value is != 0.</span></span><br><span class="line">	<span class="keyword">uint32_t</span> f_direct[NDIRECT];	<span class="comment">// direct blocks</span></span><br><span class="line">	<span class="keyword">uint32_t</span> f_indirect;		<span class="comment">// indirect block</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Pad out to 256 bytes; must do arithmetic in case we&#x27;re compiling</span></span><br><span class="line">	<span class="comment">// fsformat on a 64-bit machine.</span></span><br><span class="line">	<span class="keyword">uint8_t</span> f_pad[<span class="number">256</span> - MAXNAMELEN - <span class="number">8</span> - <span class="number">4</span>*NDIRECT - <span class="number">4</span>];</span><br><span class="line">&#125; __attribute__((packed));	<span class="comment">// required only on some 64-bit machines</span></span><br></pre></td></tr></table></figure>
<h3 id="Directories-versus-Regular-Files"><a href="#Directories-versus-Regular-Files" class="headerlink" title="Directories versus Regular Files"></a>Directories versus Regular Files</h3><p>File结构既能代表文件也能代表目录，由type字段取分，文件系统以相同的方式管理文件和目录，只是目录文件的内容是一系列File结构，这些File结构描述了在该目录下的文件或者子目录。</p>
<p>超级块包含一个File结构，代码文件系统的根目录。</p>
<h1 id="The-File-System"><a href="#The-File-System" class="headerlink" title="The File System"></a>The File System</h1><p>我们实现的文件系统的关键部分，读数据到缓存中并能写回磁盘；分配磁盘块；将文件偏移映射到磁盘块；并在IPC接口中实现读，写和打开。</p>
<h2 id="Disk-Access"><a href="#Disk-Access" class="headerlink" title="Disk Access"></a>Disk Access</h2><p>到目前为之内核还没有访问磁盘的能力。JOS不像其他操作系统一样在内核添加磁盘驱动，然后提供系统调用。我们实现一个文件系统进程来作为磁盘驱动。</p>
<p>x86处理器使用EFLAGS寄存器的IOPL位来控制保护模式下的代码能否执行设备IO指令，比如in和out。我们希望文件系统进程能访问IO空间，其他进程不能。</p>
<p><strong>exercise1</strong></p>
<p>创建一个文件系统进程，其实它和普通的进程差不多，就是能够读写IO设备。所以我们给它加上权限。</p>
<p>env_create修改为如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">env_create(<span class="keyword">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// If this is the file server (type == ENV_TYPE_FS) give it I/O privileges.</span></span><br><span class="line">	<span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="keyword">if</span>(env_alloc(&amp;e,<span class="number">0</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">		panic(<span class="string">&quot;env_alloc(): env_alloc failed!\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(type == ENV_TYPE_FS)&#123;</span><br><span class="line">		e-&gt;env_tf.tf_eflags |= FL_IOPL_MASK;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	load_icode(e,binary);</span><br><span class="line">	e-&gt;env_type = type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Question</p>
<ol>
<li><p>你是否不得不做一些其他事来确保当环境不断切换时，I/O特权设定依然能被保存和恢复？ 为什么？</p>
<p>不需要，因为我们切换环境的时候，会保存我们的EFLAGS寄存器，然后切换回来的时候，又会恢复。</p>
</li>
</ol>
</blockquote>
<h2 id="The-Block-Cache"><a href="#The-Block-Cache" class="headerlink" title="The Block Cache"></a>The Block Cache</h2><p>我们的文件系统最大支持3GB，文件系统进程保留0x10000000(DISKMAP)到0xD0000000(DISKMAP+DISKMAX)固定3GB的内存空间作为磁盘的缓存。比如block 0被映射到虚拟地址0x10000000，block 1被映射到虚拟地址0x10001000，以此类推。</p>
<p>刚开始还纳闷怎么给这么多的空间，后来想到我们的环境间虚拟空间都是独立的，并且我们的文件系统环境唯一需要做的事情就是实现文件是access，那么给这么大的空间也是合情合理。</p>
<p>如果将整个磁盘全部读到内存将非常耗时，所以我们将实现按需加载，只有当访问某个block对应的内存地址时出现页错误，才将block从磁盘加载到对应的内存区域，然后重新执行内存访问指令。</p>
<p><strong>exercise2</strong></p>
<p>bc_pgfault是FS进程缺页处理函数，负责将数据从磁盘读取到对应内存。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">bc_pgfault(struct UTrapframe *utf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> *addr = (<span class="keyword">void</span> *) utf-&gt;utf_fault_va;</span><br><span class="line">	<span class="keyword">uint32_t</span> blockno = ((<span class="keyword">uint32_t</span>)addr - DISKMAP) / BLKSIZE;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check that the fault was within the block cache region</span></span><br><span class="line">	<span class="keyword">if</span> (addr &lt; (<span class="keyword">void</span>*)DISKMAP || addr &gt;= (<span class="keyword">void</span>*)(DISKMAP + DISKSIZE))</span><br><span class="line">		panic(<span class="string">&quot;page fault in FS: eip %08x, va %08x, err %04x&quot;</span>,</span><br><span class="line">		      utf-&gt;utf_eip, addr, utf-&gt;utf_err);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Sanity check the block number.</span></span><br><span class="line">	<span class="keyword">if</span> (super &amp;&amp; blockno &gt;= super-&gt;s_nblocks)</span><br><span class="line">		panic(<span class="string">&quot;reading non-existent block %08x\n&quot;</span>, blockno);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allocate a page in the disk map region, read the contents</span></span><br><span class="line">	<span class="comment">// of the block from the disk into that page.</span></span><br><span class="line">	<span class="comment">// Hint: first round addr to page boundary. fs/ide.c has code to read</span></span><br><span class="line">	<span class="comment">// the disk.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// LAB 5: you code here:</span></span><br><span class="line">	addr = ROUNDDOWN(addr,PGSIZE);</span><br><span class="line">	sys_page_alloc(<span class="number">0</span>, addr, PTE_W|PTE_U|PTE_P);</span><br><span class="line">	<span class="keyword">uint32_t</span> secnum = blockno * BLKSECTS;</span><br><span class="line">	<span class="keyword">if</span>((r = ide_read(secnum,addr,BLKSECTS)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		panic(<span class="string">&quot;ide_read(): %e\n&quot;</span>,r);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Clear the dirty bit for the disk block page since we just read the</span></span><br><span class="line">	<span class="comment">// block from disk</span></span><br><span class="line">	<span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)) &lt; <span class="number">0</span>)</span><br><span class="line">		panic(<span class="string">&quot;in bc_pgfault, sys_page_map: %e&quot;</span>, r);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check that the block we read was allocated. (exercise for</span></span><br><span class="line">	<span class="comment">// the reader: why do we do this *after* reading the block</span></span><br><span class="line">	<span class="comment">// in?)</span></span><br><span class="line">	<span class="keyword">if</span> (bitmap &amp;&amp; block_is_free(blockno))</span><br><span class="line">		panic(<span class="string">&quot;reading free block %08x\n&quot;</span>, blockno);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flush_block()将一个block写入磁盘。flush_block()不需要做任何操作，如果block没有在内存或者block没有被写过。可以通过PTE的PTE_D位判断该block有没有被写过。注释基本写得很详细了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">flush_block(<span class="keyword">void</span> *addr)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> blockno = ((<span class="keyword">uint32_t</span>)addr - DISKMAP) / BLKSIZE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (addr &lt; (<span class="keyword">void</span>*)DISKMAP || addr &gt;= (<span class="keyword">void</span>*)(DISKMAP + DISKSIZE))</span><br><span class="line">		panic(<span class="string">&quot;flush_block of bad va %08x&quot;</span>, addr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">	<span class="comment">//panic(&quot;flush_block not implemented&quot;);</span></span><br><span class="line">	addr = ROUNDDOWN(addr,PGSIZE);</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="keyword">uint32_t</span> secnum = blockno * BLKSECTS;</span><br><span class="line">	<span class="keyword">if</span>(va_is_mapped(addr) &amp;&amp; va_is_dirty(addr))&#123;<span class="comment">//如果addr还没有映射过或者该页载入到内存后还没有被写过，does nothing</span></span><br><span class="line">		ide_write(secnum,addr,BLKSECTS);<span class="comment">//写回到磁盘</span></span><br><span class="line">		<span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, uvpt[PGNUM(addr)] &amp; PTE_SYSCALL)) &lt; <span class="number">0</span>)<span class="comment">//清空PTE_D位</span></span><br><span class="line">		panic(<span class="string">&quot;in bc_pgfault, sys_page_map: %e&quot;</span>, r);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>fs/fs.c中的fs_init()将会初始化super和bitmap全局指针变量。至此对于文件系统进程只要访问虚拟内存[DISKMAP, DISKMAP+DISKMAX]范围中的地址addr，就会访问到磁盘((uint32_t)addr - DISKMAP) / BLKSIZE block中的数据。如果block数据还没复制到内存物理页，bc_pgfault()缺页处理函数会将数据从磁盘拷贝到某个物理页，并且将addr映射到该物理页。这样FS进程只需要访问虚拟地址空间[DISKMAP, DISKMAP+DISKMAX]就能访问磁盘了。</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13927193876/0" alt="image-20210828013331417"></p>
<h2 id="The-Block-Bitmap"><a href="#The-Block-Bitmap" class="headerlink" title="The Block Bitmap"></a>The Block Bitmap</h2><p>fs_init已经初始化了bitmap，我们能通过bitmap访问磁盘的block 1，也就是位数组，每一位代表一个block，1表示该block未被使用，0表示已被使用。我们实现一系列管理函数来管理这个数组。</p>
<p><strong>exercise3</strong></p>
<p>实现fs/fs.c中的alloc_block()，该函数搜索bitmap位数组，返回一个未使用的block，并将其标记为已使用。这里可以参考上面的free_block，而且我们要注意1代表未使用，0代表已使用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">alloc_block(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// The bitmap consists of one or more blocks.  A single bitmap block</span></span><br><span class="line">	<span class="comment">// contains the in-use bits for BLKBITSIZE blocks.  There are</span></span><br><span class="line">	<span class="comment">// super-&gt;s_nblocks blocks in the disk altogether.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">	<span class="comment">//panic(&quot;alloc_block not implemented&quot;);</span></span><br><span class="line">	<span class="keyword">uint32_t</span> bmpblock_start = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">uint32_t</span> blockno = <span class="number">1</span>;blockno &lt; super-&gt;s_nblocks;blockno++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(block_is_free(blockno))&#123;</span><br><span class="line">			bitmap[blockno/<span class="number">32</span>] &amp;= ~(<span class="number">1</span>&lt;&lt;(blockno%<span class="number">32</span>));</span><br><span class="line">			flush_block(&amp;bitmap[blockno/<span class="number">32</span>]);</span><br><span class="line">			<span class="keyword">return</span> blockno;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -E_NO_DISK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="File-Operations"><a href="#File-Operations" class="headerlink" title="File Operations"></a>File Operations</h2><p>fs/fs.c文件提供了一系列函数用于管理File结构，扫描和管理目录文件，解析绝对路径。<br>基本的文件系统操作：</p>
<ol>
<li><code>file_block_walk(struct File *f, uint32_t filebno, uint32_t **ppdiskbno, bool alloc)</code>：查找f指向文件结构的第filebno个block的存储地址，保存到ppdiskbno中。如果f-&gt;f_indirect还没有分配，且alloc为真，那么将分配要给新的block作为该文件的f-&gt;f_indirect。类比页表管理pgdir_walk()。</li>
<li><code>file_get_block(struct File *f, uint32_t filebno, char **blk)</code>：该函数查找文件第filebno个block对应的虚拟地址addr，并将其保存到blk地址处。</li>
<li><code>walk_path(const char *path, struct File **pdir, struct File **pf, char *lastelem)</code>：解析路径path，填充pdir和pf地址处的File结构。比如/aa/bb/cc.c那么pdir代表指向bb目录的File结构，pf指向代表cc.c文件的File结构。又比如/aa/bb/cc.c，但是此时cc.c还不存在，那么pdir依旧指向代表bb目录的File结构，但是pf地址处应该为0，lastelem指向的字符串应该是cc.c。</li>
<li><code>dir_lookup(struct File *dir, const char *name, struct File **file)</code>：该函数查找dir指向的文件内容，寻找File.name为name的File结构，并保存到file地址处。</li>
<li><code>dir_alloc_file(struct File *dir, struct File **file)</code>：在dir目录文件的内容中寻找一个未被使用的File结构，将其地址保存到file的地址处。</li>
</ol>
<p>文件操作：</p>
<ol>
<li><code>file_create(const char *path, struct File **pf)</code>：创建path，如果创建成功pf指向新创建的File指针</li>
<li><code>file_open(const char *path, struct File **pf)</code>：寻找path对应的File结构地址，保存到pf地址处。</li>
<li><code>file_read(struct File *f, void *buf, size_t count, off_t offset)</code>：从文件f中的offset字节处读取count字节到buf处</li>
<li><code>file_write(struct File *f, const void *buf, size_t count, off_t offset)</code>：将buf处的count字节写到文件f的offset开始的位置。</li>
</ol>
<p><strong>exercise4</strong></p>
<p>file_block_walk():</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">file_block_walk(struct File *f, <span class="keyword">uint32_t</span> filebno, <span class="keyword">uint32_t</span> **ppdiskbno, <span class="keyword">bool</span> alloc)</span><br><span class="line">&#123;</span><br><span class="line">       <span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">       <span class="comment">//panic(&quot;file_block_walk not implemented&quot;);</span></span><br><span class="line">	   <span class="keyword">int</span> bn;</span><br><span class="line">	   <span class="keyword">uint32_t</span> *indirects;</span><br><span class="line">	   <span class="comment">//out of range</span></span><br><span class="line">	   <span class="keyword">if</span>(filebno &gt;= NDIRECT + NINDIRECT)&#123;</span><br><span class="line">		   <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	   &#125;</span><br><span class="line">	   <span class="comment">//filebno在前10个block中</span></span><br><span class="line">	   <span class="keyword">if</span>(filebno &lt; NDIRECT)&#123;</span><br><span class="line">		   *ppdiskbno = &amp;(f-&gt;f_direct[filebno]);</span><br><span class="line">	   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		   <span class="keyword">if</span>(f-&gt;f_indirect)&#123;</span><br><span class="line">			   indirects = diskaddr(f-&gt;f_indirect);</span><br><span class="line">			   *ppdiskbno = &amp;(indirects[filebno - NDIRECT]);</span><br><span class="line">		   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			   <span class="keyword">if</span>(!alloc) <span class="keyword">return</span> -E_NOT_FOUND;</span><br><span class="line">			   <span class="keyword">if</span>((bn = alloc_block()) &lt; <span class="number">0</span>) <span class="keyword">return</span> bn;</span><br><span class="line">			   f-&gt;f_indirect = bn;</span><br><span class="line">			   flush_block(diskaddr(bn));</span><br><span class="line">			   indirects = diskaddr(bn);</span><br><span class="line">			   *ppdiskbno = &amp;(indirects[filebno - NDIRECT]);</span><br><span class="line">		   &#125;</span><br><span class="line">	   &#125;</span><br><span class="line">	   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="The-file-system-interface"><a href="#The-file-system-interface" class="headerlink" title="The file system interface"></a>The file system interface</h2><p>到目前为止，文件系统进程已经能提供各种操作文件的功能了，但是其他用户进程不能直接调用这些函数。我们通过进程间函数调用(RPC)对其它进程提供文件系统服务。RPC机制原理如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      Regular env           FS env</span><br><span class="line">   +---------------+   +---------------+</span><br><span class="line">   |      read     |   |   file_read   |</span><br><span class="line">   |   (lib&#x2F;fd.c)  |   |   (fs&#x2F;fs.c)   |</span><br><span class="line">...|.......|.......|...|.......^.......|...............</span><br><span class="line">   |       v       |   |       |       | RPC mechanism</span><br><span class="line">   |  devfile_read |   |  serve_read   |</span><br><span class="line">   |  (lib&#x2F;file.c) |   |  (fs&#x2F;serv.c)  |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   |       v       |   |       |       |</span><br><span class="line">   |     fsipc     |   |     serve     |</span><br><span class="line">   |  (lib&#x2F;file.c) |   |  (fs&#x2F;serv.c)  |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   |       v       |   |       |       |</span><br><span class="line">   |   ipc_send    |   |   ipc_recv    |</span><br><span class="line">   |       |       |   |       ^       |</span><br><span class="line">   +-------|-------+   +-------|-------+</span><br><span class="line">           |                   |</span><br><span class="line">           +-------------------+</span><br></pre></td></tr></table></figure>
<p>本质上RPC还是借助IPC机制实现的，普通进程通过IPC向FS进程间发送具体操作和操作数据，然后FS进程执行文件操作，最后又将结果通过IPC返回给普通进程。从上图中可以看到客户端的代码在lib/fd.c和lib/file.c两个文件中。服务端的代码在fs/fs.c和fs/serv.c两个文件中。</p>
<p>相关数据结构关系：</p>
<p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab5/lab5_4_%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="文件系统相关数据结构关系"></p>
<p>文件系统服务端代码在fs/serv.c中，serve()中有一个无限循环，接收IPC请求，将对应的请求分配到对应的处理函数，然后将结果通过IPC发送回去。<br>对于客户端来说：发送一个32位的值作为请求类型，发送一个Fsipc结构作为请求参数，该数据结构通过IPC的页共享发给FS进程，在FS进程可以通过访问fsreq(0x0ffff000)来访问客户进程发来的Fsipc结构。<br>对于服务端来说：FS进程返回一个32位的值作为返回码，对于FSREQ_READ和FSREQ_STAT这两种请求类型，还额外通过IPC返回一些数据。</p>
<p><strong>exercise5</strong></p>
<p>实现fs/serv.c中的serve_read()。这是服务端也就是FS进程中的函数。直接调用更底层的fs/fs.c中的函数来实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">serve_read(<span class="keyword">envid_t</span> envid, <span class="keyword">union</span> Fsipc *ipc)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsreq_read</span> *<span class="title">req</span> =</span> &amp;ipc-&gt;read;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Fsret_read</span> *<span class="title">ret</span> =</span> &amp;ipc-&gt;readRet;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (debug)</span><br><span class="line">		cprintf(<span class="string">&quot;serve_read %08x %08x %08x\n&quot;</span>, envid, req-&gt;req_fileid, req-&gt;req_n);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Lab 5: Your code here:</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> *<span class="title">o</span>;</span></span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	r = openfile_lookup(envid,req-&gt;req_fileid,&amp;o); <span class="comment">//通过fileid找到Openfile结构</span></span><br><span class="line">	<span class="keyword">if</span>(r &lt; <span class="number">0</span>) <span class="keyword">return</span> r;</span><br><span class="line">	<span class="keyword">if</span>((r = file_read(o-&gt;o_file,ret-&gt;ret_buf,req-&gt;req_n,o-&gt;o_fd-&gt;fd_offset)) &lt; <span class="number">0</span>) <span class="keyword">return</span> r; <span class="comment">//调用fs.c中函数进行真正的读操作</span></span><br><span class="line">	o-&gt;o_fd-&gt;fd_offset += r;</span><br><span class="line">	<span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>exercise6</strong></p>
<p>实现fs/serv.c中的serve_write()和lib/file.c中的devfile_write()。<br>serve_write():</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">serve_write(<span class="keyword">envid_t</span> envid, struct Fsreq_write *req)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (debug)</span><br><span class="line">		cprintf(<span class="string">&quot;serve_write %08x %08x %08x\n&quot;</span>, envid, req-&gt;req_fileid, req-&gt;req_n);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">	<span class="comment">//panic(&quot;serve_write not implemented&quot;);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> *<span class="title">o</span>;</span></span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="keyword">if</span>((r = openfile_lookup(envid,req-&gt;req_fileid,&amp;o)) &lt; <span class="number">0</span>) <span class="keyword">return</span> r;</span><br><span class="line">	<span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		r = file_write(o-&gt;o_file,req-&gt;req_buf,req-&gt;req_n,o-&gt;o_fd-&gt;fd_offset);</span><br><span class="line">		<span class="keyword">if</span>(r &lt; <span class="number">0</span>) <span class="keyword">return</span> r;</span><br><span class="line">		total += r;</span><br><span class="line">		o-&gt;o_fd-&gt;fd_offset += r;</span><br><span class="line">		<span class="keyword">if</span>(req-&gt;req_n &lt;= total) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>devfile_write():客户端进程函数，包装一下参数，直接调用fsipc()将参数发送给FS进程处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span><br><span class="line">devfile_write(struct Fd *fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Make an FSREQ_WRITE request to the file system server.  Be</span></span><br><span class="line">	<span class="comment">// careful: fsipcbuf.write.req_buf is only so large, but</span></span><br><span class="line">	<span class="comment">// remember that write is always allowed to write *fewer*</span></span><br><span class="line">	<span class="comment">// bytes than requested.</span></span><br><span class="line">	<span class="comment">// LAB 5: Your code here</span></span><br><span class="line">	<span class="comment">//panic(&quot;devfile_write not implemented&quot;);</span></span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	fsipcbuf.write.req_fileid = fd-&gt;fd_file.id;</span><br><span class="line">	fsipcbuf.write.req_n = n;</span><br><span class="line">	memmove(fsipcbuf.write.req_buf,buf,n);</span><br><span class="line">	<span class="keyword">return</span> fsipc(FSREQ_WRITE,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="库函数open-实现"><a href="#库函数open-实现" class="headerlink" title="库函数open()实现"></a>库函数open()实现</h2><p>以打开一个文件为例，看下整体过程，read(), write()类似。open()在linux中也要实现定义在头文件&lt;fcntl.h&gt;中，原型如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在JOS中open()实现在lib/file.c中，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">open(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Find an unused file descriptor page using fd_alloc.</span></span><br><span class="line">    <span class="comment">// Then send a file-open request to the file server.</span></span><br><span class="line">    <span class="comment">// Include &#x27;path&#x27; and &#x27;omode&#x27; in request,</span></span><br><span class="line">    <span class="comment">// and map the returned file descriptor page</span></span><br><span class="line">    <span class="comment">// at the appropriate fd address.</span></span><br><span class="line">    <span class="comment">// FSREQ_OPEN returns 0 on success, &lt; 0 on failure.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// (fd_alloc does not allocate a page, it just returns an</span></span><br><span class="line">    <span class="comment">// unused fd address. Do you need to allocate a page?)</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Return the file descriptor index.</span></span><br><span class="line">    <span class="comment">// If any step after fd_alloc fails, use fd_close to free the</span></span><br><span class="line">    <span class="comment">// file descriptor.</span></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strlen</span>(path) &gt;= MAXPATHLEN)         <span class="comment">//文件名不能超过指定长度</span></span><br><span class="line">        <span class="keyword">return</span> -E_BAD_PATH;</span><br><span class="line">    <span class="keyword">if</span> ((r = fd_alloc(&amp;fd)) &lt; <span class="number">0</span>)            <span class="comment">//搜索当前进程未被分配的文件描述符</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    <span class="built_in">strcpy</span>(fsipcbuf.open.req_path, path);</span><br><span class="line">    fsipcbuf.open.req_omode = mode;</span><br><span class="line">    <span class="keyword">if</span> ((r = fsipc(FSREQ_OPEN, fd)) &lt; <span class="number">0</span>) &#123;  <span class="comment">//通过fsipc()向FS进程发起RPC调用</span></span><br><span class="line">        fd_close(fd, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fd2num(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">fsipc(<span class="keyword">unsigned</span> type, <span class="keyword">void</span> *dstva)       <span class="comment">//type, fsipcbuf是发送给fs进程的数据。dstava和fsipc()的返回值是从fs进程接收的值</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">envid_t</span> fsenv;</span><br><span class="line">    <span class="keyword">if</span> (fsenv == <span class="number">0</span>)</span><br><span class="line">        fsenv = ipc_find_env(ENV_TYPE_FS);</span><br><span class="line">    <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(fsipcbuf) == PGSIZE);</span><br><span class="line"></span><br><span class="line">    ipc_send(fsenv, type, &amp;fsipcbuf, PTE_P | PTE_W | PTE_U);  <span class="comment">//向FS进程发送数据</span></span><br><span class="line">    <span class="keyword">return</span> ipc_recv(<span class="literal">NULL</span>, dstva, <span class="literal">NULL</span>);         <span class="comment">//接收FS进程发送回来的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中fd_alloc()定义在lib/fd.c中，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">fd_alloc(struct Fd **fd_store)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Fd</span> *<span class="title">fd</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAXFD; i++) &#123;   <span class="comment">//从当前最小的未分配描述符开始</span></span><br><span class="line">        fd = INDEX2FD(i);</span><br><span class="line">        <span class="keyword">if</span> ((uvpd[PDX(fd)] &amp; PTE_P) == <span class="number">0</span> || (uvpt[PGNUM(fd)] &amp; PTE_P) == <span class="number">0</span>) &#123;</span><br><span class="line">            *fd_store = fd;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *fd_store = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> -E_MAX_OPEN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab5/lab5_7_open()%E5%8E%9F%E7%90%86.png" alt="lab5_7_open原理.png"></p>
<p>每个进程从虚拟地址0xD0000000开始，每一页对应一个FD结构，也就是说文件描述符0对应的FD结构地址为0xD0000000，文件描述符1对应的FD结构地址为0xD0000000+PGSIZE，以此类推。可以通过检查某个FD结构的虚拟地址是否分配，来判断文件描述符是否被分配。如果一个文件描述符被分配了，那么该文件描述符对应的FD结构开始的一页将被映射到和FS进程相同的物理地址处。</p>
<p>FS进程收到FSREQ_OPEN请求后，将调用serve_open()，该函数定义在fs/serv.c中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">serve_open(<span class="keyword">envid_t</span> envid, struct Fsreq_open *req,</span><br><span class="line">     <span class="keyword">void</span> **pg_store, <span class="keyword">int</span> *perm_store)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> path[MAXPATHLEN];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">File</span> *<span class="title">f</span>;</span></span><br><span class="line">    <span class="keyword">int</span> fileid;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">OpenFile</span> *<span class="title">o</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">        cprintf(<span class="string">&quot;serve_open %08x %s 0x%x\n&quot;</span>, envid, req-&gt;req_path, req-&gt;req_omode);</span><br><span class="line">    <span class="comment">// Copy in the path, making sure it&#x27;s null-terminated</span></span><br><span class="line">    memmove(path, req-&gt;req_path, MAXPATHLEN);</span><br><span class="line">    path[MAXPATHLEN<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Find an open file ID</span></span><br><span class="line">    <span class="keyword">if</span> ((r = openfile_alloc(&amp;o)) &lt; <span class="number">0</span>) &#123;                 <span class="comment">//从opentab数组中分配一个OpenFile结构</span></span><br><span class="line">        <span class="keyword">if</span> (debug)</span><br><span class="line">            cprintf(<span class="string">&quot;openfile_alloc failed: %e&quot;</span>, r);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    fileid = r;</span><br><span class="line">    <span class="comment">// Open the file</span></span><br><span class="line">    <span class="keyword">if</span> (req-&gt;req_omode &amp; O_CREAT) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = file_create(path, &amp;f)) &lt; <span class="number">0</span>) &#123;          <span class="comment">//根据path分配一个File结构</span></span><br><span class="line">            <span class="keyword">if</span> (!(req-&gt;req_omode &amp; O_EXCL) &amp;&amp; r == -E_FILE_EXISTS)</span><br><span class="line">                <span class="keyword">goto</span> try_open;</span><br><span class="line">            <span class="keyword">if</span> (debug)</span><br><span class="line">                cprintf(<span class="string">&quot;file_create failed: %e&quot;</span>, r);</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">try_open:</span><br><span class="line">        <span class="keyword">if</span> ((r = file_open(path, &amp;f)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (debug)</span><br><span class="line">                cprintf(<span class="string">&quot;file_open failed: %e&quot;</span>, r);</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Truncate</span></span><br><span class="line">    <span class="keyword">if</span> (req-&gt;req_omode &amp; O_TRUNC) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((r = file_set_size(f, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (debug)</span><br><span class="line">                cprintf(<span class="string">&quot;file_set_size failed: %e&quot;</span>, r);</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((r = file_open(path, &amp;f)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (debug)</span><br><span class="line">            cprintf(<span class="string">&quot;file_open failed: %e&quot;</span>, r);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Save the file pointer</span></span><br><span class="line">    o-&gt;o_file = f;                                      <span class="comment">//保存File结构到OpenFile结构</span></span><br><span class="line">    <span class="comment">// Fill out the Fd structure</span></span><br><span class="line">    o-&gt;o_fd-&gt;fd_file.id = o-&gt;o_fileid;</span><br><span class="line">    o-&gt;o_fd-&gt;fd_omode = req-&gt;req_omode &amp; O_ACCMODE;</span><br><span class="line">    o-&gt;o_fd-&gt;fd_dev_id = devfile.dev_id;</span><br><span class="line">    o-&gt;o_mode = req-&gt;req_omode;</span><br><span class="line">    <span class="keyword">if</span> (debug)</span><br><span class="line">        cprintf(<span class="string">&quot;sending success, page %08x\n&quot;</span>, (<span class="keyword">uintptr_t</span>) o-&gt;o_fd);</span><br><span class="line">    <span class="comment">// Share the FD page with the caller by setting *pg_store,</span></span><br><span class="line">    <span class="comment">// store its permission in *perm_store</span></span><br><span class="line">    *pg_store = o-&gt;o_fd;</span><br><span class="line">    *perm_store = PTE_P|PTE_U|PTE_W|PTE_SHARE;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数首先从opentab这个OpenFile数组中寻找一个未被使用的OpenFile结构，上图中假设找到数据第一个OpenFile结构就是未使用的。如果open()中参数mode设置了O_CREAT选项，那么就会调用fs/fs.c中的file_create函数来根据路径创建一个新的File结构，并保存到OpenFile结构的o_file字段中。结束后，serve()会将OpenFile结构对应的Fd起始地址发送给客户端进程，所以客户进程从open()返回后，新分配的fd和fs进程fd共享相同的物理页。</p>
<h1 id="Spawning-Processes"><a href="#Spawning-Processes" class="headerlink" title="Spawning Processes"></a>Spawning Processes</h1><p>lib/spawn.c中的spawn()创建一个新的进程，从文件系统加载用户程序，然后启动该进程来允许这个程序。spawn()就像UNIX中的fork()后面马上跟着exec()。</p>
<p><code>spawn(const char *prog, const char **argv)</code>做如下一系列动作：</p>
<ol>
<li>从文件系统打开prog程序文件</li>
<li>调用系统调用sys_exofork()创建一个新的Env结构</li>
<li>调用系统调用sys_env_set_trapframe()，设置新的Env结构的Trapframe字段(该字段包含寄存器信息)</li>
<li>根据ELF文件中program header，将用户程序以Segment读入内存，并映射到指定的线性地址处</li>
<li>调用系统调用sys_env_set_status()设置新的Env结构状态为ENV_RUNABLE。</li>
</ol>
<p><strong>exercise7</strong></p>
<p>实现sys_env_set_trapframe()系统调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_env_set_trapframe(<span class="keyword">envid_t</span> envid, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">	<span class="comment">// Remember to check whether the user has supplied us with a good</span></span><br><span class="line">	<span class="comment">// address!</span></span><br><span class="line">	<span class="comment">//panic(&quot;sys_env_set_trapframe not implemented&quot;);</span></span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	<span class="keyword">if</span>((r = envid2env(envid,&amp;e,<span class="number">1</span>)) &lt; <span class="number">0</span>) <span class="keyword">return</span> r;</span><br><span class="line">	tf-&gt;tf_eflags = FL_IF;</span><br><span class="line">	tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK;			<span class="comment">//普通进程不能有IO权限</span></span><br><span class="line">	tf-&gt;tf_cs = GD_UT | <span class="number">3</span>;</span><br><span class="line">	e-&gt;env_tf = *tf;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Sharing-library-state-across-fork-and-spawn"><a href="#Sharing-library-state-across-fork-and-spawn" class="headerlink" title="Sharing library state across fork and spawn"></a>Sharing library state across fork and spawn</h2><p>UNIX文件描述符是一个大的概念，包含pipe，控制台I/O。在JOS中每种设备对应一个struct Dev结构，该结构函数函数指针，指向真正实现读写操作的函数。</p>
<p>lib/fd.c文件实现了UNIX文件描述符接口，但大部分函数都是简单对struct Dev结构指向的函数的包装。</p>
<p>我们希望共享文件描述符，JOS中定义PTE新的标志位PTE_SHARE，如果有个页表条目的PTE_SHAER标志位为1，那么这个PTE在fork()和spawn()中将直接拷贝到子进程页表，从而让父进程和子进程共享相同的页映射关系，从而达到父子进程共享文件描述符的目的。</p>
<p><strong>exercise8</strong></p>
<p>修改lib/fork.c中的duppage()，使之正确处理有PTE_SHARE标志的页表条目。同时实现lib/spawn.c中的copy_shared_pages()。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">duppage(<span class="keyword">envid_t</span> envid, <span class="keyword">unsigned</span> pn)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="keyword">void</span> *addr = (<span class="keyword">void</span>*) (pn * PGSIZE);</span><br><span class="line">	<span class="keyword">if</span>(uvpt[pn] &amp; PTE_SHARE)&#123;</span><br><span class="line">		sys_page_map(<span class="number">0</span>, addr, envid, addr, PTE_SYSCALL);</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span> ((uvpt[pn] &amp; PTE_W) || (uvpt[pn] &amp; PTE_COW)) &#123; <span class="comment">//对于UTOP以下的可写的或者写时拷贝的页，拷贝映射关系的同时，需要同时标记当前进程和子进程的页表项为PTE_COW</span></span><br><span class="line">		<span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, envid, addr, PTE_COW|PTE_U|PTE_P)) &lt; <span class="number">0</span>)</span><br><span class="line">			panic(<span class="string">&quot;sys_page_map：%e&quot;</span>, r);</span><br><span class="line">		<span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, PTE_COW|PTE_U|PTE_P)) &lt; <span class="number">0</span>)</span><br><span class="line">			panic(<span class="string">&quot;sys_page_map：%e&quot;</span>, r);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		sys_page_map(<span class="number">0</span>, addr, envid, addr, PTE_U|PTE_P);	<span class="comment">//对于只读的页，只需要拷贝映射关系即可</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>copy_shared_pages()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">copy_shared_pages(<span class="keyword">envid_t</span> child)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 5: Your code here.</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> addr;</span><br><span class="line">	<span class="keyword">for</span> (addr = <span class="number">0</span>; addr &lt; UTOP; addr += PGSIZE) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((uvpd[PDX(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_P) &amp;&amp;</span><br><span class="line">				(uvpt[PGNUM(addr)] &amp; PTE_U) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_SHARE)) &#123;</span><br><span class="line">            sys_page_map(<span class="number">0</span>, (<span class="keyword">void</span>*)addr, child, (<span class="keyword">void</span>*)addr, (uvpt[PGNUM(addr)] &amp; PTE_SYSCALL));</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="The-keyboard-interface"><a href="#The-keyboard-interface" class="headerlink" title="The keyboard interface"></a>The keyboard interface</h1><p><strong>exercise9</strong></p>
<p>在trap.c的trap_dispatch中加入下面的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_KBD)&#123;</span><br><span class="line">		kbd_intr();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_SERIAL)&#123;</span><br><span class="line">		serial_intr();</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="The-Shell"><a href="#The-Shell" class="headerlink" title="The Shell"></a>The Shell</h1><p>运行make run-icode，将会执行user/icode，user/icode又会执行inti，然后会spawn sh。然后就能运行如下指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo hello world | cat</span><br><span class="line">cat lorem |cat</span><br><span class="line">cat lorem |num</span><br><span class="line">cat lorem |num |num |num |num |num</span><br><span class="line">lsfd</span><br></pre></td></tr></table></figure>
<p><strong>Exercise 10</strong></p>
<p>目前shell还不支持IO重定向，修改user/sh.c，增加IO该功能。</p>
<p>在runcmd函数中添加如下片段：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((fd = open(t,O_RDONLY)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">				cprintf(<span class="string">&quot;file %s is no exist\n&quot;</span>, t);</span><br><span class="line">				<span class="built_in">exit</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(fd != <span class="number">0</span>)&#123;</span><br><span class="line">				dup(fd,<span class="number">0</span>);</span><br><span class="line">				close(fd);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><p>构建文件系统：</p>
<ol>
<li><p>引入一个文件系统进程的特殊进程，该进程提供文件操作的接口。具体实现在fs/bc.c、fs/fs.c、fs/serv.c中</p>
</li>
<li><p>建立RPC机制，客户端进程向FS进程发送请求，FS进程真正执行文件操作。客户端进程的实现在lib/file.c，lib/fd.c中。客户端进程和FS进程交互可总结为下图</p>
<p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab5/lab5_6_fs%E8%BF%9B%E7%A8%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt="客户端进程和FS进程交互"></p>
</li>
<li><p>更高级的抽象，引入文件描述符。通过文件描述符这一层抽象可以将控制台，pipe，普通文件统统按照文件来对待。文件描述符和pipe的原理总结如下：</p>
<p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab5/lab5_5_%E6%96%87%E4%BB%B6_fd%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86_pipe%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt="文件描述符和pipe原理"></p>
</li>
</ol>
</li>
<li><p>支持从磁盘加载程序并运行。实现spawn()，该函数创建一个新的进程，并从磁盘加载程序运行，类似UNIX中的fork()后执行exec()。</p>
</li>
</ol>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13929718502/0" alt="image-20210828225527202"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">C7</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://billyotry.github.io/2021/08/24/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab5/">https://billyotry.github.io/2021/08/24/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://billyotry.github.io" target="_blank">C7</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OS/">OS</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2099/01/01/test/"><img class="prev-cover" src="https://i.loli.net/2021/01/22/QJ1bzWyEp9IKx7R.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">这是标题</div></div></a></div><div class="next-post pull-right"><a href="/2021/08/08/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab4/"><img class="next-cover" src="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【MIT 6.828】JOS学习笔记 Lab4</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/02/28/【MIT6.828】Lab1-Exercise11/" title="【MIT6.828】Lab1-Exercise11"><img class="cover" src="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-28</div><div class="title">【MIT6.828】Lab1-Exercise11</div></div></a></div><div><a href="/2021/03/05/【MIT6.828】Lab1-Exercise12/" title="【MIT6.828】Lab1-Exercise12"><img class="cover" src="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-05</div><div class="title">【MIT6.828】Lab1-Exercise12</div></div></a></div><div><a href="/2021/01/22/【MIT6.828】Lab1-Exercise2/" title="【MIT 6.828】Lab1-Exercise2"><img class="cover" src="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-22</div><div class="title">【MIT 6.828】Lab1-Exercise2</div></div></a></div><div><a href="/2021/01/31/【MIT6.828】Lab1-Exercise6/" title="【MIT6.828】Lab1-Exercise6"><img class="cover" src="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-31</div><div class="title">【MIT6.828】Lab1-Exercise6</div></div></a></div><div><a href="/2021/01/30/【MIT6.828】Lab1-Exercise5/" title="【MIT6.828】Lab1-Exercise5"><img class="cover" src="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-30</div><div class="title">【MIT6.828】Lab1-Exercise5</div></div></a></div><div><a href="/2021/02/03/【MIT6.828】Lab1-Exercise9/" title="【MIT6.828】Lab1-Exercise9"><img class="cover" src="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-03</div><div class="title">【MIT6.828】Lab1-Exercise9</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">C7</div><div class="author-info__description">雖不能至 心嚮往之</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><a class="button--animated" id="card-info-btn"><i class="fa fa-paper-plane-o"></i><span>加入书签</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/BillyoTry" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1347405944@qq.com" target="_blank" title="Email"><i class="fa fa-envelope"></i></a><a class="social-icon" href="tencent://message/?uin=1347405944&amp;Site=&amp;Menu=yes" target="_blank" title=""><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">大家疫情期间注意保护自己噢~~~~</div></div><div class="sticky_layout"><div class="card-widget card-clock" style="padding:0"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="clock" style="padding:20px"><img v-if="clockshow == &quot;false&quot;" src="/clock/images/weather/loading.gif" style="height:120px;width:100%"/><table class="clock" v-if="clockshow"><tbody><tr><td class="clockdate">{{date}}</td><td class="weatherimg" align="center" valign="middle"><img id="weatherimg" :src="weatherimg"/></td><td class="temperature" align="center" valign="middle">{{temperature}}</td><td class="humidityimg"><img id="humidityimg" :src="humidityimg"/></td><td class="humidity">{{humidity}}</td></tr><tr class="time"><td colspan="5">{{time}}</td></tr><tr><td class="usaqi" colspan="1"> <span>{{ip}}</span></td><td class="city" colspan="2">{{city}}</td><td class="daylight" colspan="2">{{daylight}}</td></tr></tbody></table></div></div></div></div></div><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#File-system-preliminaries"><span class="toc-number">1.</span> <span class="toc-text">File system preliminaries</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#On-Disk-File-System-Structure"><span class="toc-number">1.1.</span> <span class="toc-text">On-Disk File System Structure</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Sectors-and-Blocks"><span class="toc-number">1.1.1.</span> <span class="toc-text">Sectors and Blocks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Superblocks"><span class="toc-number">1.1.2.</span> <span class="toc-text">Superblocks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#File-Meta-data"><span class="toc-number">1.1.3.</span> <span class="toc-text">File Meta-data</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Directories-versus-Regular-Files"><span class="toc-number">1.1.4.</span> <span class="toc-text">Directories versus Regular Files</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#The-File-System"><span class="toc-number">2.</span> <span class="toc-text">The File System</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Disk-Access"><span class="toc-number">2.1.</span> <span class="toc-text">Disk Access</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-Block-Cache"><span class="toc-number">2.2.</span> <span class="toc-text">The Block Cache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-Block-Bitmap"><span class="toc-number">2.3.</span> <span class="toc-text">The Block Bitmap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#File-Operations"><span class="toc-number">2.4.</span> <span class="toc-text">File Operations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#The-file-system-interface"><span class="toc-number">2.5.</span> <span class="toc-text">The file system interface</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0open-%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.6.</span> <span class="toc-text">库函数open()实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spawning-Processes"><span class="toc-number">3.</span> <span class="toc-text">Spawning Processes</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Sharing-library-state-across-fork-and-spawn"><span class="toc-number">3.1.</span> <span class="toc-text">Sharing library state across fork and spawn</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#The-keyboard-interface"><span class="toc-number">4.</span> <span class="toc-text">The keyboard interface</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#The-Shell"><span class="toc-number">5.</span> <span class="toc-text">The Shell</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2099/01/01/test/" title="这是标题"><img src="https://i.loli.net/2021/01/22/QJ1bzWyEp9IKx7R.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="这是标题"/></a><div class="content"><a class="title" href="/2099/01/01/test/" title="这是标题">这是标题</a><time datetime="2098-12-31T16:00:00.000Z" title="发表于 2099-01-01 00:00:00">2099-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/24/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab5/" title="【MIT 6.828】JOS学习笔记 Lab5"><img src="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【MIT 6.828】JOS学习笔记 Lab5"/></a><div class="content"><a class="title" href="/2021/08/24/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab5/" title="【MIT 6.828】JOS学习笔记 Lab5">【MIT 6.828】JOS学习笔记 Lab5</a><time datetime="2021-08-24T11:49:31.377Z" title="发表于 2021-08-24 19:49:31">2021-08-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/08/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab4/" title="【MIT 6.828】JOS学习笔记 Lab4"><img src="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【MIT 6.828】JOS学习笔记 Lab4"/></a><div class="content"><a class="title" href="/2021/08/08/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab4/" title="【MIT 6.828】JOS学习笔记 Lab4">【MIT 6.828】JOS学习笔记 Lab4</a><time datetime="2021-08-08T14:12:16.641Z" title="发表于 2021-08-08 22:12:16">2021-08-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise9/" title="【MIT 6.828】Lab3-Exercise9"><img src="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【MIT 6.828】Lab3-Exercise9"/></a><div class="content"><a class="title" href="/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise9/" title="【MIT 6.828】Lab3-Exercise9">【MIT 6.828】Lab3-Exercise9</a><time datetime="2021-08-06T15:31:41.615Z" title="发表于 2021-08-06 23:31:41">2021-08-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise7/" title="【MIT 6.828】Lab3-Exercise7"><img src="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【MIT 6.828】Lab3-Exercise7"/></a><div class="content"><a class="title" href="/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise7/" title="【MIT 6.828】Lab3-Exercise7">【MIT 6.828】Lab3-Exercise7</a><time datetime="2021-08-06T08:07:46.281Z" title="发表于 2021-08-06 16:07:46">2021-08-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By C7</div><div class="footer_custom_text"><p><a style="margin-inline:5px" target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a><a style="margin-inline:5px" target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a><a style="margin-inline:5px" target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a><a style="margin-inline:5px" target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a><a style="margin-inline:5px" target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a><a style="margin-inline:5px" target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a><a style="margin-inline:5px" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: '',
      appKey: '',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign(initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="/js/unbanner.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script src="/clock/js/clock.js"></script><script async src="//at.alicdn.com/t/font_2264842_3izu8i5eoc2.js"></script><script async src="/js/xktool.js"></script><script async src="/js/fish.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>