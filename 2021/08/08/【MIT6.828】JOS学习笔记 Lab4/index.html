<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>【MIT 6.828】JOS学习笔记 Lab4 | C7</title><meta name="keywords" content="OS"><meta name="author" content="C7"><meta name="copyright" content="C7"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在lab4中多了如下文件：kern&#x2F;cpu.h、kern&#x2F;mpconfig.c、kern&#x2F;lapic.c、kern&#x2F;mpentry.S、kern&#x2F;spinlock.h、kern&#x2F;spinlock.c、kern&#x2F;sched.c Part A: Multiprocessor Support and Cooperative Multitasking在这个lab的第一部分，我们首先拓展JOS让其能在多处理">
<meta property="og:type" content="article">
<meta property="og:title" content="【MIT 6.828】JOS学习笔记 Lab4">
<meta property="og:url" content="https://billyotry.github.io/2021/08/08/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab4/index.html">
<meta property="og:site_name" content="C7">
<meta property="og:description" content="在lab4中多了如下文件：kern&#x2F;cpu.h、kern&#x2F;mpconfig.c、kern&#x2F;lapic.c、kern&#x2F;mpentry.S、kern&#x2F;spinlock.h、kern&#x2F;spinlock.c、kern&#x2F;sched.c Part A: Multiprocessor Support and Cooperative Multitasking在这个lab的第一部分，我们首先拓展JOS让其能在多处理">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg">
<meta property="article:published_time" content="2021-08-08T14:12:16.641Z">
<meta property="article:modified_time" content="2021-08-15T09:05:35.009Z">
<meta property="article:author" content="C7">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://billyotry.github.io/2021/08/08/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab4/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

const saveToLocal = {
  // ttl 單位是 天
  set: function setWithExpiry(key, value, ttl) {
    if (ttl === 0) return
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-08-15 17:05:35'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="/clock/css/clock.css"/><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/css/MonoFonts.addition.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/macWhite.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/font-awesome-animation.min.css"><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="C7" type="application/atom+xml">
<link rel="alternate" href="/rss2.xml" title="C7" type="application/rss+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/./"><i class="fa-fw fa fa-home faa-shake animated-hover"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive faa-shake animated-hover"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags faa-shake animated-hover"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open faa-shake animated-hover"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link faa-shake animated-hover"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart faa-shake animated-hover"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-gamepad faa-shake animated-hover"></i><span> 放松一下</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/games/2048/"><i class="fa-fw fa fa-gamepad faa-shake animated-hover"></i><span> 2048 经典2048</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="http://taqini.space/games/battle-city/#/"><i class="fa-fw fa fa-gamepad faa-shake animated-hover"></i><span> BattleCity 坦克大战</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">C7</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/./"><i class="fa-fw fa fa-home faa-shake animated-hover"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive faa-shake animated-hover"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags faa-shake animated-hover"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open faa-shake animated-hover"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link faa-shake animated-hover"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart faa-shake animated-hover"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-gamepad faa-shake animated-hover"></i><span> 放松一下</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/games/2048/"><i class="fa-fw fa fa-gamepad faa-shake animated-hover"></i><span> 2048 经典2048</span></a></li><li><a class="site-page" target="_blank" rel="noopener" href="http://taqini.space/games/battle-city/#/"><i class="fa-fw fa fa-gamepad faa-shake animated-hover"></i><span> BattleCity 坦克大战</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【MIT 6.828】JOS学习笔记 Lab4</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-08T14:12:16.641Z" title="发表于 2021-08-08 22:12:16">2021-08-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-08-15T09:05:35.009Z" title="更新于 2021-08-15 17:05:35">2021-08-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Learning/">Learning</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>在lab4中多了如下文件：kern/cpu.h、kern/mpconfig.c、kern/lapic.c、kern/mpentry.S、kern/spinlock.h、kern/spinlock.c、kern/sched.c</p>
<h2 id="Part-A-Multiprocessor-Support-and-Cooperative-Multitasking"><a href="#Part-A-Multiprocessor-Support-and-Cooperative-Multitasking" class="headerlink" title="Part A: Multiprocessor Support and Cooperative Multitasking"></a>Part A: Multiprocessor Support and Cooperative Multitasking</h2><p>在这个lab的第一部分，我们首先拓展JOS让其能在多处理器系统上运行，然后实现一些新的JOS内核系统调用以允许用户级环境创建额外的新环境。还将实现协作循环调度，当当前环境自愿放弃CPU(或退出)时，允许内核从一种环境切换到另一种环境。在第三部分中，还将实现抢占式调度，即使环境不合作，它也允许内核在经过一定时间后从环境中重新控制CPU。</p>
<h3 id="Multiprocessor-Support"><a href="#Multiprocessor-Support" class="headerlink" title="Multiprocessor Support"></a>Multiprocessor Support</h3><p>我们将让JOS支持”对称多处理”(SMP)，一种多处理器模型，其中所有CPU都具有对系统资源(如内存和IO总线)的同等访问权限。虽然在SMP模型中所有的CPU的功能都是相同的，但是启动的过程中，还是可以分为两种类型：引导处理器(BSP)负责初始化系统和引导操作系统；另一种是只有在操作系统启动并允许后，应用处理器(AP)才会被BSP激活。哪个处理器作为BSP是由硬件和BIOS决定。到目前为止，我们所有的JOS代码都已在BSP上允许。</p>
<p>在SMP系统中，每个CPU都有一个伴随的本地APIC(LAPIC) 单元。LAPIC单元负责在整个系统中传送中断。LAPIC还为其连接的 CPU提供唯一标识符，在本lab中，我们使用LAPIC单元的以下基本功能(kern/lapic.c)：</p>
<ul>
<li>读取LAPIC标识符(APIC ID)来判断我们的代码现在允许在哪个CPU上(查看cpunum())</li>
<li>从BSP向AP发送STARTUP处理器间中断(IPI)以启动其他CPU(查看lapic_startap())</li>
<li>在第三部分，我们对LAPIC的内置定时器进行编程以触发时钟中断以支持抢占式多任务处理(查看apic_init())</li>
</ul>
<p>处理器访问LAPIC使用内存映射IO(MMIO)，这样就能通过访问内存达到访问设备寄存器的目的。LAPIC从物理地址0xFE000000开始，JOS将通过MMIOBASE虚拟地址访问该物理地址。</p>
<p><strong>exercise1</strong></p>
<p>实现文件kern/pmap.c中的mmio_map_region函数。这个函数管理内存映射IO地址，输入一个在范围内的物理地址，函数返回一个虚拟地址，那么这个物理地址就被映射到这个虚拟地址上。这个也是一个分配器，比较原始，原理就和boot_alloc类似。从MMIOBASE开始分配，每次分配都是以页为单位。故函数维持了一个全局变量，表示当前分配到的地址，并将参数上调到<code>4096</code>的边界。这些操作和boot_alloc一样。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">mmio_map_region(<span class="keyword">physaddr_t</span> pa, <span class="keyword">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Where to start the next region.  Initially, this is the</span></span><br><span class="line">	<span class="comment">// beginning of the MMIO region.  Because this is static, its</span></span><br><span class="line">	<span class="comment">// value will be preserved between calls to mmio_map_region</span></span><br><span class="line">	<span class="comment">// (just like nextfree in boot_alloc).</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">uintptr_t</span> base = MMIOBASE;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Reserve size bytes of virtual memory starting at base and</span></span><br><span class="line">	<span class="comment">// map physical pages [pa,pa+size) to virtual addresses</span></span><br><span class="line">	<span class="comment">// [base,base+size).  Since this is device memory and not</span></span><br><span class="line">	<span class="comment">// regular DRAM, you&#x27;ll have to tell the CPU that it isn&#x27;t</span></span><br><span class="line">	<span class="comment">// safe to cache access to this memory.  Luckily, the page</span></span><br><span class="line">	<span class="comment">// tables provide bits for this purpose; simply create the</span></span><br><span class="line">	<span class="comment">// mapping with PTE_PCD|PTE_PWT (cache-disable and</span></span><br><span class="line">	<span class="comment">// write-through) in addition to PTE_W.  (If you&#x27;re interested</span></span><br><span class="line">	<span class="comment">// in more details on this, see section 10.5 of IA32 volume</span></span><br><span class="line">	<span class="comment">// 3A.)</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Be sure to round size up to a multiple of PGSIZE and to</span></span><br><span class="line">	<span class="comment">// handle if this reservation would overflow MMIOLIM (it&#x27;s</span></span><br><span class="line">	<span class="comment">// okay to simply panic if this happens).</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Hint: The staff solution uses boot_map_region.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Your code here:</span></span><br><span class="line">	<span class="comment">//panic(&quot;mmio_map_region not implemented&quot;);</span></span><br><span class="line">	<span class="keyword">void</span> *ret = (<span class="keyword">void</span>*)base;</span><br><span class="line">	size = ROUNDUP(size,PGSIZE);</span><br><span class="line">	<span class="keyword">if</span>(base + size &gt; MMIOLIM || base + size &lt; base)&#123;</span><br><span class="line">		panic(<span class="string">&quot;mmio_map_region(): overflow&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	boot_map_region(kern_pgdir,base,size,pa,PTE_W|PTE_PCD|PTE_PWT);</span><br><span class="line">	base += size;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Application-Processor-Bootstrap"><a href="#Application-Processor-Bootstrap" class="headerlink" title="Application Processor Bootstrap"></a>Application Processor Bootstrap</h4><p>在启动AP之前，BSP需要搜集多处理器的信息，比如总共有多少个CPU，它们的LAPIC ID以及LAPIC MMIO地址。mp_init函数从BIOS中读取这些信息。具体代码在mp_init中，该函数会在进入内核后由i386_init函数调用，主要作用就是读取mp configuration table中保存的CPU信息，初始化cpus数组，ncpu(总共可用的CPU个数)，bootcput指针(指向BSP对应的CpuInfo结构)。</p>
<p>boot_aps函数驱动AP引导程序，AP以实模式启动，很像引导程序在boot/boot.S中的启动方式，因此boot_aps函数将AP入口代码复制到实模式下寻址的内存位置。与引导加载程序不同的是，我们可以控制AP开始执行代码的位置，我们将入口代码复制到0x7000，但任何未使用的、页面对齐的低于640kb的物理地址都可以使用。</p>
<p>之后，boot_aps函数通过发送STARTUP的IPI(处理器间中断)信号到AP的LAPIC单元来一个个激活AP。在kern/mpentry.S中的入口代码跟boot/boot.S中的代码类似。在一些简短的配置后，它使AP进入开启分页机制的保护模式，调用C语言的setup函数mp_main。boot_aps 等待AP在其结构CpuInfo的cpu_status字段中发出CPU_STARTED标志信号，然后再唤醒下一个。</p>
<p><strong>exercise2</strong></p>
<p>我们需要修改我们kern/pmap.c中page_init函数的代码，来表示MPENTRY_PADDR处的地址已经不再是free的状态。因为这段地址已经被AP的引导器所占用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4:</span></span><br><span class="line">	<span class="comment">// Change your code to mark the physical page at MPENTRY_PADDR</span></span><br><span class="line">	<span class="comment">// as in use</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The example code here marks all physical pages as free.</span></span><br><span class="line">	<span class="comment">// However this is not truly the case.  What memory is free?</span></span><br><span class="line">	<span class="comment">//  1) Mark physical page 0 as in use.</span></span><br><span class="line">	<span class="comment">//     This way we preserve the real-mode IDT and BIOS structures</span></span><br><span class="line">	<span class="comment">//     in case we ever need them.  (Currently we don&#x27;t, but...)</span></span><br><span class="line">	<span class="comment">//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)</span></span><br><span class="line">	<span class="comment">//     is free.</span></span><br><span class="line">	<span class="comment">//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must</span></span><br><span class="line">	<span class="comment">//     never be allocated.</span></span><br><span class="line">	<span class="comment">//  4) Then extended memory [EXTPHYSMEM, ...).</span></span><br><span class="line">	<span class="comment">//     Some of it is in use, some is free. Where is the kernel</span></span><br><span class="line">	<span class="comment">//     in physical memory?  Which pages are already in use for</span></span><br><span class="line">	<span class="comment">//     page tables and other data structures?</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Change the code to reflect this.</span></span><br><span class="line">	<span class="comment">// NB: DO NOT actually touch the physical memory corresponding to</span></span><br><span class="line">	<span class="comment">// free pages!</span></span><br><span class="line">	<span class="comment">/*size_t i;</span></span><br><span class="line"><span class="comment">	for (i = 0; i &lt; npages; i++) &#123;</span></span><br><span class="line"><span class="comment">		pages[i].pp_ref = 0;</span></span><br><span class="line"><span class="comment">		pages[i].pp_link = page_free_list;</span></span><br><span class="line"><span class="comment">		page_free_list = &amp;pages[i];</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//mark page 0 as in use --1</span></span><br><span class="line">	pages[<span class="number">0</span>].pp_ref = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//mark page [1,npages_basemem_before) in use</span></span><br><span class="line">	<span class="keyword">size_t</span> i;</span><br><span class="line">	<span class="keyword">size_t</span> npages_basemem_before = MPENTRY_PADDR / PGSIZE;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>;i &lt; npages_basemem_before;i++)&#123;</span><br><span class="line">		pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">		pages[i].pp_link = page_free_list;</span><br><span class="line">		page_free_list = &amp;pages[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// skip the MPENTRY_PADDR</span></span><br><span class="line">	<span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> mpentry_start[], mpentry_end[];</span><br><span class="line">	<span class="keyword">size_t</span> mpentry_lent = mpentry_end - mpentry_start;</span><br><span class="line">	<span class="keyword">size_t</span> npages_mpentry = mpentry_lent / PGSIZE;</span><br><span class="line">	<span class="keyword">size_t</span> mpentry_more = mpentry_lent % PGSIZE;</span><br><span class="line">	<span class="keyword">if</span>(mpentry_more)&#123;</span><br><span class="line">		npages_mpentry++;</span><br><span class="line">	&#125;</span><br><span class="line">	i = npages_basemem_before + npages_mpentry;</span><br><span class="line">	<span class="keyword">for</span>(;i &lt; npages_basemem;i++)&#123;</span><br><span class="line">		pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">		pages[i].pp_link = page_free_list;</span><br><span class="line">		page_free_list = &amp;pages[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//[IOPHYSMEM, EXTPHYSMEM) is never be allocated --3</span></span><br><span class="line">	<span class="keyword">for</span>(;i&lt;EXTPHYSMEM/PGSIZE;i++)&#123;</span><br><span class="line">		pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//[EXTPHYSMEM, ...) --4</span></span><br><span class="line">	<span class="comment">//in this part,we need to know which pages has been used for pages-table or page-directory or kernel</span></span><br><span class="line">	<span class="keyword">physaddr_t</span> lasted_in_use_address = PADDR(boot_alloc(<span class="number">0</span>));</span><br><span class="line">	<span class="keyword">size_t</span> last_number = lasted_in_use_address/PGSIZE;</span><br><span class="line">	<span class="keyword">for</span>(;i&lt;last_number;i++)&#123;</span><br><span class="line">		pages[i].pp_ref = <span class="number">1</span>;</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="comment">//other pages for free</span></span><br><span class="line">	<span class="keyword">for</span>(;i &lt; npages;i++)&#123;</span><br><span class="line">		pages[i].pp_ref = <span class="number">0</span>;</span><br><span class="line">		pages[i].pp_link = page_free_list;</span><br><span class="line">		page_free_list = &amp;pages[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时我们又能看见check_page_free_list() succeeded!了。</p>
<blockquote>
<p>Question</p>
<p>将kern/mpentry.S与boot/boot.S并排比较。 请记住，就像内核中的其他内容一样，kern/mpentry.S被编译、链接并运行在<code>KERNBASE</code>之上，宏MPBOOTPHYS的目的是什么？ 为什么这在在kern/mpentry.S很关键？换句话说，如果在kern/mpentry.S中省略了什么可能会出错？<strong>提示：回忆链接地址与加载地址的区别。</strong></p>
<p>boot.S中，由于尚没有启用分页机制，所以我们能够指定程序开始执行的地方以及程序加载的地址；但是，在mpentry.S的时候，由于主CPU已经处于保护模式下了，因此是不能直接指定物理地址的，给定线性地址，映射到相应的物理地址是允许的。</p>
</blockquote>
<h4 id="Per-CPU-State-and-Initialization"><a href="#Per-CPU-State-and-Initialization" class="headerlink" title="Per-CPU State and Initialization"></a>Per-CPU State and Initialization</h4><p>在编写多处理器操作系统时，区分每个处理器私有的CPU状态和整个系统共享的全局状态很重要。kern/cpu.h定义了大多数的per-CPU状态，包括CpuInfo结构体，这个结构体存储了per-CPU的变量。cpunum() 总是返回调用它的CPU的ID，它可以作为cpus数组的索引。thiscpu宏是当前CPU的结构CpuInfo的简写。</p>
<p>JOS使用CpuInfo结构体来记录CPU的信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CpuInfo</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint8_t</span> cpu_id;                 <span class="comment">// Local APIC ID; index into cpus[] below</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">unsigned</span> cpu_status;   <span class="comment">// The status of the CPU</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">cpu_env</span>;</span>            <span class="comment">// The currently-running environment.</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Taskstate</span> <span class="title">cpu_ts</span>;</span>        <span class="comment">// Used by x86 to find stack for interrupt</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每个CPU如下信息是当前CPU私有的：</p>
<ul>
<li>内核栈：因为多个CPU可以同时陷入内核，所以我们需要为每个处理器使用单独的内核堆栈，以防止它们被彼此干扰。<code>percpu_kstacks[NCPU][KSTKSIZE]</code>数组为每个CPU都保留了KSTKSIZE大小的内核栈</li>
<li>TSS和TSS描述符：每个CPU都需要单独的TSS和TSS描述符来指定该CPU对应的内核栈</li>
<li>进程结构指针：每个CPU都会独立允许一个进程的代码，所以需要Env指针</li>
<li>系统寄存器：比如cr3，gdt，ltr这些寄存器都是每个CPU私有的，每个CPU都需要单独设置</li>
</ul>
<p>到目前为之CpuInfo和Env的关系可以总结如下：</p>
<p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab4/lab4_2_cpu%E5%92%8CEnv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="Env和CpuInfo关系"></p>
<p><strong>exercise 3</strong></p>
<p>处理器同时运行，不能共享一个栈，每个处理器都要有自己的栈。当然，这种区分是在虚拟地址层面上的，不是在物理地址层面上的，不同虚拟地址可以映射到相同物理地址，也可以映射到不同。在这里，我们当然希望能够映射到不同地址上。</p>
<p>主要工作在函数<code>mem_init_mp</code>，这个函数在<code>mem_init</code>初始化完成<code>BSP</code>使用的栈后调用，为各个<code>AP</code>映射栈地址。</p>
<p>讲义和代码注释要求我们给每个栈分配<code>KSTKSIZE</code>大小，中间留出<code>KSTKGAP</code>作为保护，使得一个栈溢出一定不会影响相邻的栈。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">mem_init_mp(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Map per-CPU stacks starting at KSTACKTOP, for up to &#x27;NCPU&#x27; CPUs.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// For CPU i, use the physical memory that &#x27;percpu_kstacks[i]&#x27; refers</span></span><br><span class="line">	<span class="comment">// to as its kernel stack. CPU i&#x27;s kernel stack grows down from virtual</span></span><br><span class="line">	<span class="comment">// address kstacktop_i = KSTACKTOP - i * (KSTKSIZE + KSTKGAP), and is</span></span><br><span class="line">	<span class="comment">// divided into two pieces, just like the single stack you set up in</span></span><br><span class="line">	<span class="comment">// mem_init:</span></span><br><span class="line">	<span class="comment">//     * [kstacktop_i - KSTKSIZE, kstacktop_i)</span></span><br><span class="line">	<span class="comment">//          -- backed by physical memory</span></span><br><span class="line">	<span class="comment">//     * [kstacktop_i - (KSTKSIZE + KSTKGAP), kstacktop_i - KSTKSIZE)</span></span><br><span class="line">	<span class="comment">//          -- not backed; so if the kernel overflows its stack,</span></span><br><span class="line">	<span class="comment">//             it will fault rather than overwrite another CPU&#x27;s stack.</span></span><br><span class="line">	<span class="comment">//             Known as a &quot;guard page&quot;.</span></span><br><span class="line">	<span class="comment">//     Permissions: kernel RW, user NONE</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// LAB 4: Your code here:</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NCPU; i++) &#123;</span><br><span class="line">		boot_map_region(kern_pgdir,KSTACKTOP - KSTKSIZE - i * (KSTKSIZE + KSTKGAP),KSTKSIZE,PADDR(percpu_kstacks[i]),PTE_W);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>exercise4</strong></p>
<p>在文件kern/trap.c中函数trap_init_percpu对BSP的TSS和TSS描述符进行初始化。上一个Lab留下的版本，不能正确的处理多处理器的情况，我们需要更改它，让它能够正确初始化每个AP的中断。在之前的lab中，trap_init_percpu函数在trap_init中调用，trap_init在i386_init中调用，这是给BSP初始化中断。AP内核的入口函数mp_main调用了trap_init_percpu，这是给各个AP初始化中断。在BSP调用的trap_init函数中，<strong>中断描述符表</strong>已经初始化完成了，在各个AP中也就没比要再做，故没有调用trap_init。</p>
<p>注意此时的代码已经执行在不同的CPU上了，而不是要初始化所有CPU，只需要初始化自身就可以了。用thiscpu-&gt;cpu_ts代替全局变量cpu_ts。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">trap_init_percpu(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// The example code here sets up the Task State Segment (TSS) and</span></span><br><span class="line">	<span class="comment">// the TSS descriptor for CPU 0. But it is incorrect if we are</span></span><br><span class="line">	<span class="comment">// running on other CPUs because each CPU has its own kernel stack.</span></span><br><span class="line">	<span class="comment">// Fix the code so that it works for all CPUs.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Hints:</span></span><br><span class="line">	<span class="comment">//   - The macro &quot;thiscpu&quot; always refers to the current CPU&#x27;s</span></span><br><span class="line">	<span class="comment">//     struct CpuInfo;</span></span><br><span class="line">	<span class="comment">//   - The ID of the current CPU is given by cpunum() or</span></span><br><span class="line">	<span class="comment">//     thiscpu-&gt;cpu_id;</span></span><br><span class="line">	<span class="comment">//   - Use &quot;thiscpu-&gt;cpu_ts&quot; as the TSS for the current CPU,</span></span><br><span class="line">	<span class="comment">//     rather than the global &quot;ts&quot; variable;</span></span><br><span class="line">	<span class="comment">//   - Use gdt[(GD_TSS0 &gt;&gt; 3) + i] for CPU i&#x27;s TSS descriptor;</span></span><br><span class="line">	<span class="comment">//   - You mapped the per-CPU kernel stacks in mem_init_mp()</span></span><br><span class="line">	<span class="comment">//   - Initialize cpu_ts.ts_iomb to prevent unauthorized environments</span></span><br><span class="line">	<span class="comment">//     from doing IO (0 is not the correct value!)</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// ltr sets a &#x27;busy&#x27; flag in the TSS selector, so if you</span></span><br><span class="line">	<span class="comment">// accidentally load the same TSS on more than one CPU, you&#x27;ll</span></span><br><span class="line">	<span class="comment">// get a triple fault.  If you set up an individual CPU&#x27;s TSS</span></span><br><span class="line">	<span class="comment">// wrong, you may not get a fault until you try to return from</span></span><br><span class="line">	<span class="comment">// user space on that CPU.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// LAB 4: Your code here:</span></span><br><span class="line">	<span class="keyword">int</span> cid = thiscpu-&gt;cpu_id;</span><br><span class="line">	<span class="comment">// Setup a TSS so that we get the right stack</span></span><br><span class="line">	<span class="comment">// when we trap to the kernel.</span></span><br><span class="line">	thiscpu-&gt;cpu_ts.ts_esp0 = KSTACKTOP - cid * (KSTKSIZE + KSTKGAP);</span><br><span class="line">	thiscpu-&gt;cpu_ts.ts_ss0 = GD_KD;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize the TSS slot of the gdt.</span></span><br><span class="line">	gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>)+cid] = SEG16(STS_T32A, (<span class="keyword">uint32_t</span>) (&amp;(thiscpu-&gt;cpu_ts)),</span><br><span class="line">					<span class="keyword">sizeof</span>(struct Taskstate), <span class="number">0</span>);</span><br><span class="line">	gdt[(GD_TSS0 &gt;&gt; <span class="number">3</span>)+cid].sd_s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Load the TSS selector (like other segment selectors, the</span></span><br><span class="line">	<span class="comment">// bottom three bits are special; we leave them 0)</span></span><br><span class="line">	ltr(GD_TSS0+<span class="number">8</span>*cid);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Load the IDT</span></span><br><span class="line">	lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Locking"><a href="#Locking" class="headerlink" title="Locking"></a>Locking</h4><p>目前我们已经有多个CPU同时在执行内核代码了，我们必须要处理竞争条件。最简单粗暴的办法就是使用”big kernel lock”，”big kernel lock”是一个全局锁，进程从用户态进入内核后获取该锁，退出内核释放该锁。这样就能保证只有一个CPU在执行内核代码，但缺点也很明显就是一个CPU在执行内核代码时，另一个CPU如果也想进入内核，就会处于等待的状态。</p>
<p>锁的数据结构在kern/spinlock.h中:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> locked;       <span class="comment">// Is the lock held?</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是一种<strong>spin-locks</strong>。让我们来看看<strong>自旋锁的实现原理</strong>。<br>我们最容易想到的获取自旋锁的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">acquire(struct spinlock *lk)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">     <span class="keyword">if</span>(!lk-&gt;locked) &#123;</span><br><span class="line">         lk-&gt;locked = <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这种实现是有问题的，假设两个CPU同时执行到5行，发现lk-&gt;locked是0，那么会同时获取该锁。问题出在5行和6行是两条指令。</p>
<p>我们的获取锁，释放锁的操作在kern/spinlock.c中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">spin_lock(struct spinlock *lk)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// The xchg is atomic.</span></span><br><span class="line">	<span class="comment">// It also serializes, so that reads after acquire are not</span></span><br><span class="line">	<span class="comment">// reordered before it. </span></span><br><span class="line">	<span class="keyword">while</span> (xchg(&amp;lk-&gt;locked, <span class="number">1</span>) != <span class="number">0</span>)			<span class="comment">//原理见：https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf  chapter 4</span></span><br><span class="line">		<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;pause&quot;</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">spin_unlock(struct spinlock *lk)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// The xchg instruction is atomic (i.e. uses the &quot;lock&quot; prefix) with</span></span><br><span class="line">	<span class="comment">// respect to any other instruction which references the same memory.</span></span><br><span class="line">	<span class="comment">// x86 CPUs will not reorder loads/stores across locked instructions</span></span><br><span class="line">	<span class="comment">// (vol 3, 8.2.2). Because xchg() is implemented using asm volatile,</span></span><br><span class="line">	<span class="comment">// gcc will not reorder C statements across the xchg.</span></span><br><span class="line">	xchg(&amp;lk-&gt;locked, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint32_t</span></span><br><span class="line">xchg(<span class="keyword">volatile</span> <span class="keyword">uint32_t</span> *addr, <span class="keyword">uint32_t</span> newval)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> result;</span><br><span class="line">    <span class="comment">// The + in &quot;+m&quot; denotes a read-modify-write operand.</span></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;lock; xchgl %0, %1&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">         : <span class="string">&quot;+m&quot;</span> (*addr), <span class="string">&quot;=a&quot;</span> (result)</span></span></span><br><span class="line"><span class="function"><span class="params">         : <span class="string">&quot;1&quot;</span> (newval)</span></span></span><br><span class="line"><span class="function"><span class="params">         : <span class="string">&quot;cc&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于spin_lock()获取锁的操作，使用xchgl这个原子指令，xchg()封装了该指令，交换lk-&gt;locked和1的值，并将lk-locked原来的值返回。如果lk-locked原来的值不等于0，说明该锁已经被别的CPU申请了，继续执行while循环吧。因为这里使用的xchgl指令，从addr指向的位置读数据保存到result，然后将newval写到该位置，但是原子的，相当于之前25和26行的结合，所以也就不会出现上述的问题。对于spin_unlock()释放锁的操作，直接将lk-&gt;locked置为0，表明我已经用完了，这个锁可以被别人获取了。</p>
<p>有了获取锁和释放锁的函数，我们看下哪些地方需要加锁，和释放锁：</p>
<ol>
<li>i386_init()中，BSP唤醒其它AP前需要获取内核锁。</li>
<li>mp_main()中，AP需要在执行sched_yield()前获取内核锁。</li>
<li>trap()中，需要获取内核锁，因为这是用户态进入内核的唯一入口。</li>
<li>env_run()中，需要释放内核锁，因为该函数使用iret指令，从内核返回用户态。</li>
</ol>
<p>这些添加我们就不放代码了，但是它们的意义值得思考。i386_init, mp_main函数的lock都发生在初始化完成，准备通过sched_yield进入用户进程之前。这时候加锁，让处理器依次加载用户进程，保证同一时刻只有一个处理器在内核态运行。</p>
<p>其它操作内核锁发生在进入和退出内核态的时候。处理器进入内核态后处在函数trap，故在trap开头加锁，等待其它处理器退出内核态。处理器要进入用户态时放开锁，也就是在env_run的最后，允许其它处理器进入内核态。</p>
<blockquote>
<p>Question</p>
<p>big kernel lock似乎已经确保每次仅仅一个CPU能允许内核代码，为什么我们仍然需要为每个CPU设定一个内核栈</p>
<p>因为在alltraps到lock_kernel()的过程中，进程已经切换到了内核态，但并没有上内核锁，此时如果有其他CPU进入内核，如果用同一个内核栈，则_alltraps中保存的上下文信息会被破坏，所以即使有大内核栈，CPU也不能用用同一个内核栈。同样的，解锁也是在内核态内解锁，在解锁到真正返回用户态这段过程中，也存在上述这种情况</p>
</blockquote>
<h3 id="Round-Robin-Scheduling"><a href="#Round-Robin-Scheduling" class="headerlink" title="Round-Robin Scheduling"></a>Round-Robin Scheduling</h3><p>现要JOS内核需要让CPU能在进程之间切换。目前先实现一个非抢占式的进程调度，需要当前进程主动让出CPU，其他进程才有机会在当前CPU运行。具体实现如下：</p>
<ol>
<li>实现sched_yield()，该函数选择一个新的进程运行，从当前正在运行进程对应的Env结构下一个位置开始循环搜索envs数组，找到第一个cpu_status为ENV_RUNNABLE的Env结构，然后调用env_run()在当前CPU运行这个新的进程。</li>
<li>我们需要实现一个新的系统调用sys_yield()，使得用户程序能在用户态通知内核，当前进程希望主动让出CPU给另一个进程。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">sched_yield(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">idle</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Implement simple round-robin scheduling.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Search through &#x27;envs&#x27; for an ENV_RUNNABLE environment in</span></span><br><span class="line">	<span class="comment">// circular fashion starting just after the env this CPU was</span></span><br><span class="line">	<span class="comment">// last running.  Switch to the first such environment found.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// If no envs are runnable, but the environment previously</span></span><br><span class="line">	<span class="comment">// running on this CPU is still ENV_RUNNING, it&#x27;s okay to</span></span><br><span class="line">	<span class="comment">// choose that environment.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Never choose an environment that&#x27;s currently running on</span></span><br><span class="line">	<span class="comment">// another CPU (env_status == ENV_RUNNING). If there are</span></span><br><span class="line">	<span class="comment">// no runnable environments, simply drop through to the code</span></span><br><span class="line">	<span class="comment">// below to halt the cpu.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="keyword">size_t</span> start = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="keyword">if</span>(curenv)&#123;</span><br><span class="line">		start = ENVX(curenv-&gt;env_id) + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; NENV; i++)&#123;</span><br><span class="line">		j = (start + i) % NENV;</span><br><span class="line">		<span class="keyword">if</span>(envs[j].env_status == ENV_RUNNABLE)&#123;</span><br><span class="line">			env_run(&amp;envs[j]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(curenv &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)&#123;</span><br><span class="line">		env_run(curenv);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// sched_halt never returns</span></span><br><span class="line">	sched_halt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，当前CPU在envs数组中找了一圈后没找到合适的Env去执行，需要重新执行之前运行的进程，否则当前CPU就会进入停机状态。</p>
<blockquote>
<p>关于Question3、4</p>
<p>在函数env_run中通过lcr3切换了页表之后，后面的代码依旧可以访问envs数组的成员。这是因为envs在kern_pgdir中被设置为用户态只读，而我们后面的每个用户进程的页表都是通过kern_pgdir为模板来复刻出来的，除了自身的部分，内核的部分肯定都是一样的，也就可以读取这段地址了</p>
</blockquote>
<h3 id="System-Calls-for-Environment-Creation"><a href="#System-Calls-for-Environment-Creation" class="headerlink" title="System Calls for Environment Creation"></a>System Calls for Environment Creation</h3><p>尽管现在的内核有能力在多进程之间切换，但是仅限于内核创建的用户进程。目前的JOS还没有提供系统调用，使用户进程能够创建新的进程。</p>
<p>UNIX提供fork()系统调用来创建新进程，fork()拷贝父进程的地址空间和寄存器状态到子进程。父进程从fork()返回的是子进程的进程ID，而子进程从fork()返回的是0。</p>
<p>我们将实现一组不同的、更原始的JOS系统调用来创建新的用户模式环境。我们需要完成如下函数：</p>
<ol>
<li>sys_exofork()：<br>创建一个新的进程，用户地址空间没有映射，不能运行，寄存器状态和父环境一致。在父进程中sys_exofork()返回新进程的envid，子进程返回0。</li>
<li>sys_env_set_status：设置一个特定进程的状态为ENV_RUNNABLE或ENV_NOT_RUNNABLE。</li>
<li>sys_page_alloc：为特定进程分配一个物理页，映射指定线性地址va到该物理页。</li>
<li>sys_page_map：拷贝页表，使指定进程共享当前进程相同的映射关系。本质上是修改特定进程的页目录和页表。</li>
<li>sys_page_unmap：解除页映射关系。本质上是修改指定用户环境的页目录和页表。</li>
</ol>
<p><strong>exercise7</strong></p>
<p>实现上述的系统调用</p>
<p>首先是sys_exofork函数，这个函数其实就是env_alloc函数的封装，就是创建一个空白进程，非常简单</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">envid_t</span></span><br><span class="line">sys_exofork(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Create the new environment with env_alloc(), from kern/env.c.</span></span><br><span class="line">	<span class="comment">// It should be left as env_alloc created it, except that</span></span><br><span class="line">	<span class="comment">// status is set to ENV_NOT_RUNNABLE, and the register set is copied</span></span><br><span class="line">	<span class="comment">// from the current environment -- but tweaked so sys_exofork</span></span><br><span class="line">	<span class="comment">// will appear to return 0.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="comment">//panic(&quot;sys_exofork not implemented&quot;);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret = env_alloc(&amp;e,curenv-&gt;env_id);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	e-&gt;env_tf = curenv-&gt;env_tf;<span class="comment">//寄存器状态一致</span></span><br><span class="line">	e-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">	e-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;<span class="comment">//子进程返回0</span></span><br><span class="line">	<span class="keyword">return</span> e-&gt;env_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是sys_env_set_status函数。要使得进程从sys_exofork创建得到的状态ENV_NOT_RUNNABLE变为别的状态，也需要一个系统调用来实现。这个系统调用就是对设置Env状态的改变。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_env_set_status(<span class="keyword">envid_t</span> envid, <span class="keyword">int</span> status)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Hint: Use the &#x27;envid2env&#x27; function from kern/env.c to translate an</span></span><br><span class="line">	<span class="comment">// envid to a struct Env.</span></span><br><span class="line">	<span class="comment">// You should set envid2env&#x27;s third argument to 1, which will</span></span><br><span class="line">	<span class="comment">// check whether the current environment has permission to set</span></span><br><span class="line">	<span class="comment">// envid&#x27;s status.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="comment">//panic(&quot;sys_env_set_status not implemented&quot;);</span></span><br><span class="line">	<span class="keyword">switch</span> (status)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> ENV_NOT_RUNNABLE:</span><br><span class="line">	<span class="keyword">case</span> ENV_RUNNABLE:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret = envid2env(envid, &amp;e, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span> || e == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">	e-&gt;env_status = status;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是sys_page_alloc通过分配器拿到一些page，然后把他们映射进程的地址空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_alloc(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Hint: This function is a wrapper around page_alloc() and</span></span><br><span class="line">	<span class="comment">//   page_insert() from kern/pmap.c.</span></span><br><span class="line">	<span class="comment">//   Most of the new code you write should be to check the</span></span><br><span class="line">	<span class="comment">//   parameters for correctness.</span></span><br><span class="line">	<span class="comment">//   If page_insert() fails, remember to free the page you</span></span><br><span class="line">	<span class="comment">//   allocated!</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="comment">//panic(&quot;sys_page_alloc not implemented&quot;);</span></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	ret = envid2env(envid,&amp;e,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span> || e == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((va &gt;= (<span class="keyword">void</span>*)UTOP) || (ROUNDDOWN(va, PGSIZE) != va)) </span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;		<span class="comment">//一系列判定</span></span><br><span class="line">	<span class="keyword">int</span> flag = PTE_U | PTE_P;</span><br><span class="line">	<span class="keyword">if</span> ((perm &amp; flag) != flag) </span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span> =</span> page_alloc(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(pp == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">	&#125;	</span><br><span class="line">	ret = page_insert(e-&gt;env_pgdir,pp,va,perm);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		page_free(pp);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sys_page_map</code>将一个进程的<code>Page Directory</code>拷贝给另一个进程，让另一个进程获得相同的<strong>地址空间</strong>。这是对<code>page_insert</code>的封装。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_map(<span class="keyword">envid_t</span> srcenvid, <span class="keyword">void</span> *srcva,</span><br><span class="line">	     <span class="keyword">envid_t</span> dstenvid, <span class="keyword">void</span> *dstva, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Hint: This function is a wrapper around page_lookup() and</span></span><br><span class="line">	<span class="comment">//   page_insert() from kern/pmap.c.</span></span><br><span class="line">	<span class="comment">//   Again, most of the new code you write should be to check the</span></span><br><span class="line">	<span class="comment">//   parameters for correctness.</span></span><br><span class="line">	<span class="comment">//   Use the third argument to page_lookup() to</span></span><br><span class="line">	<span class="comment">//   check the current permissions on the page.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="comment">//panic(&quot;sys_page_map not implemented&quot;);</span></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">srce</span>,*<span class="title">dste</span>;</span></span><br><span class="line">	ret = envid2env(srcenvid,&amp;srce,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span> || srce == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = envid2env(dstenvid,&amp;dste,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span> || dste == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (srcva &gt;= (<span class="keyword">void</span>*)UTOP || dstva &gt;= (<span class="keyword">void</span>*)UTOP || ROUNDDOWN(srcva,PGSIZE) != srcva || ROUNDDOWN(dstva,PGSIZE) != dstva) </span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> flag = PTE_U|PTE_P;</span><br><span class="line">	<span class="keyword">if</span> ((perm &amp; flag) != flag) </span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	<span class="keyword">pte_t</span> *pte;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span> =</span> page_lookup(srce-&gt;env_pgdir,srcva,&amp;pte);</span><br><span class="line">	<span class="keyword">if</span>(pp == NULl)&#123;</span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(perm | PTE_W)&#123;</span><br><span class="line">		<span class="keyword">if</span> (!(*pte &amp; PTE_W)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = page_insert(dste-&gt;env_pgdir,pp,dstva,perm);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后是sys_page_unmap，就是page_remove的封装。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_page_unmap(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *va)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Hint: This function is a wrapper around page_remove().</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="comment">//panic(&quot;sys_page_unmap not implemented&quot;);</span></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	ret = envid2env(envid,&amp;e,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span> || e == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((va &gt;= (<span class="keyword">void</span>*)UTOP) || (ROUNDDOWN(va, PGSIZE) != va)) </span><br><span class="line">		<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">	page_remove(e-&gt;env_pgdir,va);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>别忘记在syscall函数中加上接口。</p>
<p>到这里我们就已经完成了part A的所有部分。</p>
<h2 id="Part-B-Copy-on-Write-Fork"><a href="#Part-B-Copy-on-Write-Fork" class="headerlink" title="Part B: Copy-on-Write Fork"></a>Part B: Copy-on-Write Fork</h2><p>实现fork的方式有两种，一种是将父进程的内容全部拷贝一次给子进程，这样的话子进程和父进程就能实现进程隔离，但是这种方式非常的耗时，需要在物理内存中复制父进程的内容。</p>
<p>另一种方式叫做<strong>写时复制</strong>，父进程将自己的页目录和页表复制给子进程，这样父进程和子进程就能访问相同的内容。只有当子进程执行写操作时，才复制这一物理页。这样既能做到地址空间隔离，又能节省大量的拷贝工作。用来图来对比这两种方式：</p>
<p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab4/lab4_3_%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9Dfork.png" alt="非写时拷贝vs写时拷贝fork"></p>
<p>要实现写时复制的fork需要先实现用户级别的缺页中断处理函数，这里我们默认认为内核一定正确，没有缺页错误。</p>
<h3 id="User-level-page-fault-handling"><a href="#User-level-page-fault-handling" class="headerlink" title="User-level page fault handling"></a>User-level page fault handling</h3><p>Copy-on-Write 只是用户级页面错误处理的许多可能用途之一。</p>
<p>我们将利用用户级页面错误处理方式，来决定如何处理用户空间中的每个页面错误，而不采用传统的Unix方法，因为其产生的错误的破坏性较小。 这种设计的另一个好处是允许程序在定义内存区域时具有很大的灵活性; 稍后我们将使用用户级页面错误处理来映射和访问基于磁盘的文件系统上的文件。</p>
<p><strong>exercise8</strong></p>
<p>实现sys_env_set_pgfault_upcall(envid_t envid, void *func)系统调用。该系统调用为指定的用户环境设置env_pgfault_upcall。缺页中断发生时，会执行env_pgfault_upcall指定位置的代码。当执行env_pgfault_upcall指定位置的代码时，栈已经转到异常栈，并且压入了UTrapframe结构。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_env_set_pgfault_upcall(<span class="keyword">envid_t</span> envid, <span class="keyword">void</span> *func)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="comment">//panic(&quot;sys_env_set_pgfault_upcall not implemented&quot;);</span></span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span> *<span class="title">e</span>;</span></span><br><span class="line">	ret = envid2env(envid,&amp;e,<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret &lt; <span class="number">0</span> || e == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> -E_BAD_ENV;</span><br><span class="line">	&#125;</span><br><span class="line">	e-&gt;env_pgfault_upcall = func;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Normal-and-Exception-Stacks-in-User-Environments"><a href="#Normal-and-Exception-Stacks-in-User-Environments" class="headerlink" title="Normal and Exception Stacks in User Environments"></a>Normal and Exception Stacks in User Environments</h4><p>当缺页中断发生时，内核会返回用户模式来处理该中断。我们需要一个用户异常栈，来模拟内核异常栈。JOS的用户异常栈被定义在虚拟地址UXSTACKTOP。</p>
<h4 id="Invoking-the-User-Page-Fault-Handler"><a href="#Invoking-the-User-Page-Fault-Handler" class="headerlink" title="Invoking the User Page Fault Handler"></a>Invoking the User Page Fault Handler</h4><p>缺页中断发送时会进入内核的trap()，然后分配page_fault_handler来处理缺页中断。在该函数中应该做如下几件事：</p>
<ol>
<li>判断curenv-&gt;env_pgfault_upcall是否设置，如果没有设置也就没办法修复，直接销毁该进程。</li>
<li>修改esp，切换到用户异常栈。</li>
<li>在栈上压入一个UTrapframe结构。</li>
<li>将eip设置为curenv-&gt;env_pgfault_upcall，然后回到用户态执行curenv-&gt;env_pgfault_upcall处的代码。</li>
</ol>
<p>UTrapframe结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                    &lt;-- UXSTACKTOP</span><br><span class="line">trap-time esp</span><br><span class="line">trap-time eflags</span><br><span class="line">trap-time eip</span><br><span class="line">trap-time eax       start of struct PushRegs</span><br><span class="line">trap-time ecx</span><br><span class="line">trap-time edx</span><br><span class="line">trap-time ebx</span><br><span class="line">trap-time esp</span><br><span class="line">trap-time ebp</span><br><span class="line">trap-time esi</span><br><span class="line">trap-time edi       end of struct PushRegs</span><br><span class="line">tf_err (error code)</span><br><span class="line">fault_va            &lt;-- %esp when handler is run</span><br></pre></td></tr></table></figure>
<p><strong>exercise9</strong></p>
<p>按照上面的描述实现page_fault_handler()。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">page_fault_handler(struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> fault_va;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Read processor&#x27;s CR2 register to find the faulting address</span></span><br><span class="line">	fault_va = rcr2();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Handle kernel-mode page faults.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 3: Your code here.</span></span><br><span class="line">	<span class="keyword">if</span>((tf-&gt;tf_cs &amp;&amp; <span class="number">0x1</span>) == <span class="number">0</span> )&#123;</span><br><span class="line">		panic(<span class="string">&quot;page fault in kernel-mode,fault address %d\n&quot;</span>,fault_va);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// We&#x27;ve already handled kernel-mode exceptions, so if we get here,</span></span><br><span class="line">	<span class="comment">// the page fault happened in user mode.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Call the environment&#x27;s page fault upcall, if one exists.  Set up a</span></span><br><span class="line">	<span class="comment">// page fault stack frame on the user exception stack (below</span></span><br><span class="line">	<span class="comment">// UXSTACKTOP), then branch to curenv-&gt;env_pgfault_upcall.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// The page fault upcall might cause another page fault, in which case</span></span><br><span class="line">	<span class="comment">// we branch to the page fault upcall recursively, pushing another</span></span><br><span class="line">	<span class="comment">// page fault stack frame on top of the user exception stack.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// It is convenient for our code which returns from a page fault</span></span><br><span class="line">	<span class="comment">// (lib/pfentry.S) to have one word of scratch space at the top of the</span></span><br><span class="line">	<span class="comment">// trap-time stack; it allows us to more easily restore the eip/esp. In</span></span><br><span class="line">	<span class="comment">// the non-recursive case, we don&#x27;t have to worry about this because</span></span><br><span class="line">	<span class="comment">// the top of the regular user stack is free.  In the recursive case,</span></span><br><span class="line">	<span class="comment">// this means we have to leave an extra word between the current top of</span></span><br><span class="line">	<span class="comment">// the exception stack and the new stack frame because the exception</span></span><br><span class="line">	<span class="comment">// stack _is_ the trap-time stack.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// If there&#x27;s no page fault upcall, the environment didn&#x27;t allocate a</span></span><br><span class="line">	<span class="comment">// page for its exception stack or can&#x27;t write to it, or the exception</span></span><br><span class="line">	<span class="comment">// stack overflows, then destroy the environment that caused the fault.</span></span><br><span class="line">	<span class="comment">// Note that the grade script assumes you will first check for the page</span></span><br><span class="line">	<span class="comment">// fault upcall and print the &quot;user fault va&quot; message below if there is</span></span><br><span class="line">	<span class="comment">// none.  The remaining three checks can be combined into a single test.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Hints:</span></span><br><span class="line">	<span class="comment">//   user_mem_assert() and env_run() are useful here.</span></span><br><span class="line">	<span class="comment">//   To change what the user environment runs, modify &#x27;curenv-&gt;env_tf&#x27;</span></span><br><span class="line">	<span class="comment">//   (the &#x27;tf&#x27; variable points at &#x27;curenv-&gt;env_tf&#x27;).</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="keyword">if</span> (curenv-&gt;env_pgfault_upcall) &#123;</span><br><span class="line">		<span class="keyword">uintptr_t</span> stacktop = UXSTACKTOP;</span><br><span class="line">		<span class="keyword">if</span> (UXSTACKTOP - PGSIZE &lt; tf-&gt;tf_esp &amp;&amp; tf-&gt;tf_esp &lt; UXSTACKTOP) &#123;</span><br><span class="line">			stacktop = tf-&gt;tf_esp;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">uint32_t</span> size = <span class="keyword">sizeof</span>(struct UTrapframe) + <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">		user_mem_assert(curenv, (<span class="keyword">void</span> *)stacktop - size, size, PTE_U | PTE_W);</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">UTrapframe</span> *<span class="title">utr</span> =</span> (struct UTrapframe *)(stacktop - size);</span><br><span class="line">		utr-&gt;utf_fault_va = fault_va;</span><br><span class="line">		utr-&gt;utf_err = tf-&gt;tf_err;</span><br><span class="line">		utr-&gt;utf_regs = tf-&gt;tf_regs;</span><br><span class="line">		utr-&gt;utf_eip = tf-&gt;tf_eip;</span><br><span class="line">		utr-&gt;utf_eflags = tf-&gt;tf_eflags;</span><br><span class="line">		utr-&gt;utf_esp = tf-&gt;tf_esp;				<span class="comment">//UXSTACKTOP栈上需要保存发生缺页异常时的%esp和%eip</span></span><br><span class="line"></span><br><span class="line">		curenv-&gt;env_tf.tf_eip = (<span class="keyword">uintptr_t</span>)curenv-&gt;env_pgfault_upcall;</span><br><span class="line">		curenv-&gt;env_tf.tf_esp = (<span class="keyword">uintptr_t</span>)utr;</span><br><span class="line">		env_run(curenv);			<span class="comment">//重新进入用户态</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Destroy the environment that caused the fault.</span></span><br><span class="line">	cprintf(<span class="string">&quot;[%08x] user fault va %08x ip %08x\n&quot;</span>,</span><br><span class="line">		curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</span><br><span class="line">	print_trapframe(tf);</span><br><span class="line">	env_destroy(curenv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="User-mode-Page-Fault-Entrypoint"><a href="#User-mode-Page-Fault-Entrypoint" class="headerlink" title="User-mode Page Fault Entrypoint"></a>User-mode Page Fault Entrypoint</h4><p><strong>exercise10</strong></p>
<p>现在需要实现lib/pfentry.S中的_pgfault_upcall函数，该函数会作为系统调用sys_env_set_pgfault_upcall()的参数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">addl $<span class="number">8</span>, %esp                 <span class="comment">// esp+8 -&gt; PushRegs   over utf_fault_va utf_err</span></span><br><span class="line">   movl <span class="number">0x20</span>(%esp), %eax         <span class="comment">// eax = (esp+0x20 -&gt; utf_eip )</span></span><br><span class="line">   subl $<span class="number">4</span>, <span class="number">0x28</span>(%esp)           <span class="comment">// for trap time eip 保留32bit,   esp+48 = utf_esp</span></span><br><span class="line">   movl <span class="number">0x28</span>(%esp), %edx         <span class="comment">// %edx = utf_esp-4  </span></span><br><span class="line">   movl %eax, (%edx)             <span class="comment">// %eax = eip ----&gt; esp-4  以至于ret可以直接读取其继续执行的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Restore the trap-time registers.  After you do this, you</span></span><br><span class="line"><span class="comment">// can no longer modify any general-purpose registers.</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">popal              <span class="comment">// after popal esp-&gt;utf_eip</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Restore eflags from the stack.  After you do this, you can</span></span><br><span class="line"><span class="comment">// no longer use arithmetic operations or anything else that</span></span><br><span class="line"><span class="comment">// modifies eflags.</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">addl $<span class="number">4</span>, %esp      <span class="comment">// esp+4 -&gt; utf_eflags</span></span><br><span class="line">   popfl</span><br><span class="line"></span><br><span class="line"><span class="comment">// Switch back to the adjusted trap-time stack.</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">popl %esp</span><br><span class="line"></span><br><span class="line"><span class="comment">// Return to re-execute the instruction that faulted.</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p><strong>exercise11</strong></p>
<p>完成lib/pgfault.c中的set_pgfault_handler()。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">set_pgfault_handler(<span class="keyword">void</span> (*handler)(struct UTrapframe *utf))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (_pgfault_handler == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// First time through!</span></span><br><span class="line">		<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">		<span class="comment">//panic(&quot;set_pgfault_handler not implemented&quot;);</span></span><br><span class="line">		sys_page_alloc(sys_getenvid(), (<span class="keyword">void</span> *) (UXSTACKTOP - PGSIZE), PTE_SYSCALL);</span><br><span class="line">        sys_env_set_pgfault_upcall(sys_getenvid(), _pgfault_upcall);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Save handler pointer for assembly to call.</span></span><br><span class="line">	_pgfault_handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="缺页处理小结："><a href="#缺页处理小结：" class="headerlink" title="缺页处理小结："></a>缺页处理小结：</h4><ol>
<li>引发缺页中断，执行内核函数链子：trap()-&gt;trap_dispatch()-&gt;page_fault_handler()</li>
<li>page_fault_handler()切换到用户异常栈，并且压入UTrapframe结构，然后调用curenv-&gt;env_pgfault_upcall(系统调用sys_env_set_pgfault_upcall()设置，之前已经设置为_pgfault_upcall)处的代码。又重新回到用户态。</li>
<li>执行_pgfault_upcall处的代码，调用pgfault_handler(库函数set_pgfault_handler()设置)处的代码，最后返回到缺页处理中断发生时的那条指令重新执行。</li>
</ol>
<p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab4/lab4_4_%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91.png" alt="JOS缺页异常处理逻辑"></p>
<h3 id="Implementing-Copy-on-Write-Fork"><a href="#Implementing-Copy-on-Write-Fork" class="headerlink" title="Implementing Copy-on-Write Fork"></a>Implementing Copy-on-Write Fork</h3><p>到目前已经可以实现用户级别的写时拷贝fork函数了。fork流程如下：</p>
<ol>
<li>使用set_pgfault_handler()设置缺页处理函数。</li>
<li>调用sys_exofork()系统调用，在内核中创建一个Env结构，复制当前用户环境寄存器状态，UTOP以下的页目录还没有建立，新创建的进程还不能直接运行。</li>
<li>拷贝父进程的页表和页目录到子进程。对于可写的页，将对应的PTE的PTE_COW位设置为1。</li>
<li>为子进程设置_pgfault_upcall。</li>
<li>将子进程状态设置为ENV_RUNNABLE。</li>
</ol>
<p>缺页处理函数pgfault()流程如下：</p>
<ol>
<li>如果发现错误是因为写造成的（错误码是FEC_WR）并且该页的PTE_COW是1，则进行执行第2步，否则直接panic。</li>
<li>分配一个新的物理页，并将之前出现错误的页的内容拷贝到新的物理页，然后重新映射线性地址到新的物理页。</li>
</ol>
<p><strong>exercise12</strong></p>
<p>实现lib/fork.c中的fork, duppage and pgfault。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">pgfault(struct UTrapframe *utf)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> *addr = (<span class="keyword">void</span> *) utf-&gt;utf_fault_va;</span><br><span class="line">	<span class="keyword">uint32_t</span> err = utf-&gt;utf_err;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check that the faulting access was (1) a write, and (2) to a</span></span><br><span class="line">	<span class="comment">// copy-on-write page.  If not, panic.</span></span><br><span class="line">	<span class="comment">// Hint:</span></span><br><span class="line">	<span class="comment">//   Use the read-only page table mappings at uvpt</span></span><br><span class="line">	<span class="comment">//   (see &lt;inc/memlayout.h&gt;).</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="keyword">if</span> (!((err &amp; FEC_WR) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_COW))) &#123; <span class="comment">//只有因为写操作写时拷贝的地址这中情况，才可以抢救。否则一律panic</span></span><br><span class="line">		panic(<span class="string">&quot;pgfault():not cow&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Allocate a new page, map it at a temporary location (PFTEMP),</span></span><br><span class="line">	<span class="comment">// copy the data from the old page to the new page, then move the new</span></span><br><span class="line">	<span class="comment">// page to the old page&#x27;s address.</span></span><br><span class="line">	<span class="comment">// Hint:</span></span><br><span class="line">	<span class="comment">//   You should make three system calls.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line">	<span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, PFTEMP, PTE_U|PTE_P)) &lt; <span class="number">0</span>)		<span class="comment">//将当前进程PFTEMP也映射到当前进程addr指向的物理页</span></span><br><span class="line">		panic(<span class="string">&quot;sys_page_map: %e&quot;</span>, r);</span><br><span class="line">	<span class="keyword">if</span> ((r = sys_page_alloc(<span class="number">0</span>, addr, PTE_P|PTE_U|PTE_W)) &lt; <span class="number">0</span>)	<span class="comment">//令当前进程addr指向新分配的物理页</span></span><br><span class="line">		panic(<span class="string">&quot;sys_page_alloc: %e&quot;</span>, r);</span><br><span class="line">	memmove(addr, PFTEMP, PGSIZE);								<span class="comment">//将PFTEMP指向的物理页拷贝到addr指向的物理页</span></span><br><span class="line">	<span class="keyword">if</span> ((r = sys_page_unmap(<span class="number">0</span>, PFTEMP)) &lt; <span class="number">0</span>)					<span class="comment">//解除当前进程PFTEMP映射</span></span><br><span class="line">		panic(<span class="string">&quot;sys_page_unmap: %e&quot;</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">duppage(<span class="keyword">envid_t</span> envid, <span class="keyword">unsigned</span> pn)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="keyword">void</span> *addr = (<span class="keyword">void</span>*) (pn * PGSIZE);</span><br><span class="line">	<span class="keyword">if</span> (uvpt[pn] &amp; PTE_SHARE) &#123;</span><br><span class="line">		sys_page_map(<span class="number">0</span>, addr, envid, addr, PTE_SYSCALL);		<span class="comment">//对于表示为PTE_SHARE的页，拷贝映射关系，并且两个进程都有读写权限</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((uvpt[pn] &amp; PTE_W) || (uvpt[pn] &amp; PTE_COW)) &#123; <span class="comment">//对于UTOP以下的可写的或者写时拷贝的页，拷贝映射关系的同时，需要同时标记当前进程和子进程的页表项为PTE_COW</span></span><br><span class="line">		<span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, envid, addr, PTE_COW|PTE_U|PTE_P)) &lt; <span class="number">0</span>)</span><br><span class="line">			panic(<span class="string">&quot;sys_page_map：%e&quot;</span>, r);</span><br><span class="line">		<span class="keyword">if</span> ((r = sys_page_map(<span class="number">0</span>, addr, <span class="number">0</span>, addr, PTE_COW|PTE_U|PTE_P)) &lt; <span class="number">0</span>)</span><br><span class="line">			panic(<span class="string">&quot;sys_page_map：%e&quot;</span>, r);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		sys_page_map(<span class="number">0</span>, addr, envid, addr, PTE_U|PTE_P);	<span class="comment">//对于只读的页，只需要拷贝映射关系即可</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">envid_t</span></span><br><span class="line">fork(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="keyword">extern</span> <span class="keyword">void</span> _pgfault_upcall(<span class="keyword">void</span>);</span><br><span class="line">	set_pgfault_handler(pgfault);	<span class="comment">//设置缺页处理函数</span></span><br><span class="line">	<span class="keyword">envid_t</span> envid = sys_exofork();	<span class="comment">//系统调用，只是简单创建一个Env结构，复制当前用户环境寄存器状态，UTOP以下的页目录还没有建立</span></span><br><span class="line">	<span class="keyword">if</span> (envid == <span class="number">0</span>) &#123;				<span class="comment">//子进程将走这个逻辑</span></span><br><span class="line">		thisenv = &amp;envs[ENVX(sys_getenvid())];</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (envid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		panic(<span class="string">&quot;sys_exofork: %e&quot;</span>, envid);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint32_t</span> addr;</span><br><span class="line">	<span class="keyword">for</span> (addr = <span class="number">0</span>; addr &lt; USTACKTOP; addr += PGSIZE) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((uvpd[PDX(addr)] &amp; PTE_P) &amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_P) </span><br><span class="line">			&amp;&amp; (uvpt[PGNUM(addr)] &amp; PTE_U)) &#123;</span><br><span class="line">			duppage(envid, PGNUM(addr));	<span class="comment">//拷贝当前进程映射关系到子进程</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="keyword">if</span> ((r = sys_page_alloc(envid, (<span class="keyword">void</span> *)(UXSTACKTOP-PGSIZE), PTE_P | PTE_W | PTE_U)) &lt; <span class="number">0</span>)	<span class="comment">//为子进程分配异常栈</span></span><br><span class="line">		panic(<span class="string">&quot;sys_page_alloc: %e&quot;</span>, r);</span><br><span class="line">	sys_env_set_pgfault_upcall(envid, _pgfault_upcall);		<span class="comment">//为子进程设置_pgfault_upcall</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((r = sys_env_set_status(envid, ENV_RUNNABLE)) &lt; <span class="number">0</span>)	<span class="comment">//设置子进程为ENV_RUNNABLE状态</span></span><br><span class="line">		panic(<span class="string">&quot;sys_env_set_status: %e&quot;</span>, r);</span><br><span class="line">	<span class="keyword">return</span> envid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Part-C-Preemptive-Multitasking-and-Inter-Process-communication-IPC"><a href="#Part-C-Preemptive-Multitasking-and-Inter-Process-communication-IPC" class="headerlink" title="Part C: Preemptive Multitasking and Inter-Process communication (IPC)"></a>Part C: Preemptive Multitasking and Inter-Process communication (IPC)</h2><p>在partC部分，我们要实现抢占非协作式环境，并且实现进程间通信。</p>
<h3 id="Clock-Interrupts-and-Preemption"><a href="#Clock-Interrupts-and-Preemption" class="headerlink" title="Clock Interrupts and Preemption"></a>Clock Interrupts and Preemption</h3><p>如果一个进程获得CPU后一直死循环而不主动让出CPU的控制权， 整个系统都将 halt。为了允许内核抢占正在运行的环境，强行重获CPU控制权，我们必须扩展JOS内核以支持来自时钟的外部硬件中断。</p>
<h4 id="Interrupt-discipline"><a href="#Interrupt-discipline" class="headerlink" title="Interrupt discipline"></a>Interrupt discipline</h4><p>外部中断（如设备中断）被称为 IRQs。 IRQ号到 IDT 项的映射不是固定的，其会加上一个IRQ_OFFSET的偏移，在picirq.c的pic_init中进行了这个映射过程。外部中断的初始化，实际上就是对硬件 8259A的初始化。</p>
<p>我们必须确保在用户环境中运行时设置FL_IF标志，以便在中断到达时，它将被传递到处理器并由中断代码处理。 否则，中断将被屏蔽或被忽略，直到重新启用中断为止。Bootloader 的第一条指令屏蔽了中断，到目前为止，我们还没有重新使能它们。</p>
<p><strong>exercise13</strong></p>
<p>首先修改Trapentry.s，当调用硬件中断处理时，处理器不会传入错误代码，因此我们需要调用TRAPHANDLER_NOEC宏。添加如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TRAPHANDLER_NOEC(timer_handler, IRQ_OFFSET + IRQ_TIMER);</span><br><span class="line">TRAPHANDLER_NOEC(kbd_handler, IRQ_OFFSET + IRQ_KBD);</span><br><span class="line">TRAPHANDLER_NOEC(serial_handler, IRQ_OFFSET + IRQ_SERIAL);</span><br><span class="line">TRAPHANDLER_NOEC(spurious_handler, IRQ_OFFSET + IRQ_SPURIOUS);</span><br><span class="line">TRAPHANDLER_NOEC(ide_handler, IRQ_OFFSET + IRQ_IDE);</span><br><span class="line">TRAPHANDLER_NOEC(error_handler, IRQ_OFFSET + IRQ_ERROR);</span><br></pre></td></tr></table></figure>
<p>然后修改trap.c，注册IDT</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kbd_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serial_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spurious_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ide_handler</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_handler</span><span class="params">()</span></span>;</span><br><span class="line">...</span><br><span class="line">	SETGATE(idt[IRQ_OFFSET + IRQ_TIMER],<span class="number">0</span>,GD_KT,timer_handler,<span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_KBD],<span class="number">0</span>,GD_KT,kbd_handler,<span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_SERIAL],<span class="number">0</span>,GD_KT,serial_handler,<span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_SPURIOUS],<span class="number">0</span>,GD_KT,spurious_handler,<span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_IDE],<span class="number">0</span>,GD_KT,ide_handler,<span class="number">0</span>);</span><br><span class="line">    SETGATE(idt[IRQ_OFFSET + IRQ_ERROR],<span class="number">0</span>,GD_KT,error_handler,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>在env_alloc中加入以下代码， 同时取消 sched_halt()中sti的注释，使能中断。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Enable interrupts while in user mode.</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">e-&gt;env_tf.tf_eflags |= FL_IF;</span><br></pre></td></tr></table></figure>
<h4 id="Handling-Clock-Interrupts"><a href="#Handling-Clock-Interrupts" class="headerlink" title="Handling Clock Interrupts"></a>Handling Clock Interrupts</h4><p>目前程序一旦进入用户模式，除非发生中断，否则CPU永远不会再执行内核代码。我们需要开启时钟中断，强迫进入内核，然后内核就可以切换另一个进程执行。<br>lapic_init()和pic_init()设置时钟中断控制器产生中断。需要写代码来处理中断。</p>
<p><strong>exercise14</strong></p>
<p>修改内核的trap_dispatch()函数，使其在发生时钟中断时调用 sched_yield()以查找并运行不同的环境。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Handle clock interrupts. Don&#x27;t forget to acknowledge the</span></span><br><span class="line"><span class="comment">// interrupt using lapic_eoi() before calling the scheduler!</span></span><br><span class="line"><span class="comment">// LAB 4: Your code here.</span></span><br><span class="line"><span class="keyword">if</span>(tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_TIMER)&#123;</span><br><span class="line">	lapic_eoi();</span><br><span class="line">	sched_yield();</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时make grade ，我们能够得到65/80。</p>
<h3 id="Inter-Process-communication-IPC"><a href="#Inter-Process-communication-IPC" class="headerlink" title="Inter-Process communication (IPC)"></a>Inter-Process communication (IPC)</h3><p>到目前为止，我们都在做隔离的事情。操作系统另一个重要的内容是允许程序相互交流。</p>
<h4 id="IPC-in-JOS"><a href="#IPC-in-JOS" class="headerlink" title="IPC in JOS"></a>IPC in JOS</h4><p>我们将要实现sys_ipc_recv()和sys_ipc_try_send()这两个系统调用，来实现进程间通信。并且实现两个包装函数ipc_recv()和 ipc_send()。<br>JOS中进程间通信的“消息”包含两部分：</p>
<ol>
<li>一个32位的值。</li>
<li>可选的页映射关系。</li>
</ol>
<h4 id="Sending-and-Receiving-Messages"><a href="#Sending-and-Receiving-Messages" class="headerlink" title="Sending and Receiving Messages"></a>Sending and Receiving Messages</h4><p>sys_ipc_recv()和sys_ipc_try_send()是这么协作的：</p>
<ol>
<li>当某个进程调用sys_ipc_recv()后，该进程会阻塞（状态被置为ENV_NOT_RUNNABLE），直到另一个进程向它发送“消息”。当进程调用sys_ipc_recv()传入dstva参数时，表明当前进程准备接收页映射。</li>
<li>进程可以调用sys_ipc_try_send()向指定的进程发送“消息”，如果目标进程已经调用了sys_ipc_recv()，那么就发送数据，然后返回0，否则返回-E_IPC_NOT_RECV，表示目标进程不希望接受数据。当传入srcva参数时，表明发送进程希望和接收进程共享srcva对应的物理页。如果发送成功了发送进程的srcva和接收进程的dstva将指向相同的物理页</li>
</ol>
<p><strong>exercise15</strong></p>
<p>首先是两个系统调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_ipc_try_send(<span class="keyword">envid_t</span> envid, <span class="keyword">uint32_t</span> value, <span class="keyword">void</span> *srcva, <span class="keyword">unsigned</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="comment">//panic(&quot;sys_ipc_try_send not implemented&quot;);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Env</span>* <span class="title">rcvenv</span>;</span></span><br><span class="line">	<span class="keyword">int</span> ret = envid2env(envid,&amp;rcvenv,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret) <span class="keyword">return</span> ret;</span><br><span class="line">	<span class="keyword">if</span>(!rcvenv-&gt;env_ipc_recving) <span class="keyword">return</span> -E_IPC_NOT_RECV;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(srcva &lt; (<span class="keyword">void</span>*)UTOP)&#123;</span><br><span class="line">		<span class="keyword">pte_t</span> *pte;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">PageInfo</span> *<span class="title">pp</span> =</span> page_lookup(curenv-&gt;env_pgdir,srcva,&amp;pte);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//按注释顺序</span></span><br><span class="line">		<span class="keyword">if</span>(srcva != ROUNDDOWN(srcva,PGSIZE)) <span class="keyword">return</span> -E_INVAL;<span class="comment">//不是页对齐</span></span><br><span class="line">		<span class="keyword">if</span>((*pte &amp; perm) != perm) <span class="keyword">return</span> -E_INVAL; <span class="comment">//权限问题 perm应该是要包含于*pte中的</span></span><br><span class="line">		<span class="keyword">if</span> (!pp) <span class="keyword">return</span> -E_INVAL; <span class="comment">//src物理页未映射</span></span><br><span class="line">		<span class="keyword">if</span>((perm &amp; PTE_W) &amp;&amp; !(*pte &amp; PTE_W)) <span class="keyword">return</span> -E_INVAL; <span class="comment">//没有写权限</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(rcvenv-&gt;env_ipc_dstva &lt; (<span class="keyword">void</span>*)UTOP)&#123;</span><br><span class="line">			ret = page_insert(rcvenv-&gt;env_pgdir,pp,rcvenv-&gt;env_ipc_dstva,perm);<span class="comment">//共享相同的映射关系</span></span><br><span class="line">			<span class="keyword">if</span>(ret) <span class="keyword">return</span> ret;</span><br><span class="line">			rcvenv-&gt;env_ipc_perm = perm;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//send successed and update the target&#x27;s ipc</span></span><br><span class="line">	rcvenv-&gt;env_ipc_recving = <span class="number">0</span>;	<span class="comment">//标记接受进程可再次接受信息</span></span><br><span class="line">	rcvenv-&gt;env_ipc_from = curenv-&gt;env_id;</span><br><span class="line">	rcvenv-&gt;env_ipc_value = value;</span><br><span class="line">	rcvenv-&gt;env_status = ENV_RUNNABLE;</span><br><span class="line">	rcvenv-&gt;env_tf.tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sys_ipc_recv(<span class="keyword">void</span> *dstva)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="comment">//panic(&quot;sys_ipc_recv not implemented&quot;);</span></span><br><span class="line">	<span class="keyword">if</span>(dstva &lt; (<span class="keyword">void</span>*)UTOP)&#123;</span><br><span class="line">		<span class="keyword">if</span>(dstva != ROUNDDOWN(dstva,PGSIZE))&#123;</span><br><span class="line">			<span class="keyword">return</span> -E_INVAL;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	curenv-&gt;env_ipc_recving = <span class="number">1</span>;</span><br><span class="line">	curenv-&gt;env_status = ENV_NOT_RUNNABLE;</span><br><span class="line">	curenv-&gt;env_ipc_dstva = dstva;</span><br><span class="line">	sys_yield();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后把他们封装给用户态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">ipc_send(<span class="keyword">envid_t</span> to_env, <span class="keyword">uint32_t</span> val, <span class="keyword">void</span> *pg, <span class="keyword">int</span> perm)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="comment">//panic(&quot;ipc_send not implemented&quot;);</span></span><br><span class="line">	<span class="keyword">if</span>(pg == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		pg = (<span class="keyword">void</span>*)<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		r = sys_ipc_try_send(to_env,val,pg,perm);</span><br><span class="line">		<span class="keyword">if</span>(r == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="comment">//发送成功</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(r == -E_IPC_NOT_RECV)&#123;<span class="comment">//接受进程为准备好</span></span><br><span class="line">			sys_yield();</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			panic(<span class="string">&quot;ipc_send(): %e\n&quot;</span>,r);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int32_t</span></span><br><span class="line">ipc_recv(<span class="keyword">envid_t</span> *from_env_store, <span class="keyword">void</span> *pg, <span class="keyword">int</span> *perm_store)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// LAB 4: Your code here.</span></span><br><span class="line">	<span class="comment">//panic(&quot;ipc_recv not implemented&quot;);</span></span><br><span class="line">	<span class="keyword">if</span>(pg == <span class="literal">NULL</span>)&#123;</span><br><span class="line">		pg = (<span class="keyword">void</span>*)<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> r = sys_ipc_recv(pg);</span><br><span class="line">	<span class="keyword">if</span>(r &lt; <span class="number">0</span>)&#123; <span class="comment">//error</span></span><br><span class="line">		<span class="keyword">if</span>(from_env_store) *from_env_store = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(perm_store) *perm_store = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">return</span> r; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(from_env_store)&#123;</span><br><span class="line">		*from_env_store = thisenv-&gt;env_ipc_from;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(perm_store)&#123;</span><br><span class="line">		*perm_store = thisenv-&gt;env_ipc_perm;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> thisenv-&gt;env_ipc_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IPC总结图如下：</p>
<p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab4/lab4_5_IPC%E5%8E%9F%E7%90%86.png" alt="JOS IPC原理"></p>
<p>这里其实是有两个功能，传值和映射共同地址，但是映射地址的功能不一定是要用上的，具体怎么操作看代码和注释吧，注释写得挺详细的。</p>
<p><img src="https://inews.gtimg.com/newsapp_ls/0/13884924720/0" alt="image-20210815165636781"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本实现主要是围绕进程这个概念来展开的，主要介绍四部分：</p>
<ol>
<li><p><strong>支持多处理器</strong>。现代的处理器一般都是多核的，并且会有多个处理器，这样每个CPU能同时允许不同的进程，实现并行。。需要用锁解决多CPU的竞争。 CPU和进程在内核中的数据结构如下图所示：</p>
<p><img src="https://blog-1253119293.cos.ap-beijing.myqcloud.com/6.828/lab4/lab4_2_cpu%E5%92%8CEnv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="Env和CpuInfo关系"></p>
</li>
<li><p><strong>实现进程调度</strong>。 一种是非抢占式式的，另一种是抢占式的，借助时钟中断实现，时钟中断到来时，内核调用sched_yield()选择另一个Env结构执行。</p>
</li>
<li><p><strong>实现写时复制fork</strong>(进程创建)。fork是库函数，会调用sys_exofork这个系统调用，该系统调用在内核中为子进程创建一个新的Env结构，然后将父进程的寄存器状态复制给该Env结构，复制页表，对于PTE_W为1的页表，复制的同时，设置PTE_COW标志。为父进程和子进程设置缺页处理函数，处理逻辑就是：当缺页中断发生是因为写时拷贝的地址，分配一个新的物理页，然后将该虚拟地址映射到新的物理页。</p>
<p>原理图上面有</p>
</li>
<li><p><strong>实现进程间通信</strong>。本质还是进入内核修改Env结构的页映射关系。原理图见上。</p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">C7</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://billyotry.github.io/2021/08/08/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab4/">https://billyotry.github.io/2021/08/08/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab4/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://billyotry.github.io" target="_blank">C7</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/OS/">OS</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2099/01/01/test/"><img class="prev-cover" src="https://i.loli.net/2021/01/22/QJ1bzWyEp9IKx7R.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">这是标题</div></div></a></div><div class="next-post pull-right"><a href="/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise9/"><img class="next-cover" src="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【MIT 6.828】Lab3-Exercise9</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/02/28/【MIT6.828】Lab1-Exercise11/" title="【MIT6.828】Lab1-Exercise11"><img class="cover" src="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-28</div><div class="title">【MIT6.828】Lab1-Exercise11</div></div></a></div><div><a href="/2021/03/05/【MIT6.828】Lab1-Exercise12/" title="【MIT6.828】Lab1-Exercise12"><img class="cover" src="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-05</div><div class="title">【MIT6.828】Lab1-Exercise12</div></div></a></div><div><a href="/2021/01/22/【MIT6.828】Lab1-Exercise2/" title="【MIT 6.828】Lab1-Exercise2"><img class="cover" src="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-22</div><div class="title">【MIT 6.828】Lab1-Exercise2</div></div></a></div><div><a href="/2021/01/31/【MIT6.828】Lab1-Exercise6/" title="【MIT6.828】Lab1-Exercise6"><img class="cover" src="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-31</div><div class="title">【MIT6.828】Lab1-Exercise6</div></div></a></div><div><a href="/2021/01/30/【MIT6.828】Lab1-Exercise5/" title="【MIT6.828】Lab1-Exercise5"><img class="cover" src="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-30</div><div class="title">【MIT6.828】Lab1-Exercise5</div></div></a></div><div><a href="/2021/02/03/【MIT6.828】Lab1-Exercise9/" title="【MIT6.828】Lab1-Exercise9"><img class="cover" src="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-03</div><div class="title">【MIT6.828】Lab1-Exercise9</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">C7</div><div class="author-info__description">雖不能至 心嚮往之</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">48</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><a class="button--animated" id="card-info-btn"><i class="fa fa-paper-plane-o"></i><span>加入书签</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/BillyoTry" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1347405944@qq.com" target="_blank" title="Email"><i class="fa fa-envelope"></i></a><a class="social-icon" href="tencent://message/?uin=1347405944&amp;Site=&amp;Menu=yes" target="_blank" title=""><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">大家疫情期间注意保护自己噢~~~~</div></div><div class="sticky_layout"><div class="card-widget card-clock" style="padding:0"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="clock" style="padding:20px"><img v-if="clockshow == &quot;false&quot;" src="/clock/images/weather/loading.gif" style="height:120px;width:100%"/><table class="clock" v-if="clockshow"><tbody><tr><td class="clockdate">{{date}}</td><td class="weatherimg" align="center" valign="middle"><img id="weatherimg" :src="weatherimg"/></td><td class="temperature" align="center" valign="middle">{{temperature}}</td><td class="humidityimg"><img id="humidityimg" :src="humidityimg"/></td><td class="humidity">{{humidity}}</td></tr><tr class="time"><td colspan="5">{{time}}</td></tr><tr><td class="usaqi" colspan="1"> <span>{{ip}}</span></td><td class="city" colspan="2">{{city}}</td><td class="daylight" colspan="2">{{daylight}}</td></tr></tbody></table></div></div></div></div></div><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-A-Multiprocessor-Support-and-Cooperative-Multitasking"><span class="toc-number">1.</span> <span class="toc-text">Part A: Multiprocessor Support and Cooperative Multitasking</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Multiprocessor-Support"><span class="toc-number">1.1.</span> <span class="toc-text">Multiprocessor Support</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Application-Processor-Bootstrap"><span class="toc-number">1.1.1.</span> <span class="toc-text">Application Processor Bootstrap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Per-CPU-State-and-Initialization"><span class="toc-number">1.1.2.</span> <span class="toc-text">Per-CPU State and Initialization</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Locking"><span class="toc-number">1.1.3.</span> <span class="toc-text">Locking</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Round-Robin-Scheduling"><span class="toc-number">1.2.</span> <span class="toc-text">Round-Robin Scheduling</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#System-Calls-for-Environment-Creation"><span class="toc-number">1.3.</span> <span class="toc-text">System Calls for Environment Creation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-B-Copy-on-Write-Fork"><span class="toc-number">2.</span> <span class="toc-text">Part B: Copy-on-Write Fork</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#User-level-page-fault-handling"><span class="toc-number">2.1.</span> <span class="toc-text">User-level page fault handling</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Normal-and-Exception-Stacks-in-User-Environments"><span class="toc-number">2.1.1.</span> <span class="toc-text">Normal and Exception Stacks in User Environments</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Invoking-the-User-Page-Fault-Handler"><span class="toc-number">2.1.2.</span> <span class="toc-text">Invoking the User Page Fault Handler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#User-mode-Page-Fault-Entrypoint"><span class="toc-number">2.1.3.</span> <span class="toc-text">User-mode Page Fault Entrypoint</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%A1%B5%E5%A4%84%E7%90%86%E5%B0%8F%E7%BB%93%EF%BC%9A"><span class="toc-number">2.1.4.</span> <span class="toc-text">缺页处理小结：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Implementing-Copy-on-Write-Fork"><span class="toc-number">2.2.</span> <span class="toc-text">Implementing Copy-on-Write Fork</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Part-C-Preemptive-Multitasking-and-Inter-Process-communication-IPC"><span class="toc-number">3.</span> <span class="toc-text">Part C: Preemptive Multitasking and Inter-Process communication (IPC)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Clock-Interrupts-and-Preemption"><span class="toc-number">3.1.</span> <span class="toc-text">Clock Interrupts and Preemption</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Interrupt-discipline"><span class="toc-number">3.1.1.</span> <span class="toc-text">Interrupt discipline</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Handling-Clock-Interrupts"><span class="toc-number">3.1.2.</span> <span class="toc-text">Handling Clock Interrupts</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Inter-Process-communication-IPC"><span class="toc-number">3.2.</span> <span class="toc-text">Inter-Process communication (IPC)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IPC-in-JOS"><span class="toc-number">3.2.1.</span> <span class="toc-text">IPC in JOS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sending-and-Receiving-Messages"><span class="toc-number">3.2.2.</span> <span class="toc-text">Sending and Receiving Messages</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.3.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2099/01/01/test/" title="这是标题"><img src="https://i.loli.net/2021/01/22/QJ1bzWyEp9IKx7R.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="这是标题"/></a><div class="content"><a class="title" href="/2099/01/01/test/" title="这是标题">这是标题</a><time datetime="2098-12-31T16:00:00.000Z" title="发表于 2099-01-01 00:00:00">2099-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/08/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab4/" title="【MIT 6.828】JOS学习笔记 Lab4"><img src="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【MIT 6.828】JOS学习笔记 Lab4"/></a><div class="content"><a class="title" href="/2021/08/08/%E3%80%90MIT6.828%E3%80%91JOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%20Lab4/" title="【MIT 6.828】JOS学习笔记 Lab4">【MIT 6.828】JOS学习笔记 Lab4</a><time datetime="2021-08-08T14:12:16.641Z" title="发表于 2021-08-08 22:12:16">2021-08-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise9/" title="【MIT 6.828】Lab3-Exercise9"><img src="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【MIT 6.828】Lab3-Exercise9"/></a><div class="content"><a class="title" href="/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise9/" title="【MIT 6.828】Lab3-Exercise9">【MIT 6.828】Lab3-Exercise9</a><time datetime="2021-08-06T15:31:41.615Z" title="发表于 2021-08-06 23:31:41">2021-08-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise7/" title="【MIT 6.828】Lab3-Exercise7"><img src="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【MIT 6.828】Lab3-Exercise7"/></a><div class="content"><a class="title" href="/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise7/" title="【MIT 6.828】Lab3-Exercise7">【MIT 6.828】Lab3-Exercise7</a><time datetime="2021-08-06T08:07:46.281Z" title="发表于 2021-08-06 16:07:46">2021-08-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise6/" title="【MIT 6.828】Lab3-Exercise6"><img src="https://i.loli.net/2021/01/23/jvHCWeyMJIhQn2f.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="【MIT 6.828】Lab3-Exercise6"/></a><div class="content"><a class="title" href="/2021/08/06/%E3%80%90MIT6.828%E3%80%91Lab3-Exercise6/" title="【MIT 6.828】Lab3-Exercise6">【MIT 6.828】Lab3-Exercise6</a><time datetime="2021-08-06T05:26:10.781Z" title="发表于 2021-08-06 13:26:10">2021-08-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By C7</div><div class="footer_custom_text"><p><a style="margin-inline:5px" target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a><a style="margin-inline:5px" target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a><a style="margin-inline:5px" target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a><a style="margin-inline:5px" target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a><a style="margin-inline:5px" target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a><a style="margin-inline:5px" target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a><a style="margin-inline:5px" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: '',
      appKey: '',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign(initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="/js/unbanner.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script src="/clock/js/clock.js"></script><script async src="//at.alicdn.com/t/font_2264842_3izu8i5eoc2.js"></script><script async src="/js/xktool.js"></script><script async src="/js/fish.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>