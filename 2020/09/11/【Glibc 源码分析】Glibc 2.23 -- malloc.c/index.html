<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>C7 | C7</title><meta name="author" content="C7"><meta name="copyright" content="C7"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="源码来自:https:&#x2F;&#x2F;elixir.bootlin.com&#x2F;glibc&#x2F;glibc-2.23&#x2F;source&#x2F;malloc&#x2F;malloc.c MMAP support&#x2F;* ------------------ MMAP support ------------------  *&#x2F;#include &lt;fcntl.h&gt;#include &lt;sys&#x2F;mman.h&gt;#if !def">
<meta property="og:type" content="article">
<meta property="og:title" content="C7">
<meta property="og:url" content="https://billyotry.github.io/2020/09/11/%E3%80%90Glibc%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91Glibc%202.23%20--%20malloc.c/index.html">
<meta property="og:site_name" content="C7">
<meta property="og:description" content="源码来自:https:&#x2F;&#x2F;elixir.bootlin.com&#x2F;glibc&#x2F;glibc-2.23&#x2F;source&#x2F;malloc&#x2F;malloc.c MMAP support&#x2F;* ------------------ MMAP support ------------------  *&#x2F;#include &lt;fcntl.h&gt;#include &lt;sys&#x2F;mman.h&gt;#if !def">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/04/14/s8lQEMGd2KVD6Fx.png">
<meta property="article:published_time" content="2020-09-10T16:03:33.395Z">
<meta property="article:modified_time" content="2020-09-14T07:54:39.045Z">
<meta property="article:author" content="C7">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/04/14/s8lQEMGd2KVD6Fx.png"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://billyotry.github.io/2020/09/11/%E3%80%90Glibc%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91Glibc%202.23%20--%20malloc.c/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

const saveToLocal = {
  // ttl 單位是 天
  set: function setWithExpiry(key, value, ttl) {
    if (ttl === 0) return
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-09-14 15:54:39'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><link rel="stylesheet" href="/clock/css/clock.css"/><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/css/MonoFonts.addition.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/StaticFile_HEXO@latest/butterfly/css/macWhite.css"><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="C7" type="application/atom+xml">
<link rel="alternate" href="/rss2.xml" title="C7" type="application/rss+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="no-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">C7</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-09-10T16:03:33.395Z" title="发表于 2020-09-11 00:03:33">2020-09-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-09-14T07:54:39.045Z" title="更新于 2020-09-14 15:54:39">2020-09-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><p>源码来自:<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c">https://elixir.bootlin.com/glibc/glibc-2.23/source/malloc/malloc.c</a></p>
<h2 id="MMAP-support"><a href="#MMAP-support" class="headerlink" title="MMAP support"></a>MMAP support</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ------------------ MMAP support ------------------  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(MAP_ANONYMOUS) &amp;&amp; defined(MAP_ANON)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAP_ANONYMOUS MAP_ANON</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MAP_NORESERVE</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAP_NORESERVE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMAP(addr, size, prot, flags) \</span></span><br><span class="line"> __mmap((addr), (size), (prot), (flags)|MAP_ANONYMOUS|MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Chunk-representations"><a href="#Chunk-representations" class="headerlink" title="Chunk representations"></a>Chunk representations</h2><h3 id="malloc-chunk-结构体"><a href="#malloc-chunk-结构体" class="headerlink" title="malloc_chunk 结构体"></a>malloc_chunk 结构体</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  -----------------------  Chunk representations -----------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们在前面可以看见<code>#define INTERNAL_SIZE_T size_t</code>也就是说在64位的机器上，这个类型就是<code>unsigned long</code>类型</p>
<p>prev_size： 如果前一个块处于空闲状态，那么该值为前一个块的大小</p>
<p>size：记录当前块的大小</p>
<p>fd：当前块空闲时指向后一个空闲的chunk</p>
<p>bk：当前块空闲时指向前一个空闲的chunk</p>
<p>fd_nextsize：记录 large bin 的前驱节点</p>
<p>bk_nextsize：记录 large bin 的后继节点</p>
<h3 id="malloc-chunk-的细节"><a href="#malloc-chunk-的细节" class="headerlink" title="malloc_chunk 的细节"></a>malloc_chunk 的细节</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   malloc_chunk details:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (The following includes lightly edited explanations by Colin Plumb.)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks of memory are maintained using a `boundary tag&#x27; method as</span></span><br><span class="line"><span class="comment">    described in e.g., Knuth or Standish.  (See the paper by Paul</span></span><br><span class="line"><span class="comment">    Wilson ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a</span></span><br><span class="line"><span class="comment">    survey of such techniques.)  Sizes of free chunks are stored both</span></span><br><span class="line"><span class="comment">    in the front of each chunk and at the end.  This makes</span></span><br><span class="line"><span class="comment">    consolidating fragmented chunks into bigger chunks very fast.  The</span></span><br><span class="line"><span class="comment">    size fields also hold bits representing whether chunks are free or</span></span><br><span class="line"><span class="comment">    in use.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    An allocated chunk looks like this:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Size of previous chunk, if allocated            | |</span></span><br><span class="line"><span class="comment">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Size of chunk, in bytes                       |M|P|</span></span><br><span class="line"><span class="comment">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             User data starts here...                          .</span></span><br><span class="line"><span class="comment">       .                                                               .</span></span><br><span class="line"><span class="comment">       .             (malloc_usable_size() bytes)                      .</span></span><br><span class="line"><span class="comment">       .                                                               |</span></span><br><span class="line"><span class="comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Size of chunk                                     |</span></span><br><span class="line"><span class="comment">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Where &quot;chunk&quot; is the front of the chunk for the purpose of most of</span></span><br><span class="line"><span class="comment">    the malloc code, but &quot;mem&quot; is the pointer that is returned to the</span></span><br><span class="line"><span class="comment">    user.  &quot;Nextchunk&quot; is the beginning of the next contiguous chunk.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks always begin on even word boundaries, so the mem portion</span></span><br><span class="line"><span class="comment">    (which is returned to the user) is also on an even word boundary, and</span></span><br><span class="line"><span class="comment">    thus at least double-word aligned.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Free chunks are stored in circular doubly-linked lists, and look like this:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Size of previous chunk                            |</span></span><br><span class="line"><span class="comment">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    `head:&#x27; |             Size of chunk, in bytes                         |P|</span></span><br><span class="line"><span class="comment">      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Forward pointer to next chunk in list             |</span></span><br><span class="line"><span class="comment">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Back pointer to previous chunk in list            |</span></span><br><span class="line"><span class="comment">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">       |             Unused space (may be 0 bytes long)                .</span></span><br><span class="line"><span class="comment">       .                                                               .</span></span><br><span class="line"><span class="comment">       .                                                               |</span></span><br><span class="line"><span class="comment">nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment">    `foot:&#x27; |             Size of chunk, in bytes                           |</span></span><br><span class="line"><span class="comment">       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The P (PREV_INUSE) bit, stored in the unused low-order bit of the</span></span><br><span class="line"><span class="comment">    chunk size (which is always a multiple of two words), is an in-use</span></span><br><span class="line"><span class="comment">    bit for the *previous* chunk.  If that bit is *clear*, then the</span></span><br><span class="line"><span class="comment">    word before the current chunk size contains the previous chunk</span></span><br><span class="line"><span class="comment">    size, and can be used to find the front of the previous chunk.</span></span><br><span class="line"><span class="comment">    The very first chunk allocated always has this bit set,</span></span><br><span class="line"><span class="comment">    preventing access to non-existent (or non-owned) memory. If</span></span><br><span class="line"><span class="comment">    prev_inuse is set for any given chunk, then you CANNOT determine</span></span><br><span class="line"><span class="comment">    the size of the previous chunk, and might even get a memory</span></span><br><span class="line"><span class="comment">    addressing fault when trying to do so.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Note that the `foot&#x27; of the current chunk is actually represented</span></span><br><span class="line"><span class="comment">    as the prev_size of the NEXT chunk. This makes it easier to</span></span><br><span class="line"><span class="comment">    deal with alignments etc but can be very confusing when trying</span></span><br><span class="line"><span class="comment">    to extend or adapt this code.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The two exceptions to all this are</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     1. The special chunk `top&#x27; doesn&#x27;t bother using the</span></span><br><span class="line"><span class="comment">   trailing size field since there is no next contiguous chunk</span></span><br><span class="line"><span class="comment">   that would have to index off it. After initialization, `top&#x27;</span></span><br><span class="line"><span class="comment">   is forced to always exist.  If it would become less than</span></span><br><span class="line"><span class="comment">   MINSIZE bytes long, it is replenished.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     2. Chunks allocated via mmap, which have the second-lowest-order</span></span><br><span class="line"><span class="comment">   bit M (IS_MMAPPED) set in their size fields.  Because they are</span></span><br><span class="line"><span class="comment">   allocated one-by-one, each must contain its own trailing size field.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="Size-and-alignment-checks-and-conversions"><a href="#Size-and-alignment-checks-and-conversions" class="headerlink" title="Size and alignment checks and conversions"></a>Size and alignment checks and conversions</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* conversion from malloc headers to user pointers, and back */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span></span><br></pre></td></tr></table></figure>
<p>该宏的作用是找到堆块 p 内用来存储 fd 指针的地址</p>
<p>说白了 <code>p</code> 就是用来存储当前堆块 <code>prev_size</code> 的地址，但是我们要的不是存储当前堆块 <code>prev_size</code> 和 <code>size</code> 的地址</p>
<p>用户输入的内容都是存储到<strong>那个存储 fd 指针的地址</strong>，也就是存储 size 的地址的下一个地址</p>
<p>fd 和 bk 都是在堆块空闲的时候才会存储在这个地址上，当堆块正在别使用的时候就是正常的存储区域</p>
<h3 id="mem2chunk-mem-宏"><a href="#mem2chunk-mem-宏" class="headerlink" title="mem2chunk(mem) 宏"></a>mem2chunk(mem) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span></span><br></pre></td></tr></table></figure>
<p>该宏的作用和 <strong>chunk2mem 宏</strong>是反过来的</p>
<p>由堆块内用于给用户输入的存储区地址找到堆块的起始地址，也就是用于存储当前堆块 prev_size 的地址</p>
<h3 id="MIN-CHUNK-SIZE-宏"><a href="#MIN-CHUNK-SIZE-宏" class="headerlink" title="MIN_CHUNK_SIZE 宏"></a>MIN_CHUNK_SIZE 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The smallest possible chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))</span></span><br></pre></td></tr></table></figure>
<p>首先要了解 <strong>offsetof 宏</strong>的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> offsetof(type,ident) ((size_t)&amp;(((type*)0)-&gt;ident))</span></span><br></pre></td></tr></table></figure>
<p>该宏通过一个结构体中的元素来获取该结构体的其实地址到该元素之间的距离</p>
<p>该宏的作用是规定一整个 chunk 的最小值是多少，包括 prev_size 域和 size 域</p>
<p>由此可以知道，在 32 位系统下，MIN_CHUNK_SIZE 的值大小是 0x10字节</p>
<p>在 64 位系统下，MIN_CHUNK_SIZE 的值大小是 0x20字节</p>
<h3 id="MINSIZE-宏"><a href="#MINSIZE-宏" class="headerlink" title="MINSIZE 宏"></a>MINSIZE 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The smallest size we can malloc is an aligned minimal chunk */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINSIZE  \</span></span><br><span class="line">  (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span><br></pre></td></tr></table></figure>
<p>该宏用来规定最小的堆块的可用空间，也就是说申请的堆块至少有 MINSIZE 的大小</p>
<p>在 32 位下，MINSIZE 的值为0x10字节</p>
<p>在 64 位下，MINSIZE 的值为0x20字节</p>
<h3 id="aligned-OK-m-宏"><a href="#aligned-OK-m-宏" class="headerlink" title="aligned_OK(m) 宏"></a>aligned_OK(m) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Check if m has acceptable alignment */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br></pre></td></tr></table></figure>
<p>该宏用来判断申请到的堆块中的地址是否为对齐的地址</p>
<h3 id="misaligned-chunk-p-宏"><a href="#misaligned-chunk-p-宏" class="headerlink" title="misaligned_chunk(p) 宏"></a>misaligned_chunk(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> misaligned_chunk(p) \</span></span><br><span class="line">  ((<span class="keyword">uintptr_t</span>)(MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ ? (p) : chunk2mem (p)) \</span><br><span class="line">   &amp; MALLOC_ALIGN_MASK)</span><br></pre></td></tr></table></figure>
<p>如果 <code>MALLOC_ALIGNMENT == 2 * SIZE_SZ</code></p>
<p>即如果 <code>long double</code> 对齐所需要的字节大于 <code>2 * sizeof(size_t)</code></p>
<p>则返回 p 的地址，也就是堆块的起始地址；否则返回该堆块 fd 指针所在的地址</p>
<p>一般的架构返回 <code>chunk2mem (p)</code> 的</p>
<h3 id="REQUEST-OUT-OF-RANGE-req-宏（缺）"><a href="#REQUEST-OUT-OF-RANGE-req-宏（缺）" class="headerlink" title="REQUEST_OUT_OF_RANGE(req) 宏（缺）"></a>REQUEST_OUT_OF_RANGE(req) 宏（缺）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Check if a request is so large that it would wrap around zero when</span></span><br><span class="line"><span class="comment">   padded and aligned. To simplify some other code, the bound is made</span></span><br><span class="line"><span class="comment">   low enough so that adding MINSIZE will also not wrap around zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                 \</span></span><br><span class="line">  ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (req) &gt;=                         \</span><br><span class="line">   (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (INTERNAL_SIZE_T) (<span class="number">-2</span> * MINSIZE))</span><br></pre></td></tr></table></figure>
<p>待补充</p>
<h3 id="request2size-req-宏（缺）"><a href="#request2size-req-宏（缺）" class="headerlink" title="request2size(req) 宏（缺）"></a>request2size(req) 宏（缺）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request2size(req)                                         \</span></span><br><span class="line">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span><br><span class="line">   MINSIZE :                                                      \</span><br><span class="line">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br></pre></td></tr></table></figure>
<p>待补充</p>
<h3 id="checked-request2size-req-sz-宏（缺）"><a href="#checked-request2size-req-sz-宏（缺）" class="headerlink" title="checked_request2size(req, sz) 宏（缺）"></a>checked_request2size(req, sz) 宏（缺）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  Same, except also perform argument check */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> checked_request2size(req, sz)                             \</span></span><br><span class="line">  <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE (req)) &#123;                      \</span><br><span class="line">      __set_errno (ENOMEM);                         \</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;                               \</span><br><span class="line">    &#125;                                \</span><br><span class="line">  (sz) = request2size (req);</span><br></pre></td></tr></table></figure>
<p>待补充</p>
<h2 id="Physical-chunk-operations"><a href="#Physical-chunk-operations" class="headerlink" title="Physical chunk operations"></a>Physical chunk operations</h2><h3 id="PREV-INUSE-宏"><a href="#PREV-INUSE-宏" class="headerlink" title="PREV_INUSE 宏"></a>PREV_INUSE 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* size field is or&#x27;ed with PREV_INUSE when previous adjacent chunk in use */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_INUSE 0x1</span></span><br></pre></td></tr></table></figure>
<p>该宏的意思是当前堆块的前一个堆块处于非空闲状态，规定值为 0x1</p>
<h3 id="prev-inuse-p-宏"><a href="#prev-inuse-p-宏" class="headerlink" title="prev_inuse(p) 宏"></a>prev_inuse(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* extract inuse bit of previous chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_inuse(p)       ((p)-&gt;size &amp; PREV_INUSE)</span></span><br></pre></td></tr></table></figure>
<p>检查前一个堆块是否处于空闲状态</p>
<p>如果前一个堆块处于非空闲状态，则返回 0x1，否则返回 0</p>
<h3 id="IS-MMAPPED-宏"><a href="#IS-MMAPPED-宏" class="headerlink" title="IS_MMAPPED 宏"></a>IS_MMAPPED 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* size field is or&#x27;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IS_MMAPPED 0x2</span></span><br></pre></td></tr></table></figure>
<p>该宏的意思的当前的堆块是通过 mmap() 得到的</p>
<h3 id="chunk-is-mmapped-p-宏"><a href="#chunk-is-mmapped-p-宏" class="headerlink" title="chunk_is_mmapped(p) 宏"></a>chunk_is_mmapped(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* check for mmap()&#x27;ed chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;size &amp; IS_MMAPPED)</span></span><br></pre></td></tr></table></figure>
<p>检查当前堆块是否是通过 mmap() 得到的</p>
<p>如果是 mmap() 得到的，那么返回 0x2，否则返回 0</p>
<h3 id="NON-MAIN-ARENA-宏"><a href="#NON-MAIN-ARENA-宏" class="headerlink" title="NON_MAIN_ARENA 宏"></a>NON_MAIN_ARENA 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* size field is or&#x27;ed with NON_MAIN_ARENA if the chunk was obtained</span></span><br><span class="line"><span class="comment">   from a non-main arena.  This is only set immediately before handing</span></span><br><span class="line"><span class="comment">   the chunk to the user, if necessary.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NON_MAIN_ARENA 0x4</span></span><br></pre></td></tr></table></figure>
<p>该宏的意思是当前 chunk 不属于主线程</p>
<h3 id="chunk-non-main-arena-p-宏"><a href="#chunk-non-main-arena-p-宏" class="headerlink" title="chunk_non_main_arena(p) 宏"></a>chunk_non_main_arena(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* check for chunk from non-main arena */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_non_main_arena(p) ((p)-&gt;size &amp; NON_MAIN_ARENA)</span></span><br></pre></td></tr></table></figure>
<p>检查当前 chunk 是否属于主线程</p>
<p>如果不属于主线程，那么返回 0x4，否则返回 0</p>
<h3 id="SIZE-BITS-宏"><a href="#SIZE-BITS-宏" class="headerlink" title="SIZE_BITS 宏"></a>SIZE_BITS 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Bits to mask off when extracting size</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Note: IS_MMAPPED is intentionally not masked off from size field in</span></span><br><span class="line"><span class="comment">   macros for which mmapped chunks should never be seen. This should</span></span><br><span class="line"><span class="comment">   cause helpful core dumps to occur if it is tried by accident by</span></span><br><span class="line"><span class="comment">   people extending or adapting this malloc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br></pre></td></tr></table></figure>
<p>表面看这个宏的返回值就是 7，也就是 <code>111B</code>，作用在下面的宏中有体现</p>
<h3 id="chunksize-p-宏"><a href="#chunksize-p-宏" class="headerlink" title="chunksize(p) 宏"></a>chunksize(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p)         ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br></pre></td></tr></table></figure>
<p>得到堆块 p 中的 size 位的值，因为堆块是对齐的，所以后三位没有用而且也不算大小</p>
<p>此处清空后三位</p>
<h3 id="next-chunk-p-宏"><a href="#next-chunk-p-宏" class="headerlink" title="next_chunk(p) 宏"></a>next_chunk(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Ptr to next physical malloc_chunk. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_chunk(p) ((mchunkptr) (((char *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))</span></span><br></pre></td></tr></table></figure>
<p>mchunkptr 结构体指针变量的定义：<code>typedef struct malloc_chunk* mchunkptr;</code></p>
<p>该宏的作用就是得到当前堆块的下一个堆块的地址</p>
<p>代码的意思就是用<strong>当前堆</strong> p 的地址加上<strong>当前堆</strong>大小 size ，那么得到的值就是下一个堆块的地址了</p>
<h3 id="prev-chunk-p-宏"><a href="#prev-chunk-p-宏" class="headerlink" title="prev_chunk(p) 宏"></a>prev_chunk(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Ptr to previous physical malloc_chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_chunk(p) ((mchunkptr) (((char *) (p)) - ((p)-&gt;prev_size)))</span></span><br></pre></td></tr></table></figure>
<p>该宏的作用就是得到当前堆块的前一个堆块的地址</p>
<p>代码的意思就是用<strong>当前堆</strong> p 的地址减去<strong>前一个堆</strong>大小 size，那么得到的值就是前一个堆块的地址</p>
<p>不过 pre_size 只有在前一个堆块处于空闲状态的时候才会在当前堆块中有值</p>
<h3 id="chunk-at-offset-p-s-宏"><a href="#chunk-at-offset-p-s-宏" class="headerlink" title="chunk_at_offset(p, s) 宏"></a>chunk_at_offset(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Treat space at ptr + offset as a chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span></span><br></pre></td></tr></table></figure>
<p>也是获得一个堆块的地址，不过是通过指定偏移大小的方式</p>
<h3 id="inuse-p-宏"><a href="#inuse-p-宏" class="headerlink" title="inuse(p) 宏"></a>inuse(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* extract p&#x27;s inuse bit */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse(p)                           \</span></span><br><span class="line">  ((((mchunkptr) (((<span class="keyword">char</span> *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size) &amp; PREV_INUSE)</span><br></pre></td></tr></table></figure>
<p>获取下一个堆块的 PREV_INUSE 位，也就是说该宏是用来判断当前堆块是否处于空闲状态的</p>
<p>若是处于空闲状态就返回1，否则返回 0</p>
<h3 id="set-inuse-p-宏"><a href="#set-inuse-p-宏" class="headerlink" title="set_inuse(p) 宏"></a>set_inuse(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* set/clear chunk as being inuse without otherwise disturbing */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_inuse(p)                           \</span></span><br><span class="line">  ((mchunkptr) (((<span class="keyword">char</span> *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size |= PREV_INUSE</span><br></pre></td></tr></table></figure>
<p>这个宏的作用就是通过当前堆块的大小及地址得到下一个堆块的地址</p>
<p>然后将下一个堆块的 PREV_INUSE 位设置为 1</p>
<h3 id="clear-inuse-p-宏"><a href="#clear-inuse-p-宏" class="headerlink" title="clear_inuse(p) 宏"></a>clear_inuse(p) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clear_inuse(p)                          \</span></span><br><span class="line">  ((mchunkptr) (((<span class="keyword">char</span> *) (p)) + ((p)-&gt;size &amp; ~SIZE_BITS)))-&gt;size &amp;= ~(PREV_INUSE)</span><br></pre></td></tr></table></figure>
<p>该函数的作用是清除掉 PREV_INUSE 位，<code>~(PREV_INUSE)</code> 的值是 -2</p>
<h3 id="inuse-bit-at-offset-p-s-宏"><a href="#inuse-bit-at-offset-p-s-宏" class="headerlink" title="inuse_bit_at_offset(p, s) 宏"></a>inuse_bit_at_offset(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* check/set/clear inuse bits in known places */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inuse_bit_at_offset(p, s)                    \</span></span><br><span class="line">  (((mchunkptr) (((<span class="keyword">char</span> *) (p)) + (s)))-&gt;size &amp; PREV_INUSE)</span><br></pre></td></tr></table></figure>
<p>类似于 <code>inuse(p)</code> 宏，区别是它可以自己指定偏移</p>
<h3 id="set-inuse-bit-at-offset-p-s-宏"><a href="#set-inuse-bit-at-offset-p-s-宏" class="headerlink" title="set_inuse_bit_at_offset(p, s) 宏"></a>set_inuse_bit_at_offset(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_inuse_bit_at_offset(p, s)                     \</span></span><br><span class="line">  (((mchunkptr) (((<span class="keyword">char</span> *) (p)) + (s)))-&gt;size |= PREV_INUSE)</span><br></pre></td></tr></table></figure>
<p>类似于 <code>set_inuse(p)</code> 宏，区别是它可以自己指定偏移</p>
<h3 id="clear-inuse-bit-at-offset-p-s-宏"><a href="#clear-inuse-bit-at-offset-p-s-宏" class="headerlink" title="clear_inuse_bit_at_offset(p, s) 宏"></a>clear_inuse_bit_at_offset(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clear_inuse_bit_at_offset(p, s)                   \</span></span><br><span class="line">  (((mchunkptr) (((<span class="keyword">char</span> *) (p)) + (s)))-&gt;size &amp;= ~(PREV_INUSE))</span><br></pre></td></tr></table></figure>
<p>类似于 <code>clear_inuse(p)</code> 宏，区别是它可以自己指定偏移</p>
<h3 id="set-head-size-p-s-宏"><a href="#set-head-size-p-s-宏" class="headerlink" title="set_head_size(p, s) 宏"></a>set_head_size(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set size at head, without disturbing its use bit */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_head_size(p, s)  ((p)-&gt;size = (((p)-&gt;size &amp; SIZE_BITS) | (s)))</span></span><br></pre></td></tr></table></figure>
<p>在堆块 p 的 size 位设置该堆块的大小，并且<strong>不会</strong>影响到该堆块的使用位</p>
<h3 id="set-head-p-s-宏"><a href="#set-head-p-s-宏" class="headerlink" title="set_head(p, s) 宏"></a>set_head(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set size/use field */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_head(p, s)       ((p)-&gt;size = (s))</span></span><br></pre></td></tr></table></figure>
<p>在堆块 p 的 size 位设置该堆块的大小，该方法<strong>会</strong>影响到该堆块的使用位</p>
<h3 id="set-foot-p-s-宏"><a href="#set-foot-p-s-宏" class="headerlink" title="set_foot(p, s) 宏"></a>set_foot(p, s) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set size at footer (only when chunk is not in use) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))-&gt;prev_size = (s))</span></span><br></pre></td></tr></table></figure>
<p>设置下一个堆块的 prev_size 位，该宏只有在当前堆块为空闲堆块时才会使用</p>
<p>看样子这个宏是专门在下一个堆块的 prev_size 位设置当前堆块的大小的</p>
<p>而且就算是该堆块的地址被申请回来了，那么下一个堆块的 prev_size位也不会改变</p>
<h2 id="Internal-data-structures"><a href="#Internal-data-structures" class="headerlink" title="Internal data structures"></a>Internal data structures</h2><h3 id="mbinptr-结构体指针变量"><a href="#mbinptr-结构体指针变量" class="headerlink" title="mbinptr 结构体指针变量"></a>mbinptr 结构体指针变量</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   -------------------- Internal data structures --------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   All internal state is held in an instance of malloc_state defined</span></span><br><span class="line"><span class="comment">   below. There are no other static variables, except in two optional</span></span><br><span class="line"><span class="comment">   cases:</span></span><br><span class="line"><span class="comment"> * If USE_MALLOC_LOCK is defined, the mALLOC_MUTEx declared above.</span></span><br><span class="line"><span class="comment"> * If mmap doesn&#x27;t support MAP_ANONYMOUS, a dummy file descriptor</span></span><br><span class="line"><span class="comment">     for mmap.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Beware of lots of tricks that minimize the total bookkeeping space</span></span><br><span class="line"><span class="comment">   requirements. The result is a little over 1K bytes (for 4byte</span></span><br><span class="line"><span class="comment">   pointers and size_t.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Bins</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    An array of bin headers for free chunks. Each bin is doubly</span></span><br><span class="line"><span class="comment">    linked.  The bins are approximately proportionally (log) spaced.</span></span><br><span class="line"><span class="comment">    There are a lot of these bins (128). This may look excessive, but</span></span><br><span class="line"><span class="comment">    works very well in practice.  Most bins hold sizes that are</span></span><br><span class="line"><span class="comment">    unusual as malloc request sizes, but are more usual for fragments</span></span><br><span class="line"><span class="comment">    and consolidated sets of chunks, which is what these bins hold, so</span></span><br><span class="line"><span class="comment">    they can be found quickly.  All procedures maintain the invariant</span></span><br><span class="line"><span class="comment">    that no consolidated chunk physically borders another one, so each</span></span><br><span class="line"><span class="comment">    chunk in a list is known to be preceeded and followed by either</span></span><br><span class="line"><span class="comment">    inuse chunks or the ends of memory.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks in bins are kept in size order, with ties going to the</span></span><br><span class="line"><span class="comment">    approximately least recently used chunk. Ordering isn&#x27;t needed</span></span><br><span class="line"><span class="comment">    for the small bins, which all contain the same-sized chunks, but</span></span><br><span class="line"><span class="comment">    facilitates best-fit allocation for larger chunks. These lists</span></span><br><span class="line"><span class="comment">    are just sequential. Keeping them in order almost never requires</span></span><br><span class="line"><span class="comment">    enough traversal to warrant using fancier ordered data</span></span><br><span class="line"><span class="comment">    structures.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Chunks of the same size are linked with the most</span></span><br><span class="line"><span class="comment">    recently freed at the front, and allocations are taken from the</span></span><br><span class="line"><span class="comment">    back.  This results in LRU (FIFO) allocation order, which tends</span></span><br><span class="line"><span class="comment">    to give each chunk an equal opportunity to be consolidated with</span></span><br><span class="line"><span class="comment">    adjacent freed chunks, resulting in larger free chunks and less</span></span><br><span class="line"><span class="comment">    fragmentation.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    To simplify use in double-linked lists, each bin header acts</span></span><br><span class="line"><span class="comment">    as a malloc_chunk. This avoids special-casing for headers.</span></span><br><span class="line"><span class="comment">    But to conserve space and improve locality, we allocate</span></span><br><span class="line"><span class="comment">    only the fd/bk pointers of bins, and then use repositioning tricks</span></span><br><span class="line"><span class="comment">    to treat these as the fields of a malloc_chunk*.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mbinptr</span>;</span></span><br></pre></td></tr></table></figure>
<p>跟 <code>mchunkptr</code> 差不多，不过是用在 bin（空闲堆块）里的</p>
<h3 id="bin-at-m-i-宏"><a href="#bin-at-m-i-宏" class="headerlink" title="bin_at(m, i) 宏"></a>bin_at(m, i) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bin_at(m, i) \</span></span><br><span class="line">  (mbinptr) (((<span class="keyword">char</span> *) &amp;((m)-&gt;bins[((i) - <span class="number">1</span>) * <span class="number">2</span>]))                \</span><br><span class="line">             - offsetof (struct malloc_chunk, fd))</span><br></pre></td></tr></table></figure>
<p>该宏用于获得某种类型的 bins 的某一个 bin 的地址，且该 bins 的基地址下标是 1 ，而不能是 0</p>
<h3 id="next-bin-b-宏（缺具体）"><a href="#next-bin-b-宏（缺具体）" class="headerlink" title="next_bin(b) 宏（缺具体）"></a>next_bin(b) 宏（缺具体）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* analog of ++bin */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_bin(b)  ((mbinptr) ((char *) (b) + (sizeof (mchunkptr) &lt;&lt; 1)))</span></span><br></pre></td></tr></table></figure>
<p>获取下一个 bin 的地址</p>
<h3 id="first-b-宏"><a href="#first-b-宏" class="headerlink" title="first(b) 宏"></a>first(b) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Reminders about list directionality within bins */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> first(b)     ((b)-&gt;fd)</span></span><br></pre></td></tr></table></figure>
<p>获取 bin 中的 fd 指针</p>
<h3 id="last-b-宏"><a href="#last-b-宏" class="headerlink" title="last(b) 宏"></a>last(b) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> last(b)      ((b)-&gt;bk)</span></span><br></pre></td></tr></table></figure>
<p>获取 bin 中的 bk 指针</p>
<h3 id="unlink-AV-P-BK-FD-宏（重点）（缺）"><a href="#unlink-AV-P-BK-FD-宏（重点）（缺）" class="headerlink" title="unlink(AV, P, BK, FD) 宏（重点）（缺）"></a>unlink(AV, P, BK, FD) 宏（重点）（缺）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line">    FD = P-&gt;fd;                               \</span><br><span class="line">    BK = P-&gt;bk;                               \</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))           \</span><br><span class="line">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span><br><span class="line">    <span class="keyword">else</span> &#123;                            \</span><br><span class="line">        FD-&gt;bk = BK;                           \</span><br><span class="line">        BK-&gt;fd = FD;                           \</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size)                  \</span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;          \</span><br><span class="line">       <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)       \</span><br><span class="line">      || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">         malloc_printerr (check_action,                  \</span><br><span class="line">                <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    \</span><br><span class="line">                P, AV);                   \</span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;                \</span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)                  \</span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;           \</span><br><span class="line">                <span class="keyword">else</span> &#123;                         \</span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;              \</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;              \</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;              \</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;              \</span><br><span class="line">                  &#125;                            \</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;                         \</span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;           \</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;           \</span><br><span class="line">              &#125;                               \</span><br><span class="line">          &#125;                               \</span><br><span class="line">      &#125;                                  \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3 - 4 行：<code>FD = P-&gt;fd</code> 和 <code>BK = P-&gt;bk</code> 是分别获取传入参数 P 的前驱节点和后继节点5</p>
<p>5 行：if 语句用于判断 P 的前驱节点的后继节点是否为 P，P的后继节点的前驱节点是否为 P，且要通过条件最后返回值为 0</p>
<p>6 行：如果第五行的返回值为 1，那么就调用 <code>malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV)</code></p>
<p>7 - 9 行：如果返回值是 0，进入 else 语句，并且让 <strong>P 的前驱节点的后继节点变成 P 的后继节点</strong></p>
<p>​                再让 <strong>P 的后继节点的前驱节点变成 P 的前驱节点</strong>，完成删除双向链表上的 P 节点的操作</p>
<p>10 - 11 行：</p>
<h2 id="Indexing"><a href="#Indexing" class="headerlink" title="Indexing"></a>Indexing</h2><h3 id="NBINS-宏"><a href="#NBINS-宏" class="headerlink" title="NBINS 宏"></a>NBINS 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Indexing</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Bins for sizes &lt; 512 bytes contain chunks of all the same size, spaced</span></span><br><span class="line"><span class="comment">    8 bytes apart. Larger bins are approximately logarithmically spaced:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    64 bins of size       8</span></span><br><span class="line"><span class="comment">    32 bins of size      64</span></span><br><span class="line"><span class="comment">    16 bins of size     512</span></span><br><span class="line"><span class="comment">     8 bins of size    4096</span></span><br><span class="line"><span class="comment">     4 bins of size   32768</span></span><br><span class="line"><span class="comment">     2 bins of size  262144</span></span><br><span class="line"><span class="comment">     1 bin  of size what&#x27;s left</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    There is actually a little bit of slop in the numbers in bin_index</span></span><br><span class="line"><span class="comment">    for the sake of speed. This makes no difference elsewhere.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The bins top out around 1MB because we expect to service large</span></span><br><span class="line"><span class="comment">    requests via mmap.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Bin 0 does not exist.  Bin 1 is the unordered list; if that would be</span></span><br><span class="line"><span class="comment">    a valid chunk size the small bins are bumped up one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NBINS             128</span></span><br></pre></td></tr></table></figure>
<p>规定计算正常 bin 大小时的基准值</p>
<h3 id="NSMALLBINS-宏"><a href="#NSMALLBINS-宏" class="headerlink" title="NSMALLBINS 宏"></a>NSMALLBINS 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSMALLBINS         64</span></span><br></pre></td></tr></table></figure>
<p>规定计算正常 smallbin 大小时的基准值</p>
<h3 id="SMALLBIN-WIDTH-宏"><a href="#SMALLBIN-WIDTH-宏" class="headerlink" title="SMALLBIN_WIDTH 宏"></a>SMALLBIN_WIDTH 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span></span><br></pre></td></tr></table></figure>
<p>正常情况在 32 位下，这个值是 0x08；在 64 下这个值是 0x10</p>
<h3 id="SMALLBIN-CORRECTION-宏"><a href="#SMALLBIN-CORRECTION-宏" class="headerlink" title="SMALLBIN_CORRECTION 宏"></a>SMALLBIN_CORRECTION 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br></pre></td></tr></table></figure>
<p>这种就是在非正常情况下会有返回值 1，即在满足 <code>2 *SIZE_SZ &lt; __alignof__ (long double)</code> 时</p>
<h3 id="MIN-LARGE-SIZE-宏"><a href="#MIN-LARGE-SIZE-宏" class="headerlink" title="MIN_LARGE_SIZE 宏"></a>MIN_LARGE_SIZE 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br></pre></td></tr></table></figure>
<p>用于规定 smallbin 的最大值(不等于)和 largebin 的最大值</p>
<p>正常情况下 64 位的最小值为 <code>(64 - 0) * 0x10 == 0x400</code>；32 位的最小值为 <code>(64 - 0) * 0x08 == 0x200</code></p>
<h3 id="in-smallbin-range-sz-宏"><a href="#in-smallbin-range-sz-宏" class="headerlink" title="in_smallbin_range(sz) 宏"></a>in_smallbin_range(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> in_smallbin_range(sz)  \</span></span><br><span class="line">  ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) MIN_LARGE_SIZE)</span><br></pre></td></tr></table></figure>
<p>如果一个 chunk 的 size 小于 MIN_LARGE_SIZE，那么该 chunk 就属于 smallbin</p>
<h3 id="smallbin-index-sz-宏"><a href="#smallbin-index-sz-宏" class="headerlink" title="smallbin_index(sz) 宏"></a>smallbin_index(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line">  ((SMALLBIN_WIDTH == <span class="number">16</span> ? (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">4</span>) : (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">3</span>))\</span><br><span class="line">   + SMALLBIN_CORRECTION)</span><br></pre></td></tr></table></figure>
<p>SMALLBIN_CORRECTION 是用来兼容 <code>long double</code> 的</p>
<p>这个宏的主要意思就是在 64 位下，smallbin 中堆块的下标按照 <code>(unsigned) (sz)) &gt;&gt; 4</code> 来规划</p>
<p>在 32 位下，smallbin 中堆块的下标按照 <code>(unsigned) (sz)) &gt;&gt; 3</code> 来规划</p>
<p>且可以看出 <code>2 *SIZE_SZ &lt; __alignof__ (long double)</code> 的兼容操作只可能会在 32 位系统上出现</p>
<h3 id="largebin-index-32-sz-宏"><a href="#largebin-index-32-sz-宏" class="headerlink" title="largebin_index_32(sz) 宏"></a>largebin_index_32(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_32(sz)                                                \</span></span><br><span class="line">  (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">38</span>) ?  <span class="number">56</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>) ?  <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>) ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>) ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>) ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) :\</span><br><span class="line">   <span class="number">126</span>)</span><br></pre></td></tr></table></figure>
<p>参考 largebin_index_64(sz) 吧，这个是一般情况下 32 位的 largebin 分布</p>
<h3 id="largebin-index-32-big-sz-宏"><a href="#largebin-index-32-big-sz-宏" class="headerlink" title="largebin_index_32_big(sz) 宏"></a>largebin_index_32_big(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_32_big(sz)                                            \</span></span><br><span class="line">  (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">45</span>) ?  <span class="number">49</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>) ?  <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>) ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>) ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>) ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) :\</span><br><span class="line">   <span class="number">126</span>)</span><br></pre></td></tr></table></figure>
<p>参考 largebin_index_64(sz) 吧</p>
<p>这个是满足 <code>2 *SIZE_SZ &lt; __alignof__ (long double)</code> 下 32 位的 largebin 分布</p>
<h3 id="largebin-index-64-sz-宏"><a href="#largebin-index-64-sz-宏" class="headerlink" title="largebin_index_64(sz) 宏"></a>largebin_index_64(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// XXX It remains to be seen whether it is good to keep the widths of</span></span><br><span class="line"><span class="comment">// XXX the buckets the same or whether it should be scaled by a factor</span></span><br><span class="line"><span class="comment">// XXX of two as well.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_64(sz)                                                \</span></span><br><span class="line">  (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">48</span>) ?  <span class="number">48</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>) ?  <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>) ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>) ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) :\</span><br><span class="line">   ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>) ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) :\</span><br><span class="line">   <span class="number">126</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到大小为 <code>0x400</code> 的 chunk 对应的 index 为 <code>(0x400 &gt;&gt; 6) + 48</code> 即 64</p>
<p>而 index 为 64 对应的范围是 <code>[0x400, 0x400 + 1 &gt;&gt; 6)</code> 即 <code>[0x400, 0x440)</code></p>
<p>在这个级别的 index 中，size 的范围为 0x40（1&lt;&lt;6），依次类推 size 与 index 对应的关系是：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">size</th>
<th align="center">index</th>
</tr>
</thead>
<tbody><tr>
<td align="center">等差 0x40</td>
<td align="center">[0x400 , 0x440)</td>
<td align="center">64</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">[0x440 , 0x480)</td>
<td align="center">65</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">……</td>
<td align="center">……</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">[0xC00 , 0xC40)</td>
<td align="center">96</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">[0xC40 , 0xE00)</td>
<td align="center">97</td>
</tr>
<tr>
<td align="center">等差 0x200</td>
<td align="center">[0xE00 , 0x1000)</td>
<td align="center">98</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">[0x1000 , 0x1200)</td>
<td align="center">99</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">……</td>
<td align="center">……</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">[0x2800 , 0x2A00)</td>
<td align="center">111</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">[0x2A00 , 0x3000)</td>
<td align="center">112</td>
</tr>
<tr>
<td align="center">等差 0x1000</td>
<td align="center">[0x3000 , 0x4000)</td>
<td align="center">113</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">[0x4000 , 0x5000)</td>
<td align="center">114</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">……</td>
<td align="center">……</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">[0x9000 , 0xA000)</td>
<td align="center">119</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">[0xA000 , 0x10000)</td>
<td align="center">120</td>
</tr>
<tr>
<td align="center">等差 0x8000</td>
<td align="center">[0x10000 , 0x18000)</td>
<td align="center">121</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">[0x18000 , 0x20000)</td>
<td align="center">122</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">[0x20000 , 0x28000)</td>
<td align="center">123</td>
</tr>
<tr>
<td align="center">等差 0x18000</td>
<td align="center">[0x28000 , 0x40000)</td>
<td align="center">124</td>
</tr>
<tr>
<td align="center">等差 0x40000</td>
<td align="center">[0x40000 , 0x80000)</td>
<td align="center">125</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">[0x80000 , …. )</td>
<td align="center">126</td>
</tr>
</tbody></table>
<h3 id="largebin-index-sz-宏"><a href="#largebin-index-sz-宏" class="headerlink" title="largebin_index(sz) 宏"></a>largebin_index(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index(sz) \</span></span><br><span class="line">  (SIZE_SZ == <span class="number">8</span> ? largebin_index_64 (sz)                                     \</span><br><span class="line">   : MALLOC_ALIGNMENT == <span class="number">16</span> ? largebin_index_32_big (sz)                     \</span><br><span class="line">   : largebin_index_32 (sz))</span><br></pre></td></tr></table></figure>
<p>用来指定 largebin 应该以哪一种方式来指定当前堆块大小所对应的下标</p>
<h3 id="bin-index-sz-宏"><a href="#bin-index-sz-宏" class="headerlink" title="bin_index(sz) 宏"></a>bin_index(sz) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bin_index(sz) \</span></span><br><span class="line">  ((in_smallbin_range (sz)) ? smallbin_index (sz) : largebin_index (sz))</span><br></pre></td></tr></table></figure>
<p>判断当前堆块的大小是满足 smallbin 还是满足 largebin，然后去对应的宏里得到该堆块大小所对应的下标</p>
<h2 id="Unsorted-chunks"><a href="#Unsorted-chunks" class="headerlink" title="Unsorted chunks"></a>Unsorted chunks</h2><h3 id="unsorted-chunks-M"><a href="#unsorted-chunks-M" class="headerlink" title="unsorted_chunks(M)"></a>unsorted_chunks(M)</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Unsorted chunks</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    All remainders from chunk splits, as well as all returned chunks,</span></span><br><span class="line"><span class="comment">    are first placed in the &quot;unsorted&quot; bin. They are then placed</span></span><br><span class="line"><span class="comment">    in regular bins after malloc gives them ONE chance to be used before</span></span><br><span class="line"><span class="comment">    binning. So, basically, the unsorted_chunks list acts as a queue,</span></span><br><span class="line"><span class="comment">    with chunks being placed on it in free (and malloc_consolidate),</span></span><br><span class="line"><span class="comment">    and taken off (to be either used or placed in bins) in malloc.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The NON_MAIN_ARENA flag is never set for unsorted chunks, so it</span></span><br><span class="line"><span class="comment">    does not have to be taken into account in size comparisons.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unsorted_chunks(M)          (bin_at (M, 1))</span></span><br></pre></td></tr></table></figure>
<h2 id="Top"><a href="#Top" class="headerlink" title="Top"></a>Top</h2><h3 id="initial-top-M-宏"><a href="#initial-top-M-宏" class="headerlink" title="initial_top(M) 宏"></a>initial_top(M) 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Top</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    The top-most available chunk (i.e., the one bordering the end of</span></span><br><span class="line"><span class="comment">    available memory) is treated specially. It is never included in</span></span><br><span class="line"><span class="comment">    any bin, is used only if no other chunk is available, and is</span></span><br><span class="line"><span class="comment">    released back to the system if it is very large (see</span></span><br><span class="line"><span class="comment">    M_TRIM_THRESHOLD).  Because top initially</span></span><br><span class="line"><span class="comment">    points to its own bin with initial zero size, thus forcing</span></span><br><span class="line"><span class="comment">    extension on the first malloc request, we avoid having any special</span></span><br><span class="line"><span class="comment">    code in malloc to check whether it even exists yet. But we still</span></span><br><span class="line"><span class="comment">    need to do so when getting memory from system, so we make</span></span><br><span class="line"><span class="comment">    initial_top treat the bin as a legal but unusable chunk during the</span></span><br><span class="line"><span class="comment">    interval between initialization and the first call to</span></span><br><span class="line"><span class="comment">    sysmalloc. (This is somewhat delicate, since it relies on</span></span><br><span class="line"><span class="comment">    the 2 preceding words to be zero during this interval as well.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conveniently, the unsorted bin can be used as dummy top on first call */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> initial_top(M)              (unsorted_chunks (M))</span></span><br></pre></td></tr></table></figure>
<h2 id="Binmap"><a href="#Binmap" class="headerlink" title="Binmap"></a>Binmap</h2><h3 id="BINMAPSHIFT-宏"><a href="#BINMAPSHIFT-宏" class="headerlink" title="BINMAPSHIFT 宏"></a>BINMAPSHIFT 宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Binmap</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    To help compensate for the large number of bins, a one-level index</span></span><br><span class="line"><span class="comment">    structure is used for bin-by-bin searching.  `binmap&#x27; is a</span></span><br><span class="line"><span class="comment">    bitvector recording whether bins are definitely empty so they can</span></span><br><span class="line"><span class="comment">    be skipped over during during traversals.  The bits are NOT always</span></span><br><span class="line"><span class="comment">    cleared as soon as bins are empty, but instead only</span></span><br><span class="line"><span class="comment">    when they are noticed to be empty during traversal in malloc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Conservatively use 32 bits per map word, even if on 64bit system */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINMAPSHIFT      5</span></span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">C7</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://billyotry.github.io/2020/09/11/%E3%80%90Glibc%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91Glibc%202.23%20--%20malloc.c/">https://billyotry.github.io/2020/09/11/%E3%80%90Glibc%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91Glibc%202.23%20--%20malloc.c/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://billyotry.github.io" target="_blank">C7</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/04/14/s8lQEMGd2KVD6Fx.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/09/14/%E3%80%90ASAN%E3%80%91%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"><img class="prev-cover" src="https://i.loli.net/2020/07/11/7iqMC5nFhaEZojI.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2020/07/11/Understanding%20C%20parsers%20generated%20by%20GNU%20Bison/"><img class="next-cover" src="https://i.loli.net/2020/07/11/7iqMC5nFhaEZojI.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">C7</div><div class="author-info__description">雖不能至 心嚮往之</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div></div><a class="button--animated" id="card-info-btn"><i class="fa fa-paper-plane-o"></i><span>加入书签</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://billyotry.github.io/" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1347405944@qq.com" target="_blank" title="Email"><i class="fa fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">大家疫情期间注意保护自己噢~~~~</div></div><div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="clock"><img v-if="clockshow == &quot;false&quot;" src="/clock/images/weather/loading.gif" style="height:120px;width:100%"/><table class="clock" v-if="clockshow"><tbody><tr><td class="clockdate">{{date}}</td><td class="weatherimg" align="center" valign="middle"><img id="weatherimg" :src="weatherimg"/></td><td class="temperature" align="center" valign="middle">{{temperature}}</td><td class="humidityimg"><img id="humidityimg" :src="humidityimg"/></td><td class="humidity">{{humidity}}</td></tr><tr class="time"><td colspan="5">{{time}}</td></tr><tr><td class="usaqi" colspan="1"> <span>{{ip}}</span></td><td class="city" colspan="2">{{city}}</td><td class="daylight" colspan="2">{{daylight}}</td></tr></tbody></table></div></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#MMAP-support"><span class="toc-number">1.</span> <span class="toc-text">MMAP support</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Chunk-representations"><span class="toc-number">2.</span> <span class="toc-text">Chunk representations</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc-chunk-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">2.1.</span> <span class="toc-text">malloc_chunk 结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc-chunk-%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-number">2.2.</span> <span class="toc-text">malloc_chunk 的细节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Size-and-alignment-checks-and-conversions"><span class="toc-number">3.</span> <span class="toc-text">Size and alignment checks and conversions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mem2chunk-mem-%E5%AE%8F"><span class="toc-number">3.1.</span> <span class="toc-text">mem2chunk(mem) 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MIN-CHUNK-SIZE-%E5%AE%8F"><span class="toc-number">3.2.</span> <span class="toc-text">MIN_CHUNK_SIZE 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MINSIZE-%E5%AE%8F"><span class="toc-number">3.3.</span> <span class="toc-text">MINSIZE 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aligned-OK-m-%E5%AE%8F"><span class="toc-number">3.4.</span> <span class="toc-text">aligned_OK(m) 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#misaligned-chunk-p-%E5%AE%8F"><span class="toc-number">3.5.</span> <span class="toc-text">misaligned_chunk(p) 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#REQUEST-OUT-OF-RANGE-req-%E5%AE%8F%EF%BC%88%E7%BC%BA%EF%BC%89"><span class="toc-number">3.6.</span> <span class="toc-text">REQUEST_OUT_OF_RANGE(req) 宏（缺）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#request2size-req-%E5%AE%8F%EF%BC%88%E7%BC%BA%EF%BC%89"><span class="toc-number">3.7.</span> <span class="toc-text">request2size(req) 宏（缺）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#checked-request2size-req-sz-%E5%AE%8F%EF%BC%88%E7%BC%BA%EF%BC%89"><span class="toc-number">3.8.</span> <span class="toc-text">checked_request2size(req, sz) 宏（缺）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Physical-chunk-operations"><span class="toc-number">4.</span> <span class="toc-text">Physical chunk operations</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PREV-INUSE-%E5%AE%8F"><span class="toc-number">4.1.</span> <span class="toc-text">PREV_INUSE 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#prev-inuse-p-%E5%AE%8F"><span class="toc-number">4.2.</span> <span class="toc-text">prev_inuse(p) 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IS-MMAPPED-%E5%AE%8F"><span class="toc-number">4.3.</span> <span class="toc-text">IS_MMAPPED 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chunk-is-mmapped-p-%E5%AE%8F"><span class="toc-number">4.4.</span> <span class="toc-text">chunk_is_mmapped(p) 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NON-MAIN-ARENA-%E5%AE%8F"><span class="toc-number">4.5.</span> <span class="toc-text">NON_MAIN_ARENA 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chunk-non-main-arena-p-%E5%AE%8F"><span class="toc-number">4.6.</span> <span class="toc-text">chunk_non_main_arena(p) 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SIZE-BITS-%E5%AE%8F"><span class="toc-number">4.7.</span> <span class="toc-text">SIZE_BITS 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chunksize-p-%E5%AE%8F"><span class="toc-number">4.8.</span> <span class="toc-text">chunksize(p) 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#next-chunk-p-%E5%AE%8F"><span class="toc-number">4.9.</span> <span class="toc-text">next_chunk(p) 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#prev-chunk-p-%E5%AE%8F"><span class="toc-number">4.10.</span> <span class="toc-text">prev_chunk(p) 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chunk-at-offset-p-s-%E5%AE%8F"><span class="toc-number">4.11.</span> <span class="toc-text">chunk_at_offset(p, s) 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inuse-p-%E5%AE%8F"><span class="toc-number">4.12.</span> <span class="toc-text">inuse(p) 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set-inuse-p-%E5%AE%8F"><span class="toc-number">4.13.</span> <span class="toc-text">set_inuse(p) 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clear-inuse-p-%E5%AE%8F"><span class="toc-number">4.14.</span> <span class="toc-text">clear_inuse(p) 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inuse-bit-at-offset-p-s-%E5%AE%8F"><span class="toc-number">4.15.</span> <span class="toc-text">inuse_bit_at_offset(p, s) 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set-inuse-bit-at-offset-p-s-%E5%AE%8F"><span class="toc-number">4.16.</span> <span class="toc-text">set_inuse_bit_at_offset(p, s) 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clear-inuse-bit-at-offset-p-s-%E5%AE%8F"><span class="toc-number">4.17.</span> <span class="toc-text">clear_inuse_bit_at_offset(p, s) 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set-head-size-p-s-%E5%AE%8F"><span class="toc-number">4.18.</span> <span class="toc-text">set_head_size(p, s) 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set-head-p-s-%E5%AE%8F"><span class="toc-number">4.19.</span> <span class="toc-text">set_head(p, s) 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set-foot-p-s-%E5%AE%8F"><span class="toc-number">4.20.</span> <span class="toc-text">set_foot(p, s) 宏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Internal-data-structures"><span class="toc-number">5.</span> <span class="toc-text">Internal data structures</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mbinptr-%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F"><span class="toc-number">5.1.</span> <span class="toc-text">mbinptr 结构体指针变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bin-at-m-i-%E5%AE%8F"><span class="toc-number">5.2.</span> <span class="toc-text">bin_at(m, i) 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#next-bin-b-%E5%AE%8F%EF%BC%88%E7%BC%BA%E5%85%B7%E4%BD%93%EF%BC%89"><span class="toc-number">5.3.</span> <span class="toc-text">next_bin(b) 宏（缺具体）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#first-b-%E5%AE%8F"><span class="toc-number">5.4.</span> <span class="toc-text">first(b) 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#last-b-%E5%AE%8F"><span class="toc-number">5.5.</span> <span class="toc-text">last(b) 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unlink-AV-P-BK-FD-%E5%AE%8F%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89%EF%BC%88%E7%BC%BA%EF%BC%89"><span class="toc-number">5.6.</span> <span class="toc-text">unlink(AV, P, BK, FD) 宏（重点）（缺）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Indexing"><span class="toc-number">6.</span> <span class="toc-text">Indexing</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NBINS-%E5%AE%8F"><span class="toc-number">6.1.</span> <span class="toc-text">NBINS 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NSMALLBINS-%E5%AE%8F"><span class="toc-number">6.2.</span> <span class="toc-text">NSMALLBINS 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SMALLBIN-WIDTH-%E5%AE%8F"><span class="toc-number">6.3.</span> <span class="toc-text">SMALLBIN_WIDTH 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SMALLBIN-CORRECTION-%E5%AE%8F"><span class="toc-number">6.4.</span> <span class="toc-text">SMALLBIN_CORRECTION 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MIN-LARGE-SIZE-%E5%AE%8F"><span class="toc-number">6.5.</span> <span class="toc-text">MIN_LARGE_SIZE 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#in-smallbin-range-sz-%E5%AE%8F"><span class="toc-number">6.6.</span> <span class="toc-text">in_smallbin_range(sz) 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#smallbin-index-sz-%E5%AE%8F"><span class="toc-number">6.7.</span> <span class="toc-text">smallbin_index(sz) 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#largebin-index-32-sz-%E5%AE%8F"><span class="toc-number">6.8.</span> <span class="toc-text">largebin_index_32(sz) 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#largebin-index-32-big-sz-%E5%AE%8F"><span class="toc-number">6.9.</span> <span class="toc-text">largebin_index_32_big(sz) 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#largebin-index-64-sz-%E5%AE%8F"><span class="toc-number">6.10.</span> <span class="toc-text">largebin_index_64(sz) 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#largebin-index-sz-%E5%AE%8F"><span class="toc-number">6.11.</span> <span class="toc-text">largebin_index(sz) 宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bin-index-sz-%E5%AE%8F"><span class="toc-number">6.12.</span> <span class="toc-text">bin_index(sz) 宏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unsorted-chunks"><span class="toc-number">7.</span> <span class="toc-text">Unsorted chunks</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#unsorted-chunks-M"><span class="toc-number">7.1.</span> <span class="toc-text">unsorted_chunks(M)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Top"><span class="toc-number">8.</span> <span class="toc-text">Top</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#initial-top-M-%E5%AE%8F"><span class="toc-number">8.1.</span> <span class="toc-text">initial_top(M) 宏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binmap"><span class="toc-number">9.</span> <span class="toc-text">Binmap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BINMAPSHIFT-%E5%AE%8F"><span class="toc-number">9.1.</span> <span class="toc-text">BINMAPSHIFT 宏</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2020/10/05/%5BConfidence%20CTF%5Dkvm/" title="无题"><img src="https://i.loli.net/2020/10/05/OkMu26JEdRlGBqX.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2020/10/05/%5BConfidence%20CTF%5Dkvm/" title="无题">无题</a><time datetime="2020-10-05T02:09:56.234Z" title="发表于 2020-10-05 10:09:56">2020-10-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/09/14/%E3%80%90ASAN%E3%80%91%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" title="无题"><img src="https://i.loli.net/2020/07/11/7iqMC5nFhaEZojI.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2020/09/14/%E3%80%90ASAN%E3%80%91%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/" title="无题">无题</a><time datetime="2020-09-14T06:34:37.134Z" title="发表于 2020-09-14 14:34:37">2020-09-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/09/11/%E3%80%90Glibc%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91Glibc%202.23%20--%20malloc.c/" title="无题"><img src="https://i.loli.net/2020/04/14/s8lQEMGd2KVD6Fx.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2020/09/11/%E3%80%90Glibc%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E3%80%91Glibc%202.23%20--%20malloc.c/" title="无题">无题</a><time datetime="2020-09-10T16:03:33.395Z" title="发表于 2020-09-11 00:03:33">2020-09-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/07/11/Understanding%20C%20parsers%20generated%20by%20GNU%20Bison/" title="无题"><img src="https://i.loli.net/2020/07/11/7iqMC5nFhaEZojI.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2020/07/11/Understanding%20C%20parsers%20generated%20by%20GNU%20Bison/" title="无题">无题</a><time datetime="2020-07-11T07:28:41.581Z" title="发表于 2020-07-11 15:28:41">2020-07-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/06/25/lexical%20scanner%20generated%20by%20flex/" title="无题"><img src="https://i.loli.net/2020/04/14/s8lQEMGd2KVD6Fx.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2020/06/25/lexical%20scanner%20generated%20by%20flex/" title="无题">无题</a><time datetime="2020-06-25T14:46:37.470Z" title="发表于 2020-06-25 22:46:37">2020-06-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By C7</div><div class="footer_custom_text"><p><a style="margin-inline:5px" target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a><a style="margin-inline:5px" target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a><a style="margin-inline:5px" target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a><a style="margin-inline:5px" target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a><a style="margin-inline:5px" target="_blank" href="https://vercel.com/ "><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a><a style="margin-inline:5px" target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a><a style="margin-inline:5px" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script src="https://upcdn.b0.upaiyun.com/libs/jquery/jquery-2.0.2.min.js"><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script src="/clock/js/clock.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>